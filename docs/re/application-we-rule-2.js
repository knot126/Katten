$MODULE_FACTORY_REGISTRY = typeof $MODULE_FACTORY_REGISTRY != 'undefined' ? $MODULE_FACTORY_REGISTRY : {};
$MODULE_REGISTRY = typeof $MODULE_REGISTRY != 'undefined' ? $MODULE_REGISTRY : {};
if(typeof require == 'undefined')
function require(path){if(!$MODULE_REGISTRY[path]) $MODULE_REGISTRY[path] = $MODULE_FACTORY_REGISTRY[path](); return $MODULE_REGISTRY[path]};

if (typeof(console) == 'undefined') console = { log: (typeof __underscore_SysLog == 'function') ? __underscore_SysLog : function(str) {} };$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/NGJSEnvironmentSupport'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/NGJSEnvironmentSupport'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/NGJSEnvironmentSupport'] = exports; /**

 # NGJSEnvironmentSupport.js
 # webgame
 #
 # Created by Frederic Barthelemy on 10/01/10.
 # Copyright 2010 ngmoco:). All rights reserved.

 */

/**
 * Provides Environmental support for features missing on certain platforms.
 */


/**
 * setTimeout and setInterval implementation for platforms that don't have it.
 *	It fires timers at the beginning of the first frame past the requested millisecond,
 *	before it processes messages for a particular frame.
 *
 * Platform Consumers:
 *	- Android
 *
 * Note:
 *	- Only accurate to within the frame.
 *	- Does behaves like webkit in that it lets clearInterval and clearTimeout
 *		clear timers created by each other's constructor style.
 *
 */
var NGSetTimeoutCustom = false;
var NGSetTimeoutCallbacks = {};
var NGSetTimeoutUIDGenerator = 0;

exports.NGSetTimeoutRunTimers = function() {
	if(NGSetTimeoutCustom) {
		var timersToExecute = [];
		var curTime = new Date().getTime();
		for (var tk in NGSetTimeoutCallbacks) {
			if (NGSetTimeoutCallbacks.hasOwnProperty(tk) && NGSetTimeoutCallbacks[tk].shouldExecute(curTime)) {
				timersToExecute.push(NGSetTimeoutCallbacks[tk]);
			}
		}

		for (var i in timersToExecute) {
			if (timersToExecute.hasOwnProperty(i)) {
				timersToExecute[i].execute();
			}
		}
	}
};

if(typeof(setTimeout) != "function") {
	NGSetTimeoutCustom = true;

	var NGSingleTimeoutInstance = function(fptr, timeMs) {
		this.uid = NGSetTimeoutUIDGenerator++;
		if (NGSetTimeoutUIDGenerator == Infinity)
		{
			NGSetTimeoutUIDGenerator = 0;
		}
		this.fptr = fptr;
		this.interval = timeMs;
		this.requestedTime = new Date().getTime() + timeMs;
	};

	NGSingleTimeoutInstance.prototype.shouldExecute = function(curTime) {
		if(curTime < this.requestedTime) {
			return false;
		}
		return true;
	};

	NGSingleTimeoutInstance.prototype.execute = function() {
		delete NGSetTimeoutCallbacks[this.uid];
		this.fptr();
	};
	/**
	*
	*/
	setTimeout = function(fptr,requestedTime) {
		if(requestedTime < 0 || typeof(requestedTime) != "number") {
			requestedTime = 0;
		}

		var inst = new NGSingleTimeoutInstance(fptr,requestedTime);
		NGSetTimeoutCallbacks[inst.uid] = inst;
		return inst.uid;
	};
	/**
	*
	*/
	clearTimeout = function(uid) {
		if(NGSetTimeoutCallbacks.hasOwnProperty(uid)) {
			delete NGSetTimeoutCallbacks[uid];
		}
	};
	/**
	*
	*/
	setInterval = function(fptr,requestedTime) {
		if(requestedTime < 0 || typeof(requestedTime) != "number") {
			requestedTime = 0;
		}

		var inst = new NGSingleTimeoutInstance(fptr,requestedTime);
		/*Special setIntervalMagic */
		inst.execute = function() {
			this.requestedTime = new Date().getTime() + this.interval;
			this.fptr();
		};
		/*End setIntervalMagic */
		NGSetTimeoutCallbacks[inst.uid] = inst;
		return inst.uid;
	};
	clearInterval = clearTimeout;
	
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/SystemBinding'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/SystemBinding'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/SystemBinding'] = exports; var ClassReq = require('NGCore/Client/Core/Class');
var Base64 = require('NGCore/Client/Core/Base64').Base64;
var ResultSetReq = require('NGCore/Client/Plus/ResultSet');

var NGSystemBindingCommands = {
    HandleAction: 0
};

var SystemBinding = ClassReq.Class.subclass({
    classname: "SystemBinding",
    callbacks: {},
    callbacksUidGenerator: 0,
    _contResultSets: {},
    _contResultSetIdxs: {}
});

var ResultSet = ClassReq.Class.subclass({
    classname: "ResultSet",
    initialize: function(continueId) {
        this.items = [];
        this._continueId = continueId;
        this.totalLength = Number.MAX_VALUE;
    },
    /*
	 * Call to getMore adds more items to items list.
	 * Please note that in the callback, it is possible that addedCount == 0
	 * in some cases.  In that case access to items[newIdx] does not yield
	 * any result
	 */
    getMore: function(cb) {
        return SystemBinding._getMoreContacts(this, cb);
    },
    /*
	 * Releases resource used by current ResultSet.
	 *
	 * To avoid resource leakage, please call closeResultSet if getMore
	 * is not called all the way to the end.
	 */
    closeResultSet: function() {
        SystemBinding._closeContactsResultSet(this);
    }
});

SystemBinding._pushContactsCmd = function(cmdname, callbackFunc, continueId) {
    // Generate unused callbackEntry
    var callbackId = SystemBinding.callbacksUidGenerator++;
    if ( !! !callbackFunc) {
        callbackFunc = function() {};
    }
    SystemBinding.callbacks[callbackId] = callbackFunc;
    var message = {
        name: cmdname,
        callbackId: callbackId
    };
    if (typeof continueId != 'undefined') {
        message.continueId = continueId;
    }
    message = JSON.stringify(message);
    NgPushCommand3(NgEntityTypes.NgSystemBinding, NGSystemBindingCommands.HandleAction,
    Base64.encode(message));
};

SystemBinding._closeContactsResultSetfunction = function(rSet) {
    // Passing empty callback as caller does not need to know when the close
    // is complete
    var cb = function() {};
    SystemBinding._pushContactsCmd('closecontacts', cb, rSet._continueId);
};

SystemBinding._getMoreContacts = function(rSet, callbackFunc) {
    if ((typeof rSet._continueId != 'undefined') &&
    (rSet.items.length < rSet.totalLength)) {
        SystemBinding._pushContactsCmd('morecontacts', callbackFunc, rSet._continueId);
        return true;
    }
    return false;
};

SystemBinding.getContacts = function(callbackFunc) {
    SystemBinding._pushContactsCmd('contacts', callbackFunc, undefined);
};

SystemBinding.getDeviceToken = function(callbackFunc) {
    // Generate unused callbackEntry
    var callbackId = SystemBinding.callbacksUidGenerator++;
    if ( !! !callbackFunc) {
        callbackFunc = function() {};
    }
    SystemBinding.callbacks[callbackId] = callbackFunc;
    var message = {
        name: 'devicetoken',
        callbackId: callbackId
    };
    message = JSON.stringify(message);
    NgPushCommand3(NgEntityTypes.NgSystemBinding, NGSystemBindingCommands.HandleAction,
    Base64.encode(message));
};

SystemBinding.handleCommand = function(command) {
    var fields = NgParseCommand2(command, NgParseInt, NgParseBase64);
    var cmd = JSON.parse(fields[1]);
    if (cmd.name == 'callback') {
    	var cb = SystemBinding.callbacks[cmd.callbackId];
		if (typeof cb == "function") {
            if (cmd.callbackname == 'contacts') {
                var obj = SystemBinding._contResultSets[cmd.continueId];
                if (typeof obj == 'undefined') {
                    // First time for this callback
                    obj = new ResultSetReq.ResultSet(cmd.continueId);
                    SystemBinding._contResultSets[cmd.continueId] = obj;
                    SystemBinding._contResultSetIdxs[cmd.continueId] = 0;
                }

                var addedCount = cmd.list.length;
                while (cmd.list.length > 0) {
                    var item = cmd.list.shift();
                    obj.items.push(item);
                }

                var newIdx = SystemBinding._contResultSetIdxs[cmd.continueId];
				if ((typeof newIdx) != 'undefined') {
                	SystemBinding._contResultSetIdxs[cmd.continueId] = newIdx + addedCount;
				}

                // Invalidate the continueId if done - when total is return (no
                // more result) or when result set is explicitly closed (cmd.closed)
                if ((typeof cmd.total != 'undefined') ||
                (typeof cmd.rsclosed != 'undefined')) {
                    if (typeof cmd.total != 'undefined') {
                        obj.totalLength = cmd.total;
                    }
                    delete obj._continueId;
                    delete SystemBinding._contResultSets[cmd.continueId];
                    delete SystemBinding._contResultSetIdxs[cmd.continueId];
                }

                delete SystemBinding.callbacks[cmd.callbackId];
				if (cmd.success) {
                	cb(undefined, obj, newIdx, addedCount);
				} else {
                	cb(cmd.error, obj, newIdx, addedCount);
				}
            } else {
                // other callbacks
                delete SystemBinding.callbacks[cmd.callbackId];
                cb(cmd);
            }
        }
    }
};

exports.SystemBinding = SystemBinding;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI'] || {}; $MODULE_REGISTRY['NGCore/Client/UI'] = exports; var Commands = require('NGCore/Client/UI/Commands').Commands;

var UILoader = function(map) {
	// Internal function to define isolated-scope getters.
	var loadFn = function(object, key, fn) {
		return function() {
			delete object[key];
			return object[key] = fn();
		};
	};

	for (var key in map) {
		if (typeof map[key] == 'function') {
			this.__defineGetter__(key, loadFn(this, key, map[key]));
		} else {
			this[key] = map[key];
		}
	}
};

/**
 * <p>Classes and objects contained by the UI module.</p>
 * @name UI
 * @namespace
 * @description <p>The UI module is a collection of classes that control user interface components of a device.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 * <li><code>{@link UI.AbstractView}</code>A base class object for constructing other UI objects.</li>
 * <li><code>{@link UI.CellView}</code>: Construct <code>CellView</code> objects.</li>
 * <li><code>{@link UI.CheckBox}</code>: Construct objects that are used as checkboxes in an application.</li>
 * <li><code>{@link UI.CheckoutView}</code>: Construct objects that handle and manage information associated with <code>POST</code> methods in an application.</li>
 * <li><code>{@link UI.DateField}</code>: Construct objects used for handling data returned by date functions.</li>
 * <li><code>{@link UI.DocumentView}</code>: Constructs objects that control the location of application documents.</li>
 * <li><code>{@link UI.EditText}</code>: Constructs objects for handling editable text in an application.</li>
 * <li><code>{@link UI.EditTextArea}</code>: Constructs objects for handling multiline editable text in an application.</li>
 * <li><code>{@link UI.Element}</code>: A base class object for constructing other UI objects.</li>
 * <li><code>{@link UI.GLView}</code>: Construct objects that provide applications with access to OpenGL.</li>
 * <li><code>{@link UI.Image}</code>: Constructs objects that control the location and size of images used in the user interface.</li>
 * <li><code>{@link UI.Label}</code>: Constructs objects that control the look and feel of application labels.</li>
 * <li><code>{@link UI.ListView}</code>: Construct <code>ListView</code> objects.</li>
 * <li><code>{@link UI.ListViewItem}</code>: Construct <code>ListViewItem</code> objects.</li>
 * <li><code>{@link UI.ListViewSection}</code>: Construct <code>ListViewSection</code> objects.</li>
 * <li><code>{@link UI.NavController}</code>: Construct objects that control the flow of applcation navigation.</li>
 * <li><code>{@link UI.ProgressDialog}</code>: Construct objects that control application progress messaging.</li>
 * <li><code>{@link UI.ScrollView}</code>: Construct <code>ScrollView</code> objects.</li>
 * <li><code>{@link UI.Spinner}</code>: Construct objects that handle application menu spinners.
 * <li><code>{@link UI.Toast}</code>: Construct <code>Toast</code> objects.
 * <li><code>{@link UI.View}</code>: Construct objects that control the look and feel of the application view state.</li>
 * <li><code>{@link UI.ViewGeometry.Rect}</code>: Construct rectangle objects for use as positionable elements in the user interface.</li>
 * <li><code>{@link UI.ViewGeometry.Scale}</code>: Construct objects that handle view geometry for different scales of measurement.</li>
 * <li><code>{@link UI.WebView}</code>: Construct objects that pass event callback functions when web page events occur.</li>
 * <li><code>{@link UI.Window}</code>: Construct application window objects.</li>
 * </ul>
 */

UILoader.prototype = {
	Commands: Commands,

	FontStyle: Commands.FontStyle,
	State: Commands.State,
	FitMode: Commands.FitMode,


    /**
	 *	@function
	 * 	@name UI#animate
	 * 	Animate changes to the properties of one or more UI objects.
	 * 	Currently animates changes to frame and alpha, and animates the addition / removal of subviews.
	 * 	@param {Function} action A closure that sets the property or properties to be animated.
	 * 		This function may manipulate several objects.
	 * 	@param {Number} duration The time over which to execute the animation, in milliseconds.
	 * 	@param {Function} onCompletion A closure to be executed after the animation has completed.
	 */
    animate: Commands.animate,

    /**
		@name UI#compositeImages
		Creates a composition of images to an offscreen bitmap, writing the resulting picture to disk.
		
		The filename returned in the callback may not be the same as originally requested!
		
		@example
		UI.compositeImages( 200, 200, "basic.png", [
			{
				image:'./Content/background.png',
				rect:[ 0,0, 200, 200 ]
			},
			{
				image:'./Content/CanYouSeeThisImage.png',
				rect:[ 50, 50, 100, 100 ]
			},
		], function( data ) { 
			if ( data.error == undefined ) { 
				NgLogD("yay, picture! at:"+data.filename);
			}
		} );
	 */
    compositeImages: function(w, h, filename, infoArray, callback) {
        var cb = Commands.registerTemporaryCallback(callback);
        if (cb) {
			Commands.doCompositeImages(w, h, filename, infoArray, cb);
		}
    },

    /**
		@name UI#choosePhoto
		Show fullscreen user interface for taking a picture with the camera or choosing an existing
		photo.
		
		Currently there are no 'options' keys defined.  
		In the future, we're considering "forAvatar" key to use a custom cropping UI.
		
		The filename returned in the callback may not be the same as originally requested!
		If the user cancels or an error occurs, the callback will be passed an error string.
		
		Passing 0 for targetWide or High will return the original unscaled image.
		
		@example
		UI.choosePhoto( 0, 0, "basic.png", undefined, function( data ) { 
			if ( data.error == undefined ) { 
				NgLogD("yay, picture! at:"+data.filename);
			}
		} );
	*/
    choosePhoto: function(width, height, filename, options, callback, invokingView) {
       if (!invokingView || !invokingView.__objectRegistryId) {
            new exports.UI.Toast({
                'text': "Photo picker requires an invoking view.",
                'onDisappear': function() {
                    this.destroy();
                }
            }).show();
            return;
        }

        var cb = Commands.registerTemporaryCallback(callback);
		if (cb) {
        	Commands.doChoosePhoto(width, height, filename, options || {}, cb, invokingView.__objectRegistryId);
		}
    },

    /**
		@name UI#choosePhotoCamera
		Show fullscreen user interface for taking a picture with the camera or choosing an existing
		photo.
		
		Currently there are no 'options' keys defined.  
		In the future, we're considering "forAvatar" key to use a custom cropping UI.
		
		The filename returned in the callback may not be the same as originally requested!
		If the user cancels or an error occurs, the callback will be passed an error string.
		
		Passing 0 for targetWide or High will return the original unscaled image.
		
		@example
		UI.choosePhoto( 0, 0, "basic.png", undefined, function( data ) { 
			if ( data.error == undefined ) { 
				NgLogD("yay, picture! at:"+data.filename);
			}
		} );
	*/
    choosePhotoCamera: function(width, height, filename, options, callback) {
        var cb = Commands.registerTemporaryCallback(callback);
		if (cb) {
        	Commands.doChooseCamera(width, height, filename, options || {}, cb);
		}
    },

	measureText: function( text, w, h, font, size, callback) {
		var cb = Commands.registerTemporaryCallback(callback);
		if (cb != '') {
			Commands.measureText(text, w || -1, h || -1, font, size, cb);
		}
	}
};

exports.UI = new UILoader({
	"Window": function() { return require('NGCore/Client/UI/Window').Window; },
	"Element": function() { return require('NGCore/Client/UI/Element').Element; },
	"ViewGeometry": function() { return require('NGCore/Client/UI/ViewGeometry'); },
	"Scale": function() { return exports.UI.ViewGeometry.Scale; },
	"View": function() { return require('NGCore/Client/UI/View').View; },
	"Label": function() { return require('NGCore/Client/UI/Label').Label; },
	"Image": function() { return require('NGCore/Client/UI/Image').Image; },
	"Button": function() { return require('NGCore/Client/UI/Button').Button; },
	"GLView": function() { return require('NGCore/Client/UI/GLView').GLView; },
	"NavController": function() { return require('NGCore/Client/UI/NavController').NavController; },
	"WebView": function() { return require('NGCore/Client/UI/WebView').WebView; },
	"ScrollView": function() { return require('NGCore/Client/UI/ScrollView').ScrollView; },
	"ListView": function() { return require('NGCore/Client/UI/ListView').ListView; },
	"ListViewSection": function() { return require('NGCore/Client/UI/ListViewSection').ListViewSection; },
	"ListViewItem": function() { return require('NGCore/Client/UI/ListViewItem').ListViewItem; },
	"CellView": function() { return require('NGCore/Client/UI/CellView').CellView; },
	"CheckBox": function() { return require('NGCore/Client/UI/CheckBox').CheckBox; },
	"EditText": function() { return require('NGCore/Client/UI/EditText').EditText; },
	"EditTextArea": function() { return require('NGCore/Client/UI/EditTextArea').EditTextArea; },
	"DateField": function() { return require('NGCore/Client/UI/DateField').DateField; },
	"AlertDialog": function() { return require('NGCore/Client/UI/AlertDialog').AlertDialog; },
	"ProgressDialog": function() { return require('NGCore/Client/UI/ProgressDialog').ProgressDialog; },
	"Toast": function() { return require('NGCore/Client/UI/Toast').Toast; },
	"Style": function() { return require('NGCore/Client/UI/Style').Style; },
/** @private */
	"AdView": function() { return require('NGCore/Client/UI/AdView').AdView; },
	"DocumentView": function() { return require('NGCore/Client/UI/DocumentView').DocumentView; },
	"CheckoutView": function() { return require('NGCore/Client/UI/CheckoutView').CheckoutView; },
	"Spinner": function() { return require('NGCore/Client/UI/Spinner').Spinner; },
	"ProgressBar": function() { return require('NGCore/Client/UI/ProgressBar').ProgressBar; },
	"MapView": function() { return require('NGCore/Client/UI/MapView').MapView; },
	"MapAnnotation": function() { return require('NGCore/Client/UI/MapAnnotation').MapAnnotation; }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/DownloadManifest'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/DownloadManifest'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/DownloadManifest'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class XHR
// XMLHttpRequest implementation
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var XHR = require('NGCore/Client/Network/XHR').XHR;
var Util = require('NGCore/Client/Network/Util').Util;
var DownloadFile = require('NGCore/Client/Network/DownloadFile').DownloadFile;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;
var LocalGameList = require('NGCore/Client/Core/LocalGameList').LocalGameList;

// JMarr temporary hack to supress archive downloads on flash.
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

////////////////////////////////////////////////////////////////////////////////

var Manifest = Class.subclass(
{
	classname: 'Manifest',

	initialize: function()
	{
		this.mModified = false;
	},	
	
	isModified: function()
	{
		return this.mModified;
	},
	
	setModified: function()
	{
		this.mModified = true
	},
	
	reset: function ()
	{
		this.mJson = null;
		this.mArchives = null;
	},

	initWithJsonText: function ( text, emptyOnFail)
	{
		try
		{
			this.mJson = JSON.parse ( text );
			if (!this.mJson)
			{
				this.mJson = {};
			}
		}
		catch (e)
		{
			this.mJson = {};
		}

		if('__archives' in this.mJson)
		{
			this.mArchives = this.mJson['__archives'].files;
			delete this.mJson['__archives'];
		}
		else
		{
			this.mArchives = [];
		}
	},

	//cb: function ( itemKey, dstList, srcList ), which is compareItems
	//cb returns ! null, then dst[ item ] = cb return value.
	//cb returns null, then delete dst[ item ].
	foreach: function ( other, cb )
	{
		var dst = this.mJson;
		var src = other.mJson;
		// Handle all things in src.
		for ( var key in src )
		{
			this.handleItem ( key, dst, src, cb );
		}
		// Build up list of all things not in src.
		for ( var key in dst )
		{
			// Handle all things not in src.
			if ( ! (key in src) )
			{
				this.handleItem ( key, dst, src, cb );
			}
		}
	},

	handleItem: function ( key, dst, src, cb )
	{
		var ret = cb ( key, dst, src );
		if ( !ret )
		{
			delete dst[ key ];
		}
	},

	write: function ( fname )
	{
		var cb = function (err)
		{
			if (err)
			{
				console.log('Error writing manifest! ' + err);
			}
			// DO stuff?
		};

		if (this.mJson)
		{
			var out = JSON.stringify(this.mJson);
			FileSystem.writeFile(fname, out, cb);
		}
	}
});

////////////////////////////////////////////////////////////////////////////////

exports.DownloadManifest = MessageListener.subclass(
/** @lends Network.DownloadManifest.prototype */
{
	classname: 'DownloadManifest',

	/**
	 * @class The <code>DownloadManifest</code> class constructs objects that initiate the handling of a manifest file. 
	 * This ensures a set of files are kept up-to-date in the specified directory from the specified URL.
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this.reset();
	},

	_clearConnections: function()
	{
		for (var i in this.mConnections)
		{
			if(!this.mConnections.hasOwnProperty(i)) continue;
			
			this.mConnections[i].abort();
		}
		this.mConnections = [];
	},

	reset: function ()
	{
		this.mConcurrentRequests = 3;

		this.mManifest = null;

		this.mRemoteUrl = null;
		this.mLocalPath = null;
		this.mLocalRoot = null;

		this.mLocalText = null;
		this.mRemoteText = null;
		/** @private */
		this.mProgressCb = function() {};
		/** @private */
		this.mDoneCb = function() {};

		this.mPaused = false;
		this.mValid = false;

		this._clearConnections();
		this.mPendingItems = [];
		this.mCompleteBytes = 0;
		this.mTotalBytes = 0;
		
		this.mSpaceNeeded = 0;
		
		this.mNumRemoteManifestFiles = 0;
		this.mNumRemoteManifestBytes = 0;
		
		this.mDownloadArchives = true;
		this.mActiveRequests = [];

		this.mLocalGameList = LocalGameList;

		this.mNewJS = false;
		this.mAppObserver = null;

		this.mRetrySchedule = Util.RetrySchedule(50, 2000);
		this.mManifestRetrySchedule = this.mRetrySchedule.slice(0);

		if(this._statusListener)
		{
			this._statusListener.destroy();
			this._statusListener = null;
		}
		this.mCheckUpdateOnly = false;
		this.mCheckUpdateCallback = null;
	},

	_ensureTrailingSlashes: function(remoteUrl, localPath, secureContentUrl)
	{
		// Check for trailing slashes
		this.mRemoteUrl = remoteUrl.match(/.*\/$/) ? remoteUrl : remoteUrl + '/';
		// If the local path is nothing, do not alter the filename. Otherwise, ensure trailing slash
		this.mLocalRoot = (localPath.match(/.*\/$/) || (!localPath)) ? localPath : localPath + '/';
		this._secureContentUrl = ((!secureContentUrl) || secureContentUrl.match(/.*\/$/)) ? secureContentUrl : secureContentUrl + '/';
	},

	_readLocalManifest: function()
	{
		FileSystem.readFile ( this.mLocalPath, this._onReadLocalManifest.bind(this) );
	},

	_setRemotePath: function(manifestName)
	{
		if (this._secureContentUrl)
		{
			this.mRemotePath = this._secureContentUrl + manifestName;
		}
		else
		{
			this.mRemotePath = this.mRemoteUrl + manifestName;
		}
	},

	_parseManNames: function (man)
	{
		if (typeof man === 'string')
		{
			var obj = {};
			obj[man] = man;
			man = obj;
		}
		return man;
	},

	isUpdated: function(remoteUrl, localPath, manifest, doneCB, errorCB)
	{
		this.mCheckUpdateOnly = true;
		this.mCheckUpdateCallback = doneCB;

		this.mDoneCb = (typeof errorCB == 'function') ? errorCB : function() {};
		this.mProgressCb = function(done, left) {};
		var httpStatusCode = 0;
		var fullUrl = remoteUrl + "/configuration.json" + Util.getCacheBustingString();
		Util.OperationWithRetries(
			(function(failCall, abortCall)
			{
				// Start remote manifest download.
				var req = new XHR();
				req.onreadystatechange = (function()
				{
					if( req.readyState == 4 && this.mValid )	// done && not cancelled
					{
						this.mManifest = new Manifest ();
						var manifestUrl = null;
						// Only parse if we got a good response back
						if (req.status == 200 && req.responseText)
						{
							var config = JSON.parse(req.responseText);
							manifestUrl = config.contentUrl;
							if (!manifest)
							{
								manifest =
								{
									"webgame.ngmanifest":
									require('NGCore/Client/Core/_int_LGL')._int_LGL.getManifestName(config)
								};
							}

							// If config didn't have contentUrl or we never parsed(local testing), use the base URL
							if (!manifestUrl)
								manifestUrl = remoteUrl;

							manifest = this._parseManNames(manifest);
							var manifestSourceName;
							var manifestName;
							for (var key in manifest)
							{
								manifestSourceName = manifest[key];
								manifestName = key;
								break;
							}

							this._ensureTrailingSlashes(manifestUrl, localPath);
							this.mLocalPath = this.mLocalRoot + manifestName;
							this._setRemotePath(manifestSourceName);
							this._readLocalManifest();
						}
						else if (req.status == 404)
						{
							this._processError('404! Failed to download configuration at '+ fullUrl, false);
						}
						else
						{
							httpStatusCode = req.status;
							failCall();
						}
					}
				}).bind(this);

				req.open ( 'GET', fullUrl, true );
				req.send ();
			}).bind(this),
			(function()
			{
				console.log('Exceeded maximum number of manifest download retires, failing');
				this._processError('Failed to download manifest (' + httpStatusCode + ') at ' + fullUrl, false);
			}).bind(this),
			this.mFailEarly
		);

		this.mValid = true;
	},

	// progressCb: function ( completedRequests, totalRequests )
	// doneCb: function ( err, manifest )
	// throws if url/path arguments are null or empty.
	// TODO: Allow headers argument.  Currently null.
	// TODO: Allow HTTP method argument.  Currently GET.
	/**
	* @name Network.DownloadManifest#start
	* @description Start a download of a remote manifest file at <code>[remoteUrl + manifestName]</code> 
	* and read a local manifest at <code>[localPath + manifestName]</code>.<br><br>
	* <ul>
	* <li>If the local manifest does not exist, all files specified by the remote manifest are downloaded.</li>
	* <li>If the local manifest does exist, this method will update the file system at 
	* <code>[localPath]</code> to match the files specified in the remote manifest.</li>
	* </ul>
	* Each file download will trigger a <code>progress</code> callback function that returns the 
	* number of items downloaded and the total number of items to download.
	* <pre class="code">progressCb: function ( completedRequests, totalRequests )</pre>
	* When all downloads are complete, a <code>done</code> callback function is triggered that returns an error (if any) 
	* and the contents of <code>[localPath + manifestName]</code>. 
	* <pre class="code">doneCb: function ( err, manifest )</pre>
	* If an error does not occur, this function returns <code>undefined</code>.<br><br>
	* <b>Note:</b> The contents of <code>[localPath + manifestName]</code> are saved whether an error occurs or not.
	* @param {String} remoteUrl The URL to a manifest file.
	* @param {String} localPath The directory path to a manifest file.
	* @param {String} manifestName The manifest filename. 
	* @param {Function} progressCb The callback function to call for download progress.
	* @param {Function} doneCb The callback function to call when the download is complete.
	* @throws {invalid arguments} If the URL or directory path returns as empty or <code>null</code>.
	* @example Network.DownloadManifest.start(this._URL, './', this._manifestName, progressCb, doneCallback);
	* @function
    * @status iOS, Android
	*/
	/** @ignore */
	start: function ( remoteUrl, localPath, manifest, progressCb, doneCb, disableArchives, failEarly )
	{
		this.mCheckUpdateOnly = false;
		
		// Allow manifestName to be a hash with {manifestDestName: manifestSourceName}
		manifest = this._parseManNames(manifest);
		var manifestSourceName;
		var manifestName;
		for (var key in manifest)
		{
			manifestSourceName = manifest[key];
			manifestName = key;
			break;
		}

		console.log('DownloadManifest.start(', remoteUrl, localPath, manifestSourceName, ')');
		if ( ! remoteUrl || ! localPath || remoteUrl == '' || localPath == '' )
		{
			throw new Error ( 'invalid arguments: ' + JSON.stringify ( arguments ) );
		}

		// Set up instance state for this request.
		this.mManifest = new Manifest ();
		if(disableArchives)
			this.mDownloadArchives = false;
		
		// JMarr temporary hack to disable archive downloads on flash.
		if(Capabilities.getPlatformOS() == 'flash')
		{
			console.log('Flash does not yet support archive downloads');
			this.mDownloadArchives = false;
		}

		this._ensureTrailingSlashes(remoteUrl, localPath, this._secureContentUrl);
		this._setRemotePath(manifestSourceName);
		this.mLocalPath = this.mLocalRoot + manifestName;
		this.mFailEarly = failEarly;

		// try these to prevent a failed update due to bad code
		/** @private */
		this.mProgressCb = function (done, left)
		{
			try
			{
				progressCb(done, left);
			}
			catch (ex)
			{
				NgLogException(ex);
			}
		};

		var that = this;
		/** @private */
		this.mDoneCb = function (err, man, hadCache)
		{
			try
			{
				// touch the .nomedia file (MOB-1355)
				FileSystem.writeFile(that.mLocalRoot + '/.nomedia', '');

				/** @private */
				this.mProgressCb = function() {};
				/** @private */
				this.mDoneCb = function() {};
				this._setLifecycleListening(false);
				doneCb(err, man, hadCache);
			}
			catch (ex)
			{
				NgLogException(ex);
			}
		};

		this._readLocalManifest();
		this._setLifecycleListening(true);
		this.mValid = true;
	},

	abort: function()
	{
		this.reset();
	},

	pause: function()
	{
		// Cancel downloads
		this._clearConnections();

		// move active requests back to pending
		this.mPendingItems = this.mPendingItems.concat(this.mActiveRequests);
		this.mActiveRequests = [];

		this.mPaused = true;
	},

	resume: function()
	{
		if (this.mPaused)
		{
			this.mPaused = false;
			this._downloadPendingItems();
		}
	},

	_setLifecycleListening: function(toListen)
	{
		if (toListen && !this.lifeListening)
		{
			Device.LifecycleEmitter.addListener(this,
				function (event)
				{
					switch (event)
					{
						case Device.LifecycleEmitter.Event.Suspend:
						case Device.LifecycleEmitter.Event.Terminate:
							this._writeManifest();
						break;
					}
				}
			);
			this.lifeListening = true;
		}
		else if (this.lifeListening)
		{
			Device.LifecycleEmitter.removeListener(this);
			this.lifeListening = false;
		}
	},

	_theQuestion: function (toBe)
	{
		return toBe | !toBe;
	},

	_setConfig: function (cfg)
	{
		// For saving after completion
		this._Config = cfg;
		// for skipping JS download
		this._noJS = cfg.omitJsUpdate;
		// For using separate content URL
		this._secureContentUrl = cfg.secureContentUrl;
	},

	// Callback for read of local manifest file in start method.

	_onReadLocalManifest: function ( err, data )
	{
		if (this.mValid)
		{
			try	// always start try block in async callbacks
			{
				if ( ! err )
				{
					this.mLocalText = data;
				}
				else
				{
					this.mLocalText = '{}';	// Empty string is ! null.  It's ok for the read to fail.
				}
				this._downloadManifest();
			}
			catch ( ex )
			{
				NgLogException ( ex );
				this._processError ( 'Error reading local manifest err: ' + err , false );
			}
		}
	},

	// Called to start the manifest download.
	_downloadManifest: function()
	{
		var httpStatusCode = 0;
		Util.OperationWithRetries(
			(function(failCall, abortCall)
			{
				// Start remote manifest download.
				var req = new XHR();
				var id = this.mConnections.push(req) - 1;
				req.onreadystatechange = (function()
				{
					if( req.readyState == 4 && this.mValid )	// done && not cancelled
					{
						delete this.mConnections[id];
						httpStatusCode = req.status;
						if ( httpStatusCode == 200 )
						{
							this.mRemoteText = req.responseText;
							this._checkItems();

							if (this.mCheckUpdateOnly)
								this._checkUpdate();
							else
								this._evalManifests ();
						}
						else
						{
							console.log( 'Download of manifest at ' + this.mRemotePath
								+Util.getCacheBustingString() + ' failed: ' + httpStatusCode + ' '
								+ req.responseText);
							if (httpStatusCode == 404)
							{
								abortCall();
							}
							else
							{
								failCall();
							}
						}
					}
				}).bind(this);

				req.open ( 'GET', this.mRemotePath + Util.getCacheBustingString(), true );
				req.send ();
			}).bind(this),
			(function()
			{
				this._processError('Failed to download manifest (' + httpStatusCode + ')', false);
			}).bind(this),
			this.mFailEarly
		);
	},

	// Can be called at any time.

	_processError: function ( message , writeManifest)
	{
		if (writeManifest && this.mManifest)
		{
			this._writeManifest();
		}

		// Don't call the doneCB without checking local text
		if (this.mValid)
		{
			this.mDoneCb ( message, null,  this.mLocalText ? this.mLocalText.length > 2 : false );
			this.reset ();
		}
	},

	_checkItems: function()
	{
		// Init source and destination manifests.
		this.mManifest.initWithJsonText ( this.mLocalText , true );
		var other = new Manifest ();
		other.initWithJsonText ( this.mRemoteText );

		// Build list of pending local items.
		this.mManifest.foreach ( other, this._compareItems.bind(this));
	},

	_checkUpdate: function()
	{
		this.mPendingItems = [];
		this.mCheckUpdateCallback(this.mTotalBytes > 0, this.mTotalBytes);
	},

	_evalManifests: function ()
	{
		try
		{
			// JMarr always download with zips if they are available.
			// If we only need to download less than 33% of files and less than 33% of bytes, then don't use an archive.
			// Additinoally, we must be on wifi, or else carriers might tamper with our files.
			/*var NetworkEmitter = require('../Device/NetworkEmitter').NetworkEmitter;
			if(this.mPendingItems.length < this.mNumRemoteManifestFiles * 0.33
				&& this.mTotalBytes < this.mNumRemoteManifestBytes * 0.33
				&& NetworkEmitter.getLastStatus() == NetworkEmitter.Status.Wifi)
			{
				this.mDownloadArchives = false;
			}*/
			
			// Cache total bytes into separate variable. Archive download might increase
			// space needed, but not total bytes.
			this.mSpaceNeeded = this.mTotalBytes;

			var other = new Manifest ();
			other.initWithJsonText ( this.mRemoteText );
			// If there is no archive in the manifest, don't download an archive.
			if(!other.mArchives)
				this.mDownloadArchives = false;

			// Prepare for archive downloads. If mDownloadArchives is true,
			// then all files will be downloaded through an archive. Otherwise,
			// only files that are makred as force archive will be downloaded
			// through archive.
			this._prepareForArchiveDownload(other.mArchives, !this.mDownloadArchives);
			
			// Trigger progress callback.
			this.mProgressCb ( this.mCompleteBytes, this.mTotalBytes );

			this.mLocalGameList.freeSpace(this.mSpaceNeeded, (function (err)
			{
				if (err)
				{
					this._processError(err, false);
					return;
				}
				var num = this.mPendingItems.length;
				if (num)
				{
					console.log("Going to download %d items.", num);
					if (num < 10)
					{
						console.log("Items: " + JSON.stringify(this.mPendingItems));
					}
				}
				// Download anything that got into pending list
				this._downloadPendingItems ();
			}).bind(this));
		}
		catch (e)
		{
			NgLogException ( e );
			this.mDoneCb ( 'Failed processing manifests!', null );
		}
	},
	
	// Decides which archives need to be downloaded to ensure that all of the pending files are downloaded.
	_prepareForArchiveDownload: function(archives, onlyForcedFiles)
	{
		console.log('DownloadManfiest._prepareForArchiveDownload onlyForcedFiles:', onlyForcedFiles);
		// Iterate over files that need to be covered and make sure they are included.
		var neededFiles = [];
		var includedArcns = {};
		var includedExpSize = 0;
		var includedArcSize = 0;
		var filesToCover = this.mPendingItems;
		var nonForcedFiles = [];
		for(var i=0; i < filesToCover.length; ++i)
		{
			// If this file isn't an archive, just download the file.
			var f = filesToCover[i];
			if(!f.arcn)
			{
				//console.log('NonForced: including arnc-less %s', f.name);
				neededFiles.push(f);
				includedExpSize += f.size;
				continue;
			}
			
			// Record that this archive provides this file.
			var arcn = f.arcn;
			var a = archives[arcn];
			if(!a.files)
				a.files = [f];
			else
				a.files.push(f);
			
			// Is this archive already incldued?
			if(includedArcns[arcn])
				continue;
			
			// If we are only including forced files, remember that this
			// is a non forced file that we need to download. If after evaluating
			// all of the forced files and these files are not included, they will
			// be explicitly included.
			if(onlyForcedFiles && !f.arcForce)
			{
				nonForcedFiles.push(f);
				//console.log('NonForced: delaying decision about %s in arcn %d', f.name, f.arcn);
				continue;
			}
			
			//console.log('Forced: including %s from arcn %d', f.name, f.arcn);
			
			// Include the archive associated with this arcn.
			neededFiles.push(a);
			includedArcns[arcn] = true;
			includedExpSize += a.expSize;
			includedArcSize += a.arcSize;
		}
		
		// If only downloading forced archives, examine all of the queued
		// files that are not forced. If their archive is not included, then 
		// directly include the file.
		for(i=0; i < nonForcedFiles.length; ++i)
		{
			// Is the archive for this file already incldued?
			// This will happen if a forced file (like a .js) 
			// forced the archive to be included.
			var f = nonForcedFiles[i];
			if(includedArcns[f.arcn])
			{
				//console.log('NonForced: skipping %s because it is already in arcn %d', f.name, f.arcn);
				continue;
			}
			
			//console.log('NonForced: including %s from arch %d', f.name, f.arcn);
			
			// Otherwise, include this file.
			neededFiles.push(f);
			includedExpSize += f.size;
		}
		
		// Tell the rest of the world about our choices.
		this.mPendingItems = neededFiles;
		this.mTotalBytes = includedExpSize;
		this.mSpaceNeeded = includedExpSize + includedArcSize;
	},

	// Callback from Manifest.foreach.

	_compareItems: function ( key, dst, src )
	{
		var ditem = dst[key];
		var sitem = src[key];

		// Early out for removed file.  Always delete.
		if ( ! sitem )
		{
			this.mManifest.setModified();
			
			var fname = this.mLocalRoot + key;
			var cb = function(err)
			{
				if (err)
				{
					console.log('Error deleting ' + fname + ' error: ' + err);
				}
			};
			
			
			FileSystem.deleteFile(fname, cb);

			// If the item was pending, delete the temporary file it was downloading
			if ('pending' in ditem )
			{
				fname = fname + '.tmp';
				FileSystem.deleteFile(fname, cb);
			}
			
			return false;
		}

		var isJS = this._extensionMatch ( key, 'js' );

		// Don't download the html or the js with noJS.
		if (this._noJS && (isJS || key == "index.html"))
		{
			// Don't download JS!! keep it in the local manifest, but don't push it to download
			return true;
		}

		sitem.name = key;
		this.mNumRemoteManifestFiles += 1;
		this.mNumRemoteManifestBytes += sitem.size;

		// No local version or version mismatch, must download.
		if ( ! ditem || ditem.hash != sitem.hash)
		{
			if ( isJS )
			{
				this.mNewJS = true;
			}

			// Tally the space we need for downloading new items
			this.mTotalBytes += sitem.size;
			
			this.mManifest.setModified();

			// Add to the pending queue.
			this.mPendingItems.push ( sitem );
		}
		
		return true;
	},

	// Utility method to check for case-insensitive match for file extension.
	
	_extensionMatch: function ( fname, ext )
	{
		var pattern = new RegExp ( '^.*\.(' + ext + ')$', 'i' );
		var ret = fname.match ( pattern );
		return ret;
	},

	// Once in download state, this method is called to start downloading 
	// assets from manifest.  When each asset successfully completes, this method
	// will also be called to start the next download.  This method institutes
	// the logic for having a limited number of concurrent downloads from
	// the mCurrentRequests and mConcurrentRequests members.

	_downloadPendingItems: function ()
	{
		if (this.mValid && !this.mPaused)
		{
			// Are we done?
			if ( this.mPendingItems.length == 0 && this.mActiveRequests.length == 0)
			{
				if (this.mManifest.isModified())
				{
					this._writeManifest ();
				}
				this._writeConfig();

				// Trigger done callback and reset.
				this.mDoneCb ( null, this.mManifest );
				this.reset ();
				return;
			}

			// Not done, pop more pending items and start their downloads.
			while ( this.mPendingItems.length && this.mActiveRequests.length < this.mConcurrentRequests )
			{
				// Download the next pending file.
				var item = this.mPendingItems.pop ();
				item.retrySchedule = this.mRetrySchedule.slice(0);
				this._downloadItem(item);
			}
		}
	},
	
	_downloadItem: function(item)
	{
		this.mActiveRequests.push(item);
		var remoteUrl = this.mRemoteUrl + item.name;
		if(item.mangled)
		{
			var i = remoteUrl.lastIndexOf('.');
			remoteUrl = remoteUrl.substr(0, i) + '-' + remoteUrl.substr(i+1) + '.bin';
		}

		Util.OperationWithRetries((function(failCb)
		{
			// Start the download.
			var dlFile = new DownloadFile();
			var id = this.mConnections.push(dlFile) - 1;
			dlFile.start(this.mLocalRoot + item.name,
				'GET',
				remoteUrl + Util.getCacheBustingString(),
				[],
				this._onDownloadItemComplete.bind(this, item, failCb, id));
		}).bind(this), (function()
		{
			console.log('Manifest download failed. Too many failed download attempts for ' + item.name );
			this._processError ( 'Could not download file ' + item.name , true);
		}).bind(this), this.mFailEarly);
	},

	_removeActiveRequest: function (item)
	{
		for (var i in this.mActiveRequests)
		{
			if (item == this.mActiveRequests[i])
			{
				this.mActiveRequests.splice(i, 1);
			}
		}
	},

	// Callback for completion of download started in downloadItem method.
	// Will throw if item does not have pending member set.

	_onDownloadItemComplete: function ( item, failCb, id, status, hash )
	{
		try
		{
			delete this.mConnections[id];
			// Was there an error or bad download?
			if(status != 200 || item.hash != hash)
			{
				// Try to download the item again.
				console.log('Download failed.  Retrying ' + item.name );
				console.log('Status: ' + status + ' manifest hash: ' + item.hash + ' actual hash: ' + hash);
				failCb();
				return;
			}
			
			// Is this an archive?
			if(item.files)
			{
				// Temporarially increase the max number of connections while we decompress the archive.
				++this.mConcurrentRequests;
				
				FileSystem.decompressFile(this.mLocalRoot + item.name, this.mLocalRoot, {}, (function(err, files)
				{
					// Restore max connections to original value.
					--this.mConcurrentRequests;
					
					// Delete the zip file.
					FileSystem.deleteFile(this.mLocalRoot + '/' + item.name, {});
					
					if(err)
					{
						// Try to download the item again.
						console.log('Decompress failed.  Retrying ' + item.name );
						failCb();
					}
					
					for(var i=0; i < item.files.length; ++i)
					{
						var f = item.files[i];
						this.mManifest.mJson[f.name] = {size: f.size, hash: f.hash};
					    if (typeof f.encryption != "undefined")
						this.mManifest.mJson[f.name].encryption = f.encryption;
					}

					this._removeActiveRequest(item);
					this.mCompleteBytes += Number(item.expSize);
					this.mProgressCb ( this.mCompleteBytes, this.mTotalBytes );
					this._downloadPendingItems ();
				}).bind(this));
			}
			else
			{
				// Update our working manifest.
				this.mManifest.mJson[item.name] = {size: item.size, hash: item.hash};
			    if (typeof item.encryption != "undefined")
				this.mManifest.mJson[item.name].encryption = item.encryption;
				
				// Make callbacks (like a boss).
				this._removeActiveRequest(item);
				this.mCompleteBytes += Number(item.size);
				this.mProgressCb ( this.mCompleteBytes, this.mTotalBytes );
				this._downloadPendingItems ();
			}
		}
		catch ( ex )
		{
			// Unlikely, but safety
			NgLogException ( ex );
			this._processError ( 'Error after finishing the download of item ' + item 
				+ '. status is ' + status , true );
		}
	},

	// Flush changes to locally cached manifest file.

	_writeManifest: function ()
	{
		console.log("DM Complete!");
		try
		{
			if (this.mManifest)
				this.mManifest.write ( this.mLocalPath );
		}
		catch (ex)
		{
			NgLogException(ex);
		}
	},

	_writeConfig: function ()
	{
		try
		{
			if (this._Config)
			{
				// console.log("writing |%s| to %s", JSON.stringify(this._Config), this.mLocalRoot + Capabilities._getConfigFile());
				FileSystem.writeFile(this.mLocalRoot + Capabilities._getConfigFile(),
					JSON.stringify(this._Config), function(err) {console.log(err); } );
			}
		}
		catch (ex)
		{
			NgLogException(ex);
		}
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/LocalGameList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/LocalGameList'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/LocalGameList'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class LocalGameList
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Proc = require('NGCore/Client/Core/Proc').Proc;
var Class = require('NGCore/Client/Core/Class').Class;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Base64 = require('NGCore/Client/Core/Base64').Base64;
var toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
var Util = require('NGCore/Client/Network/Util').Util;
var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;

////////////////////////////////////////////////////////////////////////////////

var LifeListener = MessageListener.subclass(
{
	initialize: function(listen)
	{
		LifecycleEmitter.addListener(this, this.onLifecycleUpdate);
		this._listener = listen;
	},

	destroy: function()
	{
		LifecycleEmitter.removeListener(this);
	},

	onLifecycleUpdate: function(event)
	{
		switch (event)
		{
			case Device.LifecycleEmitter.Event.Resume:
				this._listener.onResume();
				break;
		}
	}
});

exports.LocalGameList = Class.singleton (
/** @lends Core.LocalGameList.prototype */
{
	classname: 'LocalGameList',

	/**
	 * @class The <code>LocalGameList</code> class constructs objects that handle the loading and updating of a user's game list.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		new LifeListener(this);
		this.mRefCount = 0;
		this.mRefTable = [];
		this.mSpaceAvailable = 0;
		this.mRequiredAvailableSpace = 0;
		
		this.mSpaceCB = [];

		this._getRepoSpaceSendGen();

		var self = this;
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		this.mGameStore = KeyValueCache.global("Core.GameList");
		this.mActiveGameKey = "activeGames";
		this.onResume();
	},


	/** @private */
	onResume: function()
	{
		this._reloadGameList();
	},

	_reloadGameList: function()
	{
		this.mGameStore.getItem(this.mActiveGameKey,
			(function(error, value)
			{
				var list;
				if (value)
					list = JSON.parse(value);
				else
					list = [];

				this.mGameList = list;
				if (typeof this.mListListen == 'function')
					this.mListListen();
			}).bind(this),
			true
		);
	},

	/** @private */
	setListListener: function(funk)
	{
		this.mListListen = funk;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 302
	// Method create = -1
	// Method updateGame = 2
	// Method updateDone = 3
	// Method getRepoSpace = 4
	// Method repoSpace = 5
	// Method deleteGame = 6
	// Method _setUpdateProgressVisible = 7
	// Method _setUpdateProgressBounds = 8
	// Method pauseUpdate = 9
	// Method resumeUpdate = 10
	// Method cancelUpdate = 11
	// Method updateProgress = 12
	// Method runGame = 13
	// Method finishGame = 14
	// Method _forwardException = 15
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._updateDoneRecv( cmd );
					break;
				case 5:
					instance._repoSpaceRecv( cmd );
					break;
				case 12:
					instance._updateProgressRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[302] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_updateDoneRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in LocalGameList.updateDone from command: " + cmd );
			return false;
		}
		
		obj[ "id" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "id" ] === undefined )
		{
			NgLogE("Could not parse id in LocalGameList.updateDone from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in LocalGameList.updateDone from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_repoSpaceRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		obj[ "space" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "space" ] === undefined )
		{
			NgLogE("Could not parse space in LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_updateProgressRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 4 )
		{
			NgLogE("Could not parse due to wrong argument count in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "cur" ] = Proc.parseInt( cmd[ 1 ] );
		if( obj[ "cur" ] === undefined )
		{
			NgLogE("Could not parse cur in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "total" ] = Proc.parseInt( cmd[ 2 ] );
		if( obj[ "total" ] === undefined )
		{
			NgLogE("Could not parse total in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Proc.parseBool( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in LocalGameList.updateProgress from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( ":302,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_updateGameSendGen: function( url, id )
	{
		Proc.appendToCommandString( ":302,2," + this.__objectRegistryId + "," + Base64.encode( url ) + "," + id  );
	},
	
	/** @private */
	_getRepoSpaceSendGen: function(  )
	{
		Proc.appendToCommandString( ":302,4," + this.__objectRegistryId );
	},
	
	/** @private */
	_deleteGameSendGen: function( mdFive )
	{
		Proc.appendToCommandString( ":302,6," + this.__objectRegistryId + "," + Base64.encode( mdFive )  );
	},
	
	/** @private */
	__setUpdateProgressVisibleSendGen: function( visible )
	{
		Proc.appendToCommandString( ":302,7," + this.__objectRegistryId + "," + ( visible ? 1 : 0 )  );
	},
	
	/** @private */
	__setUpdateProgressBoundsSendGen: function( x, y, w, h )
	{
		Proc.appendToCommandString( ":302,8," + this.__objectRegistryId + "," + x + "," + y + "," + w + "," + h  );
	},
	
	/** @private */
	_pauseUpdateSendGen: function( url )
	{
		Proc.appendToCommandString( ":302,9," + this.__objectRegistryId + "," + Base64.encode( url )  );
	},
	
	/** @private */
	_resumeUpdateSendGen: function( url )
	{
		Proc.appendToCommandString( ":302,10," + this.__objectRegistryId + "," + Base64.encode( url )  );
	},
	
	/** @private */
	_cancelUpdateSendGen: function( url )
	{
		Proc.appendToCommandString( ":302,11," + this.__objectRegistryId + "," + Base64.encode( url )  );
	},
	
	/** @private */
	_runGameSendGen: function( url )
	{
		Proc.appendToCommandString( ":302,13," + this.__objectRegistryId + "," + Base64.encode( url )  );
	},
	
	/** @private */
	_finishGameSendGen: function(  )
	{
		Proc.appendToCommandString( ":302,14," + this.__objectRegistryId );
	},
	
	/** @private */
	__forwardExceptionSendGen: function( exceptionString )
	{
		Proc.appendToCommandString( ":302,15," + this.__objectRegistryId + "," + Base64.encode( exceptionString )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// updateGame: function( url, id ) {}
	
	// _updateDoneRecv: function( cmd ) {}
	// getRepoSpace: function(  ) {}
	
	// _repoSpaceRecv: function( cmd ) {}
	// deleteGame: function( mdFive ) {}
	
	// _setUpdateProgressVisible: function( visible ) {}
	
	// _setUpdateProgressBounds: function( x, y, w, h ) {}
	
	// pauseUpdate: function( url ) {}
	
	// resumeUpdate: function( url ) {}
	
	// cancelUpdate: function( url ) {}
	
	// _updateProgressRecv: function( cmd ) {}
	// runGame: function( url ) {}
	
	// finishGame: function(  ) {}
	
	// _forwardException: function( exceptionString ) {}
	

// {{/Wg Generated Code}}
	
	_setProgressVisible: function (progressVisible) {
		this.progressVisible = progressVisible;
		this.__setUpdateProgressVisibleSendGen(progressVisible);
	},
	
	_setProgressBounds: function(bounds) {
		this.__setUpdateProgressBoundsSendGen(bounds[0],bounds[1],bounds[2],bounds[3]);
	},
	
	_createProcSwitchDialog: function(title)
	{
		var UI = require('NGCore/Client/UI').UI;
		var Device = require('NGCore/Client/Device').Device;
		var w = NGWindow.outerWidth;
		var h = NGWindow.outerHeight;
		
		if(Device.OrientationEmitter.getInterfaceOrientation() == Device.OrientationEmitter.Orientation.Landscape
			|| Device.OrientationEmitter.getInterfaceOrientation() == Device.OrientationEmitter.Orientation.LandscapeLeft)
		{
			w = NGWindow.outerHeight;
			h = NGWindow.outerWidth;
		}
		
		var r = new UI.ViewGeometry.Rect(0, 0, w, h);
		
		var background = new UI.View({
			'frame': r.array(),
			'title': title,
			'backgroundColor': "8000"
		});
		
		r.inset(Math.round( (h - 238) / 2.0 ), 10);
		
		var dialog = new UI.View({
			'frame': r.array(),
			'gradient': {
				gradient: ["FF102031 0.0", "FF102031 0.394", "FF101820 0.394", "FF101820 1.0"],
				outerLine: "FF9c 1.0"
			}
		});
		background.addChild(dialog);

		r.x = r.y = 0;
		
		var header = new UI.Label({
			'frame': r.sliceVertical(94).array(),
			'text': (title || "Please Wait…"),
			'textColor': "FFFF",
			'textShadow': "8000 1.0 {0,-1}",
			'textSize': 24.0,
			'textGravity': [0.0, 0.5],
			'textInsets': [10, 30, 10, 30]
		});
		dialog.addChild(header);
		
		r.inset(36, 36 + Math.floor( (r.w - r.h) / 2));
		r.h = r.w;
		
		var spinner = new UI.Spinner({
			'frame': r.array()
		});
		dialog.addChild(spinner);
		
		UI.Window.document.addChild(background);
		
		return background;
	},

	/**
	* Restart the current game
	*/
	restartGame: function()
	{
		this.runGame(Capabilities.getServer() + "/" + Capabilities.getGame());
	},

	/**
	* Launch a game from the specified URL.
	* @param {String} url The specified URL of a game. Null to return to mobage.
	*/
	
	runGame: function( url )
	{
		console.log("Calling runGame with " + url);
		if (!url)
		{
			console.log("Finishing");
			this._finishGame();
		}
		else
		{
			this._runGameSendGen(Util.NormalizeUrl(url));
		}
	},

/** private */
	_finishGame: function()
	{
		this._finishGameSendGen();
	},

	// Next 5 functions are for mobage, not developers.

	// callback = function(gameUrl, dl'd, total, error)
	// mobage responsibility to intercept when dl'd == total, update is finished
	//	or know if there was an error by checking that param

	listenUpdates: function(callback)
	{
		this.mUpdateListener = callback;
	},

	stopUpdateListening: function()
	{
		delete this.mUpdateListener;
	},

	pauseUpdate: function(url)
	{
		this._pauseUpdateSendGen(Util.NormalizeUrl(url));
	},

	resumeUpdate: function(url)
	{
		this._resumeUpdateSendGen(Util.NormalizeUrl(url));
	},

	cancelUpdate: function(url)
	{
		this._cancelUpdateSendGen(Util.NormalizeUrl(url));
	},

	/**
	* Update an application at the specified URL.
	* @example Core.LocalGameList.updateGame(url, (function(err)
	*	{
	*		if (err)
	*		{
	*			NgLogE("GameHub error updating game! " + err);
	*			Network.Util.showSimpleNetworkError();
	*			this._loadingGame = false;
	*		}
	*		else
	*		{
	*			Core.LocalGameList.runGame(url);
	*		}
	*	});
	* @param {String} url The specified URL.
	* @param {Function} cb The callback function to pass in.
	*/
	
	updateGame: function( url , cb )
	{
		var reqId = this.mRefCount;
		this.mRefTable[this.mRefCount++] = cb;

		this._updateGameSendGen( Util.NormalizeUrl(url), reqId );
		return reqId;
	},
	
	/**
	* Launch an updated application from the specified URL.
	* @example Core.LocalGameList.runUpdatedGame('/games/MyGames');
	* @param {String} url The specified URL of an updated application.
	*/
	
	runUpdatedGame: function (url)
	{
		if (!url)
		{
			this._finishGame();
			return;
		}

		this.updateGame(url,
			(function(err)
			{
				if (err)
				{
					NgLogE("LGL Error updating game! " + err);
					Util.showFatalErrorDialog();
				}
				else
				{
					this.runGame(url);
				}
			}).bind(this)
		);
	},

	_updateProgressRecv: function( cmd )
	{
		var obj = {};
		this._updateProgressRecvGen(cmd, obj);
		if (this.mUpdateListener)
			this.mUpdateListener(obj.url, obj.cur, obj.total, obj.error);
	},

	_updateDoneRecv: function( cmd )
	{
		var obj = {};
		this._updateDoneRecvGen(cmd, obj);

		this._reloadGameList();

		var cb = this.mRefTable[obj.id];
		if (cb)
		{
			cb(obj.error);
		}

		delete this.mRefTable[obj.id];
		this._getRepoSpaceSendGen();
	},

	_repoSpaceRecv: function( cmd )
	{
		var obj = {};
		this._repoSpaceRecvGen(cmd, obj);
		this.mSpaceAvailable = obj.space - 7340032; // KJ report 7mb less
		console.log('LocalGameList.got response:', this.mSpaceAvailable, 'and need:', this.mRequiredAvailableSpace);
		
		if(this.mRequiredAvailableSpace > this.mSpaceAvailable)
		{
			var errorAlert = new UI.AlertDialog();
			errorAlert.setText(Core.Localization.getString("SD card is full"));
			errorAlert.setChoices([Core.Localization.getString("Exit")]);
			errorAlert.game = this.game;
			errorAlert.onchoice = function(ret)
			{
				errorAlert.hide();
				LifecycleEmitter.exitProcess();
			};
			errorAlert.show();
		}
		else
		{
			for(var i=0; i < this.mSpaceCB.length; ++i)
			{
				this.mSpaceCB[i]();
			}
			this.mSpaceCB = [];
			this.mRequiredAvailableSpace = 0;
		}
	},

	/**
	 * @private
	 */
	getGameList: function()
	{
		// Caveat! This will return an empty list if it is the first call. Must initialize beforehand.-KJ
		return this.mGameList;
	},

	/**
	 * @private
	 */
	updateGameList: function(list)
	{
		this.mGameList = list;
	},

	/**
	 * @private
	 */
	freeSpace: function(space, cb)
	{
		this.mRequiredAvailableSpace += space;
		
		this.mSpaceCB.push(cb);
		console.log('LocalGameList.freeSpace space=', this.mRequiredAvailableSpace);
		if(this.mSpaceCB.length == 1)
		{
			console.log('LocalGameList.sending request to native');
			// Send request to native if this is the first requester.
			this._getRepoSpaceSendGen();
		}
	},

	/**
	 * @private
	 */
	deleteGame: function(url)
	{
		url = Util.NormalizeUrl(url);
		var hash = toMD5(url);
		this._deleteGameSendGen(hash);

		var self = this;
		var doneCB = function ()
		{
			NgLogD("LocalGameList finished deleting game from " + self.mActiveGameKey + " for " + hash );
		};

		// Update cached game list to match what's going to happen in high-priv.
		// Matches logic in _LocalGameList._deleteGameFromStorage, but doesn't
		// write to Storage key.
		if( this.mGameList )
		{
			var list = this.mGameList;
			var good = false;
			var ind;
			var out = [];
			for(ind = 0; ind < list.length; ++ind)
			{
				if(list[ind].name == hash)
					good = true;
				else
					out.push(list[ind]);
			}

			if( good )
			{
				NgLogD("LocalGameList found and removed " + hash);
				this.mGameList = out;
			}
			else
				NgLogD("LocalGameList failed to find and remove " + hash);
		}
		else
			NgLogD("LocalGameList cache not warm, can't remove " + hash);
	},

	/**
	 * Check if an update is available for the specified application.<br><br>
	 * The following code illustrates how to retrieve an application name to pass in for this call.
	 * @param {String} game The specified game. Use <code>{@link Core.Capabilities.getGame}</code> to return the game name.
	 * @param {Function} callback The function to call once the check is complete.
	 * @example
	 *
	 * updateButton.onclick = function() {
	 *     LocalGameList.updateAvailable(Core.Capabilities.getUrl(), function(updated, spaceNeeded) {
	 *         if (updated)
	 *             LGL.runUpdatedGame(Core.Capabilities.getUrl());
	 *     });
	 * };
	 * @status
	 */
	updateAvailable: function(game, doneCB, errorCB)
	{
		var _int_LGL = require('NGCore/Client/Core/_int_LGL')._int_LGL;
		_int_LGL.updateAvailable(game, doneCB, errorCB);
	},

	_forwardException: function( exceptionString )
	{
		this.__forwardExceptionSendGen({exceptionString:exceptionString});
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device'] || {}; $MODULE_REGISTRY['NGCore/Client/Device'] = exports; /**
 * <p>Classes and objects contained by the Device module.</p>
 * @name Device
 * @namespace
 * @description <p>The Device module is a collection of classes that support the effect of physical movement on a device.
 * Each class instantiates a device singleton that emits when specific device conditions are met:</p>
 *<ul>
 *<li><code>{@link Device.KeyEmitter}</code>: A singleton object for emitting when the user presses or releases a device hardware key.</li>
 *<li><code>{@link Device.LifecycleEmitter}</code>: A singleton object for emitting when device lifecycle events occur.</li>
 *<li><code>{@link Device.LocationEmitter}</code>: A singleton object for emitting the geographic location of a device.</li>
 *<li><code>{@link Device.MemoryEmitter}</code>: A singleton object for emitting when low-memory states occur on a device.</li>
 *<li><code>{@link Device.MotionEmitter}</code>: A singleton object for emitting objects that collect spatial data from a device.</li>
 *<li><code>{@link Device.NetworkEmitter}</code>: A singleton object for emitting when a change in network status occurs for a device.</li>
 *<li><code>{@link Device.OrientationEmitter}</code>: A singleton object for emitting when a change to the physical orientation of the device occurs.</li>
 *<li><code>{@link Device.ShakeEmitter}</code>: A singleton object for emitting when the device detects a shake gesture.</li>
 *</ul>
 */
exports.Device = {};

exports.Device.__defineGetter__("LifecycleEmitter", function() {
	delete this.LifecycleEmitter;
	return this.LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
});
exports.Device.__defineGetter__("LocationEmitter", function() {
	delete this.LocationEmitter;
	return this.LocationEmitter = require('NGCore/Client/Device/LocationEmitter').LocationEmitter;
});
exports.Device.__defineGetter__("MemoryEmitter", function() {
	delete this.MemoryEmitter;
	return this.MemoryEmitter = require('NGCore/Client/Device/MemoryEmitter').MemoryEmitter;
});
exports.Device.__defineGetter__("MotionEmitter", function() {
	delete this.MotionEmitter;
	return this.MotionEmitter = require('NGCore/Client/Device/MotionEmitter').MotionEmitter;
});
exports.Device.__defineGetter__("NetworkEmitter", function() {
	delete this.NetworkEmitter;
	return this.NetworkEmitter = require('NGCore/Client/Device/NetworkEmitter').NetworkEmitter;
});
exports.Device.__defineGetter__("OrientationEmitter", function() {
	delete this.OrientationEmitter;
	return this.OrientationEmitter = require('NGCore/Client/Device/OrientationEmitter').OrientationEmitter;
});
exports.Device.__defineGetter__("ShakeEmitter", function() {
	delete this.ShakeEmitter;
	return this.ShakeEmitter = require('NGCore/Client/Device/ShakeEmitter').ShakeEmitter;
});
exports.Device.__defineGetter__("KeyEmitter", function() {
	delete this.KeyEmitter;
	return this.KeyEmitter = require('NGCore/Client/Device/KeyEmitter').KeyEmitter;
});
exports.Device.__defineGetter__("PushNotificationEmitter", function() {
	delete this.PushNotificationEmitter;
	return this.PushNotificationEmitter = require('NGCore/Client/Device/_PushNotificationEmitter').PushNotificationEmitter;
});
exports.Device.__defineGetter__("InAppPurchaseEmitter", function() {
	delete this.InAppPurchaseEmitter;
	return this.InAppPurchaseEmitter = require('NGCore/Client/Device/_InAppPurchaseEmitter').InAppPurchaseEmitter;
});
exports.Device.__defineGetter__("InAppPurchase", function() {
	delete this.InAppPurchase;
	return this.InAppPurchase = require('NGCore/Client/Device/_InAppPurchase').InAppPurchase;
});
exports.Device.__defineGetter__("IPCEmitter", function() {
	delete this.IPCEmitter;
	return this.IPCEmitter = require('NGCore/Client/Device/IPCEmitter').IPCEmitter;
});
exports.Device.__defineGetter__("LayoutEmitter", function() {
	delete this.LayoutEmitter;
	return this.LayoutEmitter = require('NGCore/Client/Device/LayoutEmitter').LayoutEmitter;
});
exports.Device.__defineGetter__("LocalNotification", function() {
	delete this.LocalNotification;
	return this.LocalNotification = require('NGCore/Client/Device/_LocalNotification').LocalNotification;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core'] || {}; $MODULE_REGISTRY['NGCore/Client/Core'] = exports; /**
 * <p>Classes and objects contained by the Core module.</p>
 * @name Core
 * @namespace
 * @description <p>The Core module is a collection of classes that provide applications with access to:</p>
 * <ul>
 * <li>Core components of a device.</li>
 * <li>APIs that define a class-based structure for development.</li>
 * <li>Objects that support application updates.</li>
 * </ul>
 * <p>Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 * <li><code>{@link Core.Analytics}</code>: Construct objects that keep track of game-specific items that require analysis and counting.</li>
 * <li><code>{@link Core.Capabilities}</code>: A singleton object that contains data about device hardware components.</li>
 * <li><code>{@link Core.Class}</code>: Supports construction of objects and classes for use in OOP environments.</li>
 * <li><code>{@link Core.Color}</code>: Control the RGB color components of a device.</li>
 * <li><code>{@link Core.LocalGameList}</code>: Construct objects that manage a user's game list.</li>
 * <li><code>{@link Core.MessageEmitter}</code>: A base class object for constructing objects that emit application notifications.</li>
 * <li><code>{@link Core.MessageListener}</code>: A base class object for constructing objects that handle application notifications.</li>
 * <li><code>{@link Core.NativeAppLaunch}</code>: Construct objects for storing <code>intent</code> strings.</li>
 * <li><code>{@link Core.Point}</code>: Control the point values for <i>x</i> and <i>y</i> coordinates.</li>
 * <li><code>{@link Core.Rect}</code>: Construct rectangle objects.</li>
 * <li><code>{@link Core.Size}</code>: Control the values for <i>height</i> and <i>width</i> components.</li>
 * <li><code>{@link Core.Time}</code>: A singleton that contains data about device timing values.
 * <li><code>{@link Core.UpdateEmitter}</code>: Control the application update time rate.</li>
 * <li><code>{@link Core.Vector}</code>: Control the vector values for <i>x</i> and <i>y</i> coordinates.</li>
 * </ul>
 */
exports.Core = {};

exports.Core.__defineGetter__("Analytics", function() {
	delete this.Analytics;
	return this.Analytics = require('NGCore/Client/Core/Analytics').Analytics;
});
exports.Core.__defineGetter__("Base64", function() {
	delete this.Base64;
	return this.Base64 = require('NGCore/Client/Core/Base64').Base64;
});
exports.Core.__defineGetter__("Capabilities", function() {
	delete this.Capabilities;
	return this.Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
});
exports.Core.__defineGetter__("Class", function() {
	delete this.Class;
	return this.Class = require('NGCore/Client/Core/Class').Class;
});
exports.Core.__defineGetter__("Color", function() {
	delete this.Color;
	return this.Color = require('NGCore/Client/Core/Color').Color;
});
exports.Core.__defineGetter__("Vector", function() {
	delete this.Vector;
	return this.Vector = require('NGCore/Client/Core/Vector').Vector;
});
exports.Core.__defineGetter__("Point", function() {
	delete this.Point;
	return this.Point = require('NGCore/Client/Core/Point').Point;
});
exports.Core.__defineGetter__("Size", function() {
	delete this.Size;
	return this.Size = require('NGCore/Client/Core/Size').Size;
});
exports.Core.__defineGetter__("Rect", function() {
	delete this.Rect;
	return this.Rect = require('NGCore/Client/Core/Rect').Rect;
});
exports.Core.__defineGetter__("MessageEmitter", function() {
	delete this.MessageEmitter;
	return this.MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
});
exports.Core.__defineGetter__("MessageListener", function() {
	delete this.MessageListener;
	return this.MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
});
exports.Core.__defineGetter__("ObjectRegistry", function() {
	delete this.ObjectRegistry;
	return this.ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
});
exports.Core.__defineGetter__("Time", function() {
	delete this.Time;
	return this.Time = require('NGCore/Client/Core/Time').Time;
});
exports.Core.__defineGetter__("toMD5", function() {
	delete this.toMD5;
	return this.toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
});
exports.Core.__defineGetter__("SHA1", function() {
	delete this.SHA1;
	return this.SHA1 = require('NGCore/Client/Core/SHA1').SHA1;
});
exports.Core.__defineGetter__("UpdateEmitter", function() {
	delete this.UpdateEmitter;
	return this.UpdateEmitter = require('NGCore/Client/Core/UpdateEmitter').UpdateEmitter;
});
exports.Core.__defineGetter__("Proc", function() {
	delete this.Proc;
	return this.Proc = require('NGCore/Client/Core/Proc').Proc;
});
exports.Core.__defineGetter__("Logger", function() {
	delete this.Logger;
	return this.Logger = require('NGCore/Client/Core/Logger').Logger;
});
exports.Core.__defineGetter__("LocalGameList", function() {
	delete this.LocalGameList;
	return this.LocalGameList = require('NGCore/Client/Core/LocalGameList').LocalGameList;
});
exports.Core.__defineGetter__("Localization", function() {
	delete this.Localization;
	return this.Localization = require('NGCore/Client/Core/Localization').Localization;
});
exports.Core.__defineGetter__("_LocalGameList", function() {
	delete this._LocalGameList;
	return this._LocalGameList = require('NGCore/Client/Core/_LocalGameList')._LocalGameList;
});
exports.Core.__defineGetter__("NativeAppLaunch", function() {
	delete this.NativeAppLaunch;
	return this.NativeAppLaunch = require('NGCore/Client/Core/NativeAppLaunch').NativeAppLaunch;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Capabilities'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Capabilities'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Capabilities'] = exports; 	////////////////////////////////////////////////////////////////////////////////
// Class Capabilities
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;

////////////////////////////////////////////////////////////////////////////////

exports.Capabilities = Class.singleton(
/** @lends Core.Capabilities.prototype */
{
	classname: 'Capabilities',
	_configFile: 'configuration.json',

	/**
	 * @class The <code>Capabilities</code> class constructs a singleton object that contains device properties. These objects represent the device and provide access to device information. 
	 * This class also provides information about how a device and game servers communicate.
	 * <br><br>
	 * <b>Note:</b> An application should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 * @status iOS, Android, Flash
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

        // Please keep this on one line, sed won't update otherwise
		this._fields = {version: 'sdks_1.3.5-20110826-1.3.5', buildDate: '20111006', buildHash: 'g5e7d88f'};
	},

	_getConfigFile:			function() {return this._configFile;},
	_getAccts:				function() {return this._fields._accts;},

	meetsBinaryVersion: function(desiredVersion)
	{
		var binary = this.getBinaryVersion().split('-').pop().split('.');
		var desired = desiredVersion.split('.');

		// A shorter length means a lower version (if all other items match)
		var meets = binary.length >= desired.length;
		var len = Math.min(desired.length, binary.length);
		for (var i = 0; i < len; ++i)
		{
			var bin = Number(binary[i]);
			var des = Number(desired[i]);
			if (bin != des)
			{
				meets = bin > des;
				break;
			}
		}
		return meets;
	},

	/**
	 * Return the object stored in configuration.json for your game.
	 * @returns {Object} The JSON.parsed object represented in your configuration.json file.
	 * @type Object
	 * @status
	 */
	getConfigs:			function() {return this._configuration;},

	/**
	 * Return the SDK version number from the <code>Capabilities</code> of this device.
	 * @returns {String} The version of the SDK on the device.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getSDKVersion:           function() { return this._fields.version; },

	/**
	 * Return the build date for the currently installed SDK. The build date is in the format <i>YYYYMMDD</i>.
	 * @returns {String} The build date for the SDK on the device.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getSDKBuildDate:           function() { return this._fields.buildDate; },
	
	/**
	 * Return the build hash of the currently installed SDK.
	 * @returns {String} The build hash for the SDK on the device.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getSDKBuildHash:           function() { return this._fields.buildHash; },

	/**
	 * Return the version of the currently running ngCore binary
	 * @returns {String} The version of ngCore running
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getBinaryVersion:           function() { return this._fields.binaryVersion; },

	/**
	 * Return the build date for the currently running ngCore binary. The build date is in the format <i>YYYYMMDD</i>.
	 * @returns {String} The build date for the ngCore binary
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getBinaryBuildDate:           function() { return this._fields.binaryBuildDate; },

	/**
	 * Return the build hash of the currently running ngCore binary
	 * @returns {String} The build hash for the ngCore binary
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getBinaryBuildHash:           function() { return this._fields.binaryBuildHash; },
	
	/**
	 * Return the device ID. 
	 * @returns {String} The device ID for the device running the application.
	 * @type String
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getUniqueId:           function() { return this._fields.uniqueId; },

	/**
	 * Return the lifetime constant value of the device.<br><br>
	 * <b>Note:</b> Currently only available on Android.
	 * @returns {String} <code>Settings.Secure.ANDROID_ID</code>: A 64-bit number as a hex string randomly generated on first boot of the device. 
	 * <b>Note:</b> This value only changes when the device is reset.
	 * @status Android
	 */
	getLifetimeName: function() { return this._fields.lifetimeName; },
	
	/**
	 * Return the device name.
	 * @returns {String} The device name for the device running the application.
	 * @type String
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getDeviceName:         function() { return this._fields.deviceName; },
	
	/**
	 * Return the operating system.
	 * @returns {String} The operating system of the device running the application.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getPlatformOS:         function() { return this._fields.platformOs; },
	
	/**
	 * Return the operating system version number.
	 * @returns {String} The version number of the operating system running on the device.
	 * @type String
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getPlatformOSVersion:  function() { return this._fields.platformOsVersion; },
	
	/**
	 * Return the device hardware type.
	 * @returns {String} The type of device hardware running the application.
	 * @type String
	 * @status iOS, Flash, Test, iOSTested, AndroidTested
	 */
	getPlatformHW:         function() { return this._fields.platformHw; },
	
	/**
	 * Return the total amount of installed memory.
	 * @returns {Number} The amount of installed memory on the device running the application.
	 * @type Number
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getPhysicalMem:        function() { return this._fields.physicalMem; },
	
	/**
	 * Return the total number of installed CPUs.
	 * @returns {Number} The number of CPUs installed on the device running the application.
	 * @type Number
	 * @status iOS, Test, iOSTested, AndroidTested
	 */
	getPhysicalCpus:       function() { return this._fields.physicalCpus; },
	
	/**
	 * Return the number of active CPUs.
	 * @returns {Number} The number of active CPUs on the device running the application.
	 * @type Number
	 * @status iOS, Test, iOSTested, AndroidTested
	 */
	getActiveCpus:         function() { return this._fields.activeCpus; },
	
	/**
	 * Return the installed user language. 
	 * @returns {String} The installed user language on the device running the application.
	 * Expressed as a canonicalized IETF BCP 47 language identifier.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getLanguage:         function() { return this._fields.language; },

	_getBoot: function() { return this._fields.boot; },
	_getBootServer: function() { return this._fields.bootServer; },

	getBootDir: function () { return this._fields.bootDir; },
	getGameDir: function () { return this._fields.gameDir; },
	getProductName: function () { return this._fields.prodName; },

	/**
	 * Return the URL for the content of this application.
	 * @returns {String} The URL to content for this application.
	 * @status
	 */
	getContentUrl:			function() {return this._fields.contentUrl;},

	/**
	 * Return the name of the root application. Root application refers to the application that launches when the user taps the application icon.
	 * @returns {String} The directory name for the root application.
	 * @status
	 */
	getBootGame:         function() { return this._fields.bootgame; },

	/**
	 * Return the starting server for an application.
	 * @returns {String} The start server.
	 * @type String
	 * @status
	 */
	getStartingServer:         function() { return this._fields.startingServer; },

	/**
	 * Return the name of the application bundled with the binary of this build.
	 * @returns {String} The name of the bundled game.
	 * @type String
	 * @status
	 */
	getBundleGame:         function() { return this._fields.bundleGame; },

	/**
	 * Return the server bundled with the binary of this build.
	 * @returns {String} The bundle server.
	 * @type String
	 * @status
	 */
	getBundleServer:         function() { return this._fields.bundleServer; },

	/**
	 * Return the bundle identifier for the binary of this build.
	 * @returns {String} The bundle identifier.
	 * @type String
	 * @status
	 */
	getBundleIdentifier:         function() { return this._fields.bundleIdentifier; },
	
	/**
	 * Return the directory name of the currently running application.
	 * @returns {String} The current folder name for the application.
	 * @type String
	 * @status iOS, Android, Flash
	 */
	getGame:         function() { return this._fields.game; },

	/**
	 * Return the server from which an application was downloaded.
	 * @returns {String} The download server.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getServer:         function() { return this._fields.server; },

	/**
	 * Return the full URL for the current application.
	 * @returns {String} The URL from which a application is downloaded.
	 * @type String
	 * @status
	 */
	getUrl:         function() { return this._fields.url; },

	/**
	 * Return the logical screen width for this device.
	 * @returns {Number} The current screen width of the device.
	 * @type Number
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getScreenWidth:        function() { return this._fields.screenWidth; },
	
	/**
	 * Return the logical screen height for this device.
	 * @returns {Number} The current screen height of the device.
	 * @type Number
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getScreenHeight:       function() { return this._fields.screenHeight; },
	
	/**
	 * Return a reasonable factor for scaling logical coordinates to the current display.
	 * @returns {Number} Logically scaled screen units for the device.
	 * @type Number
	 * @status
	 */
	getScreenUnits:        function() { return this._fields.screenUnits; },
	
	/**
	 * Return the number of physical pixels associated with one unit of logical space.
	 * @returns {Number} The total number of pixels that equal one screen unit.
	 * @type Number
	 * @status
	 */
	getScreenPixelUnits:       function() { return this._fields.screenPixelUnits; },
	
	/**
	 * Return the maximum number of supported textures.
	 * @returns {Number} The maximum number of supported textures per coordinate (<i>x</i>,<i>y</i>).
	 * @type Number
	 * @status Test, iOSTested, AndroidTested
	 */
	getMaxTextureSize:     function() { return this._fields.maxTextureSize; },
	
	/**
	 * Return the maximum number of supported texture units.
	 * @returns {Number} The maximum number of supported texture units per coordinate (<i>x</i>,<i>y</i>).
	 * @type Number
	 * @status Test, iOSTested, AndroidTested
	 */
	getMaxTextureUnits:    function() { return this._fields.maxTextureUnits; },
	
	/**
	 * @deprecated Replaced by {@link UI.GLView#getGLExtensions}.
	 */
	getOglExtensions:      function()
	{
		if (this._fields.oglExtensions)
			return this._fields.oglExtensions;

		// This table should stay in sync with:
		// https://spreadsheets.google.com/a/ngmoco.com/spreadsheet/ccc?key=0AinqDSqLOjJtdDMwNGk0eDgtRFdvQ2N0eWRUcGlsc0E&hl=en_US&authkey=CMWLyoAC
		switch (this._fields.deviceName)
		{
			case "Droid":                // Motorola Droid
			case "DROID2":               // Motorola Droid 2
			case "DROIDX":               // Motorola Droid X
			case "SGH-T959":             // Samsung Galaxy S 19000 8GB
			case "SGH-T959V":            // Samsung Galaxy S 4G
			case "SAMSUNG-SGH-I997":     // Samsung Galaxy S2
			case "SAMSUNG-SGH-I897":     // Samsung Captivate
			case "Nexus S":              // Google Nexus S
				return ["GL_IMG_texture_compression_pvrtc"];
			case "HTC Desire":           // HTC Desire GSM
			case "PC36100":              // HTC Evo 4G
			case "ADR6300":              // HTC Droid Incredible
			case "001HT":                // HTC Desire HD
			case "Nexus One":            // Google Nexus One
			case "HTC Glacier":          // HTC myTouch 4G
				return ["GL_AMD_compressed_ATC_texture"];
			default:
				return [];
		}
	},

	/**
	 * Return the directory path to the temp directory for this device.
	 * @returns {String} The directory path to the temp directory on the device.
	 * @type String
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getTmpDir:           function() { return this._fields.tmpDir; },

	/**
	 * Check the <code>Capabilities</code> of this device for an accelerometer.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains an accelerometer.
	 * @type Boolean
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getHasAccel:           function() { return this._fields.hasAccel; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a gyroscope.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains an gyroscope.
	 * @type Boolean
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getHasGyro:            function() { return this._fields.hasGyro; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for touchscreen input support.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application supports touchscreen input.
	 * @type Boolean
	 * @status iOS, Test, iOSTested, AndroidTested
	 */
	getHasTouch:           function() { return this._fields.hasTouch; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for multi-touch input support.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application supports multi-touch input.
	 * @type Boolean
	 * @status iOS, Test, iOSTested, AndroidTested
	 */
	getHasMultiTouch:      function() { return this._fields.hasMultiTouch; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a GPS unit.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a GPS unit.
	 * @type Boolean
	 * @status Android, Test, iOSTested, AndroidTested
	 */
	getHasGps:             function() { return this._fields.hasGps; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a magnetic compass.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a magnetic compass.
	 * @type Boolean
	 * @status Android, Test, iOSTested, AndroidTested
	 */
	getHasCompass:         function() { return this._fields.hasCompass; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a hardware keyboard.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a hardware keyboard.
	 * @type Boolean
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getHasHwKeyboard:      function() { return this._fields.hasHwKeyboard; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for a <b>Back</b> button.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a <b>Back</b> button.
	 * @status
	 */
	getHasBackButton:      function() { return this._fields.hasBackButton; },

	/**
	 * Check the <code>Capabilities</code> of this device for a camera.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application contains a camera.
	 * @type Boolean
	 * @status Test, iOSTested, AndroidTested
	 */
	getHasCamera:          function() { return this._fields.hasCamera; },
	
	/**
	 * Check the <code>Capabilities</code> of this device for access to a wide area network (WAN).
	 * @returns {Boolean} Returns <code>true</code> when the device running the application has access to a WAN.
	 * @type Boolean
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getHasWwan:            function() { return this._fields.hasWwan; },

	/**
	 * Check the <code>Capabilities</code> of this device for access to a Wi-Fi network.
	 * @returns {Boolean} Returns <code>true</code> when the device running the application has access to Wi-Fi.
	 * @type Boolean
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getHasWifi:            function() { return this._fields.hasWifi; },

	/**
	 * Return the name of the telephony carrier this device was using at program startup.
	 * @returns {String} Returns the name of the telephony carrier, or an empty string if no carrier 
	 * was used (possibly due to no telephony service or telephony hardware in device).
	 * @status
	 */
	getCarrier:            function() { return this._fields.carrier; },

	/**
	 * Return the URL used to launch this application.
	 * @returns {String} The URL for launching this application. If the application is not launched from a URL, returns an empty string.
	 * @type String
	 * @status
	 */
	getIntentUrl:            function() { return this._fields.intentUrl; },
	
	/**
	 * Return the Action used to launch this application.
	 * @returns {String} The action for launching this application. If the application is not launched from an action, returns undefined.
	 * @type String
	 * @status
	 */
	getIntentAction:            function() { return this._fields.intentAction; },
	
	/**
	 * Return the height of the system status bar.
	 * @returns {Number} The status bar height rounded to the nearest integer (in pixels).
	 * @type Number
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 * @status Android
	*/
     getStatusBarHeight:            function() { return this._fields.statusBarHeight; },
	
	/**
	 * Return the device locale.
	 * @returns {String} The regional location of a device.
	 * The <code>locale</code> string is a combination of ISO 639-1 and ISO 3166-1. For example, <code>en_US</code>, <code>ja_JP</code>.
	 * @type String
	 * @status
	 */
	getLocale: function() { return this._fields.locale; },

	/**
	 * Return a list of installed fonts on this device.
	 * @returns {Array (Strings)} An array of font names installed on the system or addressable by name.
	 * @type Array
	 * @status iOS, Android
	 */
	getAvailableFonts: function()
	{
		return this._deserializedFonts || (this._deserializedFonts = JSON.parse(this._fields.availableFonts));
	},
	
	/** @private */
	getAutorotateDisabled: function()
	{
		return this._fields.autorotateDisabled || false;
	},
	

	/**
	 * Return the social server used for this application.
	 * @returns {String} The social server URL. For example, partner.plusplus.com.
	 * @status
	 */	
	getSocialServer: function()
	{
		return this.socialServer;
	},

	/*
	 * Returns the name of the Mobage distribution first installed on the device.
	 * @returns {String} The name of the distribution.
	 */
	getDistributionName: function() 
	{
		return this._fields.distributionName;
	},

	/*
	 * @status
	 */	
	getSourceAppID: function()
	{
		return this._fields.sourceAppID;
	},

	/*
	 * @status Android
	 */	
	getAppSignatures: function()
	{
		return this._fields.appSignatures;
	},
	
	/*
	 * Return the release version of this application.  The value comes directly from the 
	 * configuration.json value for releaseVersion.
	 * @returns {String} The version identifier. For example, 1.1:20110607183748_blf7gety.
	 * @status
	 */
	getAppReleaseVersion: function()
	{
		return this._releaseVersion;
	},

	/**
	 * Returns true of the app is disaggregated
	 * @returns {bool}
	 */
	getIsDisaggregated: function() { return this._fields.isDisaggregated; },
	
	/** @private */
	_init: function(dict)
	{
		// parse the dict
		var ifields = [];
		NgParseCommandDictionary(dict, 2, this._fields, ifields);

		try {
			// Change server based on URL passed in
			var items = /(https?:\/\/.+?)\/(.*)/.exec(this._fields.url);
			this._fields.server = items[1];
			this._fields.game  = items[2];
		}
		catch (e)
		{
			NgLogException(e);
		}

		// KJ this is necessary because an empty string passed becomes undefined
		if (!this._fields.intentUrl)
			this._fields.intentUrl = "";

		if (this._fields.oglExtensions)
		try
		{
			this._fields.oglExtensions = JSON.parse(this._fields.oglExtensions);
		}
		catch (e)
		{
			NgLogE("Unable to parse OGL Extensions! " + this._fields.oglExtensions);
			NgLogException(e);
		}

		if (this._fields._accts)
		try
		{
			this._fields._accts = JSON.parse(this._fields._accts);
		}
		catch (e)
		{
			NgLogE("Unable to parse Accounts! " + this._fields._accts);
			NgLogException(e);
		}

		try
		{
			this._configuration = JSON.parse(this._fields.configJSON);
			this._fields.contentUrl = this._configuration.contentUrl;
			this.socialServer = this._configuration.socialServer;
			this._releaseVersion = this._configuration.releaseVersion;
		}
		catch (e)
		{
			NgLogE("Unable to parse config!! (" + this._fields.configJSON + ")");
			NgLogException(e);
		}

		console.log( "dict : JS version : " + this.getSDKVersion() );
		console.log( "dict : JS build date : " + this.getSDKBuildDate() );
		console.log( "dict : JS build hash : " + this.getSDKBuildHash() );

		console.log("dict : contentUrl : " + this._fields.contentUrl);
		console.log("dict : socialServer : " + this.socialServer);
		console.log("dict : releaseVersion : " + this._releaseVersion);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 301
	// Method create = -1
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Capabilities._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Capabilities._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[301] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( ":301,-1," + __objectRegistryId  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	

// {{/Wg Generated Code}}
	// This kills the JSLint error for trailing comma (since we can't change the generated code)
	t: 0
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Localization'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Localization'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Localization'] = exports; var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;

var LocalizationEngine = exports.LocalizationEngine = MessageEmitter.subclass(
/** @lends Core.Localization.prototype */
{
	classname: 'Localization',
    
    /**
     * Specifies the directory path to language files this object will load.
     */
    directoryPath:null,
    
    /**
     * Specifies the directory path to a language file for a specific language.
     */
	languageFilePath:null,
    
	/**
	 * @class The <code>Localization</code> class provides applications with access to localized strings.
	 * Applications supply a language code corresponding to a file in <code>Content/Localization/</code> or a JSON object.<br><br> 
     * Loading of dictionary files is an anynchronous process. Applications need to listen for emitted notifications from <code>Localization</code> objects that signal when the language dictionary
     * is modified. When a <code>Localization</code> object emits a notification, localized strings are available to the application (see <code>{@link Core.MessageEmitter#emit}</code>).
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Flash
	 */
	initialize: function(directoryPath)
	{
		if(!directoryPath){directoryPath = "./Content/Localization/";}
	    NgLogD("Localization : init ("+directoryPath+")");
	    this.directoryPath = directoryPath;
	    
        this.setLanguage(Capabilities.getLanguage());
	},
    
	/**
	 * Aynchronously load the localization dictionary for the specified language.
     * <br><br>
	 * <b>Notes:</b> 
	 * <ul>
	 * <li>This function looks for the corresponding JSON dictionary file in the <code>Content/Localization</code> directory.
     * For example, <code>Content/Localization/fr.json</code>. If the application cannot load a dictionary, this call has no effect.</li>
     * <li><code>Localization</code> objects emit a notification with the new language string if this call succeeds.</li>
     *</ul>
	 *
	 * @example
	 * Core.Localization.addListener(listener, function()
     * {
     *     listener.label.setText(Core.Localization.getString("Hello World"));
     * });
	 * Core.Localization.setLanguage('es');
	 *
	 * @param {String} language The base name of a JSON dictionary file in <code>./Content/Language</code>.
	 * @see Core.Localization#setDictionary, 
	 * @see Core.MessageListener
	 * @status
	 */    
    setLanguage: function(language)
    {
        var dictionaryPath = this.languageFilePath = this.directoryPath + language + '.json';
        var self = this;
        NgLogD("Localization : reading json file "+ dictionaryPath);
        
		FileSystem.readFile(dictionaryPath, function(error, data)
        {
            if(error === '')
            {
                NgLogD("Localization : successfully read json file "+ dictionaryPath);  
                self.setDictionary(language, JSON.parse(data));
            }
            else
            {
                NgLogD("Localization: unable to read json file "+ dictionaryPath + ", use default english setting instead");                
                self.setDictionary(language, null);
            }
        });
    },

	/**
	 * Directly set the language code and localization dictionary.
     * <code>Localization</code> objects emit a message with the new language string during this call.
	 * 
	 * @example
     * var chDictionary =    
     * {
     *     "Hello World": "你好世界"
     * };
	 * Core.Localization.setDictionary('ch', chDictionary);
	 * label.setText(Core.Localization.getString("Hello World"));
	 *
	 * @param {String} language A string identifying the specified language or localization.
	 * @param {Object} dictionary An object containing key/value pairs for the specified language.
	 * @see Core.Localization#setLanguage,
	 * @see Core.MessageEmitter#emit
	 * @status
	 */    
    setDictionary: function(lang, dictionary)
    {
        this._lang = lang;
        this._dictionary = dictionary;
        this.emit(this._lang);
    },    
    
    /**
	 * Retrieve a localized string.
     * @param {String} str A localization key.
	 * @returns {String} The localized string or the provided key if the application is unable to lcoate the specified string.
	 * @status
	 */
	getString: function(str)
	{        
        if(this._dictionary && typeof this._dictionary === 'object')
        {
            var value = this._dictionary[str];
            if(value && typeof value !== 'undefined')
            {
                return value;
            }
        }
        
        return this.unknownString(str);
	},
	
	/** @protected */
	unknownString:function(str){
		NgLogD("Localization: ... No localization for "+str+" in "+this._lang);
		return str;
	}
});

/**
 * Global Localization Singleton, gets initialized when the device locale is known.
 */
exports.Localization = LocalizationEngine.singleton({});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage'] = exports; /**
 * <p>Classes and objects contained by the Storage module.</p>
 * @name Storage
 * @namespace
 * @description <p>The Storage module is a collection of classes that support file manipulation operations.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 *  <li><code>{@link Storage.FileSystem}</code>: Construct objects for reading a file, writing to a file, deleting a file, or decompressing a file.</li>
 *  <li><code>{@link Storage.KeyValue}</code>: Construct objects that store key/value pairs.</li>
 * </ul>
 * <b>Note:</b> The static method <code>KeyValueCache.global()</code> creates a <code>KeyValueCache</code> object that multiple applications can use. 
 * @param {String} globalKey The module name for the <code>KeyValueCache</code> object. The <code>global()</code> method creates a new <code>KeyValueCache</code> 
 * when the module with that name doesn't already exist.
 */
var Storage = exports.Storage = {};

Storage.__defineGetter__("KeyValue", function() {
	delete this.KeyValue;
	return this.KeyValue = require('NGCore/Client/Storage/KeyValue').KeyValue;
});
Storage.__defineGetter__("KeyValueCache", function() {
	delete this.KeyValueCache;
	return this.KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
});
Storage.__defineGetter__("FileSystem", function() {
	delete this.FileSystem;
	return this.FileSystem = require('NGCore/Client/Storage/FileSystem').FileSystem;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Logger'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Logger'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Logger'] = exports; var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var sprintf = require('NGCore/Shared/Lib/sprintf').sprintf;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

var Logger = Class.singleton(
/** @lends Core.Logger.prototype */
{
	classname: 'Logger',

	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/** @private */
	_disable: function()
	{
		console.log("Logger : javascript logging disabled");
		console.log = Logger.log = function(message, argv) {};
	},

	_enable: function()
	{
		console.log = Logger.log = function(message, argv)
		{
			if (arguments.length > 1) {
				try {
					var params = new Array();
					for (var i = 0; i < arguments.length; ++i) {
						params[i] = arguments[i];
					}
					var result = sprintf(params);
					params.unshift(result);
					message = params.join(" ");
				} catch (err) {
					var concat = new Array();
					for (var i = 0; i < arguments.length; ++i) {
						concat[i] = arguments[i];
					}
					message = concat.join(" ");
				}
			}
			__underscore_SysLog(message);
		};

		console.log("Logger : javascript logging enabled");
	},

	/**
	 * Log a message to the development console.
	 * @param {string} message
	 * @param {Array} argv Additional arguments to log.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	log: function(message, argv)
	{
		
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 305
	// Method create = -1
	// Method log = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Logger._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Logger._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[305] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( ":305,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_logSendGen: function( msg )
	{
		Proc.appendToCommandString( ":305,2," + this.__objectRegistryId + "," + Base64.encode( msg )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// log: function( msg ) {}
	

// {{/Wg Generated Code}}
	
});

Logger.instantiate();

__underscore_SysLog = function(_massage)
{
	Logger._logSendGen( _massage );
};

// JMarr Don't override console.log when on flash.
if(typeof(_NG_TARGET_FLASH) == 'undefined')
	console.log = Logger.log;

exports.Logger = Logger;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Class'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Class'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Class'] = exports; exports.Class = require('NGCore/Shared/Class').Class;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Base64'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Base64'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Base64'] = exports; exports.Base64 = require('NGCore/Shared/Lib/base64').Base64;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/ResultSet'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/ResultSet'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/ResultSet'] = exports; var ClassReq = require('NGCore/Client/Core/Class');
var SystemBindingReq = require('NGCore/Client/UI/SystemBinding');

var ResultSet = ClassReq.Class.subclass({
    classname: "ResultSet",
    initialize: function(continueId) {
        this.items = [];
        this._continueId = continueId;
        this.totalLength = Number.MAX_VALUE;
    },
    /*
	 * Call to getMore adds more items to items list.
	 * Please note that in the callback, it is possible that addedCount == 0
	 * in some cases.  In that case access to items[newIdx] does not yield
	 * any result
	 */
    getMore: function(cb) {
        return SystemBindingReq.SystemBinding._getMoreContacts(this, cb);
    },
    /*
	 * Releases resource used by current ResultSet.
	 *
	 * To avoid resource leakage, please call closeResultSet if getMore
	 * is not called all the way to the end.
	 */
    closeResultSet: function() {
        SystemBindingReq.SystemBinding._closeContactsResultSet(this);
    }
});

exports.ResultSet = ResultSet;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Class'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Class'] || {}; $MODULE_REGISTRY['NGCore/Shared/Class'] = exports; /**
 * The default constructor.
 * @constructor 
 * @class The <code>Class</code> object provides an environment for Object Oriented Programming (OOP) development in Javascript, such as Java or C++.
 * @name Core.Class
 */
var Class = function() {}
exports.Class = Class;

/**
 * Create a new class by extending another class.
 * @example
 * var MyClass = Class.subclass(
 * {
 *    initialize: function()
 *    {
 *        console.log('constructor');
 *    },
 *    foo: function(v)
 *    {
 *        console.log('MyClass.foo(' + v + ')');
 *    },
 * });
 * var myClass = new MyClass();
 * myClass.foo('param');
 * @param {Object} extensions Object literal containing new functions for the derived class.
 * @function
 * @name Core.Class.subclass
 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
 */
Class.subclass = (function()
{
/**#@+ @ignore */
	// Parse a function body and extract the parameter names.
	function argumentNames(body)
	{
		var names = body.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
			.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
			.replace(/\s+/g, '').split(',');
		return names.length == 1 && !names[0] ? [] : names;
	}
	
	// Create a function that calls overrideBody with a closure to ancestorBody.
	function overrideMethod(overrideBody, ancestorBody)
	{
		if(ancestorBody !== undefined)
		{
			// Create a function that calls overrideBody with a closure to ancestorBody as the first param.
			var override = function()
			{
				var localThis = this;
				var $super = function() { return ancestorBody.apply(localThis, arguments) };
				Array.prototype.unshift.call(arguments, $super);
				return overrideBody.apply(this, arguments);
			}
		}
		else
		{
			// Create a function that calls overrideBody with undefined as the first param, because ancestorBody is undefined.
			var override = function()
			{
				Array.prototype.unshift.call(arguments, undefined);
				return overrideBody.apply(this, arguments);
			}
		}

		// Hide our dirty tricks from the rest of the world.
		override.valueOf = function() { return overrideBody.valueOf() };
		override.toString = function() { return overrideBody.toString() };
		return override;
	}
	
	// Define some empty functions used later. This is a speed optimization.
	function TempClass() {}
	function emptyFunction() {}
	
	return function()
	{
		// Constructor for new class to be created.
		var properties = arguments[0];
		var classname = properties.classname || "AnonymousClass";
		var NewClass = eval('(function ' + classname + '(){this.initialize.apply(this, arguments)})');
		
		// Copy statics from this.
		for(var property in this)
		{
			if(!this.hasOwnProperty(property)) continue;
			NewClass[property] = this[property];
		}
		
		// Copy prototype from this.
		var ancestorPrototype = this.prototype;
		TempClass.prototype = ancestorPrototype;
		NewClass.prototype = new TempClass();
		NewClass.prototype.superclass = ancestorPrototype;
		NewClass.prototype.constructor = NewClass;
		
		// Copy properties into NewClass prototype.
		for(var property in properties)
		{
			if(!properties.hasOwnProperty(property)) continue;

			// getters / setters behave differently than normal properties.
			var getter = properties.__lookupGetter__(property)
			var setter = properties.__lookupSetter__(property)
			if(getter || setter)
			{
				if(getter)
				{
					// Copy getter into klass.
					var value = getter;
					if(argumentNames(value)[0] == "$super")
						value = overrideMethod(value, ancestorPrototype.__lookupGetter__(property));
					NewClass.prototype.__defineGetter__(property, value);
				}

				if(setter)
				{
					// Copy setter into klass.
					var value = setter;
					if(argumentNames(value)[0] == "$super")
						value = overrideMethod(value, ancestorPrototype.__lookupSetter__(property));
					NewClass.prototype.__defineSetter__(property, value);
				}
			}
			else
			{
				var value = properties[property];
				if(typeof value === "function" && property[0] != '$')
				{
					if(argumentNames(value)[0] == "$super")
					{
						// Create override method if first param is $super.
						value = overrideMethod(value, ancestorPrototype[property]);
					}
					else if(property == 'initialize')
					{
						var ancestorInitialize = ancestorPrototype.initialize
						if(ancestorInitialize)
						{
							// Automatically call inherited constructor.
							var derivedInitialize = value;
							value = function()
							{
								ancestorInitialize.apply(this, arguments);
								derivedInitialize.apply(this, arguments);
							};
						}
					}
					else if(property == 'destroy')
					{
						var ancestorDestroy = ancestorPrototype.destroy
						if(ancestorDestroy)
						{
							// Automatically call inherited destructor.
							var derivedDestroy = value;
							value = function()
							{
								derivedDestroy.apply(this, arguments);
								ancestorDestroy.apply(this, arguments);
							};
						}
					}

					// Copy function into new class prototype.
					NewClass.prototype[property] = value;
				}
				else
				{
					if(property[0] == '$')
						property = property.slice(1);

					// Copy enum into new class and the prototype.
					NewClass[property] = value;
					NewClass.prototype[property] = value;
				}
			}
		}
		
		// Make sure the is an initialize function.
		if(!NewClass.prototype.initialize)
			NewClass.prototype.initialize = emptyFunction;

		return NewClass;
	}
/**#@-*/
})();

/**
 * Create a singleton by extending a class.
 * @example
 * var MySingleton = Class.singleton(
 * {
 *    initialize: function()
 *    {
 *        console.log('constructor');
 *    },
 *    foo: function(v)
 *    {
 *        console.log('MyClass.foo(' + v + ')');
 *    },
 * });
 * MySingleton.foo('param');
 * @param {Object} extensions Object literal containing new functions for the singleton.
 * @function
 * @name Core.Class.singleton
 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
 */
Class.singleton = function()
{
	// Create sublcass as normal.
	var tempClass = this.subclass.apply(this, arguments);
	
	// Hide the initialize.
	var initialize = tempClass.prototype.initialize;
	tempClass.prototype.initialize = function() {};
	
	// Now instantiate.
	var instance = new tempClass();
	
	// Hide every prototype function with an instance function that calls initialize.
	var functions = [];
	/** 
	 * Ensure that the singleton has been created and fully initialized.
	 * @status iOS, Android, Flash
	*/
	var instantiate = function(real)
	{
		// Delete all of the instance functions we added.
		for(var i in functions)
		{
			var func = functions[i];
			delete instance[func];
		}
		
		// Restore the initialize function and call it.
		instance.initialize = initialize;
		instance.initialize();
		
		// Replace instantiate method with an empty function.
		instance.instantiate = function() {};
		
		// Call the function that caused this instantiation.
		var args = Array.prototype.slice.call(arguments, 1);
		return real.apply(instance, args);
	}
	
	// Iterate over all prototype functions.
	for(var i in instance)
	{
		// Don't do anything for setters or getters.
		if(instance.__lookupGetter__(i)
			|| instance.__lookupSetter__(i))
		{
			//TODO Should put proxies here too.
			continue;
		}
			
		var value = instance[i];
		if(typeof(value) == 'function')
		{
			// Remember the function names that we added so that instantiate() can remove them.
			functions.push(i);
			
			// Add an instance function to hide the prototype function, which will call instantiate.
			instance[i] = instantiate.bind(this, value);
		}
	}
	
	// Add instantiate method.
	instance.instantiate = instantiate.bind(this, function() {});
	
	// Return the isntance.
	return instance;
}

/**
 * @ignore
 */
Class.prototype.bind = function(func)
{
	var context = this;
	if(arguments.length < 2)
	{
		// Fast path if only the 'this' pointer is being bound.
		return function()
		{
			return func.apply(context, arguments);
		}
	}
	else
	{
		// Slower path if additional parameters are being bound.
		var args = Array.prototype.slice.call(arguments, 1);
		return function()
		{
			var finalArgs = args.concat(Array.prototype.slice.call(arguments, 0));
			return func.apply(context, finalArgs);
		}
	}
}

/**
 * @ignore
 */
Class.prototype.toString = function()
{
	return this.constructor.name;
}

// Debug implementation that will replace every method in destroyed objects with a grenade.
/*Class.prototype.destroy = function()
{
	function suicide()
	{
		throw new Error('Function called on destroyed object');
	}
	
	for(var i in this)
	{
		var value = this[i];
		if(typeof(value) == 'function')
		{
			this[i] = suicide;
		}
	}
}*/
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/base64'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/base64'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/base64'] = exports; /**
* @description
* Takes a string and encodes or decodes base-64.
* @class Base64
* @see http://coderepos.org/share/browser/lang/javascript/Base64/trunk/base64.js
*
**/

/*
 * $Id: base64.js,v 1.1 2009/03/01 22:38:45 dankogai Exp dankogai $
 *
 * History:
 *   dankogai's original: character-based
 *   drry's fix: split string to array then join
 *   new version: regexp-based
 */

var Base64 = (function() {
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin){
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) {
            t[bin.charAt(i)] = i;
        }
        return t;
    }(b64chars);

    var fromCharCode = String.fromCharCode;

    var sub_toBase64 = function(m){
        var n = (m.charCodeAt(0) << 16)
              | (m.charCodeAt(1) <<  8)
              | (m.charCodeAt(2)      );
        return b64chars.charAt( n >>> 18)
             + b64chars.charAt((n >>> 12) & 63)
             + b64chars.charAt((n >>>  6) & 63)
             + b64chars.charAt( n         & 63);
    };

    var toBase64 = function(bin){
        if (bin.match(/[^\x00-\xFF]/)) {
            throw 'unsupported character found';
        }
        var padlen = 0;
        while(bin.length % 3) {
            bin += '\x00';
            padlen++;
        }
        var b64 = bin.replace(/[\x00-\xFF]{3}/g, sub_toBase64);
        if (!padlen) return b64;
        b64 = b64.substr(0, b64.length - padlen);
        while(padlen--) b64 += '=';
        return b64;
    };

    // use native btoa() if it exists
    var _btoa = typeof(btoa) !== "undefined" ? btoa : toBase64;

    var sub_fromBase64 = function(m){
            var n = (b64tab[ m.charAt(0) ] << 18)
                |   (b64tab[ m.charAt(1) ] << 12)
                |   (b64tab[ m.charAt(2) ] <<  6)
                |   (b64tab[ m.charAt(3) ]);
        return fromCharCode(  n >> 16 )
            +  fromCharCode( (n >>  8) & 0xff )
            +  fromCharCode(  n        & 0xff );
    };

    var fromBase64 = function(b64){
        b64 = b64.replace(/[^A-Za-z0-9\+\/]/g, '');
        var padlen = 0;
        while(b64.length % 4){
            b64 += 'A';
            padlen++;
        }
        var bin = b64.replace(/[A-Za-z0-9\+\/]{4}/g, sub_fromBase64);
        bin.length -= [0,0,2,1][padlen];
        return bin;
    };

    // use native atob() if it exists
    var _atob = typeof(atob) !== "undefined" ? atob : fromBase64;

    var re_char_nonascii = /[^\x00-\xFF]/g;

    var sub_char_nonascii = function(m){
        var n = m.charCodeAt(0);
        return n < 0x800 ? fromCharCode(0xc0 | (n >>>  6))
                         + fromCharCode(0x80 | (n & 0x3f))
            :              fromCharCode(0xe0 | ((n >>> 12) & 0x0f))
                         + fromCharCode(0x80 | ((n >>>  6) & 0x3f))
                         + fromCharCode(0x80 |  (n         & 0x3f))
            ;
    };

    var utob = function(uni){
        return uni.replace(re_char_nonascii, sub_char_nonascii);
    };

    var re_bytes_nonascii
        = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;

    var sub_bytes_nonascii = function(m){
        var c0 = m.charCodeAt(0);
        var c1 = m.charCodeAt(1);
        if(c0 < 0xe0){
            return fromCharCode(((c0 & 0x1f) << 6) | (c1 & 0x3f));
        }else{
            var c2 = m.charCodeAt(2);
            return fromCharCode(
                ((c0 & 0x0f) << 12) | ((c1 & 0x3f) <<  6) | (c2 & 0x3f)
            );
        }
    };

    var btou = function(bin){
        return bin.replace(re_bytes_nonascii, sub_bytes_nonascii);
    };
    return {
        fromBase64:fromBase64,
        toBase64:toBase64,
        atob:_atob,
        btoa:_btoa,
        utob:utob,
        btou:btou,
        /**
        * @description
        * Takes an input value and returns a base-64 encoded string.
        * @name Base64.encode
        * @function
        * @param String input The input to return as a base-64 encoded string.
        * @return String A base-64 encoded string of the input parameter.
        */
        encode:function(u){
            if(!u) {
                return "";
            }
            return _btoa(utob(new String(u)));
        },
        decode:function(a){
            if(!a) {
                return "";
            }

        	if(a.length % 4 == 1)
			{
				throw new Error("Invalid Base64 string: " + a);
			}

            return btou(_atob(a.replace(/[\-_]/g, function(m0){
                return m0 == '-' ? '+' : '/';
            })));
        }
    };
})();

exports.Base64 = Base64;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Commands'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Commands'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Commands'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class Commands
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

function UIAnimationOptions() {
	this.animationCurve = "EaseInOut";
	return this;
}

var Commands = exports.Commands = Core.Class.singleton(
/** @lends UI.Commands.prototype */
{
	/**
	 * @name UI.Commands
	 * @class 
	 * @augments Core.Class
	 */
	/** 
	 * @field
	 */
	classname: 'Commands',
	
	/**
	 * @constructs
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this.initializeNative(this.__objectRegistryId);
		this._tempCBs = {};
		this._tempCBCount = 0;
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
			* Enumeration for image fit modes.
			* Image Fit is always applied relative to view bounds *after* content insets are applied.
			* @namespace
			 */
	FitMode:
	{ 
		/** The image content is not scaled at all. */
		None: 0,
		/** The image will be aspect-scaled to fit completely within the view. */
		Inside: 1,
		/** The image will be aspect-scaled to cover the entire view bounds. Clipping may occur. */
		Fill: 2,
		/** The image will be distorted to cover the exact view bounds. */
		Stretch: 3,
		/** The image will be aspect-scaled so its width matches the view bounds. Clipping may occur. */
		AspectWidth: 5,
		/** The image will be aspect-scaled so its height matches the view bounds. Clipping may occur. */
		AspectHeight: 6,
		/** The image will be scaled down to fit completely within the view, but not upscaled. */
		InsideNoUpscaling: 7,
	},
	
	/** 
			* Enumeration for supported units for dimensions.
			* Math.round() is your friend. Sending decimal pixel coordinates can result in unpredictable behavior on various platforms, but half- and quarter-pixels can be useful tools on iOS.
			* @namespace
			 */
	Scaling:
	{ 
		/** The native format, and the default for view bounds. No conversion will be performed. */
		Pixels: 0,
		/** Adjusted to roughly one typesetting point, downscaled from 72 to 160 dpi. */
		Points: 1,
		/** 1.0 represents 100% of the provided or implied size (usually a view width or height). */
		Unit: 2,
		/** A percentage of the provided or implied size (typically from 0 to 100). */
		Percent: 3,
		/** At this scale, the device's screen is always 320 units wide. */
		iPhone: 4,
	},
	
	/** 
			* Enumeration for text font styles.
			* @namespace
			 */
	FontStyle:
	{ 
		/** * */
		Normal: 0,
		/** * */
		Bold: 1,
		/** * */
		Italic: 2,
		/** * */
		BoldItalic: 3,
	},
	
	/** 
			* Flags for control / view states. Used in View and its subclasses.
			* When setting content and properties for states, the value with the highest id when AND'ed with the current state, but no additional bits, will be used.
			* @namespace
			 */
	State:
	{ 
		/** The view is in an unexceptional state. */
		Normal: 0x00,
		/** * */
		Focused: 0x01,
		/** * */
		Selected: 0x02,
		/** * */
		Pressed: 0x04,
		/** * */
		Checked: 0x08,
		/** * */
		Custom: 0x00FF0000,
		/** * */
		Disabled: 0x40000000,
	},
	
	/** 
			* Enumeration for Enter Key Behavior in editable text fields.
			* @namespace
			 */
	EnterKeyType:
	{ 
		/** * */
		Return: 0,
		/** * */
		Done: 1,
		/** * */
		Next: 2,
		/** * */
		Submit: 3,
		/** * */
		Go: 4,
		/** * */
		Search: 5,
		/** * */
		Send: 6,
	},
	
	/** 
			* Enumeration for Input Types for editable text fields.
			* @namespace
			 */
	InputType:
	{ 
		/** * */
		None: 0,
		/** * */
		TextWithCorrection: 1,
		/** * */
		Password: 2,
		/** * */
		Numeric: 4,
		/** * */
		Email: 5,
		/** * */
		URL: 6,
		/** * */
		Date: 7,
		/** * */
		ANDROID_LANDSCAPE_FULLSCREEN: 8,
	},
	
	/** 
			* Arrangement of combinations of text and images for buttons. When stacked, the button rect will be divided proportionally into two rects that completely cover the button. Gravity will apply to the image and text within their rects.
			* @namespace
			 */
	ButtonLayout:
	{ 
		/** The view is in an unexceptional state. */
		CenterTextOver: 0,
		/** * */
		StackImageLeft: 1,
		/** * */
		StackImageTop: 2,
		/** * */
		StackImageRight: 3,
		/** * */
		StackImageBottom: 4,
		/** * */
		CenterImageOver: 5,
	},
	
	/** 
			* Describes what direction a user swiped during a swipe callback.
			* @see UI.AbstractView#setOnSwipe
			* @namespace
			 */
	SwipeDirection:
	{ 
		/** * */
		Left: 1,
		/** * */
		Right: 2,
		/** * */
		Up: 3,
		/** * */
		Down: 4,
	},
	
	/** 
			* Describes which orientations a view should be visible in.
			* @see UI.AbstractView#setVisibleInOrientations
			#@namespace
			 */
	OrientationFlag:
	{ 
		/** * */
		Landscape: 0x01,
		/** * */
		Portrait: 0x02,
	},
	
	///////
	// Class Summary and Generated Constants (for internal use only):
	// Class ID = 337
	// Method -1: _initializeNative ( int reservedId )
	// Method -2: _create ( int newObjectId, str className )
	// Method 3: _destroy (  )
	// Method 4: _setActive ( bool active )
	// Method 5: _setTouchable ( bool touchable )
	// Method 6: _enableEvent ( str eventName )
	// Method 7: _disableEvent ( str eventName )
	// Method -8: _eventOccurred ( json eventObject )
	// Method 9: _setIsVisible ( bool visible )
	// Method 10: _setEnabled ( bool enable )
	// Method 11: _setState ( int state )
	// Method 12: _addSubview ( int __objectRegistryId, int index )
	// Method 13: _removeFromSuperview (  )
	// Method -14: _startAnimation ( int durationMs, str callbackId )
	// Method -15: _executeAnimation ( json options )
	// Method 16: _setFrame ( float x, float y, float w, float h )
	// Method 17: _setOrigin ( float x, float y )
	// Method 18: _setAnchor ( float x, float y )
	// Method 19: _setSize ( float w, float h )
	// Method 20: _setTransform ( float a, float b, float c, float d, float tx, float ty )
	// Method 21: _setBackgroundColor ( str color )
	// Method 22: _setImage ( int state, str imageURL )
	// Method 23: _setImageBorder ( int state, json gradientJSON )
	// Method 24: _setImageFitMode ( int fitMode )
	// Method 25: _setImageGravity ( float x, float y )
	// Method 26: _setImageOrigin ( float x, float y )
	// Method 27: _setImageAnchor ( float x, float y )
	// Method 28: _setImageSize ( float w, float h )
	// Method 29: _setImageInsets ( float t, float r, float b, float l )
	// Method 30: _setImageTransform ( float a, float b, float c, float d, float tx, float ty )
	// Method 31: _setText ( int state, str text )
	// Method 32: _setTextColor ( int state, str text )
	// Method 33: _setTextFont ( int state, str fontName )
	// Method 34: _setTextShadow ( int state, str shadow )
	// Method 35: _setTextSize ( float textFontSize )
	// Method 36: _setTextGravity ( float x, float y )
	// Method 37: _setTextInsets ( float t, float r, float b, float l )
	// Method 38: _setTextOverflow ( int overflowMode )
	// Method 39: _setTextMaxLines ( int maxLines )
	// Method 40: _setTextMinSize ( float minSize )
	// Method 41: _setTitle ( int state, str title )
	// Method 42: _setTitleColor ( int state, str title )
	// Method 43: _setTitleFont ( int state, str fontName )
	// Method 44: _setTitleShadow ( int state, str shadow )
	// Method 45: _setTitleSize ( float titleFontSize )
	// Method 46: _setTitleGravity ( float x, float y )
	// Method 47: _setTitleInsets ( float t, float r, float b, float l )
	// Method 48: _setTitleOverflow ( int overflowMode )
	// Method 49: _setTitleMaxLines ( int maxLines )
	// Method 50: _setTitleMinSize ( float minSize )
	// Method 51: _setGradient ( int state, json gradientJSON )
	// Method 52: _setStringValue ( str value )
	// Method 53: _setFloatValue ( float value )
	// Method 54: _setIntValue ( int value )
	// Method 55: _setBoolValue ( bool value )
	// Method 56: _setButtonLayout ( int layoutType )
	// Method 57: _setContentInsets ( float t, float r, float b, float l )
	// Method 58: _setBarGradient ( int state, json gradientJSON )
	// Method 59: _setPlaceholderText ( str placeholder )
	// Method 60: _setPlaceholderTextColor ( str color )
	// Method 61: _setPlaceholderTextShadow ( str shadow )
	// Method 62: _setEnterKeyType ( int enterKeyType )
	// Method 63: _setInputType ( int inputType )
	// Method 64: _setChecked ( bool checked )
	// Method 65: _setScrollPosition ( float x, float y )
	// Method 66: _setScrollableSize ( float w, float h )
	// Method 67: _setSections ( json idArray )
	// Method 68: _setTitleView ( int titleObjectID )
	// Method 69: _setSourceDocument ( str documentURL )
	// Method 70: _setChoices ( json stringArray, int defaultChoiceIndex, int cancelChoiceIndex )
	// Method 71: _show (  )
	// Method 72: _hide (  )
	// Method 73: _setPostData ( str data )
	// Method 74: _loadPostURL ( str url )
	// Method 75: _loadGetURL ( str url )
	// Method 76: _loadURL ( str url, json headers, float timeout )
	// Method 77: _stopLoading (  )
	// Method 78: _reload (  )
	// Method 79: _invoke ( str script )
	// Method 80: _goBack (  )
	// Method 81: _goForward (  )
	// Method 82: _setBasicAuthCredentials ( json credentials )
	// Method 83: _setRightImage ( int state, str rightImageURL )
	// Method 84: _setRightImageBorder ( int state, json gradientJSON )
	// Method 85: _setRightImageFitMode ( int fitMode )
	// Method 86: _setRightImageGravity ( float x, float y )
	// Method 87: _setRightImageOrigin ( float x, float y )
	// Method 88: _setRightImageAnchor ( float x, float y )
	// Method 89: _setRightImageSize ( float w, float h )
	// Method 90: _setRightImageInsets ( float t, float r, float b, float l )
	// Method 91: _setRightImageTransform ( float a, float b, float c, float d, float tx, float ty )
	// Method -92: _setStatusBarHidden ( bool statusBarStatus )
	// Method 93: _pauseAds (  )
	// Method 94: _resumeAds (  )
	// Method 95: _setAdRefreshRate ( int refreshRate )
	// Method 96: _setAdAllowAutoplay ( bool autoplay )
	// Method 97: _setAlpha ( float alpha )
	// Method 98: _postURL ( str url, str data )
	// Method 99: _setProgressGradient ( int state, json gradientJSON )
	// Method 100: _setSecondaryGradient ( int state, json gradientJSON )
	// Method 101: _setProgress ( float progress, float secondaryProgress )
	// Method 102: _useForUpdateProgress ( bool use )
	// Method 103: _setDarkStyle ( bool use )
	// Method -104: _doCompositeImages ( int w, int h, str filename, json infoArray, str callbackId )
	// Method -105: _REMOVED_doChoosePhoto ( int w, int h, str filename, json options, str callbackId )
	// Method -106: _doChooseCamera ( int w, int h, str filename, json options, str callbackId )
	// Method 107: _setScrollable ( bool enabled )
	// Method 108: _setZoomable ( bool enabled )
	// Method 109: _addAnnotation ( int __objectRegistryId )
	// Method 110: _removeAnnotation ( int __objectRegistryId )
	// Method 111: _selectAnnotation ( int __objectRegistryId )
	// Method 112: _setRegion ( float latitude, float longitude, float latitudeDelta, float longitudeDelta, bool animated )
	// Method 113: _setView ( int __objectRegistryId )
	// Method 114: _setCoordinate ( float latitude, float longitude )
	// Method 115: _setCalloutTitle ( str title )
	// Method 116: _setCalloutSubtitle ( str subTitle )
	// Method 117: _setCalloutEnabled ( bool enabled )
	// Method 118: _setCalloutLeftView ( int __objectRegistryId )
	// Method 119: _setCalloutRightView ( int __objectRegistryId )
	// Method 120: _setCenterOffset ( float xOffset, float yOffset )
	// Method -121: _doChoosePhoto ( int w, int h, str filename, json options, str callbackId, int invokingView )
	// Method 122: _setScrollIndicatorsVisible ( bool enabled )
	// Method -123: _measureText ( str string, int w, int h, str font, float fontSize, str callbackId )
	// Method 124: _setFocus ( bool enabled )
	// Method 125: _setViewportEnabled ( bool enabled )
	// Method 126: _clearAnimations (  )
	// Method 127: _setStyle ( int styleID )
	// Method 128: _setVisibleInOrientations ( int orientationFlags )
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift() );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift() );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Commands._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -8:
					Commands._eventOccurredRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in Commands._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[337] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	$_eventOccurredRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Commands.eventOccurred from command: " + cmd );
			return false;
		}
		
		obj[ "eventObject" ] = Core.Proc.parseJSONString( cmd[ 0 ] );
		if( obj[ "eventObject" ] === undefined )
		{
			NgLogE("Could not parse eventObject in Commands.eventOccurred from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$initializeNative: function( reservedId )
	{
		Core.Proc.appendToCommandString( ":337,-1," + reservedId  );
	},
	
	/** @private */
	$create: function( newObjectId, className )
	{
		Core.Proc.appendToCommandString( ":337,-2," + newObjectId + "," + Core.Base64.encode( className )  );
	},
	
	/** @private */
	destroy: function(  )
	{
		Core.Proc.appendToCommandString( ":337,3," + this.__objectRegistryId );
	},
	
	/** @private */
	setActive: function( active )
	{
		Core.Proc.appendToCommandString( ":337,4," + this.__objectRegistryId + "," + ( active ? 1 : 0 )  );
	},
	
	/** @private */
	setTouchable: function( touchable )
	{
		Core.Proc.appendToCommandString( ":337,5," + this.__objectRegistryId + "," + ( touchable ? 1 : 0 )  );
	},
	
	/** @private */
	enableEvent: function( eventName )
	{
		Core.Proc.appendToCommandString( ":337,6," + this.__objectRegistryId + "," + Core.Base64.encode( eventName )  );
	},
	
	/** @private */
	disableEvent: function( eventName )
	{
		Core.Proc.appendToCommandString( ":337,7," + this.__objectRegistryId + "," + Core.Base64.encode( eventName )  );
	},
	
	/** @private */
	setIsVisible: function( visible )
	{
		Core.Proc.appendToCommandString( ":337,9," + this.__objectRegistryId + "," + ( visible ? 1 : 0 )  );
	},
	
	/** @private */
	setEnabled: function( enable )
	{
		Core.Proc.appendToCommandString( ":337,10," + this.__objectRegistryId + "," + ( enable ? 1 : 0 )  );
	},
	
	/** @private */
	setState: function( state )
	{
		Core.Proc.appendToCommandString( ":337,11," + this.__objectRegistryId + "," + state  );
	},
	
	/** @private */
	addSubview: function( __objectRegistryId, index )
	{
		Core.Proc.appendToCommandString( ":337,12," + this.__objectRegistryId + "," + __objectRegistryId + "," + index  );
	},
	
	/** @private */
	removeFromSuperview: function(  )
	{
		Core.Proc.appendToCommandString( ":337,13," + this.__objectRegistryId );
	},
	
	/** @private */
	$startAnimation: function( durationMs, callbackId )
	{
		Core.Proc.appendToCommandString( ":337,-14," + durationMs + "," + Core.Base64.encode( callbackId )  );
	},
	
	/** @private */
	$executeAnimation: function( options )
	{
		Core.Proc.appendToCommandString( ":337,-15," + Core.Base64.encode( JSON.stringify( options ) )  );
	},
	
	/** @private */
	setFrame: function( x, y, w, h )
	{
		Core.Proc.appendToCommandString( ":337,16," + this.__objectRegistryId + "," + x + "," + y + "," + w + "," + h  );
	},
	
	/** @private */
	setOrigin: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,17," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setAnchor: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,18," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setSize: function( w, h )
	{
		Core.Proc.appendToCommandString( ":337,19," + this.__objectRegistryId + "," + w + "," + h  );
	},
	
	/** @private */
	setTransform: function( a, b, c, d, tx, ty )
	{
		Core.Proc.appendToCommandString( ":337,20," + this.__objectRegistryId + "," + a + "," + b + "," + c + "," + d + "," + tx + "," + ty  );
	},
	
	/** @private */
	setBackgroundColor: function( color )
	{
		Core.Proc.appendToCommandString( ":337,21," + this.__objectRegistryId + "," + Core.Base64.encode( color )  );
	},
	
	/** @private */
	setImage: function( state, imageURL )
	{
		Core.Proc.appendToCommandString( ":337,22," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( imageURL )  );
	},
	
	/** @private */
	setImageBorder: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( ":337,23," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( JSON.stringify( gradientJSON ) )  );
	},
	
	/** @private */
	setImageFitMode: function( fitMode )
	{
		Core.Proc.appendToCommandString( ":337,24," + this.__objectRegistryId + "," + fitMode  );
	},
	
	/** @private */
	setImageGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,25," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setImageOrigin: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,26," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setImageAnchor: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,27," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setImageSize: function( w, h )
	{
		Core.Proc.appendToCommandString( ":337,28," + this.__objectRegistryId + "," + w + "," + h  );
	},
	
	/** @private */
	setImageInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( ":337,29," + this.__objectRegistryId + "," + t + "," + r + "," + b + "," + l  );
	},
	
	/** @private */
	setImageTransform: function( a, b, c, d, tx, ty )
	{
		Core.Proc.appendToCommandString( ":337,30," + this.__objectRegistryId + "," + a + "," + b + "," + c + "," + d + "," + tx + "," + ty  );
	},
	
	/** @private */
	setText: function( state, text )
	{
		Core.Proc.appendToCommandString( ":337,31," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( text )  );
	},
	
	/** @private */
	setTextColor: function( state, text )
	{
		Core.Proc.appendToCommandString( ":337,32," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( text )  );
	},
	
	/** @private */
	setTextFont: function( state, fontName )
	{
		Core.Proc.appendToCommandString( ":337,33," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( fontName )  );
	},
	
	/** @private */
	setTextShadow: function( state, shadow )
	{
		Core.Proc.appendToCommandString( ":337,34," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( shadow )  );
	},
	
	/** @private */
	setTextSize: function( textFontSize )
	{
		Core.Proc.appendToCommandString( ":337,35," + this.__objectRegistryId + "," + textFontSize  );
	},
	
	/** @private */
	setTextGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,36," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setTextInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( ":337,37," + this.__objectRegistryId + "," + t + "," + r + "," + b + "," + l  );
	},
	
	/** @private */
	setTextOverflow: function( overflowMode )
	{
		Core.Proc.appendToCommandString( ":337,38," + this.__objectRegistryId + "," + overflowMode  );
	},
	
	/** @private */
	setTextMaxLines: function( maxLines )
	{
		Core.Proc.appendToCommandString( ":337,39," + this.__objectRegistryId + "," + maxLines  );
	},
	
	/** @private */
	setTextMinSize: function( minSize )
	{
		Core.Proc.appendToCommandString( ":337,40," + this.__objectRegistryId + "," + minSize  );
	},
	
	/** @private */
	setTitle: function( state, title )
	{
		Core.Proc.appendToCommandString( ":337,41," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( title )  );
	},
	
	/** @private */
	setTitleColor: function( state, title )
	{
		Core.Proc.appendToCommandString( ":337,42," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( title )  );
	},
	
	/** @private */
	setTitleFont: function( state, fontName )
	{
		Core.Proc.appendToCommandString( ":337,43," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( fontName )  );
	},
	
	/** @private */
	setTitleShadow: function( state, shadow )
	{
		Core.Proc.appendToCommandString( ":337,44," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( shadow )  );
	},
	
	/** @private */
	setTitleSize: function( titleFontSize )
	{
		Core.Proc.appendToCommandString( ":337,45," + this.__objectRegistryId + "," + titleFontSize  );
	},
	
	/** @private */
	setTitleGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,46," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setTitleInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( ":337,47," + this.__objectRegistryId + "," + t + "," + r + "," + b + "," + l  );
	},
	
	/** @private */
	setTitleOverflow: function( overflowMode )
	{
		Core.Proc.appendToCommandString( ":337,48," + this.__objectRegistryId + "," + overflowMode  );
	},
	
	/** @private */
	setTitleMaxLines: function( maxLines )
	{
		Core.Proc.appendToCommandString( ":337,49," + this.__objectRegistryId + "," + maxLines  );
	},
	
	/** @private */
	setTitleMinSize: function( minSize )
	{
		Core.Proc.appendToCommandString( ":337,50," + this.__objectRegistryId + "," + minSize  );
	},
	
	/** @private */
	setGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( ":337,51," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( JSON.stringify( gradientJSON ) )  );
	},
	
	/** @private */
	setStringValue: function( value )
	{
		Core.Proc.appendToCommandString( ":337,52," + this.__objectRegistryId + "," + Core.Base64.encode( value )  );
	},
	
	/** @private */
	setFloatValue: function( value )
	{
		Core.Proc.appendToCommandString( ":337,53," + this.__objectRegistryId + "," + value  );
	},
	
	/** @private */
	setIntValue: function( value )
	{
		Core.Proc.appendToCommandString( ":337,54," + this.__objectRegistryId + "," + value  );
	},
	
	/** @private */
	setBoolValue: function( value )
	{
		Core.Proc.appendToCommandString( ":337,55," + this.__objectRegistryId + "," + ( value ? 1 : 0 )  );
	},
	
	/** @private */
	setButtonLayout: function( layoutType )
	{
		Core.Proc.appendToCommandString( ":337,56," + this.__objectRegistryId + "," + layoutType  );
	},
	
	/** @private */
	setContentInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( ":337,57," + this.__objectRegistryId + "," + t + "," + r + "," + b + "," + l  );
	},
	
	/** @private */
	setBarGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( ":337,58," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( JSON.stringify( gradientJSON ) )  );
	},
	
	/** @private */
	setPlaceholderText: function( placeholder )
	{
		Core.Proc.appendToCommandString( ":337,59," + this.__objectRegistryId + "," + Core.Base64.encode( placeholder )  );
	},
	
	/** @private */
	setPlaceholderTextColor: function( color )
	{
		Core.Proc.appendToCommandString( ":337,60," + this.__objectRegistryId + "," + Core.Base64.encode( color )  );
	},
	
	/** @private */
	setPlaceholderTextShadow: function( shadow )
	{
		Core.Proc.appendToCommandString( ":337,61," + this.__objectRegistryId + "," + Core.Base64.encode( shadow )  );
	},
	
	/** @private */
	setEnterKeyType: function( enterKeyType )
	{
		Core.Proc.appendToCommandString( ":337,62," + this.__objectRegistryId + "," + enterKeyType  );
	},
	
	/** @private */
	setInputType: function( inputType )
	{
		Core.Proc.appendToCommandString( ":337,63," + this.__objectRegistryId + "," + inputType  );
	},
	
	/** @private */
	setChecked: function( checked )
	{
		Core.Proc.appendToCommandString( ":337,64," + this.__objectRegistryId + "," + ( checked ? 1 : 0 )  );
	},
	
	/** @private */
	setScrollPosition: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,65," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setScrollableSize: function( w, h )
	{
		Core.Proc.appendToCommandString( ":337,66," + this.__objectRegistryId + "," + w + "," + h  );
	},
	
	/** @private */
	setSections: function( idArray )
	{
		Core.Proc.appendToCommandString( ":337,67," + this.__objectRegistryId + "," + Core.Base64.encode( JSON.stringify( idArray ) )  );
	},
	
	/** @private */
	setTitleView: function( titleObjectID )
	{
		Core.Proc.appendToCommandString( ":337,68," + this.__objectRegistryId + "," + titleObjectID  );
	},
	
	/** @private */
	setSourceDocument: function( documentURL )
	{
		Core.Proc.appendToCommandString( ":337,69," + this.__objectRegistryId + "," + Core.Base64.encode( documentURL )  );
	},
	
	/** @private */
	setChoices: function( stringArray, defaultChoiceIndex, cancelChoiceIndex )
	{
		Core.Proc.appendToCommandString( ":337,70," + this.__objectRegistryId + "," + Core.Base64.encode( JSON.stringify( stringArray ) ) + "," + defaultChoiceIndex + "," + cancelChoiceIndex  );
	},
	
	/** @private */
	show: function(  )
	{
		Core.Proc.appendToCommandString( ":337,71," + this.__objectRegistryId );
	},
	
	/** @private */
	hide: function(  )
	{
		Core.Proc.appendToCommandString( ":337,72," + this.__objectRegistryId );
	},
	
	/** @private */
	setPostData: function( data )
	{
		Core.Proc.appendToCommandString( ":337,73," + this.__objectRegistryId + "," + Core.Base64.encode( data )  );
	},
	
	/** @private */
	loadPostURL: function( url )
	{
		Core.Proc.appendToCommandString( ":337,74," + this.__objectRegistryId + "," + Core.Base64.encode( url )  );
	},
	
	/** @private */
	loadGetURL: function( url )
	{
		Core.Proc.appendToCommandString( ":337,75," + this.__objectRegistryId + "," + Core.Base64.encode( url )  );
	},
	
	/** @private */
	loadURL: function( url, headers, timeout )
	{
		Core.Proc.appendToCommandString( ":337,76," + this.__objectRegistryId + "," + Core.Base64.encode( url ) + "," + Core.Base64.encode( JSON.stringify( headers ) ) + "," + timeout  );
	},
	
	/** @private */
	stopLoading: function(  )
	{
		Core.Proc.appendToCommandString( ":337,77," + this.__objectRegistryId );
	},
	
	/** @private */
	reload: function(  )
	{
		Core.Proc.appendToCommandString( ":337,78," + this.__objectRegistryId );
	},
	
	/** @private */
	invoke: function( script )
	{
		Core.Proc.appendToCommandString( ":337,79," + this.__objectRegistryId + "," + Core.Base64.encode( script )  );
	},
	
	/** @private */
	goBack: function(  )
	{
		Core.Proc.appendToCommandString( ":337,80," + this.__objectRegistryId );
	},
	
	/** @private */
	goForward: function(  )
	{
		Core.Proc.appendToCommandString( ":337,81," + this.__objectRegistryId );
	},
	
	/** @private */
	setBasicAuthCredentials: function( credentials )
	{
		Core.Proc.appendToCommandString( ":337,82," + this.__objectRegistryId + "," + Core.Base64.encode( JSON.stringify( credentials ) )  );
	},
	
	/** @private */
	setRightImage: function( state, rightImageURL )
	{
		Core.Proc.appendToCommandString( ":337,83," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( rightImageURL )  );
	},
	
	/** @private */
	setRightImageBorder: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( ":337,84," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( JSON.stringify( gradientJSON ) )  );
	},
	
	/** @private */
	setRightImageFitMode: function( fitMode )
	{
		Core.Proc.appendToCommandString( ":337,85," + this.__objectRegistryId + "," + fitMode  );
	},
	
	/** @private */
	setRightImageGravity: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,86," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setRightImageOrigin: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,87," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setRightImageAnchor: function( x, y )
	{
		Core.Proc.appendToCommandString( ":337,88," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	setRightImageSize: function( w, h )
	{
		Core.Proc.appendToCommandString( ":337,89," + this.__objectRegistryId + "," + w + "," + h  );
	},
	
	/** @private */
	setRightImageInsets: function( t, r, b, l )
	{
		Core.Proc.appendToCommandString( ":337,90," + this.__objectRegistryId + "," + t + "," + r + "," + b + "," + l  );
	},
	
	/** @private */
	setRightImageTransform: function( a, b, c, d, tx, ty )
	{
		Core.Proc.appendToCommandString( ":337,91," + this.__objectRegistryId + "," + a + "," + b + "," + c + "," + d + "," + tx + "," + ty  );
	},
	
	/** @private */
	$setStatusBarHidden: function( statusBarStatus )
	{
		Core.Proc.appendToCommandString( ":337,-92," + ( statusBarStatus ? 1 : 0 )  );
	},
	
	/** @private */
	pauseAds: function(  )
	{
		Core.Proc.appendToCommandString( ":337,93," + this.__objectRegistryId );
	},
	
	/** @private */
	resumeAds: function(  )
	{
		Core.Proc.appendToCommandString( ":337,94," + this.__objectRegistryId );
	},
	
	/** @private */
	setAdRefreshRate: function( refreshRate )
	{
		Core.Proc.appendToCommandString( ":337,95," + this.__objectRegistryId + "," + refreshRate  );
	},
	
	/** @private */
	setAdAllowAutoplay: function( autoplay )
	{
		Core.Proc.appendToCommandString( ":337,96," + this.__objectRegistryId + "," + ( autoplay ? 1 : 0 )  );
	},
	
	/** @private */
	setAlpha: function( alpha )
	{
		Core.Proc.appendToCommandString( ":337,97," + this.__objectRegistryId + "," + alpha  );
	},
	
	/** @private */
	postURL: function( url, data )
	{
		Core.Proc.appendToCommandString( ":337,98," + this.__objectRegistryId + "," + Core.Base64.encode( url ) + "," + Core.Base64.encode( data )  );
	},
	
	/** @private */
	setProgressGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( ":337,99," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( JSON.stringify( gradientJSON ) )  );
	},
	
	/** @private */
	setSecondaryGradient: function( state, gradientJSON )
	{
		Core.Proc.appendToCommandString( ":337,100," + this.__objectRegistryId + "," + state + "," + Core.Base64.encode( JSON.stringify( gradientJSON ) )  );
	},
	
	/** @private */
	setProgress: function( progress, secondaryProgress )
	{
		Core.Proc.appendToCommandString( ":337,101," + this.__objectRegistryId + "," + progress + "," + secondaryProgress  );
	},
	
	/** @private */
	useForUpdateProgress: function( use )
	{
		Core.Proc.appendToCommandString( ":337,102," + this.__objectRegistryId + "," + ( use ? 1 : 0 )  );
	},
	
	/** @private */
	setDarkStyle: function( use )
	{
		Core.Proc.appendToCommandString( ":337,103," + this.__objectRegistryId + "," + ( use ? 1 : 0 )  );
	},
	
	/** @private */
	$doCompositeImages: function( w, h, filename, infoArray, callbackId )
	{
		Core.Proc.appendToCommandString( ":337,-104," + w + "," + h + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( JSON.stringify( infoArray ) ) + "," + Core.Base64.encode( callbackId )  );
	},
	
	/** @private */
	$doChooseCamera: function( w, h, filename, options, callbackId )
	{
		Core.Proc.appendToCommandString( ":337,-106," + w + "," + h + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( JSON.stringify( options ) ) + "," + Core.Base64.encode( callbackId )  );
	},
	
	/** @private */
	setScrollable: function( enabled )
	{
		Core.Proc.appendToCommandString( ":337,107," + this.__objectRegistryId + "," + ( enabled ? 1 : 0 )  );
	},
	
	/** @private */
	setZoomable: function( enabled )
	{
		Core.Proc.appendToCommandString( ":337,108," + this.__objectRegistryId + "," + ( enabled ? 1 : 0 )  );
	},
	
	/** @private */
	addAnnotation: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":337,109," + this.__objectRegistryId + "," + __objectRegistryId  );
	},
	
	/** @private */
	removeAnnotation: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":337,110," + this.__objectRegistryId + "," + __objectRegistryId  );
	},
	
	/** @private */
	selectAnnotation: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":337,111," + this.__objectRegistryId + "," + __objectRegistryId  );
	},
	
	/** @private */
	setRegion: function( latitude, longitude, latitudeDelta, longitudeDelta, animated )
	{
		Core.Proc.appendToCommandString( ":337,112," + this.__objectRegistryId + "," + latitude + "," + longitude + "," + latitudeDelta + "," + longitudeDelta + "," + ( animated ? 1 : 0 )  );
	},
	
	/** @private */
	setView: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":337,113," + this.__objectRegistryId + "," + __objectRegistryId  );
	},
	
	/** @private */
	setCoordinate: function( latitude, longitude )
	{
		Core.Proc.appendToCommandString( ":337,114," + this.__objectRegistryId + "," + latitude + "," + longitude  );
	},
	
	/** @private */
	setCalloutTitle: function( title )
	{
		Core.Proc.appendToCommandString( ":337,115," + this.__objectRegistryId + "," + Core.Base64.encode( title )  );
	},
	
	/** @private */
	setCalloutSubtitle: function( subTitle )
	{
		Core.Proc.appendToCommandString( ":337,116," + this.__objectRegistryId + "," + Core.Base64.encode( subTitle )  );
	},
	
	/** @private */
	setCalloutEnabled: function( enabled )
	{
		Core.Proc.appendToCommandString( ":337,117," + this.__objectRegistryId + "," + ( enabled ? 1 : 0 )  );
	},
	
	/** @private */
	setCalloutLeftView: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":337,118," + this.__objectRegistryId + "," + __objectRegistryId  );
	},
	
	/** @private */
	setCalloutRightView: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":337,119," + this.__objectRegistryId + "," + __objectRegistryId  );
	},
	
	/** @private */
	setCenterOffset: function( xOffset, yOffset )
	{
		Core.Proc.appendToCommandString( ":337,120," + this.__objectRegistryId + "," + xOffset + "," + yOffset  );
	},
	
	/** @private */
	$doChoosePhoto: function( w, h, filename, options, callbackId, invokingView )
	{
		Core.Proc.appendToCommandString( ":337,-121," + w + "," + h + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( JSON.stringify( options ) ) + "," + Core.Base64.encode( callbackId ) + "," + invokingView  );
	},
	
	/** @private */
	setScrollIndicatorsVisible: function( enabled )
	{
		Core.Proc.appendToCommandString( ":337,122," + this.__objectRegistryId + "," + ( enabled ? 1 : 0 )  );
	},
	
	/** @private */
	$measureText: function( string, w, h, font, fontSize, callbackId )
	{
		Core.Proc.appendToCommandString( ":337,-123," + Core.Base64.encode( string ) + "," + w + "," + h + "," + Core.Base64.encode( font ) + "," + fontSize + "," + Core.Base64.encode( callbackId )  );
	},
	
	/** @private */
	setFocus: function( enabled )
	{
		Core.Proc.appendToCommandString( ":337,124," + this.__objectRegistryId + "," + ( enabled ? 1 : 0 )  );
	},
	
	/** @private */
	setViewportEnabled: function( enabled )
	{
		Core.Proc.appendToCommandString( ":337,125," + this.__objectRegistryId + "," + ( enabled ? 1 : 0 )  );
	},
	
	/** @private */
	clearAnimations: function(  )
	{
		Core.Proc.appendToCommandString( ":337,126," + this.__objectRegistryId );
	},
	
	/** @private */
	setStyle: function( styleID )
	{
		Core.Proc.appendToCommandString( ":337,127," + this.__objectRegistryId + "," + styleID  );
	},
	
	/** @private */
	setVisibleInOrientations: function( orientationFlags )
	{
		Core.Proc.appendToCommandString( ":337,128," + this.__objectRegistryId + "," + orientationFlags  );
	},
	

// {{/Wg Generated Code}}

	_eventOccurredRecv: function( cmd ) {
		var str = Core.Proc.parseString( cmd[ 0 ] );
		Commands.Window.doCommand(str);
	},
	
	registerTemporaryCallback: function( callback ) {
		if (typeof callback != 'function') return null;
		var regId = (++this._tempCBCount).toString(36);
		Commands._tempCBs[regId] = callback;
		return regId;
	},
	
	takeTemporaryCallback: function( regId ) {
		var cb = Commands._tempCBs[regId];
		delete Commands._tempCBs[regId];
		return cb;
	},

	/**
	 *	@function UI#animate
	 * 	Animate changes to the properties of one or more UI objects.
	 * 	Currently animates changes to frame and alpha, and animates the addition / removal of subviews.
	 * 	@param {Function} action A closure that sets the property or properties to be animated.
	 * 		This function may manipulate several objects.
	 * 	@param {Number} duration The time over which to execute the animation, in milliseconds.
	 * 	@param {Function} onCompletion A closure to be executed after the animation has completed.
	 */
	animate: function(action, duration, callback) {
		if (typeof action == 'function') {
			var cbFn = (typeof callback == 'function') ? callback : duration;
			var duration = (typeof duration == 'number') ? duration : callback;
			if (typeof duration != 'number') duration = 400;

			Commands.startAnimation( duration, Commands.registerTemporaryCallback(callback));
			var options = new UIAnimationOptions();
			action(options);
			Commands.executeAnimation(options);
		}
	},
});

exports.Commands.instantiate();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Window'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Window'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Window'] = exports; var Class = require('NGCore/Client/Core/Class').Class;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Element = require('NGCore/Client/UI/Element').Element;
var Rect = require('NGCore/Client/UI/ViewGeometry').Rect;

var WindowLayer = require('NGCore/Client/UI/WindowLayer').WindowLayer;

// Singleton
// Methods beginning with an underscore are considered private and should
// not be called from outside of the class.

Commands.Window = exports.Window = Class.singleton({

	/**
	 * @deprecated Replaced by {@link UI.Window#getWidth}.
	 */
	_outerWidth: 0,

	/**
	 * @deprecated Replaced by {@link UI.Window#getHeight}.
	 */
	_outerHeight: 0,

	/**
	 * @private
	 */
	_width: 0,
	/**
	 * @private
	 */
	_height: 0,

	 /**
	 * @class The <code>Window</code> class constructs a singleton object that manages application access to native UI.<br><br>
	 * <b>Note:</b> An application should never directly allocate a singleton.
	 * @name UI.Window
	 * @augments Core.Class	
	 * @see UI.Window#document
	 * @constructs The default constructor.
	 */
	initialize: function() {
		if (!this._outerWidth || !this._outerHeight) this.setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
		if (!this._width || !this._height) this._setWidthAndHeight(Capabilities.getScreenWidth(), Capabilities.getScreenHeight());
		
		Commands.instantiate();
		var LayoutListener = Core.MessageListener.subclass(
		{
			initialize: function()
			{
				Device.LayoutEmitter.addListener(this, this.onUpdate);
			},
			
			onUpdate: function(layout)
			{
				UI.Window._setWidthAndHeight(layout['width'], layout['height']);
			}
		});
		var layout = new LayoutListener();
		NgLogD("window: outer = " + this._outerWidth + " × " + this._outerHeight + " frame = " + this._width + " × " + this._height);
	},
	
	document: WindowLayer.singleton({
		'type': 'document',
		register: function() {
			// This is not a registered object.
			this.__objectRegistryId = 0;
		}
	}),
	
	_layers: {},
	_getLayer: function(level) {
		return this._layers[level] || (this._layers[level] = new WindowLayer({'level':level || 0}));
	},
	
	/**
	 * @private
	 */
	destroyObject: function(obj) {
		obj.removeFromParent();
		Commands.destroy.call(obj);
		ObjectRegistry.unregister(obj);
	},
	
	/**
	 * @private
	 */
	handleCommand: function(command) {
		// this.log(["Raw Command", command]);
		var fields = NgParseCommand2(command, NgParseInt, NgParseBase64);
	//	this.log(["handleCommand:", fields[1]]);
		this.doCommand(fields[1]);
	},
	/**
	* @private
	*/
	setStatusBarHidden: function(value) {
		Commands.setStatusBarHidden(value);
		this._outerHeight = Capabilities.getScreenHeight() - (value ? 0 : (Capabilities.getStatusBarHeight() || 0));
	},
	
	/**
	 * @private
	 */
	doCommand: function(jsonString) {
		//NgLogD(jsonString);
		var command = JSON.parse(jsonString);
		if(command.name == 'callback'){
			var cb = Commands.takeTemporaryCallback(command.callback_id);
			if (typeof cb == 'function') {
				cb(command);
			}
		} else {
			var object = ObjectRegistry.idToObject(command.objId);
			if (object instanceof Element) {
				switch (command.name) {
					case 'event':
						object.performEventCallback(command);
						break;
					case 'update':
						var properties = command.properties || {};
						for (var property in properties) {
							try {
								var setter = object['update' + property.charAt(0).toUpperCase() + property.substr(1)];
								if (typeof setter == 'function') {
									setter.apply(object, [properties[property]]);
								} else {
									// Set read-only properties!
									object['_'+property] = properties[property];
								}
							} catch (e) {};
						}
						break;
					default:
						object.handleCommand(command);
				}
			} else {
				console.log("Message received for non-element object with id " + command.objId);
				return;
			}
		}
		// log(["Got message back", command]);
	},
    
	/**
	 * @private
	 */    
	log: function(object) {
		NgLogD(object.toString());
		// this.postMessage({name: 'log', message: object});
	},
	/**
	 * Return the available screen width, with respect to orientation and system status bars.
	 * @returns {Number} The currently available width in pixels that can be drawn to.
	 * @type Number
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getWidth: function()
	{
		return this._width;
	},

	/**
	 * Return the available screen height, with respect to orientation and system status bars.
	 * @returns {Number} The currently available height in pixels that can be drawn to.
	 * @type Number
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getHeight: function()
	{
		return this._height;
	},

	getOuterWidth: function() {
		return this._outerWidth;
	},
	
	getOuterHeight: function() {
		return this._outerHeight;
	},

	getFrame: function() {
		return new Rect(0, 0, this._width, this._height);
	}
});

// Cause property access to initialize the singleton. Needed for backward compatibility.
Commands.Window.__defineGetter__("outerWidth", function() {return this.getOuterWidth()});
Commands.Window.__defineGetter__("outerHeight", function() {return this.getOuterHeight()});

/**
 * @private
 */
Commands.Window._setWidthAndHeight = function(width, height)
{
	console.log("window: set layout size to: " + width + ' × ' + height);
	this._width = width;
	this._height = height;
};

/**
 * @private
 */
Commands.Window.setWidthAndHeight = function(width, height)
{
	console.log("window: set outer size to: " + width + ' × ' + height);
	this._outerWidth = width;
	this._outerHeight = height;
};

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Element'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Element'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Element'] = exports; var Class = require('NGCore/Client/Core/Class').Class;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;

var Element = exports.Element = Class.subclass(
/** @lends UI.Element.prototype */
{
	$subclass: function() {
		if (typeof this._init == 'function') this._init();
		return Class.subclass.apply(this, arguments);
	},
	
	classname: "UI_Element",

	/**
	 * @class The <code>Element</code> class is a base class for derived classes that manage object properties and handle user interface events.<br><br>
	 * <b>Caution!:</b> This base class is not exported in the UI module. Do not access it or subclass it at runtime.
	 * Derived classes from <code>Element</code> include:
	* <div class="ul">
	 * <li>{@link UI.AbstractView}</li>
	 * <li>{@link UI.AlertDialog}</li>
	 * <li>{@link UI.ListViewSection}</li>
	 * <li>{@link UI.ProgressDialog}</li>	 
	 * </div>
	 * @constructs The default constructor. 
	 * @param {String} properties
	 * @augments Core.Class
	*/
	initialize: function(properties) {
		if (Element._init) Element._init();
		
		this.register();
		
		// Enable events that are being handled at the class level...
		var events = this._eventNames;
		if (events) for (var e in events) {
			if (this[events[e]]) Commands.enableEvent.call(this, e);
		}
		
		//	Reimplement setAttributes here for speed
		var setters = this._setters;
		if (setters) for (var k in properties) {
			if (typeof setters[k] == 'function') try {
				setters[k].call(this, properties[k]);
			} catch (e) {
				NgLogD("Unable to set " + this.type + '.' + k);
			}
		}
		
	/*	This is awesome. Maybe use it in production code, but we want to keep
	//	our stylistic constraints for core development.
	
		for (var propName in this._setters) {
			this.__defineSetter__(propName, this._setters[propName]);
		}
		for (propName in this._getters) {
			this.__defineGetter__(propName, this._getters[propName]);
		}
	*/
	
		return this;
	},
	
	register: function() {
		try {
			ObjectRegistry.register(this);
			Commands.create(this.__objectRegistryId, this.type || this.classname);
		} catch (e) {
			// Nothing yet
		} finally {
			return this.__objectRegistryId;
		}
	},
	
	retain: function() {
		(this.__retainCount) ? ++this.__retainCount : (this.__retainCount = 1);
		return this;
	},
	
	release: function() {
		if (--this.__retainCount === 0) {
			this.destroy();
		}
	},
		
	/**
	 * Retrieve the property value of the given key. 
	 * @param {String} key The property keyword.
	 * @returns {String} The current property value.
	 * @see UI.Element#getAttributes,
	 * @see UI.Element#setAttribute,
	 * @see UI.Element#setAttributes
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	getAttribute: function(key) {
		var getter = this._getters[key];
		return (typeof getter == 'function') ? getter.call(this) : undefined;
	},
	
	/**
	 * Set the property value for the given key.
	 * @example var glView = new UI.GLView
	 * ...
	 * glView.setAttribute('active', true);
	 * @param {String} key The property keyword.
	 * @param {String} value The new property value.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see UI.Element#getAttribute,
	 * @see UI.Element#getAttributes,
	 * @see UI.Element#setAttributes
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	setAttribute: function(key, value){
		var setter = this._setters[key];
		if (typeof setter == 'function') {
			return setter.call(this, value);
		} else {
			NgLogD("Unable to set " + this.type + '.' + key);
		}
		return this;
	},
	
	/**
	 * Set the property value for each specified key. Property values are passed in as key/value pairs.
	 * @param {Object} dict A dictionary of property key/value pairs.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see UI.Element#getAttribute,
	 * @see UI.Element#getAttributes,
	 * @see UI.Element#setAttribute
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	setAttributes: function(dict) {
		var setters = this._setters;
		if (setters) for (var k in dict) {
			if (typeof setters[k] == 'function') try {
				setters[k].call(this, dict[k]);
			} catch (e) {
				NgLogD("Unable to set " + this.type + '.' + k);
			}
		}
		return this;
	},
	
	/**
	 * Retrieve property values for each specified key. 
	 * @param {String} list A list of property keywords.
	 * @returns {Object} A list of key/value pairs.
	 * @see UI.Element#getAttribute,
	 * @see UI.Element#setAttribute,
	 * @see UI.Element#setAttributes
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	getAttributes: function(list) {
		var output = {};
		if (list instanceof Array) {
			var key;
			for (var i = 0; i < list.length; i++) {
				key = list[i];
				output[key] = this._getters[key].call(this);
			}
		} else {
			for (var key in this._getters) {
				output[key] = this._getters[key].call(this);
			}
		}
		return output;
	},

	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	enableEvent: Commands.enableEvent,
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	toString: function() {
		return this.type + '(' + this.__objectRegistryId + ')';
	},

	/**
	 * @function
	 * @description Destroy this instance and release resources on the backend.
	 * @status Javascript, iOS, Android, Flash, Test
	*/
	destroy: function() {
		Commands.destroy.call(this);
		ObjectRegistry.unregister(this);
		delete this.prototype;
		for (var i in this) {
			if (this.hasOwnProperty(i)) {
				delete this[i];
			}
		}
		this._destroyed = true;
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	*/
	registerCallback: function(func, oneTime) {
		var callbackId = ++this.callbackCounter;
		var obj = this;
		this.callbacks[callbackId] = function(obj, args) {
			try {
				func(obj, args);
				if(oneTime) {
					delete obj.callbacks[callbackId];
				}
			}
			catch(e) {
				NgHandleException(e);
			}
		};
		return callbackId;
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	performCallback: function(event) {
		var cb = this.callbacks[event.callbackId];
		if(cb) {
			cb(this, event.arguments);
		}
	},
	
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	performEventCallback: function(event) {
		try {
			// Look up the event by its 'onXXX' name...
			var eName = this._eventNames[event.eventType];
			var fn = this['_'+eName] || this[eName];
			if (typeof fn == 'function') {
				fn.call(this, event);
			}
		}
		catch(e) {
			NgHandleException(e);
		}
	},	
	
	// STATICS: Setter and Getter Registration
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$registerAccessors: function(propName, getterFn, setterFn, deprecationMessage) {
		// Put the new setter / getter functions into the prototype.
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);
		var byKeyOnly = Boolean(deprecationMessage || false);
	//	NgLogD("Synthesizing set" + caseAdjusted + (shouldSetClosure ? " (custom)" : " (standard)") +
	//		" and get" + caseAdjusted + (onGetClosure ? " (custom)" : " (standard)") + " for member variable " + localVar);
	
		// If this is an instance, use the instance. Otherwise, if we are a class constructor, modify the prototype.
		var pType = (this instanceof Element) ? this : this.prototype;
		if (typeof getterFn == 'function') {
			if (!pType.hasOwnProperty('_getters')) {
				try {
					var heritableMap = function() {return this;};
					var superGetters = pType.superclass._getters;
					if (superGetters) heritableMap.prototype = superGetters;
					pType._getters = new heritableMap();
				} catch (e) {};
			}
			if (byKeyOnly) {
				pType['get'+caseAdjusted] = function() {
					NgLogD("WARNING: Use of get" + caseAdjusted + "() is deprecated. " + deprecationMessage);
					getterFn.apply(this, arguments);
				};
			} else {
				pType['get'+caseAdjusted] = getterFn;
			}
			pType._getters[propName] = getterFn;
		}
		if (typeof setterFn == 'function') {
			if (!pType.hasOwnProperty('_setters')) {
				try {
					var heritableMap = function() {return this;};
					var superSetters = pType.superclass._setters;
					if (superSetters) heritableMap.prototype = superSetters;
					pType._setters = new heritableMap();
				} catch (e) {};
			}
			if (byKeyOnly) {
				pType['set'+caseAdjusted] = function() {
					NgLogD("WARNING: Calling set" + caseAdjusted + "() is deprecated. " + deprecationMessage);
					setterFn.apply(this, arguments);
				}
			} else {
				pType['set'+caseAdjusted] = setterFn;
			}
			pType._setters[propName] = setterFn;
		}
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$registerEventType: function(eventName) {
		var onEventName = 'on' + eventName.charAt(0).toUpperCase() + eventName.substr(1);
		var localVar = '_' + onEventName;
		var pType = this.prototype;
		
		var getterFn = function() {
			return this[localVar] || this[onEventName];
		};
		var setterFn = function(callback) {
			var isFn = (typeof callback == 'function');
			if (isFn) {
				this[localVar] = callback;
			} else {
				delete this[localVar];
			}
			this.enableEvent(eventName, isFn);
		};
		if (!pType.hasOwnProperty('_eventNames')) {
			try {
				var heritableMap = function() {return this;};
				var superEvents = pType.superclass._eventNames;
				if (superEvents) heritableMap.prototype = superEvents;
				pType._eventNames = new heritableMap();
			} catch (e) {};
		}
		pType._eventNames[eventName] = onEventName;
		
		this.registerAccessors(onEventName, getterFn, setterFn);
		
		// Legacy support. Let's concentrate on removing this soon or at least fixing the casing.
		pType.__defineGetter__(onEventName.toLowerCase(), getterFn);
		pType.__defineSetter__(onEventName.toLowerCase(), setterFn);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$synthesizePropertyWithState: function(propName, CommandsFn) {
		var lVarName = '_' + propName + 'Map';
		var setterFn;
		if (propName) {
			setterFn = function(value, optState) {
				optState |= 0;
			//	NgLogD("Set " + this.type + "." + propName + "[" + optState + "] = " + value);
				(this[lVarName] || (this[lVarName] = {}))[optState] = value;
				CommandsFn.call(this, optState, value);
				return this;
			};
		} else {
			setterFn = function(value, optState) {
				CommandsFn.call(this, (optState | 0), value);
				return this;
			};
		}
		
		var getterFn = function(state) {
			return (this[lVarName] || 0)[(state | 0)];
		};
		
		this.registerAccessors(propName, getterFn, setterFn);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$synthesizeCompoundProperty: function(propName, CommandsFn) {
		var lVarName = '_' + propName;
		var setterFn;
		if (CommandsFn) {
			// Synthesized setters accept EITHER an array of reasonable length OR individual args.
			setterFn = function(args) {
				this[lVarName] = (args instanceof Array)
					? args
					: Array.prototype.slice.call(arguments);
				CommandsFn.apply(this, this[lVarName]);
				return this;
			}
		} else {
			setterFn = function(args) {
				this[lVarName] = (args instanceof Array) ? args : Array.prototype.slice.call(arguments);
				return this;
			}
		}
		
		this.registerAccessors(propName, function() {return this[lVarName];} , setterFn);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	$synthesizeProperty: function(propName, CommandsFn) {
		var lVarName = '_' + propName;
		var setterFn;
		if (CommandsFn) {
			// Optional args are still passed through, even though only the first arg is assigned.
			setterFn = function(arg) {
				this[lVarName] = arg;
				CommandsFn.apply(this, arguments);
				return this;
			}
		} else {
			setterFn = function(arg) {
				this[lVarName] = arg;
				return this;
			}
		}
		
		this.registerAccessors(propName, function() {return this[lVarName];} , setterFn);
	},
	
	
	$bindPropertyState:function(propertyName, stateName, stateFlags) {
			var caseAdjusted = propertyName[0].toUpperCase() + propertyName.substr(1);
			var gName = 'get' + caseAdjusted;
			var sName = 'set' + caseAdjusted;
			var getterFn = function() {
				return this[gName].call(this, stateFlags);
			};
			var setterFn = function(val) {
				return this[sName].call(this, val, stateFlags);
			};

			this.registerAccessors( stateName + caseAdjusted, getterFn, setterFn );
		}

});


// Event Handlers
Element._init = function() {
	delete Element._init;
	
	/**
	 * @name UI.Element#setOnLoad
	 * @description Set a function to call when the <code>load</code> event occurs.
	 * @param {Function} loadCallback The new functoin to call.<br><br><b>Note:</b> The <code>load</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example function() { 
	 *	onLoad.loaded = true; 
	 * };
	 * @see UI.Element#event:getOnLoad
	 * @event
	 */
	/**
	 * @name UI.Element#getOnLoad
	 * @description Retrieve the function to call when the <code>load</code> event occurs.
	 * @returns {Function} The current function to call.
	 * @see UI.Element#event:setOnLoad
	 * @event
	 */
	Element.registerEventType('load');
	/**
	 * @name UI.Element#setOnUnload
	 * @description Set a function to call when the <code>unload</code> event occurs.
	 * @param {Function} unloadCallback The new functoin to call.<br><br><b>Note:</b> The <code>unload</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example function() { 
	 *	onUnload.unloaded = true; 
	 * };
	 * @see UI.Element#event:getOnUnload	
	 * @event
	 */
	/**
	 * @name UI.Element#getOnUnload
	 * @description Retrieve the function to call when the <code>unload</code> event occurs.
	 * @returns {Function} The current function to call.
	 * @see UI.Element#event:setOnUnload	 
	 * @event
	 */
	Element.registerEventType('unload');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ViewGeometry'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ViewGeometry'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ViewGeometry'] = exports; var Class = require('NGCore/Client/Core/Class').Class;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

/**
 * <p>Classes and objects contained by the <code>ViewGeometry</code> class.</p>
 * @name UI.ViewGeometry
 * @namespace
 * @description <p>The <code>ViewGeometry</code> class is a collection of classes and objects that control spatial components for UI views. 
 * Derived classes from <code>ViewGeometry</code> include:</p>
 * <ul>
 * <li><code>{@link UI.ViewGeometry.Rect}</code></li>
 * <li><code>{@link UI.ViewGeometry.Scale}</code></li>
 * </ul>
 * <p><code>ViewGeometry</code> utilizes the following enumerated constants:</p>
 * <ul>
 * <li><code>{@link UI.ViewGeometry.FitMode}</code></li>
 * <li><code>{@link UI.ViewGeometry.Gravity}</code></li>
 * </ul>
 */

var Scale = exports.Scale = Class.singleton(
/** @lends UI.ViewGeometry.Scale.prototype */
{
	/**
	 * @name UI.ViewGeometry.Scale
	 * @class The <code>Scale</code> class constructs objects that handle view geometry for different scales of measurement.
         * @constructs The default constructor.
	 * @augments Core.Class
	 */
   
	initialize: function() {
		var screenUnits = Capabilities.getScreenUnits();
		this.iOSConversion = screenUnits;
		this.pointConversion = this.iOSConversion * 160 / 72; 
	},

	// Use the values of generated constants... Mostly for if we need to send these to native in the future.
	Pixels: Commands.Scaling.Pixels,
	Points: Commands.Scaling.Points,
	Unit: Commands.Scaling.Unit,
	Percent: Commands.Scaling.Percent,
	iPhone: Commands.Scaling.iPhone,
	
	// Internals.
    
	pointConversion: 1.0,
    
	iOSConversion: 1.0,

    /** 
     * Retrieve the supported measurement scale from the device.
     * @param {Number} units The unit of measure.
     * @param {Number} size The screen size of the device.
     * @returns The current screen dimension supported by the device.
     */
	getScale: function(units, size) {
		switch (+units) {
			case this.Points:
				return this.pointConversion;
			case this.Unit:
				return size;
			case this.Percent:
				return size / 100;
			case this.iPhone:
				return this.iOSConversion;
		}
		return 1.0;
	}
});

var Gravity = exports.Gravity = 
{
		
	/** 
	 * @name UI.ViewGeometry.Gravity
	 * @class Enumeration for image gravity in a view.
	 */
	/** 
	* Center of gravity is the top-left corner of the image.
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	TopLeft: [0.0,0.0],
	/** 
	* Center of gravity is the top-center portion of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	TopCenter: [0.5,0.0],
	/** 
	* Center of gravity is the top-right corner of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	TopRight: [1.0, 0.0],
	/** 
	* Center of gravity is the left side of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	Left: [0.0,0.5],
	/** 
	* Center of gravity is the center of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	Center: [0.5,0.5],
	/** 
	* Center of gravity is the right side of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	Right: [1.0,0.5],
	/** 
	* Center of gravity is the bottom-left corner of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	BottomLeft: [0.0,1.0],
	/** 
	* Center of gravity is the bottom-center portion of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	BottomCenter: [0.5,1.0],
	/** 
	* Center of gravity is the bottom-right corner of the image. 
	* @memberOf UI.ViewGeometry.Gravity.prototype
	* @constant
	*/
	BottomRight: [1.0,1.0]
};

 
exports.FitModes = Commands.FitMode;
/** 
* @name UI.ViewGeometry.FitMode
* @class Enumeration for image fit modes in a view.
* @see UI.Commands#FitMode
*/

	
var Rect = exports.Rect = Class.subclass(
/** @lends UI.ViewGeometry.Rect.prototype */
{
	/**
	 * @name UI.ViewGeometry.Rect
	 * @class <code>Rect</code> constructs rectangle objects for use as positionable elements in the user interface. 
	 * @constructs The default constructor.
	 * @augments Core.Class
	 */

    initialize: function(arg0)
    {
    	if (arg0 instanceof this.constructor){
    		// Another Rect
    		this.x = arg0.x;
    		this.y = arg0.y;
    		this.w = arg0.w;
    		this.h = arg0.h;
    	} else if (arg0 instanceof Array) {
    		if (arguments.length == 2 
    			&& arguments[0].length >= 2 
    			&& arguments[1] instanceof Array 
    			&& arguments[1].length >= 2) {
				
				// Arguments can be two arrays, one of which is a point and one of which is a size,
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.w = arguments[1][0];
				this.h = arguments[1][1];
			}
			else if (arguments.length == 1 && arg0.length >= 4) {
				// Single Array
				this.x = arg0[0];
				this.y = arg0[1];
				this.w = arg0[2];
				this.h = arg0[3];
			}
			else {
				NgLogD("UI.ViewGeometry.Rect initialized with unparseable Array(s)");
			}
		} else if (arguments.length == 4) {
			// Four numbers
			this.x = arguments[0];
			this.y = arguments[1];
			this.w = arguments[2];
			this.h = arguments[3];
		}
		return this;
    },
	/**
	 * @returns {Boolean} Returns <code>true</code> if any component value is undefined, NaN, or the value indicates this rect has an area of 0 (<i>width</i> * <i>height</i>).
	 */
	isEmpty: function(){
		return !(this.w * this.h > 0) || isNaN(this.x) || isNaN(this.y) || isNaN(this.w) || isNaN(this.h);
	},
	/**
	 * Copy the component values of this <code>Rect</code>
	 * @returns {UI.ViewGeometry.Rect} A new <code>Rect</code> with identical component values.
	 */	
	copy: function() {
		return new (this).constructor(this);
	},
    /**
	 * Retrieve the component values of this <code>Rect</code>.
	 * @returns {Array (Number)} An array of component values for the specified <code>Rect</code> (<i>x</i>, <i>y</i>, <i>height</i>, <i>width</i>).
	 */	
	array: function() {
		return [this.x, this.y, this.w, this.h];
	},
    /**
	 * Set the dimensions of this <code>Rect</code> as an inset.
	 * @example var imageRect = null;
	 * var remainingRect = rect.copy();
	 * ...
	 * imageRect = remainingRect.sliceHorizontal(110).inset(8,15,8,15);
	 * @param {Number} t The size for the top of the rectangle.
	 * @param {Number} r The size for the right side of the rectangle.
	 * @param {Number} b The size for the bottom of the rectangle.
	 * @param {Number} l The size for the left side of the rectangle.
	 * @param {UI.ViewGeometry.Scale} units The unit of measure for the rectangle.
	 * @returns {UI.ViewGeometry.Rect} This function returns <code>this</code> to support method invocation chaining.
	 */	
	inset: function(t, r, b, l, units) {
		if (arguments.length > 4) {
			var xScale = Scale.getScale(units, this.w);
			var yScale = Scale.getScale(units, this.h);
			t = Math.floor(t * yScale);
			r = Math.floor(r * xScale);
			b = Math.floor(b * yScale);
			l = Math.floor(l * xScale);
		}
		
		if (arguments.length < 2) {
			r = t;
		}
		if (arguments.length < 4) {
			b = t;
			l = r;
		}
		this.y += t;
		this.h -= t + b;
		this.x += l;
		this.w -= l + r;
		return this;
	},
    /**
	 *	Create and return a new <code>Rect</code> representing the top (if positive) or bottom (if negative).
	 *	Destructively modifies this Rect, removing the new rect area from the receiver.
	 * @example var topPart = rect.inset(10).sliceVertical(50, UI.Scale.Percent);
	 * @param {Number} height The new rect height.
	 * @param {UI.ViewGeometry.Scale} [units] The scale of measurement.
	 * @returns {UI.ViewGeometry.Rect} A new <code>Rect</code> object.<br>
	 * @see UI.ViewGeometry.Rect#sliceHorizontal
	 */	
	sliceVertical: function(height, units) {
		if (arguments.length > 1) height = Math.floor(height * Scale.getScale(units, this.h));
		
		var newRect = this.copy();
		if (height < 0) {
			// Return the bottom area...
			newRect.h = -height;
			this.h += height;
			newRect.y += this.h;
		} else {
			newRect.h = height;
			this.y += height;
			this.h -= height;
		}
		return newRect;
	},
    /**
	 *	Create and return a new <code>Rect</code> representing the left (if positive) or right (if negative).
	 *	Destructively modifies this Rect, removing the new rect area from the receiver.
	 * @example var imageRect = null;
	 * var remainingRect = rect.copy();
	 * ...
	 * imageRect = remainingRect.sliceHorizontal(110).inset(8,15,8,15);
	 * @param {Number} width The new rect width.
	 * @param {UI.ViewGeometry.Scale} [units] The scale of measurement.
	 * @returns {UI.ViewGeometry.Rect} A new <code>Rect</code> object.<br>
	 * @see UI.ViewGeometry.Rect#sliceVertical
	 */	
	sliceHorizontal: function(width, units) {
		if (arguments.length > 1) width = Math.floor(width * Scale.getScale(units, this.w));

		var newRect = this.copy();
		if (width < 0) {
			newRect.w = -width;
			this.w += width;
			newRect.x += this.w;
		} else {
			newRect.w = width;
			this.x += width;
			this.w -= width;
		}
		return newRect;
	},

	toString: function() {
		return "Rect: {" + this.array().join(',') + "}";
	},

	/**
	 * Retrieve an array of component values for this <code>Rect</code> with rows and columns redistributed evenly.
	 * @returns {Array (Number)}
	 * @param {Number} rows The rect rows.
	 * @param {Number} columns The rect columns.
	 * @param {String} flat A one-dimensional array (left to right, top to bottom).
	 */
	getGrid: function(rows, columns, flat) {
		// Return an array of this rect divided equally into columns and rows.
		flat = (flat == true);
		var cellW = Math.floor(this.w / columns);
		var cellH = Math.floor(this.h / rows);
		
		var rowSet = new Array();
		for (var i = 0; i < rows; i++) {
			var colSet = new Array();
			for (var j = 0; j < columns; j++) {
				var r = new this.constructor(this.x + j * cellW, this.y + i * cellH, cellW, cellH);
				(flat ? rowSet : colSet).push(r);
			}
			if (!flat) rowSet.push(colSet);
		}
		return rowSet;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/View'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/View'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/View'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Window = require('NGCore/Client/UI/Window').Window;

var ViewParent = require('NGCore/Client/UI/ViewParent').ViewParent;

var View = exports.View = AbstractView.subclass(
/** @lends UI.View.prototype */
{
	'type':'view',

	/**	 
	 * @class The <code>View</code> class is a base class for derived classes that handle application views. Derived classes from <code>View</code> include:
	 * <div class="ul">
	 * <li>{@link UI.ScrollView}</li>
	 * <li>{@link UI.Toast}</li>
	 * </div>
	 * @constructs The default constructor. 
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {String} properties Object properties.
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (View._init) View._init();
		ViewParent.initialize.call(this);
		return $super(properties);
	},
	/**
	* Add a child node to this <code>View</code> at the specified index.
	* @example var mainView = new UI.View();
	* ...
	* var errorView = new UI.View();
	* ...
	* mainView.addChild(errorView);
	* @param {GL2.Node} childNode The child node to add.
	* @param {Number} index The specified index.
	* @throws {this.type + ".addChild: " + childNode + " is not a view!"} Specified node is not attached to a view.
	* @returns This function returns <code>this</code> to support method invocation chaining.
	* @see UI.View#removeChild
    * @status iOS, Android, Test
	*/
	addChild: ViewParent.addChild,
	
	/**
	* Remove a child node from this <code>View</code> at the specified index.
	* @example mainView.removeChild(errorView);
	* @param {GL2.Node} childNode The child node to remove.
	* @throws {this.type + ".removeChild: " + childNode + " is not a view!} Specified node is not attached to a view.
	* @returns The child node that was removed.
	* @see UI.View#addChild
    * @status iOS, Android, Test
	*/    
	removeChild: ViewParent.removeChild,


	/**
	 * Retrieve a count of the child nodes attached to this <code>View</code>.
	 * @return {Number} The current number of child nodes.
	 * @status Javascript, iOS, Android, Flash
	 */
	getChildCount: ViewParent.getChildCount,

	/**
	 * Retrieve the child nodes attached to this <code>View</code>.
	 * @return {Object} All attached children nodes.
	 * @status Javascript, iOS, Android, Flash
	 */
	getChildren: ViewParent.getChildren,

	/**
	 * @function
	 * @description Override this for custom view subclass layout code.
	 */
	layoutSubviews: function() {
		//Override this for custom view subclass layout code
	},	
	/**
	 * @protected
	 * @function
	 * @status Javascript, iOS, Android, Flash
	 */
	_setVisible: function($super, makeVisible) {
		var wasVisible = this._visible;
		$super(makeVisible);
		if (this._visible != wasVisible) {
			var l = this._children.length;
			for (var i = 0; i < l; i++) {
				this._children[i]._setVisible(makeVisible);
			}
		}
	}
});

// Properties
View._init = function() {
	delete View._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * @name UI.View#setImage
	 * @description Set an image URL for a view state. This property defines a remote image resource to use in arbitrary contexts.
	 * @example var someSprite = new UI.View();        
	 * someSprite.setImage('./Content/mySprite.png', [w, h], [0, 0]);
	 * @see UI.View#getImage
	 * @param {String} imageURL The new image URL.
	 * @param {UI.State} [flags=UI.State.Normal] A set of flags describing the view state(s) for using this URL.
 	 * @status iOS, Android, Test
	 * @function 
	 */
	/**
	 * @name UI.View#getImage
	 * @description Retrieve the <code>image</code> URL for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current image URL for the specified view state.
	 * @see UI.View#setImage
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	View.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * @name UI.View#setImageBorder
	 * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
	 * @param {Object} imageBorder The new value for <code>imageBorder</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.View#getImageBorder
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.View#getImageBorder
	 * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current value of <code>imageBorder</code>.
	 * @see UI.View#setImageBorder
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	View.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	/**
	 * @name UI.View#setImageGravity
	 * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
	 * @example var someSprite = new UI.View();
	 * ...
	 * someSprite.setImageGravity([0.5, 0.0]);
	 * @param {Number} imageGravity The new value for <code>imageGravity</code> (expressed as two floats).
	 * @see UI.View#getImageGravity
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.View#getImageGravity
	 * @description Retrieve the value of the <code>imageGravity</code> property.
	 * @returns {Number} The current value of <code>imageGravity</code> (expressed as two floats).
	 * @see UI.View#setImageGravity
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	View.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	/**
	 * @name UI.View#setImageFit
	 * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
	 * (subtracting the value for <code>imageInsets</code>).
	 * @example var someSprite = new UI.View();
	 * ...
	 * someSprite.setImageFit(UI.FitMode.None);
	 * @param {Number} imageFit The new value for <code>imageFit</code>.
	 * @see UI.View#getImageFit
	 * @function
	 */
	/**
	 * @name UI.View#getImageFit
	 * @description Retrieve the value of the <code>imageFit</code> property.
	 * @returns {Number} The current value of <code>imageFit</code>.
	 * @see UI.View#setImageFit
	 * @function
 	 * @status 
	 */
	View.synthesizeProperty('imageFit', Commands.setImageFitMode);
	
	View.synthesizeProperty('visibleInOrientations', Commands.setVisibleInOrientations);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Label'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Label'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Label'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Label = exports.Label = AbstractView.subclass(
/** @lends UI.Label.prototype */
{
	'type':'label',
	/**
	 * @name UI.Label
	 * @class The <code>Label</code> class constructs objects for managing strings that are used as application labels. 
	 * These objects include access to a wide range of attributes for manipulating the look and feel of application labels.
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (Label._init) Label._init();
		$super(properties);
	}
});

Label._init = function() {
	delete Label._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * @name UI.Label#setText
	 * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label in the specified view state.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setText("Friends List");
	 * @param {String} text The new value for <code>text</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Label#getText
	 * @status iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getText
	 * @description Retrieve the value of the <code>text</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value for <code>text</code>.
	 * @see UI.Label#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizePropertyWithState('text', Commands.setText);	
	/**
	 * @name UI.Label#setTextFont
	 * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels in the specified view state.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setTextFont(myFont);
	 * @param {String} textFont The new value for <code>textFont</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Label#getTextFont
	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getTextFont
	 * @description Retrieve the value of the <code>textFont</code> property.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value for <code>textFont</code>.
	 * @see UI.Label#setTextFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizePropertyWithState('textFont', Commands.setTextFont);
	/**
	 * @name UI.Label#setTextColor
	 * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string for a label in the specified view state.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setTextColor('FFFF');
	 * @param {String} textColor The new value for <code>textColor</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Label#getTextColor
	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getTextColor
	 * @description Retrieve the value of the <code>textColor</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textColor</code>.
	 * @see UI.Label#setTextColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * @name UI.Label#setTextShadow
	 * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on labels in the specified view state.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setTextShadow("FF00 2.0 {0,-1}");
	 * @param {String} textShadow The new value for <code>textShadow</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Label#getTextShadow
	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getTextShadow
	 * @description Retrieve the value of the <code>textShadow</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textShadow</code>.
	 * @see UI.Label#setTextShadow
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	
	/**
	 * @name UI.Label#setTextGravity
	 * @description Set the value of the <code>textGravity</code> property for this <code>Label</code>. This property defines how a text string is positioned within a viewable area.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setTextGravity([0.1, 0.5]);
	 * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
	 * @see UI.Label#getTextGravity
	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getTextGravity
	 * @description Retrieve the value of the <code>textGravity</code> property for this <code>Label</code>.
	 * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
	 * @see UI.Label#setTextGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
	/**
	 * @name UI.Label#setTextSize
	 * @description Set the value of the <code>textSize</code> property for this <code>Label</code>. This property defines the size of text strings for a label.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setTextGravity(24);
	 * @param {Number} textSize The new value for <code>textSize</code>.
	 * @see UI.Label#getTextSize
	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getTextSize
	 * @description Retrieve the value of the <code>textSize</code> property for this <code>Label</code>.
	 * @returns {Number} The current value of <code>textSize</code>.
	 * @see UI.Label#setTextSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizeProperty('textSize', Commands.setTextSize);

	/**
	 * @name UI.Label#setTextInsets
	 * @description Set the value of the <code>textInsets</code> property for this <code>Label</code>. This property defines the viewable area of a text string when applying gravity.
	 * @example var label = new UI.Label();
	 * ...
	 * label.setTextInsets(0, 0, 0, 64);
	 * @param {Number, Array (Number)} textInsets The new value for <code>textInsets</code>. Set as individual components or a single array of components.
	 * @see UI.Label#getTextInsets
	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Label#getTextInsets
	 * @description Retrieve the value of the <code>textInsets</code> property for this <code>Label</code>.
	 * @returns {Number, Array (Number)} The current value of <code>textInsets</code>.
	 * @see UI.Label#setTextInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Label.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Image'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Image'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Image'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Image = exports.Image = AbstractView.subclass(
/** @lends UI.Image.prototype */
{
	/**
	 * @name UI.Image
	 * @class The <code>Image</code> class constructs objects that control the location and size of images used in the user interface.
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (Image._init) Image._init();
		$super(properties);
	},
	
	'type':'image'
});


// Properties
Image._init = function() {
	delete Image._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * @name UI.Image#setImage
	 * @description Set an image URL for a view state. This property defines how an image appears for specific conditions. For example,
	 * set one image for the default view state and another image for a view state with focus.
	 * @example var splashGraphic = new UI.Image();
	 * ...
	 * splashGraphic.setImage('./Content/splash.png');
	 * @see UI.Image#getImage
	 * @param {String} imageURL The new image URL.
	 * @param {UI.State} [flags=UI.State.Normal] A set of flags describing the view state(s) for using this URL.
	 * @status iOS, Android, Test
	 * @function 
	 */
	/**
	 * @name UI.Image#getImage
	 * @description Retrieve the <code>image</code> URL for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current image URL for the specified view state..
	 * @see UI.Image#setImage
	 * @status iOS, Android, Test
	 * @function
	 */
	Image.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * @name UI.Image#setImageBorder
	 * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
	 * @param {Object} imageBorder The new value for <code>imageBorder</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Image#getImageBorder
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.Image#getImageBorder
	 * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current value of <code>imageBorder</code>.
	 * @see UI.Image#setImageBorder
	 * @function
	 * @status iOS, Android, Test
	 */
	Image.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	/**
	 * @name UI.Image#setImageGravity
	 * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
	 * @example var splashGraphic = new UI.Image();
	 * ...
	 * splashGraphic.setImageGravity([0.5, 0.0]);
	 * @param {Number} imageGravity The new value for <code>imageGravity</code> expressed as two floats.
	 * @see UI.Image#getImageGravity
	 * @function
	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.Image#getImageGravity
	 * @description Retrieve the value of the <code>imageGravity</code> property.
	 * @returns {Number} The current value of <code>imageGravity</code> expressed as two floats.
	 * @see UI.Image#setImageGravity
	 * @function
	 * @status iOS, Android, Test
	 */
	Image.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	 /**
	 * @name UI.Image#setImageTransform
	 * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for images.
	 * @example var splashGraphic = new UI.Image();
	 * ...
	 * splashGraphic.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
	 * @param {Array (Number)} imageTransform The new value for <code>imageTransform</code>. 
	 * Set as an array of floats (<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>tx</i>, <i>ty</i>).
	 * @see UI.Image#getImageTransform
	 * @function
	 */
	/**
	 * @name UI.Image#getImageTransform
	 * @description Retrieve the value of the <code>imageTransform</code> property.
	 * @returns {Array (Number)} The current value of <code>imageTransform</code>.
	 * @see UI.Image#setImageTransform
	 * @function
	 */
	 Image.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
	/**
	 * @name UI.Image#setImageFit
	 * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
	 * (subtracting the value for <code>imageInsets</code>).
	 * @example var splashGraphic = new UI.Image();
	 * ...
	 * splashGraphic.setImageFit(UI.FitMode.None);
	 * @param {Number} imageFit The new value for <code>imageFit</code>.
	 * @see UI.Image#getImageFit
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.Image#getImageFit
	 * @description Retrieve the value of the <code>imageFit</code> property.
	 * @returns {Number} The current value of <code>imageFit</code>.
	 * @see UI.Image#setImageFit
	 * @function
 	 * @status iOS, Android, Test
	 */
	Image.synthesizeProperty('imageFit', Commands.setImageFitMode);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Button'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Button'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Button'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Button = exports.Button = AbstractView.subclass(
/** @lends UI.Button.prototype */
{
	/**
	 * @name UI.Button
	 * @class The <code>Button</code> class constructs objects that are used as application buttons.
	 * @augments UI.AbstractView
	 */
	'type':'button',

	'Layout':Commands.ButtonLayout,
	
	initialize: function($super, properties) {
		if (Button._init) Button._init();
		$super(properties);
	}
});

// Properties
Button._init = function() {
	delete Button._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * @name UI.Button#setImage
	 * @description Set an image URL for a view state. This defines how buttons appear for specific conditions. For example, 
	 * set different images for a button in the default view state and a button when it is pressed.
	 * @example var backButton = new UI.Button();        
	 * backButton.setImage('./Content/backButton.png', [w, h], [0, 0]);
	 * @see UI.Button#getImage
	 * @param {String} imageURL The new image URL.
	 * @param {UI.State} [flags=UI.State.Normal] A set of flags describing the view state(s) for using this URL.
 	 * @status iOS, Android, Test
	 * @function 
	 */
	/**
	 * @name UI.Button#getImage
	 * @description Retrieve the <code>image</code> URL for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current image URL for the specified view state..
	 * @see UI.Button#setImage
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * @name UI.Button#setImageInsets
	 * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
	 * @example var backButton = new UI.Button();
	 * ...
	 * backButton.setImageInset([10,10,10,10]);
	 * @param {Number, Array (Number)} imageInsets The new value for <code>imageInsets</code>. Set as insets or an array of insets (expressed as floats).
	 * @see UI.Button#getImageInsets
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getImageInsets
	 * @description Retrieve the value of the <code>imageInsets</code> property.
	 * @returns {Number, Array (Number)} The current value of <code>imageInsets</code>.
	 * @see UI.Button#setImageInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
	/**
	 * @name UI.Button#setImageFit
	 * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
	 * (subtracting the value for <code>imageInsets</code>).
	 * @example var backButton = new UI.Button();
	 * ...
	 * backButton.setImageFit(UI.FitMode.None);
	 * @param {Number} imageFit The new value for <code>imageFit</code>.
	 * @see UI.Button#getImageFit
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.Button#getImageFit
	 * @description Retrieve the value of the <code>imageFit</code> property.
	 * @returns {Number} The current value of <code>imageFit</code>.
	 * @see UI.Button#setImageFit
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeProperty('imageFit', Commands.setImageFitMode);
	/**
	 * @name UI.Button#setImageGravity
	 * @description Set the value of the <code>imageGravity</code> property. This property defines how a image for a button is positioned within a viewable area.
	 * @example var backButton = new UI.Button();
	 * ...
	 * backButton.setImageGravity([0.5, 0.0]);
	 * @param {Number} imageGravity The new value for <code>imageGravity</code> (expressed as two floats).
	 * @see UI.Button#getImageGravity
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.Button#getImageGravity
	 * @description Retrieve the value of the <code>imageGravity</code> property.
	 * @returns {Number} The current value of <code>imageGravity</code> (expressed as two floats).
	 * @see UI.Button#setImageGravity
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	Button.synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
	/**
	 * @name UI.Button#setImageTransform
	 * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for an image used as a button.
	 * @example var button = new UI.Button()
	 * ...
	 * button.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
	 * @param {Array (Number)} imageTransform The new value for <code>imageTransform</code>. 
	 * Set as an array of floats (<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>tx</i>, <i>ty</i>).
	 * @see UI.Button#getImageTransform
 	 * @status iOS, Android
	 * @function
	 */
	/**
	 * @name UI.Button#getImageTransform
	 * @description Retrieve the value of the <code>imageTransform</code> property.
	 * @returns {Array (Number)} The current value of <code>imageTransform</code>.
	 * @see UI.Button#setImageTransform
 	 * @status Javascript, iOS, Android, Flash
	 * @function
	 */
	Button.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
	/**
	 * @name UI.Button#setImageBorder
	 * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
	 * @param {Object} imageBorder The new value for <code>imageBorder</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Button#getImageBorder
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getImageBorder
	 * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current value of <code>imageBorder</code>.
	 * @see UI.Button#setImageBorder
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	
	/**
	 * @name UI.Button#setText
	 * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label for a button in different view states.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setText("More information");
	 * @see UI.Button#getText
	 * @param {String} text The new value for <code>text</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getText
	 * @description Retrieve the value of the <code>text</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>text</code> in the specified view state..
	 * @see UI.Button#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizePropertyWithState('text', Commands.setText);
	/**
	 * @name UI.Button#setTextColor
	 * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string used as a label on a 
	 * button in different view states.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setTextColor('FFFFFF');
	 * @see UI.Button#getTextColor
	 * @param {String} textColor The new value for <code>textColor</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @function 
	 */
	/**
	 * @name UI.Button#getTextColor
	 * @description Retrieve the value of the <code>textColor</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textColor</code> in the specified view state..
	 * @see UI.Button#setTextColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * @name UI.Button#setTextFont
	 * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a button in different view states.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setTextFont(myFont);
	 * @param {String} textFont The new value for <code>textFont</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Button#getTextFont
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getTextFont
	 * @description Retrieve the value of the <code>textFont</code> property.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value for <code>textFont</code> in the specified view state.
	 * @see UI.Button#setTextFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizePropertyWithState('textFont', Commands.setTextFont);
	/**
	 * @name UI.Button#setTextShadow
	 * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on text strings for a button in different view states.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setTextShadow("FF00 2.0 {0,-1}");
	 * @see UI.Button#getTextShadow
	 * @param {String} textShadow The new value for <code>textShadow</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getTextShadow
	 * @description Retrieve the value of the <code>textShadow</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textShadow</code> in the specified view state..
	 * @see UI.Button#setTextShadow	
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	/**
	 * @name UI.Button#setTextGravity
	 * @description Set the value of the <code>textGravity</code> property. This property defines how a text string for a button is positioned within a viewable area.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setTextGravity([0.1, 0.5]);
	 * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components.
	 * @see UI.Button#getTextGravity
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getTextGravity
	 * @description Retrieve the value of the <code>textGravity</code> property.
	 * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
	 * @see UI.Button#setTextGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);

	/**
	 * @name UI.Button#setTextSize
	 * @description Set the value of the <code>textSize</code> property. This property defines the text size of labels for a button.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setTextSize(24);
	 * @param {Number} textSize The new value for <code>textSize</code>.
	 * @see UI.Button#getTextSize
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getTextSize
	 * @description Retrieve the value of the <code>textSize</code> property.
	 * @returns {Number} The current value for <code>textSize</code>.
	 * @see UI.Button#setTextSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * @name UI.Button#setTextInsets
	 * @description Set the value of the <code>textInsets</code> property. This property defines the viewable area of a text string when applying gravity.
	 * @example var infoButton = new UI.Button();
	 * ...
	 * infoButton.setTextInsets(0, 0, 0, 64);
	 * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
	 * @see UI.Button#getTextInsets
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.Button#getTextInsets
	 * @description Retrieve the value of the <code>textInsets</code> property.
	 * @returns {Array (Number)} The curent value for <code>textInsets</code>.
	 * @see UI.Button#setTextInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	Button.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/GLView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/GLView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/GLView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var GLView = exports.GLView = AbstractView.subclass(
/** @lends UI.GLView.prototype */
{
	'type':'glview',
	/**
	* @class The <code>GLView</code> class constructs objects that provide applications with access to OpenGL. Games must instantiate a <code>GLView</code> object, 
	* set the active state to <code>true</code> and wait for the callback before instantiating any objects in the {@link GL2} module.
	* @name UI.GLView
	* @augments UI.AbstractView	
	*/
	initialize: function($super, properties) {
		if (GLView._init) GLView._init();
		$super(properties);
	}
});

GLView._init = function() {
	delete GLView._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * @name UI.GLView#setActive
	 * @description Set the value of the <code>active</code> property.
	 * @example var glView = new UI.GLView()
	 * ...
	 * glView.setActive(true);
	 * @param {Boolean} active Set as <code>true</code> if the <code>GLView</code> object is active.
	 * @see UI.GLView#getActive
	 * @status iOS, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.GLView#getActive
	 * @description Retrieve the value of the <code>active</code> property.
	 * @returns {Boolean} Returns <code>true</code> if the <code>GLView</code> object is active.
	 * @see UI.GLView#setActive
	 * @status iOS, Android, Flash, Test
	 * @function
	 */
	GLView.synthesizeProperty('active', Commands.setActive);
	
	/**
	 * @name UI.GLView#getOGLExtensions
	 * @description Return an array containing all of the OpenGL extensions that are supported within the context of this view.
	 * The return value of this method is only valid when the view is active.
	 * @status Android
	 * @function
	 */
	GLView.registerAccessors('OGLExtensions', function() {return this['_OGLExtensions'];}, function() {} );
	
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/NavController'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/NavController'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/NavController'] = exports; var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var KeyEmitter = require('NGCore/Client/Device/KeyEmitter').KeyEmitter;
var Window = require('NGCore/Client/UI/Window').Window;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Device = require('NGCore/Client/Device').Device;
var Element = require('NGCore/Client/UI/Element').Element;
var View = require('NGCore/Client/UI/View').View;

function getAnalyticsName(item){
	if(item && item.hasOwnProperty("analyticsName")){
		return item["analyticsName"] || undefined;	// If NULL, return undefined.
	}
	return undefined;
}

var NavKeyListener = MessageListener.subclass({
	classname: "UI_NavController_KeyListener",
});

var NavController = exports.NavController = View.subclass(
/** @lends UI.NavController.prototype */
{
	/**
	 * @class The <code>NavController</code> class constructs objects that define application navigation components.
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {String} properties Object properties.
	 */
	initialize: function($super, properties) {
		if (NavController._init) NavController._init();
		
	    this.navStack = [];
		var onAndroid = Capabilities.getPlatformOS() == 'Android';
	    this._useBackButton = !onAndroid;
	
		this.keyListener = new NavKeyListener();
		KeyEmitter.addListener(this.keyListener, this.onKeyPressed.bind(this));
		$super(properties);
	},
	
	/**
	 * Turn on the onscreen <b>Back</b> button. Applications designed for iOS should always provide the <b>Back</b> button 
	 * and integrate it into the application UI (calling <code>{@link UI.NavController#back}</code> when pressed).<br><br>
	 * <b>Note:</b> This is turned off by default for applcations designed for Android because Android devices contain a hardware <b>Back</b> button.
	 * @param {Boolean} toUse Set as <code>true</code> to enable the onscreen <b>Back</b> button.
	 * @function
	 * @status Javascript, iOS, Android, Flash
	 */
	setUseBackButton: function(toUse) {
		this._useBackButton = toUse;
		if (toUse) {
			this._createBackButton();
		} else if (this.backButton) {
			this.backButton.removeFromParent();
		}
	},
    
	/**
	 * Reset the stack for this <code>NavController</code>.
	 * @param {String} fromButton The button to reset.
	 * @status Javascript, iOS, Android, Flash
	 */    
	clear: function(fromButton) {
		return this.backToView(undefined);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	logNavEvent: function (from, to, via) {
		var toName = getAnalyticsName(to);
		var fromName = getAnalyticsName(from);
		var viaName = getAnalyticsName(via);
		if (fromName || toName) {
			Core.Analytics._getPipe().navigationEvent(fromName, toName, viaName);
		}
	},
	
	/**
	 * Retrieve the top view from the nav stack of this <code>NavController</code>.
	 * @returns {Object} The top view in the nav stack
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 */
	getTopView: function() {
		return (this.navStack.length > 0) ? this.navStack[ (this.navStack.length - 1) ] : undefined;
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	navStackDepth: function() {
		return this.navStack.length;
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	depthOfView: function(targetView) {
		var targetIndex = this.navStack.indexOf(targetView);
		if(targetIndex == -1){return -1;}
		
		return this.navStack.length - targetIndex - 1;
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	viewAtDepth: function(targetDepth) {
		if(targetDepth >= this.navStack.length){
			return null;
		}
		return this.navStack[this.navStack.length - targetDepth - 1];
	},
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	*/
	removeDeepView:function(targetView) {
		var targetIndex = this.navStack.indexOf(targetView);
		if(targetIndex == -1){
			NgLogE("NavController: trying to remove a nonexistent view from the nav stack!");
			return;
		}
		this.navStack.splice(targetIndex,1);
	},
    
	/**
	 * @protected
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 */
	_viewTransition: function(fromView, toView, back, buttonRef) {
		//The views transition within the container (which is 'this')
		var myFrame = this.getFrame();
		var w = myFrame[2];
		var h = myFrame[3];
		
		//TODO: animate this (below) transition.
		if (toView) {
			toView.setFrame( (back ? -w : w), 0, w, h);
			this.addChild(toView);
		}
		
		UI.animate(function() {
			if (fromView) fromView.setFrame( (back ? w : -w), 0, w, h);
			if (toView) toView.setFrame(0, 0, w, h);
		}, 400, function() {
			if (fromView) fromView.removeFromParent();
		});
		
		this.logNavEvent(fromView, toView, buttonRef);
		this._createBackButton();
	},

	/**
	 * Retrieve removed views in the reverse order they were removed.
	 * @example var page = new NavPage({...});
	 *
	 * var controller = new UI.NavController({...});
	 *
	 * NavPage.navController = controller;
	 * controller.forwardToView(page);
	 * @param {String} destView The destination view for this navigation component.
	 * @param {String} fromButton The button that triggers this navigation component.
	 * @status Javascript, iOS, Android, Flash
	 * @see UI.NavController#backToView
	 */    
	forwardToView: function(destView, fromButton) {
		var currentView = this.getTopView();
		if (destView && 
			(!this._delegate 
				|| (this._delegate 
					&& typeof this._delegate.navControllerShouldPush == "function" 
					&& this._delegate.navControllerShouldPush(this,destView))
			)) {
			
			destView.performEventCallback({eventType:"push",navController:this})
			
			this.navStack.push(destView);
			this._viewTransition(currentView, destView, false, fromButton);
		}
	},
    
	/**
	 * Set back navigation for this <code>NavController</code>.
	 * @param {String} fromButton The button that triggers this navigation component.
	 * @status Javascript, iOS, Android, Flash
	 * @see UI.NavController#forward	
	 */
	back: function(fromButton) {
		var removed = this.navStack.pop();
		
		if (removed && 
			(!this._delegate 
				|| (this._delegate 
					&& typeof this._delegate.navControllerShouldPop == "function" 
					&& this._delegate.navControllerShouldPop(this,removed))
			)) {
			removed.performEventCallback({eventType:"pop",navController:this});
		} else {
			return null;
		}
		this._viewTransition(removed, this.getTopView(), true, fromButton);
		return removed;
	},

	/**
	 * Retrieve removed views in the order they were removed.
	 * @example var page = new NavPage({...});
	 *
	 * var controller = new UI.NavController({...});
	 *
	 * NavPage.navController = controller;
	 * controller.backToView(page);
	 * @param {String} destView The destination view for this navigation component.
	 * @param {String} fromButton The button that triggers this navigation component.
	 * @status Javascript, iOS, Android, Flash
	 * @see UI.NavController#forwardToView
	 */    
	backToView: function(destView, fromButton) {
		var removedSet = [];
		var removed = this.navStack.pop();
		var originalView = removed;
		if (removed) {
			do {
				if (removed && 
					(!this._delegate 
						|| (this._delegate 
							&& typeof this._delegate.navControllerShouldPop == "function" 
							&& this._delegate.navControllerShouldPop(this,removed))
					)) {
					removedSet.push(removed);
					removed.performEventCallback({eventType:"pop",navController:this});
				}
				else {
					//There was nothing to remove, or the this._delegate said "don't remove".
					break;
				}
				
				if (this.getTopView() == destView){break;}
			} while ((removed = this.navStack.pop()));
		}
		if(removedSet.length > 0) {
			this._viewTransition(originalView, this.getTopView(), true, fromButton);
		}
		return removedSet;
	},

	/**
	 * Set this <code>NavController</code> to launch the application when activated.
	 * @status Javascript, iOS, Android, Flash
	 */    
	loadApp: function() {		
	},
    
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */    
	onBackPressed: function() {
		if (this.navStack.length > 1) {
		//	NgLogD("Handle back on nav stack. Number of views on stack=" + this.navStack.length);
			
			var analyticsName = "bcksbtn"; // Back System Button
			
			// if the topmost view has an analytics name, prefix the button
			var topView = this.getTopView();
			if(topView.analyticsName){
				analyticsName = topView.analyticsName + "." + analyticsName;
			}

			this.back({
				analyticsName: analyticsName
			});
			return true;
		}
		return false;
	},
	
	onKeyPressed: function(event) {
		if ((event.code === Device.KeyEmitter.Keycode.back) && (this.navStack.length > 1)) {
			this.back();
			return true;
		}
		return false;
	},
	
	/**
	 * @protected
	 * @status Javascript, iOS, Android, Flash
	 */
	_delegate:null,
	/**
	 * @description Set subscribers to the <code>NavController</code> behavior. Subscribers can modify what happens. 
	 * NavControllerDelegateProtocol:
	 *	@optional - (BOOL)navControllerShouldPop(NavController,View)
	 *	@optional - (BOOL)navControllerShouldPush(NavController,View)
	 * @param {String} navDelegate A <code>NavController</code> subscriber.
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	setDelegate:function( /*NavControllerDelegate*/ navDelegate){
		this._delegate = navDelegate;
	},
	
	delegate:function(){return this._delegate;},
	
	/**
	 * @protected
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 */
	_createBackButton: function() {
		// Do nothing if this device does not require an onscreen button.
		if (!this._useBackButton) return;
		
		if (!this.backButton) {
			this.backButton = new UI.Button({
				normalText: 'Back',
				textSize: 13.0,
				normalTextColor: "FF",
				normalTextShadow: "00 1.5 {0,-1}",
				frame: [-2, 20, Window.outerWidth / 5, Window.outerHeight / 12],
				normalGradient: {
					corners: "0 8 8 0",
					outerLine: "00 1.5",
					innerShadow: "99FF 2.0 {0,-1}",
					gradient: [
						"FFCC 0.0",
						"FF80 1.0"
					]
				},
				highlightedGradient: {
					corners: "0 8 8 0",
					outerLine: "00 1.5",
					innerLine: "FF00 15 {0,-1}",
					gradient: [
						"FF50 0.0",
						"FF80 1.0"
					]
				}
			});
			this.backButton.onclick = this.bind(this.onBackPressed);
		}
		
		if (this.navStack.length > 1) {
			if (!this.backButton.getParent()) Window.document.addChild(this.backButton);
		} else if ( this.backButton.getParent() ) {
			this.backButton.removeFromParent();
		}
	}
});

NavController._init = function() {
	delete NavController._init;
	if (View._init) View._init();
}; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/WebView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/WebView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/WebView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var WebView = exports.WebView = AbstractView.subclass(
/** @lends UI.WebView.prototype */
{
	'type':'webview',

	/**
	 * @class The <code>WebView</code> class constructs objects for loading and navigating documents. 
	 * <code>WebView</code> objects also trigger event callback functions when web page events occur.
	 * @constructs The default constructor. 
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {String} properties Object properties.
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (WebView._init) WebView._init();
		this._canGoBack = false;
		this._canGoForward = false;
		return $super(properties);
	},
	
	/** @private */
	_onShouldLoad: function(event) {
		NgLogD("Should Load " + event.url + " ???????");
		var fn = this.getOnShouldload();
		if (typeof fn == 'function') {
			// If we SHOULDN'T load the url, bail.
			if (!Boolean(fn.call(this, event))) return;
		}
		// The default (if the function was missing or not a function) is to load the url.
		this.loadUrl(event.url);
	},
	
	/** @private */
	performEventCallback: function($super, event) {
		try {
			if (event.eventType == 'shouldload') {
				// We need to call the onShouldLoad function in a way that captures the return value.
				this._onShouldLoad(event);
				return;
			}
			if (event.eventType == 'pageload') {
				// Do not touch this parsing code. Everything else is wrong, extensive testing was done.
				this._canGoBack = event.canGoBack = Boolean(JSON.parse(event.canGoBack));
				this._canGoForward = event.canGoForward = Boolean(JSON.parse(event.canGoForward));
			}
			$super(event);
		} catch(e) {
			NgHandleException(e);
		}
	},
	// invoke doesn't return a value. to get response, use onpageevent
	/**
	* Run a string of Javascript code in this <code>WebView</code>. Any code requiring a result from <code>invoke()</code> must explicitly 
	* return a value by attempting to load an ngcore:// URL. The attempted load is caught by <code>pageEvent</code>. 
	* @see UI.WebView#event:setOnPageevent
	* @function
    * @status iOS, Android
	*/
	invoke: Commands.invoke,
	/**
	* Set a document to load from the specified URL.
	* @example myWebView = new UI.WebView();
	* ...
	* myWebView.loadUrl('http://www.webdoc.com/");
	* @param {String} url The URL from which to load a document.
	* @param {String} [headers] The document headers.
	* @param {Number} [timeout] The timeout duration.
	* @see UI.WebView#loadDocument
    * @status iOS, Android
	*/
	loadUrl: function(url, headers, timeout) {
		Commands.loadURL.call(this, url, headers || null, +(timeout || 0));
	},
	/**
	* Set a document to load from the specified local path.
	* @example myWebView = new UI.WebView();
	* ...
	* myWebView.loadUrl('./path/to/document/");
	* @param {String} relativePath The local path from which to load a document.
	* @see UI.WebView#loadUrl
    * @status iOS, Android
	*/
	loadDocument: function(relativePath){
		Commands.setSourceDocument.call(this, relativePath);
	},
	/**
	* Load a URL using the HTTP <code>POST</code> method.
	* @param {String} url The URL to load using <code>POST</code>.
	* @param {String / Object} data A string containing the raw <code>POST</code> body, or an object to post with <code>www/form-data</code> encoding containing key/value pairs.
	* @see UI.WebView#loadUrl,
	* @see UI.WebView#loadDocument
    * @status iOS, Android
	*/
	postUrl: function(url, data){
		var dataStr;
		if(typeof data == "object"){
			var params = [];
			for(var key in data){
				params.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
			}
			dataStr = params.join('&');
		}else{
			dataStr = data;
		}
		Commands.postURL.call(this, url, dataStr);
	},
	/**
	* Stop loading a document. 
	* @function
    * @status iOS, Android
	*/
	stopLoading: Commands.stopLoading,
	/**
	* Reload a document called with <code>loadDocument()</code> or <code>loadUrl()</code>.
	* @see UI.WebView#loadDocument,
	* @see UI.WebView#loadUrl
	* @function
    * @status iOS, Android
	*/
	reload: Commands.reload,
	/**
	* Navigate to the previous page in a document view.
	* @see UI.WebView#goForward
	* @function
    * @status iOS, Android
	*/
	goBack: Commands.goBack,
	/**
	* Navigate to the next page in a document view.
	* @see UI.WebView#goBack
	* @function
    * @status iOS, Android
	*/
	goForward: Commands.goForward,
	/**
	* Set back navigation as supported in this <code>WebView</code>.
	* @returns {Boolean} Returns <code>true</code> if this <code>WebView</code> supports back navigation.
	* @see UI.WebView#canGoForward
    * @status iOS
	*/
	canGoBack: function(){
		return this._canGoBack;
	},
	/**
	* Set that forward navigation is supported in this <code>WebView</code>.
	* @returns {Boolean} Returns <code>true</code> if this <code>WebView</code> supports forward navigation.
	* @see UI.WebView#canGoBack
    * @status iOS
	*/
	canGoForward: function(){
		return this._canGoForward;
	},
	/**
	* Set the authentication credentials for this <code>WebView</code> session.
	* @param {String} host The authentication host.
	* @param {String} realm The security realm.
	* @param {String} username The username to use for authenticating the session.
	* @param {String} password The password to use for authenticating the session.
    * @status iOS, Android
	*/
	setBasicAuthCredential: function(host, realm, username, password){
		Commands.setBasicAuthCredentials.call(this, {'host':host, 'realm':realm, 'username':username, 'password':password});
	},

	setViewportEnabled: function(enabled) {
		Commands.setViewportEnabled.call(this, enabled);
	}
});

WebView._init = function() {
	delete WebView._init;
	if (AbstractView._init) AbstractView._init();
	
	WebView.synthesizeProperty('scrollable', Commands.setScrollable);
	
	/**
	 * @name UI.WebView#setOnStartload
	 * @description Set a function to call when the <code>startload</code> event occurs.
	 * @param {Function} startloadCallback The function to call.<br><br>
	 * <b>Note:</b> The <code>startload</code> event is disabled if the value of this parameter is not a function.
	 * @see UI.WebView#event:getOnStartload
	 * @event
	 * @status iOS, Android
	 */
	/**
	 * @name UI.WebView#getOnStartload
	 * @description Retrieve the function to call when the <code>startload</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnStartload
	 * @event
	 * @status iOS, Android
	 */
	WebView.registerEventType('startload');
	/**
	 * @name UI.WebView#setOnPageload
	 * @description Set a function to call when the <code>pageload</code> event occurs.
	 * @param {Function} pageloadCallback The function to call.<br><br>
	 * <b>Note:</b> The <code>pageload</code> event is disabled if the value of this parameter is not a function.
	 * @see UI.WebView#event:getOnPageload
	 * @event
	 * @status iOS, Android
	 */
	/**
	 * @name UI.WebView#getOnPageload
	 * @description Retrieve the function to call when the <code>pageload</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnPageload
	 * @event
	 * @status iOS, Android
	 */
	WebView.registerEventType('pageload');
	/**
	 * @name UI.WebView#setOnError
	 * @description Set a function to call when the <code>error</code> event occurs.
	 * @param {Function} [errorCallback] The function to call.<br><br>
	 * <b>Note:</b> The <code>error</code> event is disabled if the value of this parameter is not a function.
	 * @see UI.WebView#event:getOnError
	 * @event
	 * @status iOS, Android
	 */
	/**
	 * @name UI.WebView#getOnError
	 * @description Retrieve the function to call when the <code>error</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnError
	 * @event
	 * @status iOS, Android
	 */
	WebView.registerEventType('error');
	/**
	 * @name UI.WebView#setOnPageevent
	 * @description Set a function to call when the <code>pageevent</code> event occurs.
	 * @param {Function} pageeventCallback The new callback function.<br><br>
	 * <b>Note:</b> The <code>pageevent</code> event is disabled if the value of this parameter is not a function.
	 * @see UI.WebView#event:getOnPageevent
	 * @event
	 * @status iOS, Android
	 */
	/**
	 * @name UI.WebView#getOnPageevent
	 * @description Retrieve the function to call when the <code>pageevent</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.WebView#event:setOnPageevent
	 * @event
	 * @status iOS, Android
	 */
	WebView.registerEventType('pageevent');	
	/** 
	* @name UI.WebView#setOnShouldLoad
	* @description Set a function to call when the <code>shouldload</code> event occurs. The callback for the event returns 
	* <code>true</code> if the page should be loaded. Otherwise, the callback returns <code>false</code>.
	* @param {function} shouldloadCallback The new callback function.<br><br>
	* <b>Note:</b> The <code>shouldload</code> event is disabled if the value of this parameter is not a function.
	* @example  myWebView.setOnShouldload( function(event) {
	NgLogD("URL is " + event.url);
	NgLogD("Nav Type is " + event.navigation);
  } );
	* @see UI.WebView#event:getOnShouldLoad
	* @event
	*/
	/**
	* @name UI.WebView#getOnShouldLoad
	* @description Retrieve the function to call when the <code>shouldload</code> event occurs.
	* @returns {function} The current callback function.
	* @see UI.WebView#event:setOnShouldLoad
	* @event
	*/
	WebView.registerEventType('shouldload');
	
	/** 
	* @name UI.WebView#setOnExternalLink
	* @description Set a function to call when a link will be opened in an external application.
	* @param {function} ExternalLinkCallback The new callback function.<br><br>
	* @see UI.WebView#event:getOnExternalLink
	* @event
	*/
	/**
	* @name UI.WebView#getOnExternalLink
	* @description Retrieve the function to call when the <code>ExternalLink</code> event occurs.
	* @returns {function} The current callback function.
	* @see UI.WebView#event:setOnExternalLink
	* @event
	*/
	WebView.registerEventType('externalLink');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ScrollView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ScrollView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ScrollView'] = exports; var View = require('NGCore/Client/UI/View').View;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var Commands = require('NGCore/Client/UI/Commands').Commands;

var ScrollView = exports.ScrollView = View.subclass(
/** @lends UI.ScrollView.prototype */
{
	'type':'scrollview',
	/**
	* @class The <code>ScrollView</code> class constructs objects that handle views in a scrolling list (see <code>{@link UI.ListView}</code>). 
	* You can define these views as scrolling vertically, horizontially, or both directions.<br><br>
	* <b>Note:</b> Android devices can only scroll in one direction at a time.
	* @name UI.ScrollView
	* @augments UI.View
	*/
	initialize: function($super, properties) {
		if (ScrollView._init) ScrollView._init();
		this._scrollPosition = [0, 0];
		return $super(properties);
	},
	
	/**
	 * @private
	 */    
	updateScrollPosition: function(newVal) {
		this._scrollPosition = newVal;
	},
	
	/**
	 * @private
	 */    
	performEventCallback: function($super, e) {
		if (e.eventType == 'scroll') this.updateScrollPosition(e.scrollPosition);
		$super(e);
	}
});

// Properties
ScrollView._init = function() {
	delete ScrollView._init;
	if (View._init) View._init();

	/**
	 * @name UI.ScrollView#setContentSize
	 * @description Set the value for the <code>contentSize</code> property. This property defines the size of a scroll area.
	 * @example var dialog = {
	 * 	width: screen.width * sizeRate.width / 100,
	 *	height: screen.height * sizeRate.height / 100
	 * };
	 * ...
	 * this.scrollView.setContentSize([dialog.width, 600]);
	 * @params {Number, Array (Number, String)} Individual components or a component array.
	 * @see UI.ScrollView#getContentSize
	 * @function
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.ScrollView#getContentSize
	 * @description Retrieve the value of the <code>contentSize</code> property.
	 * @returns {Number, Array (Number, String)} The current value of <code>contentSize</code>.
	 * @see UI.ScrollView#setContentSize
	 * @function
     * @status iOS, Android, Test
	 */
	ScrollView.synthesizeCompoundProperty('contentSize', Commands.setScrollableSize);
	/**
	 * @name UI.ScrollView#setScrollPosition
	 * @description Set the value for the <code>scrollPosition</code> property.
	 * @example var hscroller = new UI.ScrollView();
	 * ...
	 * hscroller.setScrollPosition([0.5,0]);
	 * @params {Number, Array (Number)} Individual components or a component array.
	 * @see UI.ScrollView#getScrollPosition
	 * @function
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.ScrollView#getScrollPosition
	 * @description Retrieve the value of the <code>scrollPosition</code> property.
	 * @returns {Number, Array (Number)} The current value of <code>scrollPosition</code>.
	 * @see UI.ScrollView#setScrollPosition
	 * @function
     * @status iOS, Android, Test
	 */
	ScrollView.synthesizeCompoundProperty('scrollPosition', Commands.setScrollPosition);
	
	/**
	 * @name UI.ScrollView#setScrollIndicatorsVisible
	 * @description Set the value for the <code>scrollIndicatorsVisible</code> property.
	 * @example var hscroller = new UI.ScrollView();
	 * ...
	 * hscroller.setScrollIndicatorsVisible(false);
	 * @params {Boolean} Whether scroll indicators should be visible.
	 * @see UI.ScrollView#getScrollIndicatorsVisible
	 * @function
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.ScrollView#getScrollIndicatorsVisible
	 * @description Retrieve the value of the <code>scrollIndicatorsVisible</code> property.
	 * @returns {Boolean} Whether scroll indicators will be visible during scrolling.
	 * @see UI.ScrollView#setScrollIndicatorsVisible
	 * @function
     * @status iOS, Android, Test
	 */
	ScrollView.synthesizeCompoundProperty('scrollIndicatorsVisible', Commands.setScrollIndicatorsVisible);
	
	View.synthesizeProperty('visibleInOrientations', Commands.setVisibleInOrientations);

	/**
	 * @name UI.ScrollView#setOnScroll
	 * @description Set a function to call when the <code>scroll</code> event occurs.
	 * @param {Function} scrollCallback The new callback function.<br><br>
	 * <b>Note:</b> The <code>scroll</code> event is disabled if the value of this parameter is not a function.
	 * @see UI.ScrollView#event:getOnScroll
	 * @event
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.ScrollView#getOnScroll
	 * @description Retrieve the function to call when the <code>scroll</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.ScrollView#event:setOnScroll
	 * @event
     * @status iOS, Android, Test
	 */
	ScrollView.registerEventType('scroll');
	
	ScrollView.registerEventType('scrollEnded');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ListView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ListView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ListView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var ScrollView = require('NGCore/Client/UI/ScrollView').ScrollView;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');

var ListView = exports.ListView = ScrollView.subclass(
/** @lends UI.ListView.prototype */
{
	'type':'listview',
	/**
	* @class The <code>ListView</code> class constructs objects that contain <code>{@link UI.ListViewItem}</code> and <code>{@link UI.ListViewSection}</code> objects. 
	* These objects handle and render scrolling lists in an application.
	* A <code>ListView</code> object can contain potentially thousands of items, 
	* in sections, that use a pool of reusable views to display content.
	* @name UI.ListView
	* @augments UI.ScrollView
	*/
	initialize:function($super, properties) {
		if (ListView._init) ListView._init();
		$super(properties);
		
		this._sections = [];
		this._scrollPosition = [0,0];
		this.enableEvent('scroll', true);
		
		this._ownedViews = [];
		this._queuedViews = {};
		
		this._cellDivider = 0;
		
		return this;
	},
	
	destroy: function($super) {
		var l = this._ownedViews.length;
		for (var i = 0; i < l; i++) {
			this._ownedViews[i].release();
		}
		this._ownedViews = null;
		$super();
	},
	
	addChild: function($super, child, index) {
		if (index == "cell") {
			index = this._cellDivider++;
		} else if ((index || -1) >= 0) {
			index += this._cellDivider;
		}
		$super(child, index);
	},
	
	_viewForItem: function(lvItem) {
		if (lvItem._currentView instanceof AbstractView) return lvItem._currentView;
		
		var rID = lvItem._reuseId;
		var queue = this._queuedViews[rID];
		
		var view = null;
		while (queue && queue.length > 0) {
			if ((view = queue.pop()) instanceof AbstractView) break;
		}
		
		if (!(view instanceof AbstractView)) {
			view = lvItem._onCreateView(lvItem);
			if (view instanceof AbstractView) {
				this._ownedViews.push(view.retain());
				this.addChild(view, "cell");
			} else {
				console.log("Error creating view for list item with reuse id " + rID);
			}
		}
	//	console.log("_viewForItem: " + lvItem + " = " + view);
		return view;
	},
	
	_queueViewForItem: function(lvItem) {
		var viewToQueue = lvItem._currentView;
		if (viewToQueue instanceof AbstractView) {
			var rId = lvItem._reuseId;
			var queue = this._queuedViews[rId] || (this._queuedViews[rId] = []);
			queue.push(viewToQueue);
		}
		lvItem._setCurrentView();
	},
	
	_removeQueuedViews: function() {
		for (var q in this._queuedViews) {
			if (!this._queuedViews.hasOwnProperty(q)) continue;
			
			q = this._queuedViews[q];
			for (var i = 0, l = q.length; i < l; i++) {
				q[i].removeFromParent();
			}
		}
		this._cellDivider = 0;
	},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	flushSections: function() {
		for (var i in this._sections) {
			if(!this._sections.hasOwnProperty(i)) { continue; }
				
			var section = this._sections[i];
			// Cause every section to completely queue out its item views.
			section.flush();
			section.calculateItemPositions();
		}
		this._removeQueuedViews();
	},
	
	/**
	 * Clear this <code>ListView</code> and reload all list data.
	 * @see UI.ListViewItem,
	 * @see UI.ListViewSection
 	 * @status Javascript, iOS, Android, Flash
	 */
	reloadData: function() {
		this.flushSections();
		this.calculateSectionPositions();
		this.updateScrollPosition(this._scrollPosition);
	},
	
	/**
	 * Retrieve all contained sections by this <code>ListView</code>.
	 * @returns {Object} The current section list as an array of section IDs.
	 * @see UI.ListView#setSections
 	 * @status Javascript, iOS, Android, Flash
	 */
	getSections: function() {
		return this._sections;
	},
	
	/**
	 * Set the list of sections that this <code>ListView</code> contains.
	 * @example var sections = [];
	 * var section = new UI.ListViewSection;
	 * ...
	 * var items = [];
	 * for(news in News)
	 * {
	 *	var item = new ListItem.ListItem();
	 *	item.game = News[news];
	 *	items.push(item);
	 * }
	 *
	 * section.setItems(items);
	 * sections.push(section);
	 *
	 * gameNews.setSections(sections);
	 * @param {Object} newSections A new aray of section IDs.
	 * @see UI.ListView#getSections
 	 * @status Javascript, iOS, Android, Flash
	 */
	setSections: function(newSections) {
		this.flushSections();
		for (var i in this._sections) {
			if(this._sections.hasOwnProperty(i)) {
				this._sections[i].setListView(null);
			}
		}
		this._sections = newSections;
		var idArray = new Array();
		for (var i in newSections) {
			if(newSections.hasOwnProperty(i)) {
				idArray.push(0+(newSections[i].__objectRegistryId || 0));
			}
		}
		UI.Commands.setSections.call(this, idArray);
		this.reloadData();
	},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	calculateSectionPositions: function() {
		if(!this.getFrame()){
			console.log("UI.ListView Warning: You probably called setSections before you actually set a frame.");
			return;
		}
		this._stackedSections = {};
		topY = 0;
		// Should account for header here.
		var l = this._sections.length;
		for (var i = 0; i < l; i++) {
		//	NgLogD("Calculating height for Section " + i + " / " + l + " from yPos " + topY);
			var section = this._sections[i];
			this._stackedSections[topY] = section;
			section.setListView(this);
			section.setYPosition(topY);
			var relTopY = this._scrollPosition[1/*y*/] - topY;
			section.updateVisibleRange(relTopY, relTopY + this._frame[3/*h*/]);
			var h = section._measureHeight();
			// Set the section's frame...
			section._setFrame(0, topY, this._frame[2], h);
			topY += h;
		}
		// Should account for footer here.
		this.setContentSize([this._frame[2], topY]);
	},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	updateScrollPosition:function(newVal) {
		if (this._scrollPosition[1] === newVal[1]) return;
		this._scrollPosition = newVal;
		
		var myHeight = this._frame[3];
		for (var yPos in this._stackedSections) {
			if(this._stackedSections.hasOwnProperty(yPos)) {
				var section = this._stackedSections[yPos];
				relTopY = newVal[1] - yPos;
				section.updateVisibleRange(relTopY, relTopY + myHeight);
			}
		}
	},
	
	/**
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 */
	'_onScroll': function() {},
	
	/**
	 * @private
 	 * @status Javascript, iOS, Android, Flash
	 */
	enableEvent: function($super, eventName, enable) {
		// Don't allow scrolling events to be turned off!
		if ( (eventName == 'scroll') && !enable ) return;
		$super(eventName, enable);
	}
});

ListView._init = function() {
	delete ListView._init;
	if (ScrollView._init) ScrollView._init();

	/**
	 * @name UI.ListView#setHeader
	 * @description Set the value for the <code>header</code> property. This string is used as a header for the <code>ListView</code>.
	 * @example var friendHeader = mew UI.ListView();
	 * ...
	 * friendHeader.setHeader('Friends List');
	 * @param {String} header The new header.
	 * @see UI.ListView#getHeader
	 * @function
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.ListView#getHeader
	 * @description Retrieve the value of the <code>header</code> property.
	 * @returns {String} The current header.
	 * @see UI.ListView#setHeader
	 * @function
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	ListView.synthesizeProperty('header');
	/**
	 * @name UI.ListView#setFooter
	 * @description Set the value for the <code>footer</code> property. This string is used as a footer for the <code>ListView</code>.
	 * @example var friendFooter = mew UI.ListView();
	 * ...
	 * friendHeader.setHeader('This is a footer');
	 * @param {String} footer The new footer.
	 * @see UI.ListView#getFooter
	 * @function
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.ListView#getFooter
	 * @description Retrieve the value of the <code>footer</code> property.
	 * @returns {String} The current footer.
	 * @see UI.ListView#setFooter
	 * @function
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	ListView.synthesizeProperty('footer');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ListViewSection'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ListViewSection'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ListViewSection'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var ListViewItem = require('NGCore/Client/UI/ListViewItem').ListViewItem;

/* This class does not have a physical view representation.
	We still fully map and register it so that sections can be persisted independently of tables. */

var ListViewSection = exports.ListViewSection = Element.subclass(
/** @lends UI.ListViewSection.prototype */
{
	'type':'listview-section',
	/**
	* @class The <code>ListViewSection</code> class constructs objects that contain <code>ListViewItem</code> objects. 
	* These objects are rendered as individual sections of a scrolling list (see <code>{@link UI.ListView}</code>).
	* @name UI.ListViewSection
	* @augments UI.Element
	*/
	initialize:function($super, properties) {
		if (ListViewSection._init) ListViewSection._init();
		
		this._visibleRange = [0,0];
		this._headerHeight = 0;
		this._titleHeight = 0;
		
		delete this._measuredHeight;
		this._needsLayout = false;
		
		$super(properties);
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	addItemToVisible: function(lvItem, index) {
		if (!(lvItem instanceof ListViewItem)) return;
		if (lvItem._currentView instanceof Element) return;
		
		var useView = this._listView._viewForItem(lvItem);
		var w = this._listView.getFrame()[2];
		
		if (this._rowHeight > 0) {
			useView.setFrame(0, this._yPosition + this._titleHeight + index * this._rowHeight, w, this._rowHeight);
		} else {
			useView.setFrame(0, this._yPosition + this._cellPositions[index], w, lvItem._height);
		}
		
		lvItem._setCurrentView(useView);
		if (!useView.getParent()) this._listView.addChild(useView, "cell");
	},
	
	_setFrame: function(l, t, w, h) {
		UI.Commands.setFrame.call(this, l, t, w, h);
		if (this._titleView) {
			var f = this._titleView.getFrame();
			this._titleView.setFrame(l, t, w, f[3]);
		}
	},
	
	/**
	 * Reset the visible range for this <code>ListViewSection</code>.
	 * @function
	 * @status Javascript, iOS, Android, Flash
	 */
	flush: function() {
		for (var i = this._visibleRange[0], l = this._visibleRange[1]; i < l; i++) {
			this._listView._queueViewForItem(this._items[i]);
		}
		this._visibleRange = [0,0];
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	updateVisibleRange: function(topY, bottomY) {
		var totalH = this._getMeasuredHeight();
		
		// Expand the view window. This is really only necessary for Android...
		var l = this._items.length;
		var rowH = this._rowHeight > 0 ? this._rowHeight : totalH / l;
		topY -= rowH * 5;
		bottomY += rowH * 5;
		
		var oldStartIndex = this._visibleRange[0];
		var oldEndIndex = this._visibleRange[1];
		var startIndex = l > 0 ? Math.max(0, Math.floor(topY / rowH)) : 0;
		var endIndex = l > 0 ? Math.min(l, startIndex + Math.floor((bottomY - topY) / rowH)) : 0;
		
		if (this._cellPositions) {
			// We should have a good guess into the array from the above code,
			// so now it just needs to be adjusted until accurate.
			while (startIndex < l && this._cellPositions[startIndex] < topY) startIndex++;
			while (startIndex > 0 && this._cellPositions[startIndex] > topY) startIndex--;
			if (startIndex >= l) startIndex = Math.max(0, l - 1);
			
			while (endIndex < l && this._cellPositions[endIndex] < bottomY) endIndex++;
			while (endIndex > startIndex && this._cellPositions[endIndex] > bottomY) endIndex--;
		
			topY = this._cellPositions[startIndex];
			// EndIndex is one past the last element...
			bottomY = endIndex == 0 ? topY : (this._cellPositions[endIndex-1] + this._items[endIndex-1]._height );
		}
		if (bottomY < 0 || topY > totalH) {
			for (var i = this._visibleRange[0]; i < this._visibleRange[1]; i++) {
				this._listView._queueViewForItem(this._items[i]);
			}
			this._visibleRange = [0,0];
			return;
		}
		
		if (oldStartIndex == startIndex && oldEndIndex == endIndex) return;
		
//		NgLogD("(" + oldStartIndex + "," + oldEndIndex + ") -> (" + startIndex + "," + endIndex + ")");
		
		if (oldStartIndex == oldEndIndex) {
			for (var i = startIndex; i < endIndex; i++) {
				this.addItemToVisible(this._items[i], i);
			}
		} else {
			// Dequeue and requeue from both ends.
			if (oldStartIndex < startIndex) {
				do {
					this._listView._queueViewForItem(this._items[oldStartIndex]);
				} while (++oldStartIndex < startIndex);
			}
			if (oldEndIndex > endIndex) {
				while (oldEndIndex-- > endIndex) {
					this._listView._queueViewForItem(this._items[oldEndIndex]);
				}
				oldEndIndex = endIndex;	// Keep later codepath from triggering
			}
		
			if (oldStartIndex > startIndex) {
				while (oldStartIndex-- > startIndex) {
					this.addItemToVisible(this._items[oldStartIndex], oldStartIndex);
				}
				oldStartIndex = startIndex;
			} 
			if (oldEndIndex < endIndex) {
				do {
					this.addItemToVisible(this._items[oldEndIndex], oldEndIndex);
				} while (++oldEndIndex < endIndex)
			}
		
		}
		this._visibleRange = [startIndex, endIndex];
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	setListView : function(listView) {
		this._listView = listView;
		delete this._measuredHeight;
		return this;
	},
	
	_getMeasuredHeight : function() {
		return this._measuredHeight || this._measureHeight();
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	_measureHeight : function() {
		// Sum the heights of the rows.  No variable-heights yet!!!
		if (this._rowHeight < 0) {
			// Variable Height Trigger
			var totalHeight = this._titleHeight + this._headerHeight;
			var runningHeights = [];
			var l = this._items.length;
			for (var i = 0; i < l; i++) {
				runningHeights.push(totalHeight);
				totalHeight += this._items[i]._height;
			}
			this._cellPositions = runningHeights;
			return this._measuredHeight = totalHeight;
		}
		
		delete this._cellPositions;
		return this._measuredHeight = this._titleHeight + this._headerHeight + this._rowHeight * this._items.length;
	},
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	calculateItemPositions: function() {
		// Not used?.
	},
});

ListViewSection._init = function() {
	delete ListViewSection._init;
	if (Element._init) Element._init();

	// We don't have a set pattern for sending the id of a view we want to assign by reference...
	/**
	 * @name UI.ListViewSection#setTitleView
	 * @description 
	 * @function
	 * @see UI.ListViewSection#getTitleView
 	 * @status Javascript, iOS, Android, Flash
	 */
	var boundTitleFunction = function() {
		if (this.listViewMonitor) this.listViewMonitor.setTitleView(this);
		boundTitleFunction._superfunc.apply(this, Array.prototype.slice.call(arguments));
	};
	var setTitleView = function(titleView) {
		if (this._titleView && this._titleView.listViewMonitor == this) {
			delete this._titleView.listViewMonitor;
		}
		this._titleView = titleView;
		
		if (!(titleView.listViewMonitor == this)) {
			titleView.listViewMonitor = this;
			if (!boundTitleFunction._superfunc) {
				boundTitleFunction._superfunc = titleView.setFrame;
			}
			if (titleView.setFrame != boundTitleFunction) {
				titleView.registerAccessors('frame', null, boundTitleFunction);
			}
		}
		
		this._titleHeight = titleView.getFrame()[3];
		delete this._measuredHeight;
		Commands.setTitleView.call(this, ObjectRegistry.objectToId(titleView));
		return this;
	}
	/**
	 * @name UI.ListViewSection#getTitleView
	 * @description 
	 * @function
	 * @see UI.ListViewSection#setTitleView
 	 * @status Javascript, iOS, Android, Flash
	 */
	var getTitleView = function() {
		return this._titleView;
	}
	/**
	 * @name UI.ListViewSection#setTitle
	 * @description Set the value for the <code>title</code> property.
	 * @param {String} title The new section title.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.ListViewSection#getTitle
	 * @function
	 */
	/**
	 * @name UI.ListViewSection#getTitle
	 * @description Retrieve the value of the <code>title</code> property.
	 * @returns {String} The current section title.
	 * @see UI.ListViewSection#setTitle
	 * @function
	 */
	ListViewSection.registerAccessors('titleView', getTitleView, setTitleView);
	
	// Other properties
	/**
	 * @name UI.ListViewSection#setRowHeight
	 * @description Set the value for the <code>rowHeight</code> property.
	 * @param {Number} rowHeight The new row height.
	 * @see UI.ListViewSection#getRowHeight
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.ListViewSection#getRowHeight
	 * @description Retrieve the value of the <code>rowHeight</code> property.
	 * @returns {Number} The current row height.
	 * @see UI.ListViewSection#setRowHeight
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	ListViewSection.synthesizeProperty('rowHeight');
	/**
	 * @name UI.ListViewSection#setItems
	 * @description Set the value for the <code>items</code> property.
	 * Setting this updates the visual state of the <code>listView</code> if the section is in a <code>listView</code> that is visible.
	 * @param {UI.ListViewItem} items The new <code>ListView</code> items.
	 * @see UI.ListViewSection#getItems
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	var setItems = function(newItems) {
		newItems = (newItems instanceof Array) ? newItems : Array.prototype.slice.call(arguments);
		
		this.flush();
		this._items = newItems;
		
		if (!this._listView) return;
		this._listView.reloadData();
		delete this._measuredHeight;
	}
	/**
	 * @name UI.ListViewSection#getItems
	 * @description Retrieve the value of the <code>items</code> property.
	 * @returns {UI.ListViewItem} The current <code>ListView</code> items.
	 * @see UI.ListViewSection#setItems
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	var getItems = function() {
		return this._items;
	}
	ListViewSection.registerAccessors('items', getItems, setItems);
	/**
	 * @name UI.ListViewSection#setYPosition
	 * @description Set the value for the <code>yPosition</code> property.
	 * @param {Number} yPosition The new position for <i>y</i>.
	 * @see UI.ListViewSection#getYPosition
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.ListViewSection#getYPosition
	 * @description Retrieve the value of the <code>yPosition</code> property.
	 * @returns {Number} The current position of <i>y</i>.
	 * @see UI.ListViewSection#setYPosition
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	ListViewSection.synthesizeProperty('yPosition');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ListViewItem'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ListViewItem'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ListViewItem'] = exports; /* This class does not have a physical view representation, and is just a holder for closures / a bag for data...
	We still fully map and register it so that sections can be persisted independently of tables. */
var Class = require('NGCore/Client/Core/Class').Class;

var ListViewItem = exports.ListViewItem = Class.subclass(
/** @lends UI.ListViewItem.prototype */
{	/**
	* @class The <code>ListViewItem</code> class constructs objects that contain data for individual items in a scrolling list (see <code>{@link UI.ListView}</code>).
	* @name UI.ListViewItem
	* @constructs The default constructor.
	* @augments Core.Class
	*/
	
	'type':'listview-item',
	
	_reuseId: "__default__",
	/** @protected */
	_currentView: null,
	
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 */
	_onCreateView: function() {},
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 */
	_onReleaseView: function(oldView) {},
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 */
	_onSetView: function(newView) {},
	
	/**
	 * Set the callback for the <code>onCreateView</code> event. 
	 * This event must return a newly created view that displays the data type represented by the item.
	 * @param {Function} newFn The new function to call.
	 * @event
	 */
	setOnCreateView: function(newFn)	{this._onCreateView = newFn},
	/**
	 * Set the callback for the <code>onReleaseView</code> event. This event occurs when the view is set to <code>null</code>. 
	 * Use this to remove uncommon view states or clean up the view when necessary.
	 * @param {Function} newFn The new function to call.
	 * @event
	 */
	setOnReleaseView: function(newFn)	{this._onReleaseView = newFn},
	/**
	 * Set the callback for the <code>onSetView</code> event. When this event occurs, the item puts any relevant visual state / data into <code>newView</code>.
	 * This transfer should occur before the item is visible to the user:
	 * <pre class="code">onSetView(newView)</pre>
	 * @param {Function} newFn The new function to call.
	 * @event
	 */
	setOnSetView: function(newFn)		{this._onSetView = newFn},
	
	/**
	 * Set the height of the current ListViewItem in pixels.
	 * <pre class="code">setHeight(Number)</pre>
	 * This should occur before the item is visible to the user.
	 * This setting is only used when the item's ListViewSection has height = -1
	 * @param {Function} newFn The new function to call.
	 */
	setHeight: function(h) {
		this._height = h;
	},
	
	/**
	 * Get the current height of the ListViewItem.
	 * <pre class="code">getHeight()</pre>
	 * This should occur before the item is visible to the user.
	 * @returns {Number} The height of this ListViewItem.
	 */
	getHeight: function() {
		return this._height;
	},
	
	/**
	 * @function
	 * @protected
 	 * @status Javascript, iOS, Android, Flash
	 */
	_setCurrentView: function(newView) {
		if (newView instanceof Class) {
			this._onSetView(newView);
		} else {
			this._onReleaseView(this._currentView);
		}
		this._currentView = newView;
		return this;
	},
	
	/**
 	 * Retrieve the current view attached to this <code>ListViewItem</code>.
	 * @returns {UI.View} The current <code>ListViewItem</code> view.
	 * @status Javascript, iOS, Android, Flash
	 */
	getCurrentView: function(){
		return this._currentView;
	},
		
	initialize: function(reuseId) {
		if (reuseId) this._reuseId = reuseId;
		return this;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/CellView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/CellView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/CellView'] = exports; var View = require('NGCore/Client/UI/View').View;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var CellView = exports.CellView = View.subclass(
/** @lends UI.CellView.prototype */
{
	'type':'cell',
	/**
	* @class The <code>CellView</code> class constructs objects that handle cell views in an application. For example, a cell in a scrolling list.
	* These objects are rendered with images on the left and right, and two text areas (title and text) stacked vertically in the middle.
	* @name UI.CellView
	* @augments UI.AbstractView
	*/
	initialize: function($super, properties) {
		if (CellView._init) CellView._init();
		$super(properties);
	}
});

// Properties
CellView._init = function() {
	delete CellView._init;
	if (View._init) View._init();
	
	/**
	 * @name UI.CellView#setImage
	 * @description Set the value of the <code>image</code> property for a view state. This defines how a cell view appears for specific conditions. For example,
	 * set different images for a cell view in the default state and when the cell view has focus.
	 * @example background.setImage('./Content/blank.png', [w, h], [0, 0]);
	 * @param {String} image The new <code>image</code> URL.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.CellView#getImage
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.CellView#getImage
	 * @description Retrieve the value of the <code>image</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current <code>image</code> URL.
	 * @see UI.CellView#setImage
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * @name UI.CellView#setImageBorder
	 * @description Set the value of the <code>imageBorder</code> property for a view state. This property defines a border for images used in the specified view state.
	 * @param {Object} imageBorder The new value for <code>imageBorder</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.CellView#getImageBorder
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.CellView#getImageBorder
	 * @description Retrieve the value of the <code>imageBorder</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current value of <code>imageBorder</code>.
	 * @see UI.CellView#setImageBorder
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	CellView.synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
	/**
	 * @name UI.CellView#setImageInsets
	 * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
	 * @example background.setImageInsets([10,10,10,10]);
	 * @param {Number, Array (Number)} imageInsets The new value for <code>imageInsets</code>. Set as insets or an array of insets (float).
	 * @see UI.CellView#getImageInsets
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#getImageInsets
	 * @description Retrieve the value of the <code>imageInsets</code> property.
	 * @returns {Number, Array (Number)} The current value of <code>imageInsets</code>.
	 * @see UI.CellView#setImageInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	CellView.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
	/**
	 * @name UI.CellView#setImageFit
	 * @description Set the value of the <code>imageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
	 * (subtracting the value for <code>imageInsets</code>).
	 * @example background.setImageFit(UI.FitMode.None);
	 * @param {Number} imageFit The new value for <code>imageFit</code>.
	 * @see UI.CellView#getImageFit
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#getImageFit
	 * @description Retrieve the value of the <code>imageFit</code> property.
	 * @returns {Number} The current value of <code>imageFit</code>.
	 * @see UI.CellView#setImageFit
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	CellView.synthesizeProperty('imageFit', Commands.setImageFitMode);
	/**
	 * @name UI.CellView#setImageGravity
	 * @description Set the value of the <code>imageGravity</code> property. This property defines how an image is positioned within a viewable area.
	 * @example background.setImageGravity([0.5, 0.0]);
	 * @param {Number} imageGravity The new value for <code>imageGravity</code> (expressed as two floats).
	 * @see UI.CellView#getImageGravity
	 * @function
 	 * @status iOS, Android, Test
	 */
	/**
	 * @name UI.CellView#getImageGravity
	 * @description Retrieve the value of the <code>imageGravity</code> property.
	 * @returns {Number} The current value of <code>imageGravity</code> (expressed as two floats).
	 * @see UI.CellView#setImageGravity
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	CellView.synthesizeProperty('imageGravity', Commands.setImageGravity);
	 /**
	 * @name UI.CellView#setImageTransform
	 * @description Set the value of the <code>imageTransform</code> property. This property defines data compression for images used with a cell view.
	 * @example background.setImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
	 * @param {Array (Number)} imageTransform The new value for <code>imageTransform</code>. Set as an array of floats (<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>tx</i>, <i>ty</i>).
	 * @see UI.CellView#getImageTransform
 	 * @status iOS, Android, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#getImageTransform
	 * @description Retrieve the value of the <code>imageTransform</code> property.
	 * @returns {Array (Number)} The current value of <code>imageTransform</code>.
	 * @see UI.CellView#setImageTransform
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	 CellView.synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
	/**
	 * @name UI.CellView#getRightImage
	 * @description Retrieve the value of the <code>rightImage</code> property in the specified view state.
	 * @returns {String} The current value of <code>rightImage</code>.
	 * @function
	 * @see UI.CellView#setRightImage
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setRightImage
	 * @description Set the value of the <code>rightImage</code> property in the specified view state. This defines how images used for UI controls appear for specific conditions. For example, 
	 * use seperate images for a closure arrow in the default state and a closure arrow when expanded.
	 * @example var cellClosure = new UI.CellView()
	 * ...
	 * cellClosure.setRightImage('./Content/closure.png', [w, h], [0, 0]);
	 * @param {String} rightImage The new value for <code>rightImage</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI State.
	 * @function
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getRightImage
	 */
	CellView.synthesizePropertyWithState('rightImage', Commands.setRightImage);
	/**
	 * @name UI.CellView#getRightImageBorder
	 * @description Retrieve the value of the <code>rightImageBorder</code> property in the specified view state. 
	 * @returns {Object} The current value of <code>rightImageBorder</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 * @see UI.CellView#setRightImageBorder
	 */
	/**
	 * @name UI.CellView#setRightImageBorder
	 * @description Set the value of the <code>rightImageBorder</code> property in the specified view state. This property defines a border for images used in the specified view state.
	 * @param {Object} rightImageBorder The new value for <code>rightImageBorder</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI View state.
 	 * @status iOS, Android, Test
	 * @function
	 * @see UI.CellView#getRightImageBorder
	 */
	CellView.synthesizePropertyWithState('rightImageBorder', Commands.setRightImageBorder);
	/**
	 * @name UI.CellView#getRightImageInsets
	 * @description Retrieve the value of the <code>rightImageInsets</code> property.
	 * @returns {Array (Number)} The current value of <code>rightImageInsets</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @see UI.CellView#setRightImageInsets
	 */
	/**
	 * @name UI.CellView#setRightImageInsets
	 * @description Set the value of the <code>rightImageInsets</code> property. This property defines the viewable area of an image when applying gravity.
	 * @example closureIcon.setRightImageInsets([10,10,10,10]);
	 * @param {Array (Number)} rightImageInsets The new value for <code>rightImageInsets</code>. Set as floats (<i>t</i>, <i>r</i>, <i>b</i>, <i>l</i>).
	 * @function
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getRightImageInsets
	 */
	CellView.synthesizeProperty('rightImageInsets', Commands.setRightImageInsets);
	/**
	 * @name UI.CellView#getRightImageFit
	 * @description Retrieve the value of the <code>rightImageFit</code> property. 
	 * @returns {Number} The current value of <code>rightImageFit</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @see UI.CellView#setRightImageFit
	 */
	/**
	 * @name UI.CellView#setRightImageFit
	 * @description Set the value of the <code>rightImageFit</code> property. This property defines the scaling of bitmap images to fit within the bounds of a control 
	 * (subtracting the value for <code>imageInsets</code>).
	 * @example closureIcon = new UI.CellView();
	 * ...
	 * closureIcon.setRightImageFit(UI.FitMode.None);
	 * @param {Number} rightImageFit The new value for <code>rightImageFit</code>.
	 * @function
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getRightImageFit
	 */
	CellView.synthesizeProperty('rightImageFit', Commands.setRightImageFitMode);
	/**
	 * @name UI.CellView#getRightImageGravity
	 * @description Retrieve the value of the <code>rightImageGravity</code> property. 
	 * @returns {Number} The current value of <code>rightImageGravity</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @see UI.CellView#setRightImageGravity
	 */
	/**
	 * @name UI.CellView#setRightImageGravity
	 * @description Set the value of the <code>rightImageGravity</code> property. This property defines how a image for a control is positioned within a viewable area.
	 * @example var closureIcon = new UI.CellView();
	 * ...
	 * closureIcon.setRightImageGravity([0.5, 0.0]);
	 * @param {Number} rightImageGravity The new value for <code>rightImageGravity</code>. Set as two floats (<i>x</i>, <i>y</i>).
	 * @function
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getRightImageGravity
	 */
	CellView.synthesizeProperty('rightImageGravity', Commands.setRightImageGravity);
	/**
	 * @name UI.CellView#getRightImageTransform
	 * @description Retrieve the value of the <code>rightImageTransform</code> property.
	 * @returns {Array (Number)} The current value of <code>rightImageTransform</code>.
	 * @see UI.CellView#setRightImageTransform
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	 /**
	 * @name UI.CellView#setRightImageTransform
	 * @description Set the value of the <code>rightImageTransform</code> property. This property defines data compression for images used with right image objects.
	 * @example var closureIcon = new UI.CellView();
	 * ...
	 * closureIcon.setRightImageTransform([Math.cos(angle), Math.sin(angle), Math.sin(angle), Math.cos(angle), 0, 0]);
	 * @param {Array (Number)} rightImageTransform The new value for <code>rightImageTransform</code>. 
	 * Set as six floats (<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>tx</i>, <i>ty</i>).
	 * @see UI.CellView#getRightImageTransform
 	 * @status iOS, Android, Test
	 * @function
	 */
	 CellView.synthesizeCompoundProperty('rightImageTransform', Commands.setRightImageTransform);
	 
	/**
	 * @name UI.CellView#getTitle
	 * @description Retrieve the value of the <code>title</code> property in a view state.
	 * @returns {String} The current value of <code>title</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 * @see UI.CellView#setTitle
	 */
	/**
	 * @name UI.CellView#setTitle
	 * @description Set the value of the <code>title</code> property for a view state. This property defines the title string for a view in the specified view state.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitle('Game of Foo');
	 * @param {String} title The new value for <code>title</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getTitle
	 * @function
	 */
	CellView.synthesizePropertyWithState('title', Commands.setTitle);
	/**
	 * @name UI.CellView#getTitleColor
	 * @description Retrieve the value of the <code>titleColor</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>titleColor</code>.
	 * @see UI.CellView#setTitleColor
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#setTitleColor
	 * @description Set the value of the <code>titleColor</code> property for a view state. This property defines the title string color for the <code>CellView</code> object in the specified view state.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitleColor(0,0,1);
	 * @param {String} titleColor The new value for <code>titleColor</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.CellView#getTitleColor
	 * @function 
 	 * @status iOS, Android, Test
	 */
	CellView.synthesizePropertyWithState('titleColor', Commands.setTitleColor);
	/**
	 * @name UI.CellView#getTitleFont	 
	 * @description Retrieve the value of the <code>titleFont</code> property in a view state. 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>titleFont</code>.
	 * @function
	 * @see UI.CellView#setTitleFont
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTitleFont
	 * @description Set the value of the <code>titleFont</code> property in a view state. This property defines the title string font for cell view labels in the specified view state.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitleFont('Content/Cacophony.ttf');
	 * @param {String} titleFont The new value for <code>titleFont</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @function
	 * @see UI.CellView#getTitleFont
 	 * @status iOS, Android, Test
	 */
	CellView.synthesizePropertyWithState('titleFont', Commands.setTitleFont);
	/**
	 * @name UI.CellView#getTitleShadow
	 * @description Retrieve the value of the <code>titleShadow</code> property in a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>titleShadow</code>.
	 * @see UI.CellView#setTitleShadow
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTitleShadow
	 * @description Set the value of the <code>titleShadow</code> property in a view state. This property defines the amount of text shadowing used for title strings in a cell view.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitleShadow('FFCCCCFF 2.0 {0,0}');
	 * @param {String} titleShadow The new value for <code>titleShadow</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getTitleShadow
	 * @function
	 */
	CellView.synthesizePropertyWithState('titleShadow', Commands.setTitleShadow);

	/**
	 * @name UI.CellView#getTitleGravity
	 * @description Retrieve the value of the <code>titleGravity</code> property. 
	 * @returns {Array (Number)} The current value of <code>titleGravity</code>.
	 * @see UI.CellView#setTitleGravity
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTitleGravity
	 * @description Set the value of the <code>titleGravity</code> property. This property defines how a title string is positioned within a viewable area.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitleGravity([0.5, 0.0]);	 
	 * @param {Array (Number)} titleGravity The new value for <code>titleGravity</code>. Set as two floats (<i>x</i>, <i>y</i>).
	 * @see UI.CellView#getTitleGravity
 	 * @status iOS, Android, Test
	 * @function
	 */
	CellView.synthesizeCompoundProperty('titleGravity', Commands.setTitleGravity);

	/**
	 * @name UI.CellView#getTitleSize
	 * @description Retrieve the value of the <code>titleSize</code> property.
	 * @returns {Number} The current value of <code>titleSize</code>.
	 * @see UI.CellView#setTitleSize
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTitleSize
	 * @description Set the value of the <code>titleSize</code> property. This property defines the text size of title strings in the specified view state.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitleSize(32);
	 * @param {Number} titleSize The new value for <code>titleSize</code>. Set as two floats (<i>x</i>, <i>y</i>).	
	 * @function
	 * @see UI.CellView#getTitleSize
 	 * @status iOS, Android, Test
	 */
	CellView.synthesizeProperty('titleSize', Commands.setTitleSize);
	/**
	 * @name UI.CellView#getTitleInsets
	 * @description Retrieve the value of the <code>titleInsets</code> property.	 
	 * @returns {Array (Number)} The current value of <code>titleInsets</code>.
	 * @function
	 * @see UI.CellView#setTitleInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTitleInsets
	 * @description Set the value of the <code>titleInsets</code> property. This property defines the viewable area of a title string when applying gravity.
	 * @example var cellTitle = new UI.CellView()
	 * ...
	 * cellTitle.setTitleInsets([10,10,10,10]);	 
	 * @param {Array (Number)} titleInsets The new value for <code>titleInsets</code>. Set as four floats (<i>t</i>, <i>r</i>, <i>b</i>, <i>l</i>).
	 * @function
	 * @see UI.CellView#getTitleInsets
 	 * @status iOS, Android, Test
	 */
	CellView.synthesizeCompoundProperty('titleInsets', Commands.setTitleInsets);
	
	/**
	 * @name UI.CellView#getText
	 * @description Retrieve the value of the <code>text</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>text</code>..
	 * @see UI.CellView#setText
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#setText
	 * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use in the specified view state.
	 * @example var cellView = new UI.CellView();
	 * ...
	 * cellView.setText(this.game.description);
	 * @see UI.CellView#getText
	 * @param {String} text The new value for <code>text</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @function
	 */
	CellView.synthesizePropertyWithState('text', Commands.setText);
	/**
	 * @name UI.CellView#getTextColor
	 * @description Retrieve the value of the <code>textColor</code> property for a view state. 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textColor</code>.
	 * @see UI.CellView#setTextColor
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTextColor
	 * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string in the specified view state.
	 * @example var cellText = new UI.CellView();
	 * ...
	 * cellText.setTextColor('FFFF');
	 * @see UI.CellView#getTextColor
	 * @param {String} textColor The new value for <code>textColor</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @function 
	 */
	CellView.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * @name UI.CellView#getTextShadow
	 * @description Retrieve the value of the <code>textShadow</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textShadow</code>.
	 * @see UI.CellView#setTextShadow	
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTextShadow
	 * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on text strings in this view.
	 * @example var cellText = new UI.CellView();
	 * ...
	 * cellText.setTextShadow('FFCCCCFF 2.0 {0,0}');
	 * @see UI.CellView#getTextShadow
	 * @param {String} textShadow The new value for <code>textShadow</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android, Test
	 * @function
	 */
	CellView.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	/**
	 * @name UI.CellView#getTextFont
	 * @description Retrieve the value of the <code>textFont</code> property. 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value for <code>textFont</code> in the specified view state.
	 * @see UI.CellView#setTextFont
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	/**
	 * @name UI.CellView#setTextFont
	 * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a cell view.
	 * @example var cellText = new UI.CellView()
	 * ...
	 * cellText.setTextFont('Content/Cacophony.ttf');
	 * @param {String} textFont The new value for <code>textFont</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.CellView#getTextFont
 	 * @status iOS, Android, Test
	 * @function
	 */
	CellView.synthesizePropertyWithState('textFont', Commands.setTextFont);
	
	/**
	 * @name UI.CellView#getTextGravity
	 * @description Retrieve the value of the <code>textGravity</code> property.
	 * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @see UI.CellView#setTextGravity
	 */
	/**
	 * @name UI.CellView#setTextGravity	 
	 * @description Set the value of the <code>textGravity</code> property. This property defines how a text string is positioned within a viewable area.
	 * @example var cellText = new UI.CellView()
	 * ...
	 * cellText.setTextGravity([0.5, 0.0]);
	 * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a component array (<i>x</i>, <i>y</i>).
	 * @function
 	 * @status iOS, Android, Test
	 * @see UI.CellView#getTextGravity
	 */
	CellView.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);

	/**
	 * @name UI.CellView#getTextSize
	 * @description Retrieve the value of the <code>textSize</code> property.
	 * @returns {Number} The current value for <code>textSize</code>.
	 * @see UI.CellView#setTextSize
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#setTextSize
	 * @description Set the value of the <code>textSize</code> property. This property defines the size of text strings for a view.
	 * @example var cellText = new UI.CellView()
	 * ...
	 * cellText.setTextSize(18);
	 * @param {Number} textSize The new value for <code>textSize</code>.
	 * @see UI.CellView#getTextSize
 	 * @status iOS, Android, Test
	 * @function
	 */
	CellView.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * @name UI.CellView#getTextInsets
	 * @description Retrieve the value of the <code>textInsets</code> property.
	 * @returns {Array (Number)} The curent value for <code>textInsets</code>.
	 * @see UI.CellView#setTextInsets
 	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CellView#setTextInsets
	 * @description Set the value of the <code>textInsets</code> property. This property defines the viewable area of a text string when applying gravity.
	 * @example var cellText = new UI.CellView()
	 * ...
	 * cellText.setTextInsets([10,10,10,10]);
	 * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
	 * @see UI.CellView#getTextInsets
 	 * @status iOS, Android, Test
	 * @function
	 */
	CellView.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/CheckBox'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/CheckBox'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/CheckBox'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var WindowR = require('NGCore/Client/UI/Window');

var gradients = {
	'normal': {
		"gradient": ["FFED 0.000", "FFA4 1.000"],
		"insets": "{4.0,4.0,4.0,4.0}",
		"outerLine": "FF51 2.0",
		"outerShadow": "0000 0.0 {0.0,0.0}",
		"corners": "3.0 3.0 3.0 3.0"
	},
	'pressed': {
		"innerShadow": "FF00 6.0 {0.0,-1.0}",
		"gradient": ["FF80 0.000", "FF80 1.000"],
		"insets": "{4.0,4.0,4.0,4.0}",
		"outerLine": "FF51 2.0",
		"outerShadow": "0000 0.0 {0.0,0.0}",
		"corners": "3.0 3.0 3.0 3.0"
	},
	'checked': {"innerLine":"FF27A227 2.0","corners":"3.0 3.0 3.0 3.0","insets":"{4.0,4.0,4.0,4.0}","gradient":["FF2CFF2B 0.000","FF179117 1.000"],"outerShadow":"0000 0.0 {0.0,0.0}","outerLine":"FF51 3.0","innerShadow":"FF97FE97 1.0 {0.0,0.0}"},
	'checkedpressed': {"innerShadow":"FF0F610F 5.0 {0.0,-1.0}","gradient":["FF179117 0.000","FF179117 1.000"],"insets":"{4.0,4.0,4.0,4.0}","outerLine":"FF2B512B 3.0","outerShadow":"0000 0.0 {0.0,0.0}","corners":"3.0 3.0 3.0 3.0"},
	'disabled': {
		"innerShadow": "0000 0.0 {0.0,0.0}",
		"gradient": ["66B6 0.000", "66CA 1.000"],
		"insets": "{4.0,4.0,4.0,4.0}",
		"outerLine": "7FE0 3.0",
		"outerShadow": "0000 0.0 {0.0,0.0}",
		"corners": "3.0 3.0 3.0 3.0"
	},
};

var CheckBox = exports.CheckBox = AbstractView.subclass(
/** @lends UI.CheckBox.prototype */
{
	'type':'checkbox',

    /**
     * @class The <code>CheckBox</code> class constructs objects that handle the state of application checkboxes.
     * @constructs The default constructor. 
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     * @augments UI.AbstractView
     */
    initialize: function($super, properties) {
		if (CheckBox._init) CheckBox._init();
        this._checked = false;
        $super();
		this.setGradient(gradients['normal'], Commands.State.Normal);
		this.setGradient(gradients['pressed'], Commands.State.Pressed);
		this.setGradient(gradients['checked'], Commands.State.Checked);
		this.setGradient(gradients['checkedpressed'], Commands.State.Checked | Commands.State.Pressed);
		this.setGradient(gradients['disabled'], Commands.State.Disabled);
		this.setImageInsets([4,4,4,4]);
		this.setAttributes(properties);
    },
	
	/**
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
    performEventCallback: function($super, event) {
		if (event.eventType == 'click') {
        	this._checked = event.checked;
			if (this._checked) {
				this._state = this._state | Commands.State.Checked;
			} else {
				this._state = this._state & ~Commands.State.Checked;
			}
		}
		$super(event);
    }
});

CheckBox._init = function() {
	delete CheckBox._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * @name UI.CheckBox#getImage
	 * @description Retrieve the <code>image</code> URL for a view state. 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current image URL for the specified view state.
	 * @see UI.CheckBox#setImage
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setImage
	 * @description Set an image URL for a view state. This defines how a checkbox appears for specific conditions. For example,
	 * set different images for a checkbox in the default state and when the checkbox is checked.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setImage('./Content/checkbox.png', [w, h], [0, 0]);
	 * @see UI.CheckBox#getImage
	 * @param {String} imageURL The new image URL.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @status iOS, Android, Test
	 * @function 
	 */
	CheckBox.synthesizePropertyWithState('image', Commands.setImage);
	/**
	 * @name UI.CheckBox#getImageInsets
	 * @description Retrieve the value of the <code>imageInsets</code> property (expressed as floats).
	 * @returns {Number, Array (Number)} The current value of <code>imageInsets</code>.
	 * @see UI.CheckBox#setImageInsets
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setImageInsets
	 * @description Set the value of the <code>imageInsets</code> property. This property defines the viewable area of an image when applying gravity.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setImageInset([10,10,10,10]);
	 * @param {Number, Array (Number)} imageInsets The new value for <code>imageInsets</code>. Set as insets or an array of insets (expressed as floats).
	 * @see UI.CheckBox#getImageInsets
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
	
	/**
	 * @name UI.CheckBox#getText
	 * @description Retrieve the value of the <code>text</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>text</code> in the specified view state.
	 * @see UI.CheckBox#setText
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setText
	 * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use as a label for a 
	 * checkbox in the specified view state.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setText("Yes");
	 * @see UI.CheckBox#getText
	 * @param {String} text The new value for <code>text</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizePropertyWithState('text', Commands.setText);
	/**
	 * @name UI.CheckBox#getTextColor
	 * @description Retrieve the value of the <code>textColor</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textColor</code> in the specified view state.
	 * @see UI.CheckBox#setTextColor
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setTextColor
	 * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string used as a label for a 
	 * checkbox in different view states.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setTextColor('FFFFFF');
	 * @see UI.CheckBox#getTextColor
	 * @param {String} textColor The new value for <code>textColor</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @status iOS, Android, Test
	 * @function 
	 */
	CheckBox.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * @name UI.CheckBox#getTextShadow
	 * @description Retrieve the value of the <code>textShadow</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textShadow</code> in the specified view state.
	 * @see UI.CheckBox#setTextShadow	
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setTextShadow
	 * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of shadowing used on text strings for a checkbox in different view states.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setTextShadow("FF00 2.0 {0,-1}");
	 * @see UI.CheckBox#getTextShadow
	 * @param {String} textShadow The new value for <code>textShadow</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	/**
	 * @name UI.CheckBox#getTextGravity
	 * @description Retrieve the value of the <code>textGravity</code> property (expressed as floats).
	 * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
	 * @see UI.CheckBox#setTextGravity
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setTextGravity
	 * @description Set the value of the <code>textGravity</code> property. This property defines how a text string is positioned within a viewable area.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setTextGravity([0.1, 0.5]);
	 * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as individual components or a single array of components (expressed as floats).
	 * @see UI.CheckBox#getTextGravity
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);

	/**
	 * @name UI.CheckBox#getTextSize
	 * @description Retrieve the value of the <code>textSize</code> property.
	 * @returns {Number} The current value for <code>textSize</code>.
	 * @see UI.CheckBox#setTextSize
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setTextSize
	 * @description Set the value of the <code>textSize</code> property. This property defines the text size of labels for a checkbox.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setTextSize(18);
	 * @param {Number} textSize The new value for <code>textSize</code>.
	 * @see UI.CheckBox#getTextSize
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * @name UI.CheckBox#getTextFont
	 * @description Retrieve the value of the <code>textFont</code> property.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value for <code>textFont</code> in the specified view state.
	 * @see UI.CheckBox#setTextFont
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setTextFont
	 * @description Set the value of the <code>textFont</code> property. This property defines the font face used with labels for a checkbox in different view states.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setTextFont(myFont);
	 * @param {String} textFont The new value for <code>textFont</code> in the specified view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.CheckBox#getTextFont
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizePropertyWithState('textFont', Commands.setTextFont);
	/**
	 * @name UI.CheckBox#getTextInsets
	 * @description Retrieve the value of the <code>textInsets</code> property.
	 * @returns {Array (Number)} The curent value for <code>textInsets</code>.
	 * @see UI.CheckBox#setTextInsets
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setTextInsets
	 * @description Set the value of the <code>textInsets</code> property. This property defines the viewable area of a text string when applying gravity.
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setTextInsets(0, 0, 0, 64);
	 * @param {Array (Number)} textInsets The new value for <code>textInsets</code>.
	 * @see UI.CheckBox#getTextInsets
	 * @status iOS, Android, Test
	 * @function
	 */
	CheckBox.synthesizeCompoundProperty('textInsets', Commands.setTextInsets);
	
	// Corresponding event is onClick
	/**
	 * @name UI.CheckBox#getChecked
	 * @description Retrieve whether this <code>CheckBox</code> is currently "checked".
	 * @returns {Boolean} Returns <code>true</code> if this <code>CheckBox</code> is currently "checked".
	 * @see UI.CheckBox#setChecked
	 * @status Javascript, iOS, Android, Flash
	 * @function
	 */
	/**
	 * @name UI.CheckBox#setChecked
	 * @description Set whether this <code>CheckBox</code> is "checked".
	 * @example var gameCheck = new UI.CheckBox();
	 * ...
	 * gameCheck.setChecked(true);
	 * @param {Boolean} checked Set as <code>true</code> if this <code>CheckBox</code> is "checked".
	 * @see UI.CheckBox#getChecked
	 * @status iOS, Android
	 * @function 
	 */
	CheckBox.synthesizeProperty('checked', Commands.setChecked);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/EditText'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/EditText'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/EditText'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var EditText = exports.EditText = AbstractView.subclass(
/** @lends UI.EditText.prototype */
{
	'type':'edittext',
	/**
	* @class The <code>EditText</code> class is a base class for derived classes that handle text-editing functions.
	* Derived classes from <code>EditText</code> include:
	* <div class="ul">
	 * <li>{@link UI.DateField}</li>
	 * </div>
	* @name UI.EditText
	* @augments UI.AbstractView
	*/
	initialize: function($super, properties) {
		if (EditText._init) EditText._init();
		$super(properties);
	},
	
	
	'InputTypes': Commands.InputType,
	'EnterKeyTypes': Commands.EnterKeyType,
	
	
	performEventCallback: function($super, event) {
		try {
			switch (event.eventType) {
				case 'change':
					this._text = event.text;
					// Fallthrough
				default: $super(event);
			}
		} catch(e) {
			NgHandleException(e);
		}
	},
	
	// Adapt API to the single-state model for "text" on editable text.
	/**
	 * Retrieve the value of the <code>text</code> property.
	 * @returns {String} The current value of <code>text</code>.
	 * @see UI.EditText#setText
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */	
	getText: function() {
		return this._text || "";
	},
	
	/**
	 * Set the value of the <code>text</code> property. This property defines a text string to use in arbitrary fashion.
	 * @example var someText = new UI.EditText();
	 * ...
	 * someText.setText("Pow!");
	 * @param {String} text The new value for <code>text</code>.
	 * @see UI.EditText#getText
	 * @status Javascript, iOS, Android, Test
	 * @function
	 */
	setText: function(text) {
		this._text = text;
		Commands.setText.call(this, 0, text);
	},

	focus: function() {
		Commands.setFocus.call(this, true);
	},
	
	blur: function() {
		Commands.setFocus.call(this, false);
	},
	
	setFocus: function(focus) {
		try {
			throw new Error("EditText.setFocus is deprecated and should not be used. Please use .focus() and .blur().");
		} catch (e) {
			NgHandleException(e);
		}
		Commands.setFocus.call(this, focus);
	}
});

EditText._init = function() {
	delete EditText._init;
	if (AbstractView._init) AbstractView._init();
	
	// ==== Content
	// API defines state for the text property, but we ONLY support one state for this control.
	
	EditText.registerAccessors('text', EditText.prototype.getText, EditText.prototype.setText);
	
	/**
	 * @name UI.EditText#getPlaceholder
	 * @description Retrieve the value of the <code>placeholderText</code> property.
	 * @returns {String} The current value of <code>placeholder</code>.
	 * @see UI.EditText#setPlaceholder
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setPlaceholder
	 * @description Set the value of the <code>placeholderText</code> property. This property defines a text string to use as a placeholder for fields that require text input.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setPlaceholder("This is a placeholder");
	 * @param {String} placeholder The new value for <code>placeholder</code>.
	 * @see UI.EditText#getPlaceholder
	 * @function
	 */
	EditText.synthesizeProperty('placeholder', Commands.setPlaceholderText);
	/**
	 * @name UI.EditText#getPlaceholderColor
	 * @description Retrieve the value of the <code>placeholderTestColor</code> property. 
	 * @see UI.EditText#setPlaceholderColor
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */	
	/**
	 * @name UI.EditText#setPlaceholderColor
	 * @description Set the value of the <code>placeholderTestColor</code> property. This property defines the color of the placeholder text string.
	 * @returns {String} The current value of <code>placeholderTextColor</code>.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setPlaceholderColor('FFFFFF');
	 * @param {String} placeholderColor The new value for <code>placeholderTestColor</code>.
	 * @see UI.EditText#getPlaceholderColor
	 * @function
	 */
	EditText.synthesizeProperty('placeholderColor', Commands.setPlaceholderTextColor);
	/**
	 * @name UI.EditText#getPlaceholderShadow
	 * @description Retrieve the value of the <code>placeholderTestShadow</code> property.
	 * @returns {String} The current value of <code>placeholderTestShadow</code>.
	 * @see UI.EditText#setPlaceholderShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setPlaceholderShadow
	 * @description Set the value of the <code>placeholderTestShadow</code> property.  This property defines the amount of shawdow applied to the placeholder text string.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setPlaceholderShadow("FF00 2.0 {0,-1}");
	 * @param {String} placeholderShadow The new value for <code>placeholderTestShadow</code>.
	 * @see UI.EditText#getPlaceholderShadow
	 * @function
	 */
	 EditText.synthesizeProperty('placeholderShadow', Commands.setPlaceholderTextShadow);
	
	// ==== Behavior
	/**
	 * @name UI.EditText#getInputType
	 * @description Retrieve the value of the <code>inputType</code> property.
	 * @returns {Number} The current value of <code>inputType</code>.
	 * @see UI.EditText#setInputType
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setInputType
	 * @description Set the value of the <code>inputType</code> property.
	 * @param {Number} inputType The new value for <code>inputType</code>.
	 * @see UI.EditText#getInputType
	 * @function
	 */	
	 EditText.synthesizeProperty('inputType', Commands.setInputType);
	/**
	 * @name UI.EditText#getEnterKeyType
	 * @description Retrieve the value of the <code>enterKeyType</code> property.
	 * @returns {Number} The current value of <code>enterKeyType</code>.
	 * @see UI.EditText#setEnterKeyType
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setEnterKeyType
	 * @description Set the value of the <code>enterKeyType</code> property.
	 * @param {Number} enterKeyType The new value for <code>enterKeyType</code>.
	 * @see UI.EditText#getEnterKeyType
	 * @function
	 */
	EditText.synthesizeProperty('enterKeyType', Commands.setEnterKeyType);
	
	// ==== Appearance
	/**
	 * @name UI.EditText#getTextColor
	 * @description Retrieve the value of the <code>textColor</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} textColor The current value of <code>textColor</code>.
	 * @see UI.EditText#setTextColor
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setTextColor
	 * @description Set the value of the <code>textColor</code> property for a view state. This property defines the color of a text string in the specified view state.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setTextColor('FFFFFF');
	 * @param {String} textColor The new value for <code>textColor</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.EditText#getTextColor
	 * @status iOS, Test
	 * @function
	 */
	EditText.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * @name UI.EditText#getTextShadow
	 * @description Retrieve the value of the <code>textShadow</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textShadow</code>.
	 * @see UI.EditText#setTextShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setTextShadow
	 * @description Set the value of the <code>textShadow</code> property for a view state. This property defines the amount of text shadowing used on text strings in this view.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setTextShadow("FF00 2.0 {0,-1}");
	 * @param {String} textShadow The new value for <code>textShadow</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.EditText#getTextShadow
	 * @status iOS, Test
	 * @function
	 */
	EditText.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	
	/**
	 * @name UI.EditText#getTextGravity
	 * @description Retrieve the value of the <code>textGravity</code> property for this <code>EditText</code>.
	 * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.
	 * @see UI.EditText#setTextGravity
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setTextGravity
	 * @description Set the value of the <code>textGravity</code> property for this <code>EditText</code>. This property defines how a text string is positioned within a viewable area.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setTextGravity([0.1, 0.5]);
	 * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as a float or an array.
	 * @see UI.EditText#getTextGravity
	 * @function
	 */
	EditText.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
	/**
	 * @name UI.EditText#getTextSize
	 * @description Retrieve the value of the <code>teztSize</code> property for this <code>EditText</code>.
	 * @returns {Number} The current value of <code>textSize</code>.
	 * @see UI.EditText#setTextSize
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setTextSize
	 * @description Set the value of the <code>textSize</code> property for this <code>EditText</code>. This property defines the size of text strings for a view.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setTextSize(18);
	 * @param {Number} textSize The new value for <code>textSize</code>.
	 * @see UI.EditText#getTextSize
	 * @status iOS, Test
	 * @function
	 */
	EditText.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * @name UI.EditText#getTextFont
	 * @description Retrieve the value of the <code>textFont</code> property for this <code>EditText</code>.
	 * @returns {String} The current value of <code>textFont</code>.
	 * @see UI.EditText#setTextFont
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditText#setTextFont
	 * @description Set the value of the <code>textFont</code> property. This property defines the font face used with text strings in a view.
	 * @example var placeHolder = new UI.EditText();
	 * ...
	 * placeHolder.setTextFont(myFont);
	 * @param {String} textFont The new value for <code>textFont</code>.
	 * @see UI.EditText#getTextFont
	 * @status iOS, Test
	 * @function
	 */
	EditText.synthesizePropertyWithState('textFont', Commands.setTextFont);
	
	// ==== Events
	/**
	 * @name UI.EditText#getOnChange
	 * @description Retrieve the function to call when the <code>change</code> event occurs.
	 * @returns {Function} The current <code>change</code> callback function.
	 * @see UI.EditText#event:setOnChange
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event
	 */
	/**
	 * @name UI.EditText#setOnChange
	 * @description Set a function to call when the <code>change</code> event occurs.
	 * @param {Function} changeCallback The new <code>change</code> callback function. <br><br><b>Note:</b> The <code>change</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example EditText.setOnChange( function(event) { 
	 * 	console.log(event.text) 
	 *	} 
	 * );
	 * @see UI.EditText#event:getOnChange
	 * @status iOS
	 * @event
	 */
	EditText.registerEventType('change');
	/**
	 * @name UI.EditText#getOnFocus 
	 * @description Retrieve the function to call when the <code>focus</code> event occurs.
	 * @returns {Function} The current <code>focus</code> callback function.
	 * @see UI.EditText#event:setOnFocus
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event	 
	 */
	/**
	 * @name UI.EditText#setOnFocus
	 * @description Set a function to call when the <code>focus</code> event occurs.
	 * @param {Function} focusCallback The new <code>focus</code> callback function. <br><br><b>Note:</b> The <code>focus</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example EditText.setOnFocus( function(event) { 
	 * 	console.log(event.text) 
	 *	} 
	 * );
	 * @see UI.EditText#event:getOnFocus
	 * @event
	 */
	EditText.registerEventType('focus');
	/**
	 * @name UI.EditText#getOnBlur
	 * @description Retrieve the function to call when the <code>blur</code> event occurs.
	 * @returns {Function} The current <code>blur</code> callback function.
	 * @see UI.EditText#event:setOnBlur
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event
	 */
	/**
	 * @name UI.EditText#setOnBlur
	 * @description Set a function to call when the <code>blur</code> event occurs.
	 * @note WARNING! This event is not guaranteed to occur on Android devices. Developers must not rely on this event occurring.
	 * @param {Function} blurCallback The new <code>blur</code> callback function.<br><br><b>Note:</b> The <code>blur</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example EditText.setOnBlur( function(event) { 
	 * 	console.log(event.text) 
	 *	} 
	 * );
	 * @see UI.EditText#event:getOnBlur
	 * @event
	 */
	EditText.registerEventType('blur');

	/**
	 * @name UI.EditText#getOnAction
	 * @description Retrieve the function to call when the <code>action</code> event occurs.
	 * @returns {Function} The current <code>action</code> callback function.
	 * @see UI.EditText#event:setOnAction
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event
	 */
	/**
	 * @name UI.EditText#setOnAction
	 * @description Set a function to call when a keyboard key corresponding to executing an action is pressed.
	 * Available since 1.1.6
	 * @note WARNING! Soft keyboards on Android devices are not required to offer actions. Developers must not rely on this event occurring.
	 * @param {Function} actionCallback The new <code>action</code> callback function.<br><br><b>Note:</b> The <code>action</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @see UI.EditText#event:getOnAction
	 * @event
	 */
	EditText.registerEventType('action');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/EditTextArea'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/EditTextArea'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/EditTextArea'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var EditTextArea = exports.EditTextArea = AbstractView.subclass(
/** @lends UI.EditTextArea.prototype */
{
	'type':'edittextarea',
	/**
	* @class The <code>EditTextArea</code> class is multiline text-editing area.
	* @name UI.EditTextArea
	* @augments UI.AbstractView
	*/
	initialize: function($super, properties) {
		if (EditTextArea._init) EditTextArea._init();
		$super(properties);
	},
	
	
	performEventCallback: function($super, event) {
		try {
			switch (event.eventType) {
				case 'change':
					this._text = event.text;
					$super(event);
					break;
				case 'focus':
				case 'blur':
					$super(event);
					break;
			}
		} catch(e) {
			NgHandleException(e);
		}
	},
	
	// Adapt API to the single-state model for "text" on editable text.
	/**
	 * Retrieve the value of the <code>text</code> property.
	 * @returns {String} The current value of <code>text</code>.
	 * @see UI.EditTextArea#setText
	 * @status Javascript, iOS
	 * @function
	 */	
	getText: function() {
		return this._text || "";
	},
	
	/**
	 * Set the value of the <code>text</code> property.
	 * @param {String} text The new value for <code>text</code>.
	 * @see UI.EditTextArea#getText
	 * @status Javascript, iOS
	 * @function
	 */
	setText: function(text) {
		this._text = text;
		Commands.setText.call(this, 0, text);
	},

	setFocus: function(focus) {
		Commands.setFocus.call(this, focus);
	}
});

EditTextArea._init = function() {
	delete EditTextArea._init;
	if (AbstractView._init) AbstractView._init();
	
	// ==== Content
	// API defines state for the text property, but we ONLY support one state for this control.
	
	EditTextArea.registerAccessors('text', EditTextArea.prototype.getText, EditTextArea.prototype.setText);
	
	/**
	 * @name UI.EditTextArea#getPlaceholder
	 * @description Retrieve the value of the <code>placeholder</code> property.
	 * @returns {String} The current value of <code>placeholder</code>.<br>
	 * @see UI.EditTextArea#setPlaceholder
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setPlaceholder
	 * @description Set the value of the <code>placeholder</code> property.
	 * @param {String} placeholder The new value for <code>placeholder</code>.
	 * @see UI.EditTextArea#getPlaceholder
	 * @function
	 */
	EditTextArea.synthesizeProperty('placeholder', Commands.setPlaceholderText);
	/**
	 * @name UI.EditTextArea#getPlaceholderColor
	 * @description Retrieve the value of the <code>placeholder color</code> property.
	 * @returns {String} The current value of <code>placeholder color</code>.<br>
	 * @see UI.EditTextArea#setPlaceholderColor
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */	
	/**
	 * @name UI.EditTextArea#setPlaceholderColor
	 * @description Set the value of the <code>placeholder color</code> property.
	 * @param {String} placeholderColor The new value for <code>placeholder color</code>.
	 * @see UI.EditTextArea#getPlaceholderColor
	 * @function
	 */
	EditTextArea.synthesizeProperty('placeholderColor', Commands.setPlaceholderTextColor);
	/**
	 * @name UI.EditTextArea#getPlaceholderShadow
	 * @description Retrieve the value of the <code>placeholder shadow</code> property.
	 * @returns {String} The current value of <code>placeholder shadow</code>.<br>
	 * @see UI.EditTextArea#setPlaceholderShadow
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setPlaceholderShadow
	 * @description Set the value of the <code>placeholder shadow</code> property.
	 * @param {String} placeholderShadow The new value for <code>placeholder shadow</code>.
	 * @see UI.EditTextArea#getPlaceholderShadow
	 * @function
	 */
	 EditTextArea.synthesizeProperty('placeholderShadow', Commands.setPlaceholderTextShadow);
	
	
	// ==== Appearance
	/**
	 * @name UI.EditTextArea#getTextColor
	 * @description Retrieve the value of the <code>textColor</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} textColor The current value of <code>textColor</code>.<br>
	 * @see UI.EditTextArea#setTextColor
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setTextColor
	 * @description Set the value of the <code>textColor</code> property for a view state.
	 * @param {String} textColor The new value for <code>textColor</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.EditTextArea#getTextColor
	 * @status iOS, Test
	 * @function
	 */
	EditTextArea.synthesizePropertyWithState('textColor', Commands.setTextColor);
	/**
	 * @name UI.EditTextArea#getTextShadow
	 * @description Retrieve the value of the <code>textShadow</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>textShadow</code>.<br>
	 * @see UI.EditTextArea#setTextShadow
	 * @private not working on iOS
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setTextShadow
	 * @description Set the value of the <code>textShadow</code> property for a view state.
	 * @param {String} textShadow The new value for <code>textShadow</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.EditTextArea#getTextShadow
	 * @private not working on iOS
	 * @status iOS, Test
	 * @function
	 */
	EditTextArea.synthesizePropertyWithState('textShadow', Commands.setTextShadow);
	
	/**
	 * @name UI.EditTextArea#getTextGravity
	 * @description Retrieve the value of the <code>textGravity</code> property for this <code>EditTextArea</code>.
	 * @returns {Number, Array (Number)} The current value of <code>textGravity</code>.<br>
	 * @see UI.EditTextArea#setTextGravity
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setTextGravity
	 * @description Set the value of the <code>textGravity</code> property for this <code>EditTextArea</code>.
	 * @param {Number, Array (Number)} textGravity The new value for <code>textGravity</code>. Set as a float or an array.
	 * @see UI.EditTextArea#getTextGravity
	 * @function
	 */
	EditTextArea.synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
	/**
	 * @name UI.EditTextArea#getTextSize
	 * @description Retrieve the value of the <code>teztSize</code> property for this <code>EditTextArea</code>.
	 * @returns {Number} The current value of <code>textSize</code>.<br>
	 * @see UI.EditTextArea#setTextSize
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setTextSize
	 * @description Set the value of the <code>textSize</code> property for this <code>EditTextArea</code>.
	 * @param {Number} textSize The new value for <code>textSize</code>.
	 * @see UI.EditTextArea#getTextSize
	 * @status iOS, Test
	 * @function
	 */
	EditTextArea.synthesizeProperty('textSize', Commands.setTextSize);
	/**
	 * @name UI.EditTextArea#getTextFont
	 * @description Retrieve the value of the <code>textFont</code> property for this <code>EditTextArea</code>.
	 * @returns {String} The current value of <code>textFont</code>.<br>
	 * @see UI.EditTextArea#setTextFont
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.EditTextArea#setTextFont
	 * @description Set the value of the <code>textFont</code> property for this <code>EditTextArea</code>.
	 * @param {String} textFont The new value for <code>textFont</code>.
	 * @see UI.EditTextArea#getTextFont
	 * @status iOS, Test
	 * @function
	 */
	EditTextArea.synthesizePropertyWithState('textFont', Commands.setTextFont);
	
	// ==== Events
	/**
	 * @name UI.EditTextArea#getOnChange
	 * @description Retrieve the function to call when the <code>change</code> event occurs.
	 * @returns {Function} The current <code>change</code> callback function.
	 * @see UI.EditTextArea#event:setOnChange
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event
	 */
	/**
	 * @name UI.EditTextArea#setOnChange
	 * @description Set a function to call when the <code>change</code> event occurs.
	 * @param {Function} changeCallback The new <code>change</code> callback function. <br><br><b>Note:</b> The <code>change</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @see UI.EditTextArea#event:getOnChange
	 * @status iOS
	 * @event
	 */
	EditTextArea.registerEventType('change');
	/**
	 * @name UI.EditTextArea#getOnFocus 
	 * @description Retrieve the function to call when the <code>focus</code> event occurs.
	 * @returns {Function} The current <code>focus</code> callback function.
	 * @see UI.EditTextArea#event:setOnFocus
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event	 
	 */
	/**
	 * @name UI.EditTextArea#setOnFocus
	 * @description Set a function to call when the <code>focus</code> event occurs.
	 * @param {Function} focusCallback The new <code>focus</code> callback function. <br><br><b>Note:</b> The <code>focus</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @see UI.EditTextArea#event:getOnFocus
	 * @event
	 */
	EditTextArea.registerEventType('focus');
	/**
	 * @name UI.EditTextArea#getOnBlur
	 * @description Retrieve the function to call when the <code>blur</code> event occurs.
	 * @returns {Function} The current <code>blur</code> callback function.
	 * @see UI.EditTextArea#event:setOnBlur
	 * @status Javascript, iOS, Android, Flash, Test
	 * @event
	 */
	/**
	 * @name UI.EditTextArea#setOnBlur
	 * @description Set a function to call when the <code>blur</code> event occurs.
	 * @param {Function} blurCallback The new <code>blur</code> callback function.<br><br><b>Note:</b> The <code>blur</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @see UI.EditTextArea#event:getOnBlur
	 * @event
	 */
	EditTextArea.registerEventType('blur');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/DateField'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/DateField'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/DateField'] = exports; var EditText = require('NGCore/Client/UI/EditText').EditText;

function isValidDate(d) {
	if ( !d.getTime )
		return false; 
		
	return !isNaN(d.getTime());
}

/*
 Date Parser code to handle WebKit's lack of following the implementation.
 http://stackoverflow.com/questions/3085937/safari-js-cannot-parse-yyyy-mm-dd-date-format/3085993#3085993
 */
function parseDate(input, format) {
  format = format || 'yyyy-mm-dd'; // default format
  var parts = input.match(/(\d+)/g), 
      i = 0, fmt = {};
  // extract date-part indexes from the format
  format.replace(/(yyyy|dd|mm)/g, function(part) { fmt[part] = i++; });

  return new Date(parts[fmt['yyyy']], parts[fmt['mm']]-1, parts[fmt['dd']]);
}
/*
 * Our Code is not actually passing its format to parseDate (already had all the code to rejigger the date pieces to yyyy-mm-dd before I realized the problems with webkit's date constructor / date string parser). -fbartho 2010-11-30
 */

exports.DateField = EditText.subclass(
/** @lends UI.DateField.prototype */
{
	/**
	 * @class The <code>DateField</code> class constructs objects that handle data returned by date functions.
	 * @constructs The default constructor. 
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {String} properties
	 * @augments UI.EditText
	 */
	initialize: function($super, properties) {
		var constructorRVal = $super(properties);
		this.setDateFormat("yyyy-mm-dd");
		this.ondatechange = function(newDate){};
		
		this.setInputType(EditText.InputTypes.Date);
		return constructorRVal;
	},
    
	/**
	 * Trigger an event callback for this <code>DateField</code>.
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {String} event The event that triggers a callback function.
	 * @private
	 * @status Javascript, iOS, Android, Flash
	 */
	performEventCallback: function($super, event) {
		try {
			if (event.eventType == 'change') {
				// Make Sure the Text is changed (call $super), before we call our listeners!
				var oldText = this.getText();
				$super(event);
				this.ondatechange(this.getDate());
			}
		} catch(e) {
			NgHandleException(e);
		}
	},
	_filterAndInsertDashes:function(oldText,newText) {
		var t = newText;
		if((oldText.length == t.length + 1) && oldText[oldText.length-1] == "-") {
			//This lets the user backspace through - marks as if they weren't there.
			// fbartho: Currently not in use! 2010-12-10
			//this.setText(t.substring(0,t.length-1));
			return t.substring(0,t.length-1);
		}
		
		var nt = "";
		var j = 0;
		for(var i = 0; i < t.length && nt.length < this.formatStr.length; i++,j++) {
			if(j < this.formatStr.length && this.formatStr[j] == "-" && i < t.length){
				if(t[i] == "-"|| t[i] == "/"){
					nt+="-";
					continue;
				}
				else {
					nt+="-";
					nt+=t[i];
					continue;
				}
			}
			if ( i < t.length && (t[i] == "-" || t[i] == "/") ) {
				--j; 
				continue;
			}
			nt+=t[i];
		}
		
		if(this.formatStr.length > j && (this.formatStr[j] == "-" || this.formatStr[j] == "/") ) {
			nt+="-";
		}
		
		return nt;
	},
	/**
	 * Format a date parsed from this <code>DateField</code> into a human-readable string.
	 * @status Javascript, iOS, Android, Flash, Test
	 */    
	normalizeDateLayout:function() {
		var ot = this.getText();
		var nt = this._filterAndInsertDashes(this.getText(),this.getText());
		if(ot!=nt)this.setText(nt);
	},
	/**
	 * Retrieve the date format of date strings parsed from this <code>DateField</code>
	 * @returns {String} The current date format.
	 * @see UI.DateField#setDateFormat
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	getDateFormat:function() {
		return this.formatStr;
	},
	/**
	 * Set the date format for date strings parsed from this <code>DateField</code>.
	 * @param {String} dateFormat The new date format.
	 * @see UI.DateField#getDateFormat
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	setDateFormat:function(fStr) 
	{
		if (   fStr != "yyyy-mm-dd"
			&& fStr != "mm-yyyy"
			&& fStr != "yyyy-mm"
			&& fStr != "mm-dd-yyyy"
			&& fStr != "dd-mm-yyyy" ) {
			// Invalid Format String Error Case
			NgLogD("Error: Invalid Format String set for Birthdate Field!!\n");
			
			return;
		}
		
		this.formatStr = fStr;
		this.setPlaceholder(this.formatStr);
		return;
	},
	/**
	 * Retrieve a date string parsed from this <code>DateField</code>.
	 * @returns {String} The current date.
	 * @status Javascript, iOS, Android, Flash, Test
	 */
	getDate:function() {
		return this._dateFromText(this._filterAndInsertDashes(this.getText(),this.getText()));
	}, 
	_dateFromText:function(text) 
	{
		var tmp = null;
		var t = text;
		var bits = null;
		var b2 = null;
		if ( this.formatStr == "dd-mm-yyyy" ) {
			bits = t.split("-");
			if(bits.length != 3 || bits[2].length != 4)
				return null;
			
			b2 = [];
			b2.push(bits.pop());
			b2.push(bits.pop());
			b2.push(bits.pop());
			tmp = parseDate(b2.join("-"));
		} else if ( this.formatStr == "mm-yyyy" ) {
			bits = t.split("-");
			if(bits.length != 2 || bits[1].length != 4)
				return null;
			
			b2 = [];
			b2.push(bits.pop());
			b2.push(bits.pop());
			b2.push("01");
			var tStr = b2.join("-");
			
			tmp = parseDate(tStr);
		} else if ( this.formatStr == "yyyy-mm" ) {
			bits = t.split("-");
			if(bits.length != 2 || bits[0].length != 4)
				return null;
			
			tmp = parseDate(t+"-01");
		} else if ( this.formatStr == "mm-dd-yyyy" ) {
			bits = t.split("-");
			if(bits.length != 3 || bits[2].length != 4)
				return null;
			
			b2 = [];
			b2.push(bits.pop());
			b2.push(bits.shift());
			b2.push(bits.shift());
			tmp = parseDate(b2.join("-"));
		} else {
			tmp = parseDate(t);
		}
		
		if(!isValidDate(tmp)) {
			NgLogD("Failed to parse date: "+tmp+"   -  "+tmp.toString()+"\n");
			return null;
		}
		return tmp;
	}
});

//TODO: make a proper DatePicker?
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/AlertDialog'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/AlertDialog'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/AlertDialog'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var AlertDialog = exports.AlertDialog = Element.subclass(
/** @lends UI.AlertDialog.prototype */
{
	'type':'alertdialog',
	/**
	 * @name UI.AlertDialog
	 * @class The <code>AlertDialog</code> class constructs objects that handle alert dialogs in an application.
	 * @augments UI.Element
	 */
	initialize: function($super, properties) {
		if (AlertDialog._init) AlertDialog._init();
		$super(properties);
	},
	
	/** 
	 * Show this dialog.
	 * @function
	 */
	show: Commands.show,
	/** 
	 * Hide this dialog.
	 * @function
	 */
	hide: Commands.hide
});

// Properties
AlertDialog._init = function() {
	delete AlertDialog._init;
	if (Element._init) Element._init();

	/**
	 * @name UI.AlertDialog#setTitle
	 * @description Set the value of the <code>title</code> property for a view state. This property defines the title string for an alert dialog window.
	 * @example var alertDialog = new UI.AlertDialog();
	 * alertDialog.setTitle("Exiting Game..");
	 * @see UI.AlertDialog#getTitle
	 * @param {String} title The new value for <code>title</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android
	 * @function
	 */
	/**
	 * @name UI.AlertDialog#getTitle
	 * @description Retrieve the value of the <code>title</code> property for a view state.
	 * @see UI.AlertDialog#setTitle
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>title</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	AlertDialog.synthesizePropertyWithState('title', Commands.setTitle);
	/**
	 * @name UI.AlertDialog#setText
	 * @description Set the value of the <code>text</code> property for a view state. This property defines a text string that is on display within an alert dialog window.
	 * @example var alertDialog = new UI.AlertDialog();
	 * ...
	 * alertDialog.setText("Returning to launcher..");
	 * @see UI.AlertDialog#getText
	 * @param {String} text The new value for <code>text</code>
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
 	 * @status iOS, Android
	 * @function
	 */
	/**
	 * @name UI.AlertDialog#getText
	 * @description Retrieve the value of the <code>text</code> property for a view state.
	 * @see UI.AlertDialog#setText
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>text</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	AlertDialog.synthesizePropertyWithState('text', Commands.setText);
	// Not a compound property; AlertDialog.getChoices() should return the array of strings.
	/**
	 * @name UI.AlertDialog#setChoices
	 * @description Set the value of the <code>choices</code> property. This property defines any available interface options for the user.
	 * @example var errorAlert = new UI.AlertDialog();
	 * ...
	 * errorAlert.setChoices(["Yes", "No"]);
	 * @see UI.AlertDialog#getChoices
	 * @param {String} choices The new value for <code>choices</code>.
	 * @param {Number} defaultChoice The index of the default choice.
	 * @param {Number} cancelChoice The index of the <code>cancel</code> choice.
 	 * @status iOS, Android
	 * @function
	 */
	/**
	 * @name UI.AlertDialog#getChoices
	 * @description Retrieve the value of the <code>choices</code> property.
	 * @see UI.AlertDialog#setChoices
	 * @returns {Array (String)} The current value of <code>choices</code>.
	 * @function
 	 * @status Javascript, iOS, Android, Flash, Test
	 */
	AlertDialog.synthesizeProperty('choices', Commands.setChoices);
	
	// Event will contain .choice, which is the index of the option chosen.
	/**
	 * @name UI.AlertDialog#setOnChoice
	 * @description Set a function to call on <code>choice</code> events.	 
	 * @param {Function} choiceCallback The new function to call. <br><br>
	 * <b>Note:</b> The <code>choice</code> event is disabled if the value for this parameter is not a function.
	 * @see UI.AlertDialog#event:getOnChoice
 	 * @status iOS, Android, Test
	 * @event
	 */
	/**
	 * @name UI.AlertDialog#getOnChoice
	 * @description Retrieve the function to call on <code>choice</code> events.
	 * @see UI.AlertDialog#event:setOnChoice
	 * @returns {Function} The current function to call.
	 * @event
	 * @type {Function}
 	 * @status iOS, Android, Test
	 */
	 AlertDialog.registerEventType('choice');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ProgressDialog'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ProgressDialog'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ProgressDialog'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var ProgressDialog = exports.ProgressDialog = Element.subclass(
/** @lends UI.ProgressDialog.prototype */
{
	'type':'progressdialog',

    /**
     * @class The <code>ProgressDialog</code> class constructs objects that handle progress updates from the application.
     * @constructs The default constructor. 
     * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
     * @param {String} properties Object properties.
     * @augments UI.Element
     */
    initialize: function($super, properties) {
		if (ProgressDialog._init) ProgressDialog._init();
        return $super(properties);
    },
	/**
	 * Show this dialog.
	 * @function
     * @status iOS, Android, Test
	 */    
    show: Commands.show,
	/**
	 * Hide this dialog.
	 * @function
     * @status iOS, Android, Test
	 */    
    hide: Commands.hide
});

ProgressDialog._init = function() {
	delete ProgressDialog._init;
	if (Element._init) Element._init();
	
	/**
	 * @name UI.ProgressDialog#setTitle
	 * @description Set the value of the <code>title</code> property for a <code>ProgressDialog</code>. This property defines the title string for a progress dialog in the specified view state.
	 * @example var progDialog = new UI.ProgressDialog();
	 * progDialog.setTitle("Downloading game components...");
	 * @param {String} title The new value for <code>title</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.ProgressDialog#getTitle
	 * @function
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.ProgressDialog#getTitle
	 * @description Retrieve the value of the <code>title</code> property for a <code>ProgressDialog</code> in the specified view state. 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>title</code>.
	 * @see UI.ProgressDialog#setTitle
	 * @function
     * @status iOS, Android, Test
	 */
	ProgressDialog.synthesizePropertyWithState('title', Commands.setTitle);
	/**
	 * @name UI.ProgressDialog#setText
	 * @description Set the value of the <code>text</code> property for a <code>ProgressDialog</code> in the specified view state. This property defines a text string for a progress dialog in the specified view state.
	 * @example var progDialog = new UI.ProgressDialog();
	 * progDialog.setText("Please wait...");
	 * @param {String} text The new value for <code>text</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.ProgressDialog#getText
	 * @function
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.ProgressDialog#getText
	 * @description Retrieve the value of the <code>text</code> property for a <code>ProgressDialog</code> in the specified view state.	 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>text</code>.
	 * @see UI.ProgressDialog#setText
	 * @function
     * @status iOS, Android, Test
	 */
	ProgressDialog.synthesizePropertyWithState('text', Commands.setText);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Toast'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Toast'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Toast'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Toast = exports.Toast = Element.subclass(
/** @lends UI.Toast.prototype */
{	
    'type': 'toast',
    /**
    * @class The <code>Toast</code> class constructs objects that render temporary messages on the device screen.
    * @name UI.Toast
    * @augments UI.View
    */
	initialize: function($super, properties) {
		if (Toast._init) Toast._init();
		$super(properties);
	},
	
	/** 
	 * Show this dialog.
	 * @function
     * @status iOS, Android, Test
	 */
    show: Commands.show
});

Toast._init = function() {
	delete Toast._init;
	if (Element._init) Element._init();

	/**
	 * @name UI.Toast#setText
	 * @description Set the value of the <code>text</code> property for a view state. This property defines a text string to use in the specified view state.
	 * @example var tempMessage = new UI.Toast();
	 * tempMessage.setText("Game Over");
	 * @param {String} text The new value for <code>text</code>.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.Toast#getText
	 * @function
     * @status iOS, Android, Test
	 */
	/**
	 * @name UI.Toast#getText
	 * @description Retrieve the value of the <code>text</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {String} The current value of <code>text</code>.
	 * @see UI.Toast#setText
	 * @function	 
     * @status iOS, Android, Test
	 */
	Toast.synthesizePropertyWithState('text', Commands.setText);
	/** 
	* @name UI.Toast#setOnDisappear
	* @description Set a function to call when the <code>disappear</code> event occurs. The callback for the event returns 
	* <code>true</code> if the temporary message should disappear. Otherwise, the callback returns <code>false</code>.
	* @param {function} disappearCallback The new callback function.<br><br>
	* <b>Note:</b> The <code>disappear</code> event is disabled if the value of this parameter is not a function.
	* @see UI.Toast#event:getOnDisappear
	* @event
	*/
	/**
	* @name UI.Toast#getOnDisappear
	* @description Retrieve the function to call when the <code>disappear</code> event occurs.
	* @returns {function} The current callback function.
	* @see UI.Toast#event:setOnDisappear
	* @event
	*/
	Toast.registerEventType('disappear');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Style'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Style'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Style'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var stateMap = {
	'normal': Commands.State.Normal,
	'focused': Commands.State.Focused,
	'selected': Commands.State.Selected,
	'pressed': Commands.State.Pressed,
	'disabled': Commands.State.Disabled
};

var Style = exports.Style = Element.subclass({
	"type":"style",
	"classname":"UI_Style",
	initialize: function($super, properties) {
		if (Style._init) Style._init();
		$super(properties);
	},
	
	/** Internal Use */
	$synthesizePropertyWithState: function(propName, commandsFn) {
		function doSynthesis(caseAdjusted, stateName, stateFlags) {
			var gName = 'get' + caseAdjusted;
			var sName = 'set' + caseAdjusted;
			var getterFn = function() {
				return this[gName].call(this, stateFlags);
			};
			var setterFn = function(val) {
				return this[sName].call(this, val, stateFlags);
			};

			this.registerAccessors( stateName + caseAdjusted, getterFn, setterFn );
		}
		Element.synthesizePropertyWithState.call(this, propName, commandsFn);
		// Synthesize stateful accessors.
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);
		for (var stateName in stateMap) {
			doSynthesis.call(this, caseAdjusted, stateName, stateMap[stateName]);
		}
	}
});

Style._init = function() {
	delete Style._init;
	if (Element._init) Element._init();

	with (Style) {
		synthesizePropertyWithState('gradient', Commands.setGradient);
		
		synthesizePropertyWithState('image', Commands.setImage);
		synthesizePropertyWithState('imageBorder', Commands.setImageBorder);
		synthesizeProperty('imageFit', Commands.setImageFitMode);
		synthesizeCompoundProperty('imageInsets', Commands.setImageInsets);
		synthesizeCompoundProperty('imageGravity', Commands.setImageGravity);
		synthesizeCompoundProperty('imageTransform', Commands.setImageTransform);
		
		synthesizePropertyWithState('text', Commands.setText);
		synthesizePropertyWithState('textColor', Commands.setTextColor);
		synthesizePropertyWithState('textFont', Commands.setTextFont);
		synthesizePropertyWithState('textShadow', Commands.setTextShadow);
		synthesizeCompoundProperty('textGravity', Commands.setTextGravity);
		synthesizeProperty('textSize', Commands.setTextSize);
		synthesizeCompoundProperty('textInsets', Commands.setTextInsets);

		synthesizePropertyWithState('rightImage', Commands.setRightImage);
		synthesizePropertyWithState('rightImageBorder', Commands.setRightImageBorder);
		synthesizeProperty('rightImageFit', Commands.setRightImageFitMode);
		synthesizeCompoundProperty('rightImageInsets', Commands.setRightImageInsets);
		synthesizeCompoundProperty('rightImageGravity', Commands.setRightImageGravity);
		synthesizeCompoundProperty('rightImageTransform', Commands.setRightImageTransform);
		
		synthesizePropertyWithState('title', Commands.setTitle);
		synthesizePropertyWithState('titleColor', Commands.setTitleColor);
		synthesizePropertyWithState('titleFont', Commands.setTitleFont);
		synthesizePropertyWithState('titleShadow', Commands.setTitleShadow);
		synthesizeCompoundProperty('titleGravity', Commands.setTitleGravity);
		synthesizeProperty('titleSize', Commands.setTitleSize);
		synthesizeCompoundProperty('titleInsets', Commands.setTitleInsets);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/AdView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/AdView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/AdView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

/** @private */
var AdView = exports.AdView = AbstractView.subclass(
{
	'type':'adview',

	/**
	 * @class The <code>AdView</code> class constructs objects that handle event callback functions and ad event metadata.
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @param {String} properties
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (AdView._init) AdView._init();
		$super(properties);
		
		this.onappear = this.bind(this._onappear);
		this.ondisappear = this.bind(this._ondisappear);
		this.onclick = this.bind(this._onclick);
	},
	
	/**
	 * An event for signaling when an <code>AdView</code> is on display.
	 * @event
	 */
	onappear: function() {
	 },
	
	/**
	 * An event for signaling when an <code>AdView</code> has been closed.
	 * @event
	 */
	ondisappear: function() { 
	},
	
	/** @protected */
	_onappear: function($super, event) {
		( $super || function(){} )(event);
//		Core.Analytics._getPipe().revenueEvent("ADSHOW",  this.getAdEventMetadata());
        visible = true;
	},
	
	/** @protected */
	_ondisappear: function($super, event) {
		( $super || function(){} )(event);
//		Core.Analytics._getPipe().revenueEvent("ADCLOSE", this.getAdEventMetadata());
        visible = false;
	},
	
	performEventCallback: function($super, event) {
		if (event.eventType == 'click')
		{
//			Core.Analytics._getPipe().revenueEvent("ADCLCK", this.getAdEventMetadata());
			NgLogD("AD WAS CLICKED in AdView wooo!!!!");
			( $super || function(){} )(event);
		}
		if (event.eventType == 'load')
		{
//			Core.Analytics._getPipe().revenueEvent("ADLOAD", this.getAdEventMetadata());
			NgLogD("AD WAS LOADED in AdView wooo!!!!");
			( $super || function(){} )(event);
		}
	},
	/**
	* Pause this <code>AdView</code>.<br><br>
	* <b>Note:</b> If an <code>AdView</code> is already paused, this call does nothing.
	* @see UI.AdView#resumeAds
	* @status Android
	*/
	pauseAds: function() {
		Commands.pauseAds.call(this);
	},
	/**
	* Resume this <code>AdView</code> from a paused state. Setting this will resume the <code>AdView</code> from the current position.
	* @see UI.AdView#resumeAds
	* @status Android
	*/
	resumeAds: function() {
		Commands.resumeAds.call(this);
	},
	/**
	* Set the refresh rate for this <code>AdView</code>. 
	* @param {Number} refreshRate The amount of time each ad is on display (in milliseconds).
	* @status Android
	*/
	setRefreshRate: function(refreshRate) {
		Commands.setAdRefreshRate.call(this, refreshRate);
	},
	/**
	* Set this <code>AdView</code> to automatically play.
	* @status Android
	* @param {Boolean} autoplay Set as <code>true</code> if autoplay is enabled.
	*/
	setAutoplay: function(autoplay) {
		Commands.setAdRefreshRate.call(this, autoplay);
	},
	
	/**
	 * Retrieve event metadata from this <code>AdView</code>. 
	 */
	getAdEventMetadata: function(){
		NgLogD("AD EventMetetData was requested!");
		var AdMeteData = "DefaultAdEventMetaData";
		return AdMeteData;
	}
});

// Event Handlers
AdView._init = function() {
	delete AdView._init;
	if (AbstractView._init) AbstractView._init();

    /**
	 * @name UI.AdView#getActive
	 * @description Retrieve the value of the <code>active</code> property.
	 * @returns {Boolean} Returns <code>true</code> if the <code>AdView</code> object is set to active.
	 * @see UI.AdView#setActive
	 * @status iOS, Android, Flash, Test
	 * @function
	 */
	AdView.synthesizeProperty('active', Commands.setActive);
    
	/**
	 * @name UI.AdView#setOnClick
	 * @description Set a function to call on <code>click</code> events.	 
	 * @param {Function} clickCallback The new <code>click</code> callback function. <br><br>
	 * <b>Note:</b> The <code>click</code> event is disabled if the value for this parameter is not a function.<br>
	 * @see UI.AdView#event:setOnClick
 	 * @status Android, Test
	 * @event
	 */
	/**
	 * @name UI.AdView#getOnClick
	 * @description Retrieve the function to call on <code>click</code> events.<br>
	 * @see UI.AdView#event:getOnClick
	 * @returns {Function} The current <code>click</code> callback function.<br>
 	 * @status Android, Test
	 * @event
	 */
	AdView.registerEventType('click');
	/**
	 * @name UI.AdView#setOnLoad
	 * @description Set a function to call on <code>load</code> events.	 
	 * @param {Function} loadCallback The new <code>load</code> callback function. <br><br>
	 * <b>Note:</b> The <code>load</code> event is disabled if the value for this parameter is not a function.<br>
	 * @see UI.AdView#event:getOnClick
 	 * @status Android, Test
	 * @event
	 */
	/**
	 * @name UI.AdView#getOnLoad
	 * @description Retrieve the function to call on <code>load</code> events.<br>
	 * @see UI.AdView#event:getOnClick
	 * @returns {Function} The current <code>load</code> callback function.<br>
 	 * @status Android, Test
	 * @event
	 */
	AdView.registerEventType('load');
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/DocumentView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/DocumentView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/DocumentView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var DocumentView = exports.DocumentView = AbstractView.subclass(
/** @lends UI.DocumentView.prototype */
{
	'type':'documentview',
	/**
	 * @name UI.DocumentView
	 * @class The <code>DocumentView</code> class constructs objects that handle document locations.
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (DocumentView._init) DocumentView._init();
		$super(properties);
	}
});

// Properties
DocumentView._init = function() {
	delete DocumentView._init;
	if (AbstractView._init) AbstractView._init();
	
	/**
	 * @name UI.DocumentView#setDocumentURL
	 * @description Set the document URL for this <code>DocumentView</code>.
	 * @param {String} documentURL The new document URL.
	 * @see UI.DocumentView#getDocumentURL
	 * @status Javascript, iOS, Android, Flash, Test
	 * @function
	 */
	/**
	 * @name UI.DocumentView#getDocumentURL
	 * @description Retrieve the document URL of this <code>DocumentView</code>.
	 * @returns {String} The current document URL.
	 * @see UI.DocumentView#setDocumentURL
	 * @status iOS, Android, Test
	 * @function
	 */
	DocumentView.synthesizeProperty('documentURL', Commands.setSourceDocument);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/CheckoutView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/CheckoutView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/CheckoutView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry');
var Commands = require('NGCore/Client/UI/Commands').Commands;

var CheckoutView = exports.CheckoutView = AbstractView.subclass(
/** @lends UI.CheckoutView.prototype */
{
	'type':'checkoutview',
	/**
	 * @name UI.CheckoutView
	 * @class The <code>CheckoutView</code> class constructs objects that handle and manage information associated with <code>POST</code> methods in an application.
	 * @augments UI.AbstractView
	 */
	initialize: function($super, properties) {
		if (CheckoutView._init) CheckoutView._init();
		$super(properties);
	}
});

// Properties
CheckoutView._init = function() {
	delete CheckoutView._init;
	if (AbstractView._init) AbstractView._init();
	
	// THESE ARE METHODS NOT PROPERTIES... THIS SHOULD BE FIXED.
	// We define ONLY setters, and no getters (write-only props, no local copies)
	/**
	 * @name UI.CheckoutView#setPostData
	 * @description Set the value returned by the <code>postData()</code> method of this <code>CheckoutView</code>.
	 * @param {String} postData The new value for <code>postData</code>.
	 * @see UI.CheckoutView#getPostData
	 * @status Android
	 * @function
	 */
	/**
	 * @name UI.CheckoutView#getPostData
	 * @description Retrieve the value returned by the <code>postData()</code> method of this <code>CheckoutView</code>.
	 * @returns {String} The current value of <code>postData</code>.
	 * @see UI.CheckoutView#setPostData
	 * @status Android
	 * @function
	 */
	CheckoutView.registerAccessors('postData', null, Commands.setPostData);
	/**
	 * @name UI.CheckoutView#setPostURL
	 * @description Set the value returned by the <code>postURL()</code> method of this <code>CheckoutView</code>.
	 * @param {String} postURL The new value for <code>postURL</code>.
	 * @see UI.CheckoutView#getPostURL
	 * @status Android
	 * @function
	 */
	/**
	 * @name UI.CheckoutView#getPostURL
	 * @description Retrieve the value returned by the <code>postURL()</code> method of this <code>CheckoutView</code>.
	 * @returns {String} The current value of <code>postURL</code>.
	 * @see UI.CheckoutView#setPostURL
	 * @status Android
	 * @function
	 */
	CheckoutView.registerAccessors('postURL', null, Commands.loadPostURL);
	/**
	 * @name UI.CheckoutView#setGetURL
	 * @description Set the value returned by the <code>getURL()</code> method of this <code>CheckoutView</code>.
	 * @param {String} getURL The new value for <code>getURL</code>.
	 * @see UI.CheckoutView#getGetURL
	 * @status Android
	 * @function
	 */
	/**
	 * @name UI.CheckoutView#getGetURL
	 * @description Retrieve the value returned by the <code>getURL()</code> method of this <code>CheckoutView</code>.
	 * @returns {String} The current value for <code>getURL</code>.
	 * @see UI.CheckoutView#setGetURL
	 * @status Android
	 * @function
	 */
	CheckoutView.registerAccessors('getURL', null, Commands.loadGetURL);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/Spinner'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/Spinner'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/Spinner'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var Spinner = exports.Spinner = AbstractView.subclass(
/** @lends UI.Spinner.prototype */
{
	'type':'spinner',
	
	/**
	* @class The <code>Spinner</code> class constructs objects that handle menu spinners in a user interface. 
	* @name UI.Spinner
	* @augments UI.AbstractView
	*/
	initialize: function($super, properties) {
		if (Spinner._init) Spinner._init();
		return $super(properties);
	}
});

Spinner._init = function() {
	delete Spinner._init;
	if (AbstractView._init) AbstractView._init();
	
	Spinner.synthesizeProperty('darkStyle', Commands.setDarkStyle);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ProgressBar'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ProgressBar'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ProgressBar'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var WindowR = require('NGCore/Client/UI/Window');

var ProgressBar = exports.ProgressBar = AbstractView.subclass(
/** @lends UI.ProgressBar.prototype */
{
	'type':'progressbar',

    /**
     * @class <code>ProgressBar</code> constructs a horizontal bar that gives a finite indication of progress.
     * @constructs The default constructor. 
     * @param $super This parameter is stripped out during execution. Do not supply it.
     * @param {String} properties
     * @augments UI.AbstractView
     */
    initialize: function($super, properties) {
		if (ProgressBar._init) ProgressBar._init();
        return $super(properties);
    },

	useForUpdateProgress: Commands.useForUpdateProgress,
});

ProgressBar._init = function() {
	delete ProgressBar._init;
	if (AbstractView._init) AbstractView._init();

	/**
	 * @name UI.ProgressBar#getProgressGradient
	 * @description Retrieve the <code>progressGradient</code> for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current progressGradient for the specified view state.<br>
	 * @see UI.ProgressBar#setProgressGradient
	 * @status Javascript, Android
	 * @function
	 */
	/**
	 * @name UI.ProgressBar#setProgressGradient
	 * @description Set a progressGradient for a view state.
	 * @see UI.ProgressBar#getProgressGradient
	 * @param {Object} progressGradientURL The new progressGradient.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @status Android
	 * @function 
	 */
	ProgressBar.synthesizePropertyWithState('progressGradient', Commands.setProgressGradient);
	/**
	 * @name UI.SecondaryBar#getSecondaryGradient
	 * @description Retrieve the <code>secondaryGradient</code> for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current secondaryGradient for the specified view state.<br>
	 * @see UI.SecondaryBar#setSecondaryGradient
	 * @status Javascript, Android
	 * @function
	 */
	/**
	 * @name UI.SecondaryBar#setSecondaryGradient
	 * @description Set a secondaryGradient for a view state.
	 * @see UI.SecondaryBar#getSecondaryGradient
	 * @param {Object} secondaryGradientURL The new secondaryGradient.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @status Android
	 * @function 
	 */
	ProgressBar.synthesizePropertyWithState('secondaryGradient', Commands.setSecondaryGradient);
	
	/**
	 * @name UI.ProgressBar#getProgress
	 * @description Retrieve the value of the <code>progress</code> properties.
	 * @returns {Array} The current values of <code>progress</code> and <code>secondaryProgress</code>.<br>
	 * @see UI.ProgressBar#setProgress
	 * @status Javascript, Android
	 * @function
	 */
	/**
	 * @name UI.ProgressBar#setProgress
	 * @description Set the values of the <code>progress</code> properties.
	 * @see UI.ProgressBar#getProgress
	 * @param {Number} progress The new value for <code>progress</code>, as a decimal Number between 0.0 and 1.0.
	 * @param {Number} secondaryProgress The new value for <code>secondaryProgress</code>, as a decimal Number between 0.0 and 1.0.
	 * @status Javascript, Android
	 * @function
	 */
	var setProgressGuarded = function(arg0) {
		var args = (arg0 instanceof Array) ? arg0 : Array.prototype.slice.call(arguments);
		while (args.length < 2) args.push(0);
		Commands.setProgress.apply(this, args);
	}
	ProgressBar.synthesizeCompoundProperty('progress', setProgressGuarded);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/MapView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/MapView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/MapView'] = exports; var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var MapAnnotation = require('NGCore/Client/UI/MapAnnotation').MapAnnotation;

var MapView = exports.MapView = AbstractView.subclass(
/** @lends UI.MapView.prototype */
{
	'type':'mapview',
	/**
	* @class <code>MapView</code>
	* @name UI.MapView
	* @augments UI.View
	*/
	initialize: function($super, properties) {
		this._annotations = [];
		this._region = [];
		return $super(properties);
	},
	
	getCenterCoordinate: function()
	{
		return [this._region[0], this._region[1]];
	},
    
    setCenterCoordinate: function(lat, lon, animated)
    {
        this._region[0] = lat;
        this._region[1] = lon;
        if (!this._region[2])
            this._region[2] = 0.05;
        if (!this._region[3])
            this._region[3] = 0.05;            
        this.setRegion(this._region[0], this._region[1], this._region[2], this._region[3], animated);
    },
	
	getCoordinateSpan: function()
	{
		return [this._region[2], this._region[3]];
	},	
	
	selectAnnotation: function(annotation)
	{
		if (annotation instanceof MapAnnotation) {
			var index = this._annotations.indexOf(annotation);
			if (index != -1) {
				Commands.selectAnnotation.call(this, annotation.__objectRegistryId);
				return;
			}
		}
		Commands.selectAnnotation.call(this, -1);
	},
	
	addAnnotation: function(annotation)
	{
		if (annotation instanceof MapAnnotation) {
			this._annotations.push(annotation);
			
			Commands.addAnnotation.call(this, annotation.__objectRegistryId);
			
		} else throw {message: this.type + ".addAnnotation: " + annotation + " is not a MapAnnotation!"};
		return this;
	},
	
	removeAnnotation: function(annotation)
	{
		if (annotation instanceof MapAnnotation) {
			// Remove this node from parent's child list
			var index = this._annotations.indexOf(annotation);
			if (index != -1) {
				this._annotations.splice(index, 1);
			}
			
			// Remove from the parent at the system level
			Commands.removeAnnotation.call(this, annotation.__objectRegistryId);
		} else throw {message: this.type + ".removeAnnotation: " + annotation + " is not a MapAnnotation!"};
		return annotation;
	},
	
	/**
	 * @private
	 */    
	updateRegionFits: function(lat, lon ,latD , lonD) {
		//console.log(lat + " " + lon + " " + latD + " " + lonD);
		//console.log(this._region[0] + " " + this._region[1] + " " + this._region[2] + " " + this._region[3]);
		this._region[0] = lat;
		this._region[1] = lon;
		this._region[2] = latD;
		this._region[3] = lonD;
	},
	
	/**
	 * @private
	 */    
	performEventCallback: function($super, e) {
		if (e.eventType == 'regionchange') this.updateRegionFits(e.latitude, e.longitude , e.latitudeDelta , e.longitudeDelta);
		$super(e);
	}
});

// Properties
(function() {
	MapView.synthesizeProperty('scrollable', Commands.setScrollable);
	
	MapView.synthesizeProperty('zoomable', Commands.setZoomable);
	
	MapView.synthesizeCompoundProperty('region', Commands.setRegion);
	
	MapView.registerEventType('regionchange');
})();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/MapAnnotation'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/MapAnnotation'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/MapAnnotation'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;

var MapAnnotation = exports.MapAnnotation = Element.subclass(
/** @lends UI.MapAnnotation.prototype */
{
	'type':'mapannotation',
	/**
	* @class <code>MapAnnotation</code>
	* @name UI.MapAnnotation
	* @augments Core.Class
	*/
	initialize: function($super, properties) {
		return $super(properties);
	},

	setCalloutLeftView: function(view)
	{
		this._calloutLeftView = view;
		Commands.setCalloutLeftView.call(this, view.__objectRegistryId);
	},

	getCalloutLeftView: function()
	{
		return this._calloutLeftView;
	},

	setCalloutRightView: function(view)
	{
		this._calloutRightView = view;
		Commands.setCalloutRightView.call(this, view.__objectRegistryId);
	},

	getCalloutRightView: function()
	{
		return this._calloutRightView;
	},

	setView: function(view)
	{
		this._view = view;
		Commands.setView.call(this, view.__objectRegistryId);
	},

	getView: function()
	{
		return this._view;
	},

	setImage: function(image)
	{
		console.log("WARNING : MapAnnotation.setImage has been deprecated. Use MapAnnotation.setView instead.");
		var iV = new UI.Image();
		iV.setImage(image);
		iV.setFrame([0, 0, 40, 40]);
		this.setView(iV);
	},

	/**
	 * @private
	 */    
	performEventCallback: function($super, e) {
		$super(e);
	}
});

// Properties
(function() {

	MapAnnotation.synthesizeCompoundProperty('coordinate', Commands.setCoordinate);
	
	MapAnnotation.synthesizeCompoundProperty('centerOffset', Commands.setCenterOffset);
	
	MapAnnotation.synthesizeProperty('calloutTitle', Commands.setCalloutTitle);

	MapAnnotation.synthesizeProperty('calloutSubtitle', Commands.setCalloutSubtitle);
	
	MapAnnotation.synthesizeProperty('calloutEnabled', Commands.setCalloutEnabled);

	MapAnnotation.registerEventType('select');
	MapAnnotation.registerEventType('deselect');
})();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Analytics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Analytics'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Analytics'] = exports; var Class = require('NGCore/Client/Core/Class').Class,
NgPipe = require('NGCore/Shared/NgPipe').NgPipe,
NgPipesRemote = require('NGCore/Shared/NgPipesRemote').NgPipesRemote;

var Analytics = Class.singleton(
/** @lends Core.Analytics.prototype */
{
    classname: 'Analytics',

    /**
     * @class The <code>Analytics</code> class serves as the custom messaging channel to the ngCore platform. 
     * The <code>Analytics</code> class provides developers with a way to keep track of game-specific items that require analysis and counting.
     * Use this class when you need your games to send custom elements that require in-game analytics support. 
     * @constructs The default constructor for setting up the NgPipe.
     * @augments Core.Class
     * @param {Boolean} [sendToRemote=true] Set <code>sendToRemote</code> to <code>true</code> to send analytics data to a remote server.
     * @param {String} [analyticsServer=ngmoco analytics server] A custom analytics server.
     * @private
     */
    initialize: function() {
        if (!this._pipe) {
          this._pipe = new NgPipe();
        }
    },

	/** @private */
	updateGLEXT: function()
	{
		try
		{
			var caps = require('NGCore/Client/Core/Capabilities').Capabilities;
			var ext = caps.getOglExtensions();
			if (ext.length > 2)	// > 2 means we got some actual data, not our fake string
			{
				// We need to rip out just one of the four tex compressions we want.
				var list = [];
				var goodies =
				[
					"GL_IMG_texture_compression_pvrtc",
					"GL_AMD_compressed_ATC_texture",
					"GL_OES_compressed_ETC1_RGB8_texture",
					"GL_AMD_compressed_3DC_texture"
				];
				for (var i in goodies)
				{
					var item = goodies[i];
					for (var j in ext)
					{
						if (ext[j] ===  item)
						{
							var rep = {};
							rep[caps.getDeviceName()] = item;
							list.push(rep);
						}
					}
				}

				for (i in list)
				{
					Analytics.reportGameEvent("openglexts", list[i]);
				}
			}
		}
		catch (e)
		{
			NgLogException(e);
		}
	},

    /** @private */
    enable: function() {
        this._pipe.enable();
    },

    /** @private */
    disable: function() {
        this._pipe.disable();
    },

    /** @private */
    setUrl: function(url) {
        this._pipe.setRemoteUrl(url);
    },

    /**
    * Report a navigation event that occurs when users navigate between application pages. 
    * Calling this function will alert the analytics platform that a user has generated a navigation event.
    * This information is used to plot how users move through the game, how long they spend on a page, and what page they navigate to next.
    *
    * @param {String} from The name of the page from which navigation originates. 
    * @param {String} to An analytics name for the destination page.
    * @param {String} btnid The ID of the button that triggered the navigation.
    */
    reportNavigation : function(from, to, btnid) {
        if (!(from && to)) {
            return false;
        }
        this._pipe.uiEvent('NAV', {to: to, fro: from, btnid: btnid} );
        return true;
    },
    /**
    * Report a custom game event. Call <code>reportGameEvent</code> to record events that do not alter a user's core game statistics.
    * <b>Note:</b> This function serves as a catch-all. Call <code>reportGameEvent</code> to count or analyze events that do not fit into any 
    * other category.
    * 
    * @param {String} eventId The ID for the custom event.
    * @param {Object} payload A hash of extra information.
    * @param {Object} playerState A hash of important player states.
    */
    reportGameEvent : function(eventId, payload, playerState ) {
        if (!eventId) {
            return false;
        }

        this._pipe.gameEvent(eventId, payload, playerState);

        return true;
    },
    /**
    * Report a change to a playerstate. A playerstate is the object representation of the player's core stats. 
    * For example, if a player purchased an in-game item, you would call this to let the analytics system know what happened and how much gold was spent.
    * Everything in the player state is counted and recorded. Make sure to only pass in things for which you want to see the change 
    * (gold, mojo, grow, level, xp, health, lives, and so on).
    * <b>Note:</b> This is only for game state and should not include information that is unique to a user. For example, the user game tag or the user ID.
    *
    * @param {String} action The product ID of a purchased product. This essentially points out when an action is performed.
    * @param {Object} change A hash of currencies spent and/or gained. For example {mojo: 100, gold:-10}
    * @param {Object} playerState A hash of important player states after the purchase.
    */
    reportPlayerStateChange : function(action, change,  playerState) {
        if (action) {
            this._pipe.playerEvent(action, 'PLSTCHANGE', change, playerState);
            return true;
        } else {
            return false;
        }
    },

    /**
    * Report when a user reaches a new stage of a funnel. Funnel refers to a set of pages or requirements a user is required to engage in before proceeding. 
    * You can use this call to keep track of progress for all users. For example, keeping track of various stages users engage in for game registration.
    * Funnel stages are ordered by numeric ID. The funnel <code>stageName</code> is used for display. You do not need to define funnels ahead of time.
    * Funnel stages start at 0 and increase as the user proceeds further.<br><br>
    * <b>Note:</b> Calling <code>reportFunnelStage()</code> multiple times for a single user generates an incorrect count.
    *
    * @param {String} funnelName The name of the funnel that the user has progressed to.
    * @param {Number} funnelStage The integer value of the stage that the user reached.
    * @param {String} stageName The name of the stage that the user reached.
    * @param {Object} playerState A hash of important player states after a funnel stage.
    * @private
    */
    reportFunnelStage : function(funnelName, funnelStage, stageName, playerState) {
        var payload =  {};

        if (!(funnelName)) {
            return false;
        }
        if (funnelStage !== null && funnelStage !== undefined) {
            payload.stage = funnelStage;
        } else {
            return false;
        }

        if (stageName) {
            payload.stageName = stageName;
        }
        this._pipe.funnelEvent(funnelName, payload, playerState);

        return true;
    },
    /**
     * Report an interaction between two users.
     *
     * @param {String} actionId The action that the user is performing to interact with the other user
     * @param {String} friendGamerTag The other user with whom the current user is interacting.
     * @param {Object} payload A hash of extra information
     */
    reportSocialEvent: function(actionId, friendGamerTag, payload) {
        if (actionId && actionId.length && friendGamerTag && friendGamerTag.length ) {
            this._pipe.socialEvent(actionId, friendGamerTag, payload);
            return true;
        }
        return false;
    },
    /**
    * Report an error to analytics.
    *
    * @param {String} error_msg The error message to log.
    */
    reportError : function(error_msg) {
        if (!error_msg) {
            return false;
        }
        this._pipe.gameOpsEvent("ERR", {err: error_msg } );
        return true;
    },
    /**
     * @private
     */
    addTag: function(tag) {
        if (tag) {
            var evpl = {tag:tag};
            this._pipe.gameEvent('tag', evpl);
            return true;
        }
        return false;
    },
    /** @private */
    _getPipe: function() {
        return this._pipe;
    },
    /**
    * Game Service running inside privileged interpreter may use this method
    * to change the Social Analytic object to be used.  Please see MOBWEST-2300
	* for details
	*
    * @private
    */
	_setNgPipeSocialAnalytics: function(socialAnalyticObj) {
		if (this._pipe) {
			this._pipe._setSocialAnalytics(socialAnalyticObj);
		}
	}
});
exports.Analytics = Analytics;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Color'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Color'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Color'] = exports; exports.Color = require('NGCore/Shared/Color').Color;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Vector'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Vector'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Vector'] = exports; exports.Vector = require('NGCore/Shared/Vector').Vector;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Point'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Point'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Point'] = exports; exports.Point = require('NGCore/Shared/Point').Point;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Size'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Size'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Size'] = exports; exports.Size = require('NGCore/Shared/Size').Size;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Rect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Rect'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Rect'] = exports; exports.Rect = require('NGCore/Shared/Rect').Rect;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/MessageEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/MessageEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/MessageEmitter'] = exports; exports.MessageEmitter = require('NGCore/Shared/MessageEmitter').MessageEmitter;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/MessageListener'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/MessageListener'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/MessageListener'] = exports; exports.MessageListener = require('NGCore/Shared/MessageListener').MessageListener;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/ObjectRegistry'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/ObjectRegistry'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/ObjectRegistry'] = exports; var Class = require('NGCore/Client/Core/Class').Class;

exports.ObjectRegistry = Class.singleton(
{
	classname: 'ObjectRegistry',
		
	/** @private @class @status */
	initialize: function()
	{
		this._currentId = 0;
		this._guardId = 0;
		this._objects = {};
	},
	
	/** @status */
	register: function(obj)
	{
		if(obj.__objectRegistryId)
			throw new Error('ObjectRegistry.register: object already registered');
			
		var id = "" + ++this._currentId;
		obj.__objectRegistryId = id;
		this._objects[id] = obj;
	},
	
	/** @status */
	unregister: function(obj)
	{
		if(!obj.__objectRegistryId)
			throw new Error('ObjectRegistry.unregister: object not registered');
			
		var id = obj.__objectRegistryId;
		obj.__objectRegistryId = 0;
		delete this._objects[id];
	},
	
	/** @status */
	isObjectRegistered: function(obj)
	{
		if(obj.__objectRegistryId)
			return true;
		else
			return false;
	},
	
	/** @status */
	isIdRegistered: function(id)
	{
		if(this._objects[id])
			return true;
		else
			return false;
	},
	
	/** @status */
	objectToId: function(obj)
	{
		var id = obj.__objectRegistryId;
		
		if(!id)
			throw new Error('ObjectRegistry.objectToId: object not registered');
		
		return id;
	},
	
	/** @status */
	idToObject: function(id)
	{
		return this._objects[id];
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Time'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Time'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Time'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class Time
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;

var Time = Class.singleton(
/** @lends Core.Time.prototype */
{
	classname: 'Time',
	mFrameTime: 0,
	mFrameDelta: 0,

	/**
	 * @class the <code>Time</code> class constructs objects that provide access to the system clock and system timings for a device.
	 * @status iOS, Android, Flash
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 */
	initialize: function()
	{
	},

	/**
	 * Return the timestamp for the current time frame (expressed in milliseconds).
	 * @returns {Number} The timestamp for the current time frame.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getFrameTime: function()
	{
		return this.mFrameTime;
	},

	/**
	 * Return the delta time in milliseconds since the last time frame.
	 * @returns {Number} The delta time since the last time frame.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getFrameDelta: function()
	{
		return this.mFrameDelta;
	},

	/**
	 * Return the real-time clock in milliseconds. 
	 * <b>Note:</b> This differs from the time frame timestamp, which is constant for the entire time frame.
	 * @returns {Number} The real-time clock.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getRealTime: function()
	{
		return (new Date()).getTime();
	},

	$_frameTimeRecv: function( cmd )
	{
		var o = {};
		this._frameTimeRecvGen(cmd, o);

		this.mFrameDelta = this.mFrameTime ? o.time - this.mFrameTime : 1;
		this.mFrameTime = o.time;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 351
	// Method frameTime = -1
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Time._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				case -1:
					Time._frameTimeRecv( cmd );
					break;
				default:
					NgLogE("Unknown static method id " + cmdId + " in Time._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[351] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	$_frameTimeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Time.frameTime from command: " + cmd );
			return false;
		}
		
		obj[ "time" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "time" ] === undefined )
		{
			NgLogE("Could not parse time in Time.frameTime from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $_frameTimeRecv: function( cmd ) {}

// {{/Wg Generated Code}}

});

exports.Time = Time;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/toMD5'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/toMD5'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/toMD5'] = exports; exports.toMD5 = require('NGCore/Shared/Lib/md5').toMD5;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/SHA1'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/SHA1'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/SHA1'] = exports; var sha1 = require('NGCore/Shared/Lib/sha1');

exports.SHA1 = {
	b64_hmac_sha1: sha1.b64_hmac_sha1,
	hex_sha1: sha1.hex_sha1,
	b64_sha1: sha1.b64_sha1
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/UpdateEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/UpdateEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/UpdateEmitter'] = exports; var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var Time = require('NGCore/Client/Core/Time').Time;

exports.UpdateEmitter = MessageEmitter.singleton(
/** @lends Core.UpdateEmitter.prototype */
{
	classname: 'UpdateEmitter',
		
	/**
	 * @class The <code>UpdateEmitter</code> module constructs a singleton object that emits every frame with the delta in milliseconds since the last frame.<br><br>
	 * <b>Note:</b> <code>{@link Core.UpdateEmitter#setTickRate}</code> is also used to define the framerate of any animation reproduced by a sprite 
	 * (see <code>{@link GL2.Sprite#setAnimation}</code>).
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Flash
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		
		this.__clubObject = new NgEngineEntity();
		this.__clubObject.mIsUpdatable = true;
		this.__clubObject.onUpdate = this._emitTime.bind(this);
		this.__clubObject.register();
		
		this._createSendGen(this.__objectRegistryId);
	},
	
	_emitTime: function()
	{
		this.emit(Time.getFrameDelta());
	},
	/**
	 * Set the tick rate that this <code>UpdateEmitter</code> object uses to send updates.<br><br>
	 * <b>Example:</b> Calling <code>setTickRate(15)</code>, any <code>MessageListener</code> objects that are listening 
	 * to the <code>UpdateEmitter</code> receive messages 15 times a second.	 
	 * @param {Number} r The new tick rate.
	 * @see GL2.Sprite
	 * @status iOS, Android, Flash
	 */
	setTickRate: function( r ) 
	{
		this._setTickRateSendGen(r);
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 304
	// Method create = -1
	// Method setTickRate = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in UpdateEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in UpdateEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[304] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( ":304,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_setTickRateSendGen: function( rate )
	{
		Proc.appendToCommandString( ":304,2," + this.__objectRegistryId + "," + rate  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setTickRate: function( rate ) {}
	

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/Proc'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/Proc'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/Proc'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class Proc
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

////////////////////////////////////////////////////////////////////////////////

exports.Proc = Class.singleton(
{
	classname: 'Proc',
	
	initialize: function()
	{
		this._commandString = "";
	},
	
	appendToCommandString: function( str )
	{
		this._commandString += str;
	},
	
	getCommandString: function()
	{
		return this._commandString;
	},
	
	clearCommandString: function ()
	{
		this._commandString = "";
	},
	
	parseBool: function( v )
	{
		return v == 1 ? true : false;
	},

	parseInt: function( v )
	{
		return parseInt( v, 10 );
	},
	
	parseFloat: function( v )
	{
		return parseFloat( v );
	},
	
	parseString: function( v )
	{
		return Base64.decode( v );
	},
	
	parseJSONString: function( v )
	{
		return JSON.parse( Base64.decode( v ) );
	},

	setPrivileged: function()
	{
		this._privileged = true;
	},

	isPrivileged: function()
	{
		return this._privileged ? true : false;
	},

// {{?Wg Generated Code}}
	_classRecvGen: function( cmd )
	{
		var classId = parseInt( cmd.shift(), 10 );
		
		var handler = PROC_DISPATCH_TABLE[classId];
		if(handler)
		{
			handler(cmd);
		}
		else
		{
			NgLogE( "Unknown class id " + classId + " in _classRecvGen" );
		}
	}
// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/_LocalGameList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/_LocalGameList'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/_LocalGameList'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class _LocalGameList
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Time = require('NGCore/Client/Core/Time').Time;
var toMD5 = require('NGCore/Client/Core/toMD5').toMD5;
var Util = require('NGCore/Client/Network/Util').Util;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

////////////////////////////////////////////////////////////////////////////////

exports._LocalGameList = Class.singleton (
/** @lends Core._LocalGameList.prototype */
{
	classname: '_LocalGameList',

	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this.mGameList = [];
		var Storage = require('NGCore/Client/Storage').Storage;
		this.mFile = Storage.FileSystem;
		this.mGameStore = Storage.KeyValueCache.global("Core.GameList");

		this.mLoadingGames = {};
		this.mActiveGameKey = "activeGames";
		this.mRequiredAvailableSpace = 0;
		this.mSpaceAvailable = 0;
		this.mSpaceFreeCallbacks = [];
		this._firstBootGameLaunch = true;

		this._getRepoSpaceSendGen();

		this._setStage(this.ProgressStage.BootFirst);
		this._reloadGameList();
		this._allowDeterminateProgress = true;
	},
	
	ProgressStage:
	{
		BootFirst: {},
		CheckConfiguration: {},
		CheckManifest: {},
		DownloadFiles: {},
		Launching: {}
	},
	
	_setStage: function(stage)
	{
		this._progressStage = stage;
		switch(stage)
		{
			case this.ProgressStage.BootFirst:
				console.log('setStage BootFirst');
				this._progressMin = -1;
				this._progressRange = 0;
				break;
			case this.ProgressStage.CheckConfiguration:
				console.log('setStage CheckConfiguration');
				this._progressMin = -1;
				this._progressRange = 0;
				break;
			case this.ProgressStage.CheckManifest:
				console.log('setStage CheckManifest');
				this._progressMin = -1;
				this._progressRange = 0;
				break;
			case this.ProgressStage.DownloadFiles:
				console.log('setStage DownloadFiles');
				this._progressMin = 0.1;
				this._progressRange = 0.9;
				break;
			case this.ProgressStage.Launching:
				console.log('setStage Launching');
				this._progressMin = -1;
				this._progressRange = 0;
				break;
			default:
				console.log('setStage ERROR');
				this._progressMin = -1;
				this._progressRange = 0;
		}
		console.log('min:', this._progressMin, 'range:', this._progressRange);
		this._setProgress(0);
	},
	
	_nextStage: function()
	{
		switch(this._progressStage)
		{
			case this.ProgressStage.BootFirst:
				this._setStage(this.ProgressStage.CheckConfiguration);
				break;
			case this.ProgressStage.CheckConfiguration:
				this._setStage(this.ProgressStage.CheckManifest);
				break;
			case this.ProgressStage.CheckManifest:
				this._setStage(this.ProgressStage.DownloadFiles);
				break;
			case this.ProgressStage.DownloadFiles:
				this._setStage(this.ProgressStage.Launching);
				break;
		}
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 303
	// Method create = -1
	// Method updateGame = 2
	// Method updateDone = 3
	// Method getRepoSpace = 4
	// Method repoSpace = 5
	// Method deleteGame = 6
	// Method setUpdateProgress = 7
	// Method pauseUpdate = 8
	// Method resumeUpdate = 9
	// Method cancelUpdate = 10
	// Method updateProgress = 11
	// Method allowBGUpdates = 12
	// Method runGame = 13
	// Method finishGame = 14
	// Method setProgressText = 15
	// Method setSplashVisible = 16
	// Method exceptionForwarded = 17
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._updateGameRecv( cmd );
					break;
				case 5:
					instance._repoSpaceRecv( cmd );
					break;
				case 6:
					instance._deleteGameRecv( cmd );
					break;
				case 8:
					instance._pauseUpdateRecv( cmd );
					break;
				case 9:
					instance._resumeUpdateRecv( cmd );
					break;
				case 10:
					instance._cancelUpdateRecv( cmd );
					break;
				case 12:
					instance._allowBGUpdatesRecv( cmd );
					break;
				case 13:
					instance._runGameRecv( cmd );
					break;
				case 14:
					instance._finishGameRecv( cmd );
					break;
				case 17:
					instance._exceptionForwardedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in _LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in _LocalGameList._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[303] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_updateGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.updateGame from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.updateGame from command: " + cmd );
			return false;
		}
		
		obj[ "id" ] = Proc.parseInt( cmd[ 1 ] );
		if( obj[ "id" ] === undefined )
		{
			NgLogE("Could not parse id in _LocalGameList.updateGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_repoSpaceRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		obj[ "space" ] = Proc.parseInt( cmd[ 0 ] );
		if( obj[ "space" ] === undefined )
		{
			NgLogE("Could not parse space in _LocalGameList.repoSpace from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_deleteGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.deleteGame from command: " + cmd );
			return false;
		}
		
		obj[ "mdFive" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "mdFive" ] === undefined )
		{
			NgLogE("Could not parse mdFive in _LocalGameList.deleteGame from command: " + cmd );
			return false;
		}
		
		obj[ "game" ] = Proc.parseString( cmd[ 1 ] );
		if( obj[ "game" ] === undefined )
		{
			NgLogE("Could not parse game in _LocalGameList.deleteGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_pauseUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.pauseUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.pauseUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_resumeUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.resumeUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.resumeUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_cancelUpdateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.cancelUpdate from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.cancelUpdate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_allowBGUpdatesRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.allowBGUpdates from command: " + cmd );
			return false;
		}
		
		obj[ "allow" ] = Proc.parseBool( cmd[ 0 ] );
		if( obj[ "allow" ] === undefined )
		{
			NgLogE("Could not parse allow in _LocalGameList.allowBGUpdates from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_runGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.runGame from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in _LocalGameList.runGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_finishGameRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.finishGame from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_exceptionForwardedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in _LocalGameList.exceptionForwarded from command: " + cmd );
			return false;
		}
		
		obj[ "exceptionString" ] = Proc.parseString( cmd[ 0 ] );
		if( obj[ "exceptionString" ] === undefined )
		{
			NgLogE("Could not parse exceptionString in _LocalGameList.exceptionForwarded from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Proc.appendToCommandString( ":303,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_updateDoneSendGen: function( id, error )
	{
		Proc.appendToCommandString( ":303,3," + this.__objectRegistryId + "," + id + "," + Base64.encode( error )  );
	},
	
	/** @private */
	_getRepoSpaceSendGen: function(  )
	{
		Proc.appendToCommandString( ":303,4," + this.__objectRegistryId );
	},
	
	/** @private */
	_setUpdateProgressSendGen: function( progress )
	{
		Proc.appendToCommandString( ":303,7," + this.__objectRegistryId + "," + progress  );
	},
	
	/** @private */
	_updateProgressSendGen: function( url, cur, total, error )
	{
		Proc.appendToCommandString( ":303,11," + this.__objectRegistryId + "," + Base64.encode( url ) + "," + cur + "," + total + "," + ( error ? 1 : 0 )  );
	},
	
	/** @private */
	_setProgressTextSendGen: function( text )
	{
		NgLogD("@@@ _LocalGameList _setProgressTextSendGen " + text);
	
		Proc.appendToCommandString( ":303,15," + this.__objectRegistryId + "," + Base64.encode( text )  );
	},
	
	/** @private */
	_setSplashVisibleSendGen: function( visible )
	{
		Proc.appendToCommandString( ":303,16," + this.__objectRegistryId + "," + ( visible ? 1 : 0 )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _updateGameRecv: function( cmd ) {}
	// updateDone: function( id, error ) {}
	
	// getRepoSpace: function(  ) {}
	
	// _repoSpaceRecv: function( cmd ) {}
	// _deleteGameRecv: function( cmd ) {}
	// setUpdateProgress: function( progress ) {}
	
	// _pauseUpdateRecv: function( cmd ) {}
	// _resumeUpdateRecv: function( cmd ) {}
	// _cancelUpdateRecv: function( cmd ) {}
	// updateProgress: function( url, cur, total, error ) {}
	
	// _allowBGUpdatesRecv: function( cmd ) {}
	// _runGameRecv: function( cmd ) {}
	// _finishGameRecv: function( cmd ) {}
	// setProgressText: function( text ) {}
	
	// setSplashVisible: function( visible ) {}
	
	// _exceptionForwardedRecv: function( cmd ) {}

// {{/Wg Generated Code}}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_updateGameRecv: function( cmd )
	{
		this._getRepoSpaceSendGen();

		var o = {};
		this._updateGameRecvGen(cmd, o);

		if (o.url in this.mLoadingGames)
		{
			this.mLoadingGames[o.url].id = o.id;
			this.mLoadingGames[o.url].dlman.resume();
		}
		else
		{
			this.updateGame(o.url, o.id,
				(function (url, newFiles, err)
				{
					o.id = this.mLoadingGames[url].id;
					this._updateDoneSendGen(o.id, err);
				}).bind(this, o.url)
			);
		}
	},
	mobageRunGame: function (funk)
	{
		this._gameRunner = funk;
	},
	_runGameRecv: function( cmd )
	{
		var o = {};
		this._runGameRecvGen(cmd, o);
		if (this._gameRunner)
		{
			console.log("_LGL running gameRunner " + o.url);
			this._gameRunner(o.url);
		}
		else
		{
			console.log("_LGL running game " + o.url);
			var _int_LGL = require('NGCore/Client/Core/_int_LGL')._int_LGL;
			_int_LGL.launch(o.url, _int_LGL.ProcID.Game);
		}
	},
	/**
	 * set the function that kills the current game app
	 */
	setFinishGameHandler: function(funk)
	{
		this._finishGameHandler = funk;
	},
	_finishGameRecv: function()
	{
		if (this._finishGameHandler)
		{
			this._finishGameHandler();
		} else {
			console.log("_LocalGameList: finishGameHandler is not set");
		}
	},
	_repoSpaceRecv: function( cmd )
	{
		var obj = {};
		this._repoSpaceRecvGen(cmd, obj);
		this.mSpaceAvailable = obj.space;
		console.log("SD card space available(b): " + this.mSpaceAvailable);

		var length = this.mSpaceFreeCallbacks.length;
		while (length--)
		{
			(this.mSpaceFreeCallbacks.pop())();
		}
	},

	_deleteGameRecv: function( cmd )
	{
		// site to calc md5: http://pajhome.org.uk/crypt/md5/
		var allowedGames =
		[
			"http://10.15.", // Allow partial ones, for testing
			'http://gamehub.mobage.com/app/1.0s/gamehub',
			'url of allowed game'
		];

		var obj = {};
		this._deleteGameRecvGen(cmd, obj);
		var i;
		for(i in allowedGames)
		{
			var match = obj.game.match(allowedGames[i]);
			if(match && !match.index)
			{
				NgLogD("Deleting " + obj.mdFive);
				this.deleteGameFiles(obj.mdFive);

				var doneCB = (function ()
				{
					NgLogD("Finished deleting game from " + this.mActiveGameKey + " for " + obj.mdFive );
				}).bind(this);
				this._deleteGameFromStorage(obj.mdFive,doneCB);

				return;
			}
			else
			{
				// for testing, allow any local server starting with 10.15
			}
		}
		NgLogE("_LocalGameList unauthorized call to deleteGame from "+obj.game+"!");
	},

// _deleteGameFromStorage is for deleting the games info from LGL storage, not the game's storage

	_deleteGameFromStorage: function(mdFive,doneCB)
	{
		var self = this;
		this.mGameStore.getItem(this.mActiveGameKey,
			function(error, value)
			{
				var list = JSON.parse(value);
				
				var good = false;
				var ind;
				var out = [];
				for(ind = 0; ind < list.length; ++ind)
				{
					if(list[ind].name == mdFive)
						good = true;
					else
						out.push(list[ind]);
				}
				
				if( good )
				{
					NgLogD("_LocalGameList found and removed " + mdFive);
					self.mGameStore.setItem(self.mActiveGameKey, JSON.stringify(out), doneCB);
				}
				else
				{
					NgLogD("_LocalGameList failed to find and remove " + mdFive);
					doneCB("Could not remove item: " + error);
				}
				
			}, true
		);
	},

	getGameConfig: function(identifier, isMDFive, callBack)
	{
		if (typeof isMDFive == 'function')
		{
			callBack = isMDFive;
			isMDFive = false;
		}

		var folder;
		if (isMDFive)
		{
			folder = identifier;
		}
		else
		{
			var Util = require('NGCore/Client/Network/Util').Util;
			var norm = Util.NormalizeUrl(identifier);
			folder = toMD5(norm);
		}

		NgLogD("@@@ _LocalGameList.getGameConfig readFile +");

		this.mFile.readFile(folder + "/" + Capabilities._getConfigFile(),
			function (err, contents)
			{
				NgLogD("@@@ _LocalGameList.getGameConfig readFile -");
				
				var ret = {};
				if (err || !contents)
				{
					console.log("Could not get config from %s! err: %s", identifier, err);
				}
				else
				{
					ret = JSON.parse(contents);
				}
				callBack(ret);
			}
		);
	},

	getRepoSpace: function()
	{
		return this.mSpaceAvailable;
	},

	getConfig: function(gameOrigin, name, callback, failEarly)
	{// callback = function (config, err)
		// XHR
		var XHR = require('NGCore/Client/Network/XHR').XHR;
		var Util = require('NGCore/Client/Network/Util').Util;
		
		var httpStatus = 0;
		
		Util.OperationWithRetries(function(failCb)
		{
			var req = new XHR();
			req.onreadystatechange = function()
			{
				if(req.readyState == 4)
				{
					httpStatus = req.status;
					if(httpStatus == 200)
					{
						// Succes.
						callback(req.responseText);
					}
					else if(httpStatus == 404)
					{
						// File not on server, so load from the regular location
						console.log("no configuration file found at %s, using root server", gameOrigin + name);
						callback( "{}" );
					}
					else
					{
						//Error! Retry
						failCb();
					}
				}
			};

			req.open('GET', gameOrigin + name + Util.getCacheBustingString(), true);
			req.send();
		}, function()
		{
			callback(null, true, httpStatus);
		}, failEarly);
	},

	// gameOrigin: url to folder holding webgame.ngmanifest
	// doneCB = function(totalBytes, error)
	updateGame: function(gameOrigin, id, doneCB, failEarly, failAllowed)
	{
		// console.log ( "LGL.updateGame url = " + gameOrigin );
		// console.log ( "LGL.updateGame boot game = " + Capabilities.getBootGame() );
		
		var re = new RegExp(".*" + Capabilities.getBootGame());
		var match = gameOrigin.match(re);
		
		if (match) 
			this._firstBootGameLaunch = false;
			
		// console.log ( "_LocalGameList.updateGame updating game." );

		// Normalize URL
		var Util = require('NGCore/Client/Network/Util').Util;
		gameOrigin = Util.NormalizeUrl(gameOrigin);

		var name = Util.GetMD5HashDirectoryFromUrl(gameOrigin);
		this.mLoadingGames[gameOrigin] = {id: id};

		NgLogI("_LocalGameList.updateGame(): url = " + gameOrigin + " name = " + name);

		// Get device-specific manifest directory
		var buildPath = {"Android" : "android", "iPhone OS" : "ios", "flash" : ""};
		// Get Device capabilities platformOs
		var caps = require('NGCore/Client/Core/Capabilities').Capabilities;
		var build = "/" + buildPath[caps.getPlatformOS()];

		this._setStage(this.ProgressStage.CheckConfiguration);

		var curContUrl = "";
		var configFile = name + "/" + caps._getConfigFile();
		
		// This is guaranteed to be synchronous, so will always occur before the callback for subsequent operations.
		this.mFile.readFile(configFile,
			function(err, data)
			{
				if (data)
				{
					var obj = JSON.parse(data);
					curContUrl = obj.contentUrl;
				}
			}
		);

		var url = gameOrigin + build + "/" + caps._getConfigFile();
		NgLogI("_LocalGameList.updateGame(): downloading configuration.json, url = " + url);
		this.getConfig(gameOrigin + build, "/" + caps._getConfigFile(),
        (function(config, error, status)
		{
			if (error)
			{
				NgLogI("_LocalGameList.updateGame(): ERROR downloading configuration.json, url = " + url);
				this._setStage(-1); // ERROR
				doneCB(0, error);
				delete this.mLoadingGames[gameOrigin];
			}
			else
			{
				// Read config
				var parsedConfig = JSON.parse(config);
				if(!parsedConfig.contentUrl)
				{
					parsedConfig.contentUrl = gameOrigin + build;
				}
				else if (parsedConfig.contentUrl == curContUrl)
				{
					NgLogI("_LocalGameList.updateGame(): Game is up to date! url = " + url);

					// no need to update.
					this._setStage(this.ProgressStage.Launching);
					this.mFile.writeFile(configFile, JSON.stringify(parsedConfig),
						function(err) {console.log(err); } );
					doneCB(0);
					delete this.mLoadingGames[gameOrigin];
					return;
				}

				NgLogI("_LocalGameList.updateGame(): Downloading game! url = " + url);
				this._setStage(this.ProgressStage.CheckManifest);
				this._callDownloadManifest(parsedConfig, gameOrigin, name, failEarly, failAllowed, (function(bytes, error)
				{
					NgLogI("_LocalGameList.updateGame(): Finished Downloading game! url = " + url);

					if (! error) {
						var that = this;
						this._reloadGameList({name:name, url:gameOrigin}, function()
						{
							if (doneCB && (typeof doneCB == 'function')) {
								doneCB(bytes, error);
								delete that.mLoadingGames[gameOrigin];
							}
						});
					} else {
						doneCB(bytes, error);
						delete this.mLoadingGames[gameOrigin];
					}
				}).bind(this));
			}
		}).bind(this), failEarly);
	},

	_allowBGUpdatesRecv: function( cmd )
	{
		var o = {};
		this._allowBGUpdatesRecvGen(cmd, o);
		this._pauseOrResumeAll(o.allow);
	},

	_pauseOrResumeAll: function(resume)
	{
		for (i in this.mLoadingGames)
		{
			if (resume)
			{
				console.log("Resuming download of " + i);
				this.resumeUpdate(i);
			}
			else
			{
				console.log("Pausing download of " + i);
				this.pauseUpdate(i);
			}
		}
	},

	pauseUpdate: function(url)
	{
		if (this.mLoadingGames[url])
		{
			if(this.mLoadingGames[url].dlman)
			{
				this.mLoadingGames[url].dlman.pause();
				this.mLoadingGames[url].userPause = true;
			}
		}
	},

	_pauseUpdateRecv: function(cmd)
	{
		var o = {};
		this._pauseUpdateRecvGen(cmd, o);
		this.pauseUpdate(o.url);
	},

	resumeUpdate: function(url)
	{
		if (this.mLoadingGames[url])
		{
			if(this.mLoadingGames[url].dlman)
			{
				this.mLoadingGames[url].dlman.resume();
				this.mLoadingGames[url].userPause = false;
			}
		}
	},

	_resumeUpdateRecv: function(cmd)
	{
		var o = {};
		this._resumeUpdateRecvGen(cmd, o);
		this.resumeUpdate(o.url);
	},

	cancelUpdate: function(url)
	{
		if (this.mLoadingGames[url])
		{
			if (this.mLoadingGames[url].dlman) {
                this.mLoadingGames[url].dlman.abort();
            }
			delete this.mLoadingGames[url];

			//Cancel the keep alive request as well
			var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;

            this.identification_key = 'manifest_download';
            LifecycleEmitter.cancelEngineKeepAlive(this);
		}
	},

	_cancelUpdateRecv: function(cmd)
	{
		var o = {};
		this._cancelUpdateRecvGen(cmd, o);
		this.cancelUpdate(o.url);
	},

	_setProgress: function (progress) {
		if(progress > 1) progress = 1;
		// Indeterminate
		if(progress < 0) progress = -1;
		this._progress = progress;
		if (progress >= 0 && this._allowDeterminateProgress) {
			this._setUpdateProgressSendGen( this._progressMin + progress * this._progressRange );
		} else {
			this._setUpdateProgressSendGen(-1);
		}
	},
	
	_setAllowDeterminateProgress: function (allow) {
		this._allowDeterminateProgress = allow;
		this._setProgress(this._progress);
	},

	listenToProgress: function (listener)
	{
		this._privListener = listener;
	},

	_updateProgress: function(url, prog, total, err)
	{
		//console.log("Updating progress for: %s, %d, %d " + err, url, prog, total);
		if (this._privListener)
			this._privListener(url, prog, total, err);

		if (this.mLoadingGames[url] && this.mLoadingGames[url].id >=0)
			this._updateProgressSendGen(url,prog,total,err);
	},

	// doneCB = function(totalBytes, error)
	_callDownloadManifest: function (config, gameOrigin, name, failEarly, failAllowed, doneCB)
	{
		var contentUrl = config.contentUrl;
		var reportTotalBytes = 0;
		var self = this;
		var Downloader = require('NGCore/Client/Network/DownloadManifest').DownloadManifest;
		
		var manifestName = require('NGCore/Client/Core/_int_LGL')._int_LGL.getManifestName(config);

		// Do download
		(function doDownload()
		{
			var dler = new Downloader();
			dler.mLocalGameList = self;
			var firstProgress = true;
            var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
            this.identification_key = 'manifest_download';
            NgLogD("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Manifest Download Request Keep Engine Alive");
            LifecycleEmitter.requestEngineKeepAlive(this);
			// Only allow this on iOS
			config.omitJsUpdate = config.omitJsUpdate && (Capabilities.getPlatformOS() == "iPhone OS");
			dler._setConfig(config);
			dler.start(contentUrl, name, {'webgame.ngmanifest':manifestName}, function(bytesDownloaded, bytesTotal)
			{
				if(firstProgress)
				{
					// First progress callback is made when manifest is downloaded.
					firstProgress = false;
					self._setStage(bytesDownloaded < bytesTotal ? self.ProgressStage.DownloadFiles : self.ProgressStage.Launching);
					reportTotalBytes = bytesTotal;
				}
				else
				{
					self._setProgress( bytesDownloaded / bytesTotal );
				}

				// update LGL
				self._updateProgress(gameOrigin, bytesDownloaded, bytesTotal);
			}, function(error, manifest, wasCached)
			{
				if (failAllowed)
				{
					if (doneCB)
					{
						doneCB(reportTotalBytes, error);
					}
				}
				else if(error)
				{
					NgLogE("Error: " + error);
					// update LGL
					self._updateProgress(gameOrigin, 0, 0, error);
					doneCB(0, error);
				}
				else
				{
					if (doneCB)
					{
						doneCB(reportTotalBytes);
					}
				}

                this.identification_key = 'manifest_download';
                LifecycleEmitter.cancelEngineKeepAlive(this);
			}, false, failEarly);
			self.mLoadingGames[gameOrigin].dlman = dler;
		})();
	},

	freeSpace: function(space, cb)
	{
		this.mRequiredAvailableSpace = space;
		this.mSpaceFreeCallbacks.push(
			(function()
			{
				if (this.mRequiredAvailableSpace > this.mSpaceAvailable)
				{
					if (this._privListener)
					{
						this._privListener("", 0, 0, "SD card is full");
					}
					else
					{
						console.log("Warning!! Mobage is not handling SD card full error!");
						// This is Preservation of ancient code which has and will likely never execute
						var checkAgain = function()
						{
							if (this.mRequiredAvailableSpace > this.mSpaceAvailable)
							{
								this.pruneGames(1);
								this.mSpaceFreeCallbacks.push(checkAgain);
							}
							else
							{
								cb();
							}
						};
						// Is a redundant check on space, but looks better/is simpler/won't ever be used anyhow
						checkAgain();
					}
				}
				else
				{
					cb();
				}
			}).bind(this)
		);

		this._getRepoSpaceSendGen();
	},

	pruneGames: function(number)
	{
		var self = this;

		// Function to put oldest games on top of the stack
		var sort = function (l, r)
		{
			return r.lastRun - l.lastRun;
		};

		this.mGameStore.getItem(this.mActiveGameKey,
			function(error, value)
			{
				var list = JSON.parse(value);
				list.sort(sort);
				while (number-- && (list.length - 1))
				{
					var game = list.pop();

					// Do not delete the currently loading game
					if (!(game.name in self.mLoadingGames))
					{
						// delete game
						self.deleteGameFiles(game.name);
					}
					else
					{
						list.push(game);
					}
				}

				// Save the data
				self.mGameStore.setItem(self.mActiveGameKey, JSON.stringify(list));
			}, true
		);
	},

	deleteGame: function (url, callBack)
	{
		var Util = require('NGCore/Client/Network/Util').Util;
		var norm = Util.NormalizeUrl(url);
		var mdFive = toMD5(norm);

		this.deleteGameFiles(mdFive);
		this._deleteGameFromStorage(mdFive, callBack);
	},

	// Delete the KeyValueCache.local of the given game
	deleteGameKeyValue: function(mdFive)
	{
		var kvm = require('NGCore/Client/Storage').KeyValueCache;
		kvm.global(mdFive).clear();
	},

	deleteGameFiles: function(game)
	{
		var self = this;
		self.mFile.deleteFile( game , 
			function(err)
				{
					if(err == "" )
						NgLogI('Deleted');
					else
						NgLogD("Could not delete game");

					self._getRepoSpaceSendGen();
				});
	},

	getGameList: function()
	{
		return this.mGameList;
	},

	clearWatch: function()
	{
		var fs = require('NGCore/Client/Storage/FileSystem').FileSystem;
		fs.deleteFile(".watch");
	},

	/**
	 * @private
	 */
	_reloadGameList: function(newItem, cb)
	{
		this.mGameStore.getItem(this.mActiveGameKey,
			(function(error, value)
			{
				var list;
				if (value)
					list = JSON.parse(value);
				else
					list = [];

				if (newItem)
				{
					var bNew = true;
					for (var i in list)
					{
						if (list[i].name == newItem.name)
						{
							bNew = false;
							newItem.lastRun = list[i].lastRun;
							list[i] = newItem;
							break;
						}
					}

					if (bNew)
					{
						list.push(newItem);
					}
					this.mGameStore.setItem(this.mActiveGameKey, JSON.stringify(list));
				}

				this.mGameList = list;

				if (typeof cb == 'function')
					cb();
			}).bind(this),
			true
		);
	},

	_getRunningGame: function(callBack)
	{
		// Function to put oldest games on top of the stack
		var sort = function (l, r)
		{
			return r.lastRun - l.lastRun;
		};

		this._reloadGameList(false, (function(cb)
		{
			var list = this.mGameList;
			list.sort(sort);
			var current = null;
			var len = list.length;
			for (var i = 0; i < len; ++i)
			{
				if (list[i].lastRun)
				{
					current = list[i];
					break;
				}
			}
			if (current && current.url)
				cb(current.url);
		}).bind(this, callBack));
	},

	/** @private */
	_pausingGame: function()
	{
		// true to resume download when pausing a game
		this._pauseOrResumeAll(true);
	},

	/** @private */
	_resumingGame: function()
	{
		// Check if the current game allows downloading
		this._getRunningGame((function(game)
		{
			this.getGameConfig(game, (function(config)
			{
				if (config.noBackgroundUpdates)
				{
					// false to pause download when resuming a game
					this._pauseOrResumeAll(false);
				}
			}).bind(this));
		}).bind(this));
	},

	setSplashVisible: function( visible )
	{
		this._setSplashVisibleSendGen(visible);
	},

	setProgressText: function( text )
	{
		this._progressText = text;
		this._setProgressTextSendGen(text);
	},

	updateAvailable: function(game, doneCB, errorCB)
	{
		var _int_LGL = require('NGCore/Client/Core/_int_LGL')._int_LGL;
		_int_LGL.updateAvailable(game, doneCB, errorCB);
	},

	/*
	 * Set the exception handler. Default is undefined.
	 * @param {Function} the function that handles the exception occurred in the Game proc. signature: function(exceptionString)
	 */
	setExceptionHandler: function(func)
	{
		this._exceptionHandler = func;
	},

	_exceptionForwardedRecv: function( cmd )
	{
		var obj = {};
		this._exceptionForwardedRecvGen(cmd, obj);
		try {
			var exception = JSON.parse(obj.exceptionString);
		} catch (e) {
			console.log("ERROR: Unparseable exception: " + obj.exceptionString);
		}
		
		if (this._exceptionHandler)
			this._exceptionHandler(exception);
		else
			NgLogException(exception);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/NativeAppLaunch'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/NativeAppLaunch'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/NativeAppLaunch'] = exports; // @deprecated
var NativeAppLaunch;

exports.NativeAppLaunch = NativeAppLaunch;; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/NgPipe'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/NgPipe'] || {}; $MODULE_REGISTRY['NGCore/Shared/NgPipe'] = exports; var Class = require('NGCore/Shared/Class').Class;
var NgPipesRemote = require('NGCore/Shared/NgPipesRemote').NgPipesRemote;
var hex_sha1 = require('NGCore/Shared/Lib/sha1').hex_sha1;
var __hasProp = Object.prototype.hasOwnProperty;
var CapabilitiesReq = require('NGCore/Client/Core/Capabilities');

/*
The NgPipes object
*/

NgPipe = Class.subclass({
    classname: "NgPipe",
    initialize: function(options) {
        options = options || {};
		/*
		 * Note that this require statement cannot be put at the top level
		 * because it will cause code to fail to execute.  It's an intricacy
		 * in our require system.
		 */
		this._socAnalytics = require('NGCore/Client/Social').Social.Common.Analytics;
        this._meta = options.meta || {};
        this._queue = null;
        this._isSendQueued = false;
        this._sendDelay = options.sendDelay || 5000;
        this._meta = options.meta || {};
        this._seqStart = options.seqStart || new Date().getTime();
        this._playerState = options.playerState || null;
        this._seqNumber = options.seqNumber || 0;
        this._allowedLargeValue = {
            msg: 1024 * 5,
            err: 1024 * 5,
            sid: 64,
            udid: 64
        };

        this._sendToRemote = true;
        this._globalKey = '__PipeKey';
        var self = this;
        var cb = function(error,value, key) {
            var new_queue = [];
            if (!error) {
                try {
                    new_queue = JSON.parse(value);
                } catch(e) {
                    new_queue = [];
                }
            }

            if (self._queue) {
                new_queue = self._queue.concat(new_queue);
            }

            self._setQueue(new_queue);
            if (self._queue.length > 0 ){
                self._drainQueue();
            }
        };
        this._locListener = null;
        this._location = null;
        Storage.KeyValueCache.global(this._globalKey).getItem(this._globalKey, cb);
        var starting_queue = [].concat(options.queue || []);
        this._queue = starting_queue;
        this._sessionEnded = false;
        this._capAlphaNumStringKeys = ['afam', 'asku', 'srcty', 'evcl', 'evid', 'pltfmsku','carr','srv'];
        this.sessionStartEvent();
        this._tagQa();
        this._hookLifetime();
        this._hookGeo();
        return true;
    },

    close: function() {
        this._drainQueue();
        return true;
    },

    enable: function() {
        this._sendToRemote = true;
    },

    disable: function() {
        this._sendToRemote = false;
    },

    setRemoteUrl: function(url) {
        NgPipesRemote.setUrl(url);
    },

    playerEvent: function(eventId, evcl, change, playerState) {
        var e;
        evcl || (evcl = "PLST");
        e = {
            change: change,
            srcty: 'GC',
            evid: eventId,
            evcl: evcl,
            plst: this._getPlayerStateDiff(playerState || this._playerState)
        };
        this._queueMessage(e);
        this._setCurrentPlayerState(playerState);
        return e;
    },
    gameEvent: function(eventId, payload, playerState) {
        var e;
        e = {
            evid: eventId,
            evpl: payload,
            srcty: 'GC',
            evcl: 'GAME'
        };

        if (playerState) {
          e.plst = this._getPlayerStateDiff(playerState || this._playerState);
        }
        this._queueMessage(e);
        return e;
    },
    gameOpsEvent: function(eventId, payload) {
        var e;
        e = {
            evid: eventId,
            evpl: payload,
            srcty: 'GC',
            evcl: 'GAMEOPS'
        };
        this._queueMessage(e);
        return e;
    },
    revenueEvent: function(eventId, payload) {
        var e;
        e = {
            evcl: 'REV',
            evid: eventId,
            srcty: 'PC',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    uiEvent: function(eventId, payload) {
        var e;
        e = {
            evcl: 'UI',
            srcty: 'GC',
            evid: eventId,
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    funnelEvent: function(eventId, payload, playerState) {
        var e;
        e = {
            evcl: 'FUNNEL',
            srcty: 'GC',
            evid: eventId,
            evpl: payload
        };

        if (playerState) {
          e.plst = this._getPlayerStateDiff(playerState || this._playerState);
          this._setCurrentPlayerState(playerState);
        }
        this._queueMessage(e);
        return e;
    },
    plusEvent: function(eventId, payload) {
        var e;
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            evid: eventId,
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    plusUIEvent: function(eventId, payload) {
        var e = {
            evcl: 'PLUSUI',
            srcty: 'PC',
            evid: eventId,
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },
    navigationEvent: function(fromScreen, toScreen, buttonID){
        var payload = {};
        payload.fro = fromScreen;
        payload.to  = toScreen;
        if(buttonID){
            payload.btnid = buttonID;
        }

        return this.plusUIEvent("NAV", payload);
    },
    sessionEndEvent: function() {
        if (!(this._sessionEnded)) {
            var e;
            var Capabilities = CapabilitiesReq.Capabilities;

            e = {
                evid:  'SFN',
                evcl:  'PLUS',
                srcty: 'PC',
                hwty:  Capabilities.getDeviceName(), // cat ro.product.manufacturer, ro.product.brandh, ro.product.model
                hwrev: Capabilities.getPlatformHW(), // cat ro.revision + ro.build.date.utc
                osrev: ""+  Capabilities.getPlatformOS() + " " + Capabilities.getPlatformOSVersion(), // ro.build.fingerprint
                lang: Capabilities.getLanguage()
            };

            e = this._queueMessage(e);
            this._sessionEnded = true;
            return e;
        }
        return null;
    },
    sessionStartEvent: function() {
        var e;
        var Capabilities = CapabilitiesReq.Capabilities;

        e = {
            evid:  'SST',
            evcl:  'PLUS',
            srcty: 'PC',
            hwty:  Capabilities.getDeviceName(), // cat ro.product.manufacturer, ro.product.brandh, ro.product.model
            hwrev: Capabilities.getPlatformHW(), // cat ro.revision + ro.build.date.utc
            osrev: ""+  Capabilities.getPlatformOS() + " " + Capabilities.getPlatformOSVersion(), // ro.build.fingerprint
            lang: Capabilities.getLanguage()
        };



        e = this._queueMessage(e);
        return e;
    },
    socialEvent: function(eventId, friendId,  payload) {
        var e;
        e = {
            evcl: 'SOCL',
            srcty: 'GC',
            frid: friendId,
            evid: eventId,
            evpl: payload
        };
        return this._queueMessage(e);
    },
    initPlayerState: function(inState) {
        this._setCurrentPlayerState(inState);
        return true;
    },

    updatePlayerState: function(newState) {
        this._setCurrentPlayerState(newState);
        return true;
    },

    //params for internal IAP events:

    //promo campaign unique identifier
    //promoid (String)

    //price of virtual good
    //price (Float)

    //currency used. Defaults to USD
    //cur (String)

    //user's moba balance after purchase
    //mobabalance (Integer)

    //unique identifier for purchase
    //orderid (String)

    //a string identifier for an item, e.g. "IceCastle"
    //sku (String)

    //the value of the item in moba
    //mobaprice (Float)

    //the quantity of item being purchased
    //itemamt (Float)

    //a text description of the item.
    //desc (String)

    //a message displayed to the user when the debit or credit occurs
    //dispmsg (String)

    //the name of the item, as displayed to the user
    //dispname (String)

    //the Mobage ID for the product.
    //productid (Integer)

    //dynamic data accepts a custom object with any params not included above
    //dynamicdata (Object)

    reportAdShow : function(adid) {
        return this.revenueEvent('ADSHOW',{'adid':adid});      
    },

    reportAdClick : function(adid) {
        return this.revenueEvent('ADCLCK',{'adid':adid});    
    },

    reportPromoShow : function(promoid) {
        return this.revenueEvent('PROMOSHOW',{'promoid':promoid});    
    },

    reportPromoClick : function(promoid) {
        return this.revenueEvent('PROMOCLCK',{'promoid':promoid});    
    },

    reportPromoRedeem : function(promoid) {
        return this.revenueEvent('PROMOREDM',{'promoid':promoid});    
    },

    //user clicks on money sku
    reportMoneyIAPIntent : function(sku,item_amt,price,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPINTENT', evpl);
    },

    //user cancels a money sku transaction
    reportMoneyIAPCancel : function(sku,item_amt,price,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPCANCEL', evpl);
    },

    //money sku transaction is successful; orderid required
    reportMoneyIAPSuccess : function(sku,item_amt,price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            orderid : orderid,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPSUCCESS',evpl);
    },

    //money iap purchase fails after being authorized by user; orderid optional if available, pass in null otherwise
    reportMoneyIAPFail : function(sku,item_amt,price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,cur,dynamicdata) {
        var evpl = {
            sku : sku,
            itemamt : item_amt,
            productid: product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance,
            amt : price,
            cur : cur || 'USD'
            };
        orderid ? evpl.orderid = orderid : "";
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('IAPFAIL', evpl);
    },

    //user opens money IAP store
    reportMoneyIAPShow : function() {
        return this.revenueEvent('IAPSHOW',{});
    },

    //user opens moba IAP store
    reportMobaIAPShow : function() {
        return this.revenueEvent('MOBAIAPSHOW',{});
    },

    //user clicks on a moba sku
    reportMobaIAPIntent : function(sku,moba_price,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPINTENT', evpl);
    },

    //user cancels moba sku transaction
    reportMobaIAPCancel : function(sku,moba_price,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPCANCEL', evpl);
    },

    //moba sku transaction is successful. orderid required. 
    reportMobaIAPSuccess : function(sku,moba_price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            orderid : orderid,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPSUCCESS', evpl);
    },

    //moba sku purchase fails after being authorized by user. orderid optional if available, pass in null otherwise
    reportMobaIAPFail : function(sku,moba_price,orderid,product_id,display_name,user_end_moba_balance,description,display_message,dynamicdata) {
        var evpl = {
            sku : sku,
            mobaprice : moba_price,
            productid : product_id,
            //desc : description,
            dispmsg : display_message,
            dispname : display_name,
            mobabalance : user_end_moba_balance
            };
        orderid ? evpl.orderid = orderid : '';
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        return this.revenueEvent('MOBAIAPFAIL', evpl);
    },

    /**
    * Report us scraping a facebook user's profile - ext_id is the user's facebook ID.
    *
    */
    reportFacebookScrape : function(ext_id, dynamicdata) {
        var e;
        var evpl={};
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            extid: ext_id,
            evid: 'FBSCRAPE',
            evpl: evpl
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * Report us scraping a user's contact list - ext_id is the user's facebook ID.
    *
    */
    reportContactScrape : function(dynamicdata) {
        var e;
        var evpl={};
        dynamicdata ? evpl.dynamicdata = dynamicdata : '';
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            evid: 'CONTACTSCRAPE',
            evpl: evpl
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * Report a user posting to another user's wall.
    *
    */
    reportWallPost : function(friendId, payload) {
        var e;
        e = {
            evcl: 'SOCL',
            srcty: 'PC',
            frid: friendId,
            evid: 'WALLPOST',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * Report a user downloading a game from a specific section in the store.
    * @param {String} game is the asku for the game being downloaded.
    * @param {String} section is the name of the section that the user downloaded from:
    *   AllGames, FeaturedGames, MyProfile, FriendsLastPlayedGame, FriendsPlayingGame
    * @param {String} slot is the order of the game in the section (if applicable)
    */
    reportDownload : function(game, section, slot) {
        var payload = {};
        payload.game = game;
        payload.section = section;
        payload.slot = slot;
        var e;
        e = {
            evcl: 'PLUS',
            srcty: 'PC',
            evid: 'DOWNLOAD',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },

    /**
    * add internal tag to a user.
    */
    addTag : function(tagName) {
        var payload = {};
        payload.tag = tagName;
        var e;
        e = {
            evcl: 'PLUS',
            evid: 'TAG', 
            srcty: 'PC',
            evpl: payload
        };
        this._queueMessage(e);
        return e;
    },

    getSeqNumber: function() {
        this._seqNumber += 1;
        return this._seqNumber;
    },

    getQueueCount: function() {
        return this._queue.length;
    },

    getSendDelay: function() {
        return this._sendDelay;
    },

    setSendDelay: function(val) {
        return (this._sendDelay = val);
    },

    setMeta: function(key, value) {
        if (!value) {
            value = key;
            return (this._meta = value);
        } else {
            return (this._meta[key] = value);
        }
    },

    getMeta: function(key) {
        if (key) {
            return this._meta[key];
        } else {
            return this._meta;
        }
    },

    _queueMessage: function(msg) {
        if (!msg) {
            return false;
        }

        var self = this;

        //This sets metas that don't change often
        this._setUnsetMetaKeys();

        // The rest of these function set properties that 
        msg = this._mergeMeta(msg);
        msg = this._addSeqDetails(msg);
        msg = this._addGeo(msg);
        msg = this._addEvts(msg);
        msg = this._addGameSku(msg);
        msg = this._addGameRel(msg);
        msg = this._addCarrier(msg);
        msg = this._addService(msg);
        msg = this._addPlatformVersion(msg);
        msg = this._addUserId(msg);
        msg = this._addUserName(msg);
        msg = this._normalizeValues(msg);
        var queue = this._getQueue();
        queue.push(msg);
        this._setQueue(queue);

        if (!this._isSendQueued) {
            setTimeout(function() {
                self._isSendQueued = false;
                return self._drainQueue();
            }, self._sendDelay);
        }
        return msg;
    },
    _tagQa: function() {
        var fs = require('NGCore/Client/Storage/FileSystem').FileSystem;
        var self = this;
        fs.readFile('QA',function(err,data) {
            if (!err) {
                self.addTag("NGMOCOQA");
            }
        });
    },
    _hookGeo: function() {
        var Social = require('NGCore/Client/Social').Social;
        if(Social.US){
            var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
            var Device = require('NGCore/Client/Device').Device, self = this;
            var LocationListener = MessageListener.subclass({
                initialize: function() {
                    Device.LocationEmitter.addListener(this, this.onUpdate, false);
                },
                onUpdate: function(location) {
                    self._location = location;
                    Device.LocationEmitter.removeListener(this);
                    self._locListener = null;
                }
            });
            this._locListener = new LocationListener();
        }
    },
    _hookLifetime: function() {
        var self = this;
        var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
        var Device = require('NGCore/Client/Device').Device;
        var ListenerClass =  MessageListener.subclass({
            initialize: function() {
                Device.LifecycleEmitter.addListener(this, this.onLifecycleUpdate);
            },
            onLifecycleUpdate: function(event) {
                switch (event) {
                case Device.LifecycleEmitter.Event.Suspend:
                case Device.LifecycleEmitter.Event.Terminate:
                    self.sessionEndEvent();
					self._drainQueue();
                    break;
                }
            }
        });
        if (!this._listener) {
            this._listener = new ListenerClass();
        }
    },
    /**
    * Game Service running inside privileged interpreter may use this method
    * to change the Social Analytic object to be used.  Please see MOBWEST-2300
	* for details
	*
    * @private
    */
	_setSocialAnalytics: function(obj) {
		this._socAnalytics = obj;
	},
    _setUnsetMetaKeys: function() {
        var Capabilities = CapabilitiesReq.Capabilities, udid;
        if ((!this.getMeta('udid')) && (udid = Capabilities.getUniqueId() )) {
            this.setMeta('udid', udid);
        }

        if (!this.getMeta('sid')) {
            var sid = ''+ hex_sha1(this._seqStart+ (this.getMeta('udid')|| "UNKNOWN"));
            this.setMeta('sid', sid);
        }

        if (!this.getMeta('pltfmsku')) {
            var platRegex = /android/;

            var plat = Capabilities.getPlatformOS();
            if (plat) {
                plat = plat.toLowerCase();
                if (plat.match(platRegex) ) {
                    plat = "android";
                } else if ("flash" === plat ) {
                    plat = "flash";
                } else {
                    plat = "ios";
                }
                this.setMeta( 'pltfmsku', plat);
            }
        }

        if (!this.getMeta('apiver')) {
            this.setMeta('apiver', 5);
        }
        return true;
    },

    _getPlayerStateDiff: function(newState) {
        var delta_sign, delta_value, diff, key, value;
        diff = {};
        if (!this._playerState) {
            this._setCurrentPlayerState(newState);
        }
        for (key in newState) {
            if (!__hasProp.call(newState, key)) continue;
            value = newState[key];
            if (typeof value === 'number') {
                delta_value = (value - this._playerState[key]) || 0;
                if (delta_value < 0) {
                    delta_sign = '-';
                }
                if (delta_value >= 0) {
                    delta_sign = '+';
                }
                diff[key] = "" + delta_sign + "," + Math.abs(delta_value) + "," + (this._playerState[key]);
            } else if (typeof value === 'string') {
                diff[key] = value;
            }
        }
        return diff;
    },

    _setCurrentPlayerState: function(pst) {
        var key, value;
        this._playerState = {};
        for (key in pst) {
            if (!__hasProp.call(pst, key)) continue;
            value = pst[key];
            this._playerState[key] = value;
        }
        return true;
    },

    _addEvts: function(msg) {
      var d = new Date(); 
      msg.evts =  d.getTime();
      return msg;
    },
    _addGeo: function(msg) {
        var loc_point;

        if (this._location && (loc_point = this._location.getPosition())  && !isNaN(loc_point.getX()) && !isNaN(loc_point.getY())) {
            msg.geo = "" + loc_point.getX() + "," + loc_point.getY();
        }
        return msg;
    },
    _addCarrier: function(msg) {
        var Capabilities = CapabilitiesReq.Capabilities;
        var carr = Capabilities.getCarrier();
        if (carr) {
            msg.carr = carr;
        }
        return msg;
    },
    _addService: function(msg) {
        var Analytics = this._socAnalytics;
        msg.srvc = Analytics.getServiceId();
        return msg;
    },
    _addPlatformVersion: function(msg) {
        var Analytics = this._socAnalytics;
        msg.pver = Analytics.getPlatformVersion();
        return msg;

    },
    _addSeqDetails: function(msg) {
        this._seqNum += 1;
        msg.seq = this.getSeqNumber();
        msg.seqdt = new Date().getTime() - this._seqStart;
        return msg;
    },
    _addUserId: function(msg) {
      var Analytics = this._socAnalytics;
      var uid = Analytics.getUserId();
      if (uid) {
        msg.uid = uid;
      }
      return msg;
    },
    _addUserName: function(msg) {
      var Analytics = this._socAnalytics;
      var un = Analytics.getUsername();
      if (un) {
        msg.plus = un;
      }
      return msg;
    },
    _addGameSku: function(msg) {
        var app_key = (Capabilities.getConfigs() || {} )["appId"];
        if ( app_key ) {
            msg.asku = app_key;
        }
        return msg;
    },
    _addGameRel: function(msg) {
        var arel = Capabilities.getAppReleaseVersion();
        if (arel) {
          msg.arel = arel;
        }
        return msg;
    },
    _normalizeValues: function(msg) {
        var key, value;
        for (key in msg) {
            if (!__hasProp.call(msg, key)) continue;
            value = msg[key];
            if (typeof value === 'string') {
                value = this._normalizeString(key, value);
            } else if (typeof value === 'object') {
                value = this._normalizeValues(value);
            }
            msg[key] = value;
        }
        return msg;
    },

    _normalizeString: function(key, value) {
        value = value.substring(0, this._allowedLargeValue[key] || 32);
        if (-1 !== this._capAlphaNumStringKeys.indexOf(key)) {
            value = value.toUpperCase().replace(/[^\w]+/g, "").replace("_", "");
        }
        return value;
    },

    _mergeMeta: function(msg) {
        var _ref, _ref2, key, new_msg, value;
        new_msg = {};
        for (key in msg) {
            if (!__hasProp.call(msg, key)) continue;
            value = msg[key];
            new_msg[key] = value;
        }
        for (key in _ref = this._meta) {
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            (_ref2 = new_msg[key]) ? _ref2 : new_msg[key] = value;
        }
        return new_msg;
    },

    _drainQueue: function() {
        var cb, self, toDrain;
        toDrain = this._getQueue();
        this._setQueue([]);
        self = this;

        if (! this._sendToRemote)
            return true;

        cb = function(state, not_sent) {
            if (state === NgPipesRemote.possibleStates.error) {
                self._queueMany(not_sent);
				self._storeQueue();
                self._sendDelay = self._sendDelay * 2;
            } else if (state === NgPipesRemote.possibleStates.finished ) {
                self._sendDelay = 5000;
            }
            return true;
        };
        NgPipesRemote.clearQueue(toDrain, cb);
        toDrain = null; // explicit clear to keep memory down
        return true;
    },

    _queueMany: function(msg_arr) {
        var _i, _len, msg, self = this;
        this._setQueue( (this._getQueue() || [] ).concat(msg_arr) );
        if (this._isSendQueued) {
          this._isSendQueued = true;
          setTimeout(function() {
              self._isSendQueued = false;
              return self._drainQueue();
          }, self._sendDelay);
        }

        return true;
    },
    _setQueue: function(new_queue) {
        this._queue = new_queue;
        return true;
    },
	_storeQueue: function()
	{
		Storage.KeyValueCache.global(this._globalKey).setItem(this._globalKey, JSON.stringify(this._queue));
    },
    _getQueue: function() {
        return this._queue;

    }
});

exports.NgPipe = NgPipe;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/NgPipesRemote'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/NgPipesRemote'] || {}; $MODULE_REGISTRY['NGCore/Shared/NgPipesRemote'] = exports; var Network = require('NGCore/Client/Network').Network;

var ngPipesRequestNum = 0;

NgPipesRemote = {
  listeners: [],
  debug: false,

  possibleStates: {
    unknown: {},
    finished: {},
    error: {}
  }
};

NgPipesRemote.addListener = function(listner) {
  this.listeners.push(listner);
  return true;
};

NgPipesRemote.clearQueue = function(queue, callback) {

  if (!queue) {
    return false;
  }

  if (!this.getUrl()) {
    if (callback) {
      callback(NgPipesRemote.possibleStates.finished, []);
    }
    return false;
  }
	var copy_array = queue.slice(0, queue.length);

	var _j, _len2, data;
  while (copy_array && copy_array.length > 0) {
    var to_send = copy_array.slice(0, 10);
    copy_array = copy_array.slice(10);
    data = "";

    for (_j = 0, _len2 = to_send.length; _j < _len2; _j++) {
      data += JSON.stringify(to_send[_j]);
      if (_j+1 < _len2) {
         data += "\r\n";
      } //if len
    } //for

    if (data) {
      NgPipesRemote._makeRequest(data, to_send, callback);
    } //if data
  }//while

};

NgPipesRemote._makeRequest = function(json_data, objs, callback) {
    var request = new Network.XHR(), url = this.getUrl();
    if (this.debug) {
        NgPipesRemote._debugOutput(json_data);
    }

    ngPipesRequestNum++;
    var reqKey = ngPipesRequestNum;

    var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;
    LifecycleEmitter.requestEngineKeepAlive(reqKey);

    request.onreadystatechange = function() {
        var status = null;
        try {
            if (this.readyState === 4) {
                LifecycleEmitter.cancelEngineKeepAlive(reqKey);
                status = NgPipesRemote._handleResponse(request.responseText);
            } else {
                status = NgPipesRemote.possibleStates.unknown;
            }
        } catch (ex) {
            status = NgPipesRemote.possibleStates.error;
            NgLogException(ex);
        }

        if (callback) {
            callback(status, objs);
        }

        NgPipesRemote._notifyListeners(status);
        return true;
    };

    request.open("POST", url, true);

    request.setRequestHeader("X-Ngpipes-Api", "1.0");
    request.setRequestHeader("Content-Type", "application/json+batch");
    request.setRequestHeader("If-None-Match", "0");

    request.send(json_data);

    NgPipesRemote._notifyListeners('started');
    return true;
};

NgPipesRemote.setUrl = function(url) {
    this.url = url;
};
NgPipesRemote.getUrl = function() {
    if (this.url)
        return this.url;
    var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
    var url = null;
    
    if (Capabilities) {
      //Get the url from the configuration.json
      url = (Capabilities.getConfigs() || {} )["analyticsServer"] || null;
      if (url) {
        url = "https://"+url+"/pipes/r.2/bulk_record_stats";
        if (this.debug) {
          NgLogD("Pipes URL => " + url );
        }
      }
    }
    return url;
};


NgPipesRemote._handleResponse = function(respText) {
  var respObj, result;
  result = NgPipesRemote.possibleStates.unknown;
  if (respText && respText.length > 0) {
    try {
    respObj = JSON.parse(respText);
    } catch (e) {
      //Clean up after ourselves.
      respObj = null;
    }
	if (respObj  && (respObj.success !== null && respObj.success !== undefined ) && respObj.success) {
      if (this.debug) {
        NgLogD("[NgPipesRemote] Got Success" );
      }
      result = NgPipesRemote.possibleStates.finished;
    } else {
      result = NgPipesRemote.possibleStates.error;
    }
  } else {
      if (this.debug) {
        NgLogD('[NgPipesRemote] ERROR posting');
      }

    result = NgPipesRemote.possibleStates.error;
  }
  return result;
};

NgPipesRemote._debugOutput = function(str) {
  var _i, _len, _result, msg, msgs;
  msgs = str.split("\r\n");
  for (_i = 0, _len = msgs.length; _i < _len; _i++) {
    msg = msgs[_i];
    NgLogD("[NgPipesRemote] Message sent: " + msg);
  }
  return false;
};

NgPipesRemote._notifyListeners = function(state) {
  var _i, _len, _ref, l;
  for (_i = 0, _len = (_ref = this.listeners).length; _i < _len; _i++) {
    l = _ref[_i];
    l(state);
  }
  return true;
};

exports.NgPipesRemote = NgPipesRemote;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/sha1'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/sha1'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/sha1'] = exports; /*
 * @description
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 * @namespace
 * @name sha1
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) { return (b & c) | ((~b) & d); }
  if(t < 40) { return b ^ c ^ d; }
  if(t < 60) { return (b & c) | (b & d) | (c & d); }
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) { w[j] = x[i + j]; }
      else {
		w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
	  }
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz) {
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  }
  return bin;
}

/**
 * @description
 * Call the <code>core_hmac_sha1()</code> function to calculate the HMAC-SHA1 of a key and some data.
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See <a href="http://pajhome.org.uk/crypt/md5">this</a> or <a href="http://www.itl.nist.gov/fipspubs/fip180-1.htm">NIST</a> for details.
 * @namespace
 * @name core_hmac_sha1
 * @function
 * @param key The key to use with sha1.
 * @param data The data to hash.
 * @return A sha1 hash of the data and key.
 * @example
 * var key = "12345"
 * var data = "The data I would like to hash."
 * core_hmac_sha1(key, data);
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) {
	bkey = core_sha1(bkey, key.length * chrsz);
  }

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz) {
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
                  (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
                   ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32){
		str += b64pad;
	  } else {
		str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
	  }
    }
  }
  return str;
}

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data, padChar){
	if ((typeof padChar != "undefined") && padChar) {
        b64pad = padChar;
	}
	return binb2b64(core_hmac_sha1(key, data));
}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

// Exports for node.js
if((typeof exports != "undefined") && exports)
{
	exports.b64_hmac_sha1 = b64_hmac_sha1;
	exports.hex_sha1 = hex_sha1;
	exports.b64_sha1 = b64_sha1;
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social'] || {}; $MODULE_REGISTRY['NGCore/Client/Social'] = exports; /**
 * Public API for GameService
 * 
 * Access this file as NGCore/Client/Social.js
 */

// Note the proper require path for our public interface files is: "./Social/US/[filename]"

/** @namespace
 * @name Social
 * @description
 * The <code>Social</code> namespace provides interfaces for the Mobage Social APIs.
 */
exports.Social = {
};

/** @namespace
 * @name Social.Common
 * @description
 * The <code>Social.Common</code> namespace provides interfaces for functionality common to submodules for Japan (JP), the United States (US), 
 * and future submodules. The common features include Auth, People, Appdata, Blacklist, Profanity and Service. Service APIs can be both common
 * or native, and include the Community button, the Balance button, the Friend Picker, the User Finder, and the User Profile.
 */
exports.Social.Common = new (require('NGCore/Client/Social/US/_Internal/_RequireLoader').RequireLoader)({
	"Appdata": function() { return require('NGCore/Client/Social/US/Common/Appdata').Appdata; },
	"Auth": function() { return require('NGCore/Client/Social/US/Common/Auth').Auth; },
	"Blacklist": function() { return require('NGCore/Client/Social/US/Common/Blacklist').Blacklist; },
	"Config": function() { return require('NGCore/Client/Social/US/Common/Config').Config; },
	"People": function() { return require('NGCore/Client/Social/US/Common/People').People; },
	"Profanity": function() { return require('NGCore/Client/Social/US/Common/Profanity').Profanity; },
	"Request": function() { return require('NGCore/Client/Social/US/Common/Request').Request; },
	"Service": function() { return require('NGCore/Client/Social/US/Common/Service').Service; },
	"Analytics": function() { return require('NGCore/Client/Social/US/Common/Analytics').Analytics; }
});

/** @namespace
 * @name Social.US
 * @description
 * The <code>Social.US</code> namespace provides interfaces for the United States (US) submodule. 
 * The features include User, Game, Leaderboard, Score, Ordered List, and AppData.
 */
exports.Social.US = new (require('NGCore/Client/Social/US/_Internal/_RequireLoader').RequireLoader)({
	// Data Models
	"DataModel": function() { return require('NGCore/Client/Social/US/Models/DataModel').DataModel; },
	"User": function() { return require('NGCore/Client/Social/US/Models/User').User; },
	"Game": function() { return require('NGCore/Client/Social/US/Models/Game').Game; },
	"Leaderboard": function() { return require('NGCore/Client/Social/US/Models/Leaderboard').Leaderboard; },
	"Score": function() { return require('NGCore/Client/Social/US/Models/Score').Score; },
	
	"AppData": function() { return require('NGCore/Client/Social/US/Models/AppData').AppData; },
	
	// Data Cache
	"Cache": function() { return require('NGCore/Client/Social/US/Models/Cache').Cache; },

	// Data APIs
	"Session": function() { return require('NGCore/Client/Social/US/Data/Session').Session; },
	"Dispatcher": function() { return require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher; }
});

/** @namespace
 * @name Social.US.Service
 * @description
 * Service APIs include the Community button, the Balance button, the Friend Picker, the User Finder, and the User Profile.
 */
exports.Social.US.Service = new (require('NGCore/Client/Social/US/_Internal/_RequireLoader').RequireLoader)({
	"Friends": function() { return require('NGCore/Client/Social/US/Service/Friends').Friends; },
	"Profile": function() { return require('NGCore/Client/Social/US/Service/Profile').Profile; },
	"ButtonOverlays": function() { return require('NGCore/Client/Social/US/Service/ButtonOverlays').ButtonOverlays; },
	"GameLaunchPayload": function() { return require('NGCore/Client/Social/US/Service/GameLaunchPayload').GameLaunchPayload; }
});

/** @namespace
 * @name Bank
 * @description
 * The <code>Bank</code> namespace provides interfaces for the Mobage Bank APIs.
 */
exports.Bank = require('NGCore/Client/Social/US/Service/Bank').Bank;; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage/FileSystem'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage/FileSystem'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage/FileSystem'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class FileSystem
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////

exports.FileSystem = Class.singleton(
/** @lends Storage.FileSystem.prototype */
{
	classname: 'FileSystem',

  /** @private */
  _options: {
    blocking    : 0x0001, /* legacy blocking(main thread) mode operation for backward compatibility */
    binary      : 0x0002,
    returnFiles : 0x0100
  },
	
	/**
	 * @class The <code>FileSystem</code> class constructs a singleton object that controls file manipulation tasks: reading, writing, deleting, or decompressing a file.
	 * 
	 * @constructs The default constructor.
	 * @augments Core.Class
	 */
	initialize: function()
	{
		/** @private */
		this.readRequests = {};
		/** @private */
		this.writeRequests = {};
		/** @private */
		this.cbIdCounter = 1;
		
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * Read a file into memory from local storage.
   * NOTE: Legacy function signature, readFile(fname, [{Boolean]binary], [{Function}cb]) is still supported but deprecated.
	 * @example FileSys.readFile(SomeFile, { binary:true }, function(err, data){...}
	 * @param {String} fname The name of the file to read into memory.
	 * @param {Object} options Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking: Operation blocks main thread. Default is false (recommended).
   *   {Boolean} binary  : Open file as a binary file. (default: false)
   * }
   * </pre>
	 * @param {Function} [cb] Specifies a callback function that returns an error if the file read operation fails.
   * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	readFile: function( fname, options, cb )
	{
		this.readFileIn(this.Store.Local, fname, options, cb);
	},

	/**
	 * @private
	 * read a file from a common store on the filesystem
	 * NOTE: This is not a secure location and games should not rely on this for critical data
	 * @param {store} The shared location to read from
	 * @param {fname} The name of the file to be read
	 * @param {options} Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking: Operation blocks main thread. Default is false (recommended).
   *   {Boolean} binary  : Open file as a binary file. (default: false)
   * }
   * </pre>
	 * @param {cb} The callback function to be called
   * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	readFileIn: function( store, fname, options, cb )
	{
		var cbId = 0;

		if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.readFile/readFileIn(): using deprecated function signature");
      var binary = options;

      if(typeof(binary) == 'function')
      {
        cb = binary;
        binary = false;
      }
      binary = binary || false;

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.readRequests[ cbId ] = cb;
      }

      this._readFileSendGen(cbId,store,fname,binary);
    }
    else
    {
      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;
      if(options['binary'])
        op |= this._options.binary;

      if(cb)
      {
        cbId = this.cbIdCounter++;
        this.readRequests[ cbId ] = cb;
      }

      this._readFileAsyncSendGen(cbId,store,fname,op);
    }
	},

	/**
	 * Write a file to local storage.
   * NOTE: Legacy function signature, writeFile({String}fname, {String}data, [{Boolean]binary], [{Function}cb]) is still supported but deprecated.
	 * @example FileSys.writeFile(SomeFile, someData, { binary:true }, (function(){...});
	 * @param {String} fname The name of the file to write into storage.
	 * @param {Binary, String} data The data to write to the file.
	 * @param {Object} options Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking: Operation blocks main thread. Default is false (recommended).
   *   {Boolean} binary  : Open file as a binary file. (default: false)
   * }
   * </pre>
	 * @param {Function} [cb] Specifies a callback function that returns an error if the file write operation fails.
   * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	writeFile: function( fname, data, options, cb )
	{
		this.writeFileIn(this.Store.Local, fname, data, options, cb);
	},

	/**
	 * @private
	 * write a file to a common store on the filesystem
	 * NOTE: This is not a secure location and games should not rely on this for critical data
	 * @param {store} The shared location to write to
	 * @param {fname} The name of the file to be written
	 * @param {options} Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking: Operation blocks main thread. Default is false (recommended).
   *   {Boolean} binary  : Open file as a binary file. (default: false)
   * }
   * </pre>
	 * @param {cb} The callback function to be called after completion
   * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	writeFileIn: function( store, fname, data, options, cb )
	{
		var cbId = 0;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.writeFile/writeFileIn(): using deprecated function signature");
      var binary = options;

      if(typeof(binary) == 'function')
      {
        cb = binary;
        binary = false;
      }
      binary = binary || false;

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }

      this._writeFileSendGen(cbId,store,fname,data,binary);
    }
    else
    {
      var op = 0;
      if(options['blocking'])
        op |= this._options.blocking;
      if(options['binary'])
        op |= this._options.binary;

      if(cb)
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }

      this._writeFileAsyncSendGen(cbId,store,fname,data,op);
    }
	},

	/**
	 * Delete a file from local storage.
   * NOTE: Legacy function signature, deleteFile(fname, data, [{Function}cb]) is still supported but deprecated.
	 * @example FileSys.deleteFile(SomeFile, {}, function(err, data){});
	 * @param {String} fname The name of the file to delete.
	 * @param {Object} options Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking: Operation blocks main thread. Default is false (recommended).
   * }
   * </pre>
	 * @param {Function} [cb] Specifies a callback function that returns an error if the file delete operation fails.
   * @status iOS, Android, Test, iOSTested, AndroidTested     
	 */
	deleteFile: function ( fname, options, cb )
	{
		this.deleteFileIn(this.Store.Local, fname, options, cb);
	},

	/**
	 * @private
	 * delete a file from a common store on the filesystem
	 * NOTE: This is not a secure location and games should not rely on this for critical data
	 * @param {store} The shared location path
	 * @param {fname} The name of the file to be deleted
	 * @param {options} Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking: Operation blocks main thread. Default is false (recommended).
   * }
   * </pre>
	 * @param {cb} The callback function to be called
   * @status iOS, Android, Test, iOSTested, AndroidTested     
	 */
	deleteFileIn: function ( store, fname, options, cb )
	{
		var cbId = 0;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.deleteFile/deleteFileIn(): using deprecated function signature");
      cb = options;

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._deleteFileSendGen(cbId,store,fname);
    }
    else
    {
      var op = 0;

      if(options['blocking'])
      {
        op |= this._options.blocking;
      }

      if(cb)
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._deleteFileAsyncSendGen(cbId, store, fname, op);
    }
	},
	
	/**
	 * Decompress a zipfile.
   * NOTE: Legacy function signature, decompressFile({String}fname, {String}destination, [{Boolean}returnFiles], [{Function}cb]) is still supported but deprecated.
	 * @example FileSys.readFile(SomeFile, ./some/path/to/destination/, { returnFiles:true }, function(err, data){...}
	 * @param {String} fname The name of the zipfile to decompress.
	 * @param {String} destination The directory path where the contents of the decompressed file are written.
	 * @param {Object} options Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking   : Operation blocks main thread. Default is false (recommended).
   *   {Boolean} returnFiles: If true it returns a json object with a list of each file, its MD5 hash and its size. Default is false.
   * }
   * </pre>
	 * @param {Function} [cb] Specifies a callback function that returns an error if the file decompress operation fails.
   * @status iOS, Android
	 */
	decompressFile: function( fname, destination, options, cb )
	{
		this.decompressFileIn(this.Store.Local, fname, destination, options, cb);
	},
	
	/**
	 * @private
	 * decompress a file to a shared location on the filesystem
	 * NOTE: This is not a secure location and games should not rely on this for critical data
	 * @param {store} The shared location path
	 * @param {fname} The name of the file to be read
	 * @param {cb} The callback function to be called
	 * @param {destination} destination location to unzip files to
	 * @param {options} Options. Available options are:
   * <pre>
   * {
   *   {Boolean} blocking   : Operation blocks main thread. Default is false (recommended).
   *   {Boolean} returnFiles: If true it returns a json object with a list of each file, its MD5 hash and its size. Default is false.
   * }
   * </pre>
   * @status iOS, Android    
	 */
	decompressFileIn: function( store, fname, destination, options, cb )
	{
		var cbId = 0;

    if(typeof(options) !== 'object')
    {
      /* Legacy function signature */
      NgLogW("FileSystem.decompressFile/decompressFileIn(): using deprecated function signature");
      var returnFiles = options;
      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._decompressFileSendGen(cbId,store,fname,destination,returnFiles);
    }
    else
    {
      var op = 0;

      if(options['blocking'])
      {
        op |= this._options.blocking;
      }
      if(options['returnFiles'])
      {
        op |= this._options.returnFiles;
      }

      if ( cb )
      {
        cbId = this.cbIdCounter++;
        this.writeRequests[ cbId ] = cb;
      }
      this._decompressFileAsyncSendGen(cbId, store, fname, destination, op);
    }
	},
	
	/**
	 * @private
	 */
	_readFileCbRecv: function( cmd ) 
	{
		var msg = {};
		if(!this._readFileCbRecvGen(cmd, msg))
			return;
			
		var cbId = msg[ "callbackId" ];
		var data = msg[ "data" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			NgLogE ( "FileSystem.onReadFile: No cbId" );
			return;
		}
		
		var cb = this.readRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem.onReadFile: No registered cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.readRequests[ cbId ];
		cb ( err, data );
	},
	
	/**
	 * @private
	 */
	_writeFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._writeFileCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg[ "callbackId" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
			
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}

		delete this.writeRequests[ cbId ];
		cb ( err );
	},
	
	/**
	 * @private
	 */
	_deleteFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._deleteFileCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg[ "callbackId" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}
		
		delete this.writeRequests[ cbId ];
		cb ( err );
	},
	
	/**
	 * @private
	 */
	_decompressFileCbRecv: function( cmd )
	{
		var msg = {};
		if(!this._decompressFileCbRecvGen(cmd, msg))
			return;
			
		var cbId = msg[ "callbackId" ];
		var files = msg[ "files" ];
		var err = msg[ "error" ];
		
		if ( !cbId )
		{
			//NgLogE ( "FileSystem command : No cbId" );
			return;
		}
		
		var cb = this.writeRequests[ cbId ];
		
		if ( !cb )
		{
			NgLogE ( "FileSystem command : No registered cb found..cbId is :" + cbId );
			return;
		}
		
		try
		{
			files = JSON.parse(files);
		}
		catch(e)
		{
			NgLogE ( "FileSystem command : Could not parse response :" + files );
			err = "Could not parse files";
		}
		
		delete this.writeRequests[ cbId ];
		cb ( err, files );
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	Store:
	{ 
		/** /tmp */
		Temp: 0,
		/** local sandbox */
		Local: 1,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 338
	// Method create = -1
	// Method readFile = 2
	// Method writeFile = 3
	// Method deleteFile = 4
	// Method decompressFile = 5
	// Method readFileCb = 6
	// Method writeFileCb = 7
	// Method deleteFileCb = 8
	// Method decompressFileCb = 9
	// Method readFileAsync = 10
	// Method writeFileAsync = 11
	// Method deleteFileAsync = 12
	// Method decompressFileAsync = 13
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 6:
					instance._readFileCbRecv( cmd );
					break;
				case 7:
					instance._writeFileCbRecv( cmd );
					break;
				case 8:
					instance._deleteFileCbRecv( cmd );
					break;
				case 9:
					instance._decompressFileCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in FileSystem._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in FileSystem._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[338] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_readFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.readFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_writeFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.writeFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.writeFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.writeFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_deleteFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.deleteFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.deleteFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.deleteFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_decompressFileCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "files" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "files" ] === undefined )
		{
			NgLogE("Could not parse files in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in FileSystem.decompressFileCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":338,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_readFileSendGen: function( callbackId, storeId, filename, binary )
	{
		Core.Proc.appendToCommandString( ":338,2," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + ( binary ? 1 : 0 )  );
	},
	
	/** @private */
	_writeFileSendGen: function( callbackId, storeId, filename, data, binary )
	{
		Core.Proc.appendToCommandString( ":338,3," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( data ) + "," + ( binary ? 1 : 0 )  );
	},
	
	/** @private */
	_deleteFileSendGen: function( callbackId, storeId, filename )
	{
		Core.Proc.appendToCommandString( ":338,4," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename )  );
	},
	
	/** @private */
	_decompressFileSendGen: function( callbackId, storeId, filename, destination, returnFiles )
	{
		Core.Proc.appendToCommandString( ":338,5," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( destination ) + "," + ( returnFiles ? 1 : 0 )  );
	},
	
	/** @private */
	_readFileAsyncSendGen: function( callbackId, storeId, filename, options )
	{
		Core.Proc.appendToCommandString( ":338,10," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + options  );
	},
	
	/** @private */
	_writeFileAsyncSendGen: function( callbackId, storeId, filename, data, options )
	{
		Core.Proc.appendToCommandString( ":338,11," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( data ) + "," + options  );
	},
	
	/** @private */
	_deleteFileAsyncSendGen: function( callbackId, storeId, filename, options )
	{
		Core.Proc.appendToCommandString( ":338,12," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + options  );
	},
	
	/** @private */
	_decompressFileAsyncSendGen: function( callbackId, storeId, filename, destination, options )
	{
		Core.Proc.appendToCommandString( ":338,13," + this.__objectRegistryId + "," + callbackId + "," + storeId + "," + Core.Base64.encode( filename ) + "," + Core.Base64.encode( destination ) + "," + options  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// readFile: function( callbackId, storeId, filename, binary ) {}
	
	// writeFile: function( callbackId, storeId, filename, data, binary ) {}
	
	// deleteFile: function( callbackId, storeId, filename ) {}
	
	// decompressFile: function( callbackId, storeId, filename, destination, returnFiles ) {}
	
	// _readFileCbRecv: function( cmd ) {}
	// _writeFileCbRecv: function( cmd ) {}
	// _deleteFileCbRecv: function( cmd ) {}
	// _decompressFileCbRecv: function( cmd ) {}
	// readFileAsync: function( callbackId, storeId, filename, options ) {}
	
	// writeFileAsync: function( callbackId, storeId, filename, data, options ) {}
	
	// deleteFileAsync: function( callbackId, storeId, filename, options ) {}
	
	// decompressFileAsync: function( callbackId, storeId, filename, destination, options ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network'] || {}; $MODULE_REGISTRY['NGCore/Client/Network'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class Network
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
/**
 * @name Network
 * @namespace
 * <p>Classes and objects contained by the Network module.</p>
 * @description <p>The Network module is a collection of classes that support manipulation of network flow.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 *<ul>
 *<li><code>{@link Network.DownloadFile}</code>: Construct objects that conduct a file download.</li>
 *<li><code>{@link Network.DownloadManifest}</code>: Construct objects that keep manifests up-to-date.</li>
 *<li><code>{@link Network.XHR}</code>: Construct XmlHttpRequest objects.</li>
 *</ul>
 */
exports.Network = {};

exports.Network.__defineGetter__("XHR", function() {
	delete this.XHR;
	return this.XHR = require('NGCore/Client/Network/XHR').XHR;
});
exports.Network.__defineGetter__("DownloadFile", function() {
	delete this.DownloadFile;
	return this.DownloadFile = require('NGCore/Client/Network/DownloadFile').DownloadFile;
});
exports.Network.__defineGetter__("DownloadManifest", function() {
	delete this.DownloadManifest;
	return this.DownloadManifest = require('NGCore/Client/Network/DownloadManifest').DownloadManifest;
});
exports.Network.__defineGetter__("Util", function() {
	delete this.Util;
	return this.Util = require('NGCore/Client/Network/Util').Util;
});
exports.Network.__defineGetter__("_int_Util", function() {
	delete this._int_Util;
	return this._int_Util = require('NGCore/Client/Network/_int_Util')._int_Util;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/LifecycleEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/LifecycleEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/LifecycleEmitter'] = exports; var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Proc = require('NGCore/Client/Core/Proc').Proc;

exports.LifecycleEmitter = MessageEmitter.singleton(
/** @lends Device.LifecycleEmitter.prototype */
{
	classname: 'LifecycleEmitter',
		
	/**
	 * @class The <code>LifecycleEmitter</code> class constructs a singleton object that emits <code><a href="Device.LifecycleEmitter.html#Event">Event</a></code> 
	 * objects when device lifecycle events occur.
	 * Applications can respond to these events by notifying external sources. For example,
	 * an application can respond to a <code>Terminate</code> event by writing an analytics log.<br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		/** @private */
		this.identificationCache = {};
		this.numEngineRequests = 0;
	},
	
	_lifecycleEventRecv: function( cmd )
	{
		var msg = {};
		if(!this._lifecycleEventRecvGen(cmd, msg))
			return;
			
		this.emit(msg.event);
		//Cascade the original message back out to native for forwarding
		//	to the next interpreter in the chain.
		this._lifecycleEventSendGen(msg.event);
	},

	/** @private */
	$exitProcess: function()
	{
		this._exitProcessSendGen();
	},
	
	/** @private */
	$_bgMe: function()
	{
		this.__bgMeSendGen();
	},

	/** @private */
	$pauseGame: function()
	{
		NgLogD("+++++++++++++++++++++++++++++++++++++++++Pausing Game");
		this._pauseGameSendGen();
		var _lgl = require('NGCore/Client/Core/_LocalGameList')._LocalGameList;
		_lgl._pausingGame();
	},

	/** @private */
	$resumeGame: function()
	{
		NgLogD("+++++++++++++++++++++++++++++++++++++++++Resuming Game");
		this._resumeGameSendGen();
		var _lgl = require('NGCore/Client/Core/_LocalGameList')._LocalGameList;
		_lgl._resumingGame();
	},

	requestEngineKeepAlive: function(obj)
	{
		var key = obj;
		if (obj.identification_key !== undefined)
		{
			key = obj.identification_key;
		}

		{
			//Store identification key and increment request to engine
			this.identificationCache[key] = true;
			++this.numEngineRequests;
			this.incrementEngineAlive();
		}
	},
	
	cancelEngineKeepAlive: function(obj)
	{
		var key = obj;
		if (obj.identification_key !== undefined)
		{
			key = obj.identification_key;
		}

		{
			if (this.identificationCache[key])
			{
				//Store identification key and increment request to engine
				delete this.identificationCache[key];
				--this.numEngineRequests;
				this.decrementEngineAlive();
			}else{
				NgLogW("LifecycleEmitter.cancelEngineKeepAlive() Identification Key not found");
			}
		}
	},

	incrementEngineAlive: function()
	{
		this._incrementEngineAliveSendGen();
	},
	
	decrementEngineAlive: function()
	{
		this._decrementEngineAliveSendGen();
	},
	
	cancelAllEngineRequests: function()
	{
		this._cancelAllEngineRequestsSendGen();
	},

	_killGameProc: function( )
	{
		this.__killGameProcSendGen();
	},

// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Enumeration values for lifecycle events.
	 * @fieldOf Device.LifecycleEmitter.prototype
	 */
	Event:
	{ 
		/** Application is being suspended. */
		Suspend: 0,
		/** Application is being resumed. */
		Resume: 1,
		/** Application is being terminated. */
		Terminate: 2,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 334
	// Method create = -1
	// Method lifecycleEvent = 2
	// Method exitProcess = -3
	// Method pauseGame = -4
	// Method resumeGame = -5
	// Method incrementEngineAlive = 6
	// Method decrementEngineAlive = 7
	// Method cancelAllEngineRequests = 8
	// Method _killGameProc = -9
	// Method _bgMe = -10
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._lifecycleEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LifecycleEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LifecycleEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[334] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_lifecycleEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in LifecycleEmitter.lifecycleEvent from command: " + cmd );
			return false;
		}
		
		obj[ "event" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "event" ] === undefined )
		{
			NgLogE("Could not parse event in LifecycleEmitter.lifecycleEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":334,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_lifecycleEventSendGen: function( event )
	{
		Core.Proc.appendToCommandString( ":334,2," + this.__objectRegistryId + "," + event  );
	},
	
	/** @private */
	$_exitProcessSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334," + -3  );
	},
	
	/** @private */
	$_pauseGameSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334," + -4  );
	},
	
	/** @private */
	$_resumeGameSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334," + -5  );
	},
	
	/** @private */
	_incrementEngineAliveSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334,6," + this.__objectRegistryId );
	},
	
	/** @private */
	_decrementEngineAliveSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334,7," + this.__objectRegistryId );
	},
	
	/** @private */
	_cancelAllEngineRequestsSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334,8," + this.__objectRegistryId );
	},
	
	/** @private */
	$__killGameProcSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334," + -9  );
	},
	
	/** @private */
	$__bgMeSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":334," + -10  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _lifecycleEventRecv: function( cmd ) {}
	// lifecycleEvent: function( event ) {}
	
	// $exitProcess: function(  ) {}
	
	// $pauseGame: function(  ) {}
	
	// $resumeGame: function(  ) {}
	
	// incrementEngineAlive: function(  ) {}
	
	// decrementEngineAlive: function(  ) {}
	
	// cancelAllEngineRequests: function(  ) {}
	
	// $_killGameProc: function(  ) {}
	
	// $_bgMe: function(  ) {}
	

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/XHR'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/XHR'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/XHR'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class XHR
// XMLHttpRequest implementation
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Class = require('NGCore/Client/Core/Class').Class;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Util = require('NGCore/Client/Network/Util').Util;
var Caps = require('NGCore/Client/Core/Capabilities').Capabilities;

////////////////////////////////////////////////////////////////////////////////

var Header = function (item, content)
{
	this.item = item;
	this.content = content;
};
var headerEx = /(.*?): (.*)/;

/**
 * Constants
 */
var State =
{
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
};

// ///////////// Begin HTTP req'd methods of testing! //////
var methods =
[
	"OPTIONS",
	"GET",
	"HEAD",
	"POST",
	"PUT",
	"DELETE",
	"TRACE",
	"CONNECT"
];

var unsecureMethods = ["CONNECT", "TRACE", "TRACK"];

var checkMethod = function(method)
{
	if(!method) return "GET";

	method = method.toString();

	if (method in unsecureMethods)
	{
		throw "SECURITY_ERROR " + method + " not allowed.";
	}
	if (method.toUpperCase() in methods)
	{
		return method.toUpperCase();
	}
	return method;
};

// ////////////////////////// End! /////////////////////

////////////////////////////////////////////////////////////////////////////////

exports.XHR = Class.subclass(
/** @lends Network.XHR.prototype */
{
	classname: 'XHR',
	
	/**
	 * @class The <code>XHR</code> class constructs <code>XmlHttpRequest</code> objects. Applications can use these objects to
	 * send HTTP or HTTPS requests directly to a web server and load the server response data directly back into a script.
	 * @constructs The default constructor. 
	 * @see <a href="http://www.w3.org/TR/XMLHttpRequest/">Official W3C XmlHttpRequest specification</a>
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this.request;
		this.respHeaders = {};

		this.settings = {};
		this.headers = [];

		// State-associated flags
		this.sendFlag = false;
		this.errorFlag = false;
		
		// Status & response
		this.readyState = State.UNSENT;
		this.responseText = null;
		this.responseXML = null;
		this.status = 0;
		this.statusText = "";
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 340
	// Method create = -1
	// Method destroy = 2
	// Method sendStatus = 3
	// Method sendHeaders = 4
	// Method sendData = 5
	// Method onFinish = 6
	// Method start = 7
	// Method header = 8
	// Method setComposition = 9
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._sendStatusRecv( cmd );
					break;
				case 4:
					instance._sendHeadersRecv( cmd );
					break;
				case 5:
					instance._sendDataRecv( cmd );
					break;
				case 6:
					instance._onFinishRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in XHR._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in XHR._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[340] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_sendStatusRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.sendStatus from command: " + cmd );
			return false;
		}
		
		obj[ "statNum" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "statNum" ] === undefined )
		{
			NgLogE("Could not parse statNum in XHR.sendStatus from command: " + cmd );
			return false;
		}
		
		obj[ "statStr" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "statStr" ] === undefined )
		{
			NgLogE("Could not parse statStr in XHR.sendStatus from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_sendHeadersRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.sendHeaders from command: " + cmd );
			return false;
		}
		
		obj[ "headers" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "headers" ] === undefined )
		{
			NgLogE("Could not parse headers in XHR.sendHeaders from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_sendDataRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.sendData from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in XHR.sendData from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onFinishRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in XHR.onFinish from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseBool( cmd[ 0 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in XHR.onFinish from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":340,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":340,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_startSendGen: function( method, url, data, headers )
	{
		Core.Proc.appendToCommandString( ":340,7," + this.__objectRegistryId + "," + Core.Base64.encode( method ) + "," + Core.Base64.encode( url ) + "," + Core.Base64.encode( data ) + "," + headers  );
	},
	
	/** @private */
	_headerSendGen: function( item, content )
	{
		Core.Proc.appendToCommandString( "," + Core.Base64.encode( item ) + "," + Core.Base64.encode( content )  );
	},
	
	/** @private */
	_setCompositionSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":340,9," + this.__objectRegistryId );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// _sendStatusRecv: function( cmd ) {}
	// _sendHeadersRecv: function( cmd ) {}
	// _sendDataRecv: function( cmd ) {}
	// _onFinishRecv: function( cmd ) {}
	// start: function( method, url, data, headers ) {}
	
	// header: function( item, content ) {}
	
	// setComposition: function(  ) {}
	

// {{/Wg Generated Code}}

// API
	/**
	 * Initialize a request for this <code>XHR</code>.
	 *
	 * <b>Note:</b> Calling <code>open()</code> will wipe all request headers. You must set them after making this call.
	 *
	 * @param {String}
	 *            method The request method 
	 * 		(<code>GET</code>, <code>POST</code>, <code>OPTIONS</code>, <code>HEAD</code>,  
	 *		<code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code>)
	 * @param {String}
	 *            url The request URL.
	 * @param {Boolean}
	 *            [async=true] Returns <code>true</code> if the request is synchronous. Returns <code>false</code> in all other cases.<br><br> 
	 * 		<b>Note:</b> Currently not implemented.
	 * @param {String}
	 *            [user] Username for basic authentication.<br><br> 
	 *		<b>Note:</b> Currently not implemented.
	 * @param {String}
	 *            [password] Password for basic authentication.
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	open: function(method, url, async, user, password)
	{
		url = url.split(' ').join('%20');
		this.settings =
		{
			"method": checkMethod(method),
			"url": Util.buildRelativeUrl(url),
			"async": async,
			"user": user,
			"password": password
		};

		// Check URL and set XHR flag appropriately
// 		var localServer = Caps.getServer();
// 		if (localServer == url.substr(0, localServer.length) && Caps.getPlatformOS() == "Android")
// 		{
// 			this.NXS = true;
// 		}

		if (this.me && this.sendFlag)
		{
			http.abort(this.me);
		}
		this.reset();
		this.setState(State.OPENED);
	},

	/**
	* @ private
	* Send a request initialized by the <code>open()</code> method. 
	* @param {Array} [composition] Array of strings and file names to be composed into the body.<br><br>
	* <b>Note:</b> This parameter is ignored if <code>readyState</code> is set as <code>GET</code> or <code>HEAD</code>.
	* @throws {INVALID_STATE_ERR} If <code>readyState</code> is set as anything other than <code>OPENED</code> or if the <code>send()</code> flag is true.
	* @see Network.XHR#open
	* @status iOS, Android
	*/

	sendComposition: function(comp)
	{
		// ex: [{"str":"string to send"},{"file":"path/to/file.bin"},{"str":"more goods"}]
		this.composing = true;
		this.send(JSON.stringify(comp));
	},

	/**
	* Send a request initialized by the <code>open()</code> method.
	* @param {String} [data] The request entity body.<br><br>
	* <b>Note:</b> This parameter is ignored if <code>readyState</code> is set as <code>GET</code> or <code>HEAD</code>.
	* @throws {INVALID_STATE_ERR} If <code>readyState</code> is set as anything other than <code>OPENED</code> or if the <code>send()</code> flag is true.
	* @see Network.XHR#open
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	send: function(data)
	{
		if (this.readyState != State.OPENED || this.sendFlag)
		{
			throw "INVALID_STATE_ERR: " + (this.sendFlag ? "Already sending" : "in state " + this.readyState);
		}
		this.sendFlag = true;

		if (data && this.settings.method != "GET" && this.settings.method != "HEAD")
		{
			// TODO http://www.w3.org/TR/XMLHttpRequest/#the-send-method step 3
		}

		this.errorFlag = false;

		// Set content length header
		if (this.settings.method == "GET" || this.settings.method == "HEAD")
		{
			data = null;
		}
		else if (data)
		{
			var bFound = false;
			for (var i in this.headers)
			{
				if (this.headers[i].item == "Content-Type")
				{
					bFound = true;
					break;
				}
			}
			if (!bFound)
			{
				this.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
			}
		}

		this.responseText = "";

		// Send data to the server
		if (!data)
		{
			data = "";
		}

		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

/* Not supporting NXS. Could remove it, but maybe we will support it one day */
		if (this.NXS)
		{
			this.me = http.create(this);
			for (var i in this.headers)
			{
				var h = this.headers[i];
				http.addHeader(this.me, h.item + ": " + h.content);
			}
			http.send(this.me, this.settings.method, this.settings.url, data);
		}
		else
		{
			if (this.composing)
				this._setCompositionSendGen();

			this._startSendGen(this.settings.method, this.settings.url, data, this.headers.length);
			for (var i in this.headers)
			{
				var obj = this.headers[i];
				this._headerSendGen(obj.item, obj.content);
			}
		}
	}, // this.send() 

	/**
	 * Cancel any existing or pending network activity for this <code>XHR</code>. 
	 * This method is invoked using the specification outlined by W3C.
	 * @see <a href="http://www.w3.org/TR/XMLHttpRequest/#the-abort-method">W3C specification outline for <code>abort()</code></a>
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	abort: function()
	{
		this.responseText = null;
		this.errorFlag = true;
		this.headers = [];

		if (this.sendFlag)
		{
			if (this.NXS)
			{
				http.abort(this.me);
			}

			if (this.readyState != State.DONE)
			{
				this.sendFlag = false;
				this.setState(State.DONE);
			}
		}
		this.readyState = State.UNSENT;
	},

	/**
	 * Retrieve a header from the server response.
	 *
	 * @param {String}
	 *            header Name of header to retrieve.
	 * @returns {String} Text of the header or <code>null</code> if text does not exist.
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getResponseHeader: function(header)
	{
		if (this.readyState > State.OPENED)
		{
			return this.respHeaders[header.toLowerCase()];
		}
		return null;
	},

	/**
	 * Nonstandard: Retrieve the key-value map of all response headers.
	 *
	 * @return {Object} A key-value map as an object.
     * @status iOS, Android, Test, iOSTested, AndroidTested
     */
	getUnflattenedResponseHeaders: function()
	{
		return this.respHeaders;
	},

	/**
	 * Retrieve all the response headers from a request.
	 * This method is invoked using the specification outlined by W3C.
	 * @return {String} All the response headers from a request.
	 * @see <a href="http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method">W3C specification outline for <code>getAllResponseHeaders()</code>.</a>
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getAllResponseHeaders: function()
	{
		if (this.readyState < State.HEADERS_RECEIVED || this.errorFlag)
		{
			return "";
		}

		var result = "";
		for (var i in this.respHeaders)
		{
			result += i + ": " + this.respHeaders[i] + "\r\n";
		}
		return result.substr(0, result.length - 2);
	},

	/**
	 * Set a header for the request.
	 *
	 * @param {String}
	 *            header The name of the header.
	 * @param {String}
	 *            value The value of the header.
	 * @see Network.XHR#getRequestHeader
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	setRequestHeader: function(header, value)
	{
		this.headers.push(new Header(header, value));
	},

	/**
	 * Retrieve a header from the request.
	 *
	 * @param {String} header The name of the header.
	 * @return {String} The value of the header.
	 * @see Network.XHR#setRequestHeader
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getRequestHeader: function(header)
	{
		var ret = null;
		for (var i in this.headers)
		{
			if (this.headers[i].item == header)
			{
				ret = this.headers[i].content;
				break;
			}
		}
		return ret;
	},

// Receivers
    /*
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	onStatus: function ( num, str)
	{
		this.status = num;
		this.statusText = str;
	},

	_sendStatusRecv: function( cmd )
	{
		var obj = {};
		this._sendStatusRecvGen(cmd, obj);
		this.onStatus(obj.statNum, obj.statStr);
	},
    /*
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	onHeaders: function(str)
	{
		var lines = str.split('\n');
		lines.pop();
		for (var i in lines)
		{
			var match = headerEx.exec(lines[i]);
			if (match)
				this.respHeaders[match[1].toLowerCase()] = match[2];
		}
		this.setState(State.HEADERS_RECEIVED);
	},

	_sendHeadersRecv: function( cmd )
	{
		var obj = {};
		this._sendHeadersRecvGen(cmd, obj);
		this.onHeaders(obj.headers);
	},
    /*
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	onData: function(data)
	{
		this.responseText += data;
		this.setState(State.LOADING);
	},

	_sendDataRecv: function( cmd )
	{
		var obj = {};
		this._sendDataRecvGen(cmd, obj);
		this.onData(obj.data);
	},
    /*
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	onFinish: function (err)
	{
		this.sendFlag = false;
		if (err)
		{
			this.responseText = null;
			this.error = "Network Error";
			this.errorFlag = true;
			this.status = 0;
		}
		this.setState(State.DONE);
	},

	_onFinishRecv: function( cmd )
	{
		var obj = {};
		this._onFinishRecvGen(cmd, obj);
		this.onFinish(obj.error);
	},

// Internal methods
	/**
	 * Reset all fields from a request. This call sets <code>readyState</code> to <code>UNSENT</code> 
	 * and the response properties to <code>null</code>.
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	reset: function()
	{
		this.headers = [];
		this.readyState = State.UNSENT;
		this.responseText = null;
		this.responseXML = null;
		this.composing = false;
	},
	/**
	 * Change the value of <code>readyState</code> and call <code>onreadystatechange()</code>.
	 *
	 * @param {Number}
	 *            state The new value for <code>readyState</code>
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	setState: function(state)
	{
		this.readyState = state;
		if (state == State.DONE)
		{
			this._destroySendGen();
			ObjectRegistry.unregister(this);
		}
		if (typeof this.onreadystatechange != 'undefined')
		{
			try
			{
				this.onreadystatechange();
			}
			catch (e)
			{
				NgLogException(e);
			}
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/DownloadFile'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/DownloadFile'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/DownloadFile'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class DownloadFile
// Downloads a file to the sandbox
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////

exports.DownloadFile = Class.subclass(
/** @lends Network.DownloadFile.prototype */
{
	classname: 'DownloadFile',
	/**
	* @class The <code>DownloadFile</code> class constructs objects that conduct a file download through an HTTP request.
	* @constructs The default constructor. 
	* @augments Core.Class
	*/
	initialize: function() {},

	/**
	  * Initiate a file download.
	  * @example var url = 'http://url/to/stuff/
	  * new Network.DownloadFile).start(filename, 'GET', url, [], (function(status, md5)
	  * @param {String} filename A local and relative path for storing the downloaded data.
	  * @param {String} method The HTTP method to use.  For example, <code>GET</code> or <code>POST</code>.
	  * @param {String} url The URL of the downloaded file.
	  * @param {Array} [headers] An Array of dictionaries {item:"Content-Easter",content:"egg"} that each describe a header you wish to send.
	  * @param {Function} [callback] A callback function for notification
	  * of when the download completes. The signature for the callback is equivalent
	  * to:<br><br>
	  * <pre>function(statusCode,fileSignature)</pre><br>
	  * The <code>fileSignature</code> is currently the
	  * md5 checksum of the file.
	  * @type void
      * @status iOS, Android, Test, iOSTested, AndroidTested
	  */
	start: function(filename, method, url, headers, callback)
	{
		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		url = url.split(' ').join('%20');
		// Check headers
		if (!(headers instanceof Array))
		{
			if(headers){
				NgLogE('Improper headers sent('+headers+'). Need an array, ex: [{item:"Content-Easter", content:"egg"}]');
			}
			headers = [];
		}

		// Send the goods
		this.__sendSendGen( filename, method, url, headers.length );

		// Send headers
		for (var i in headers)
		{
			this.__headerSendGen(headers[i].item, headers[i].content);
		}

		// Save the callback
		this.mCB = callback
	},

	abort: function()
	{
		this._destroySendGen();
		ObjectRegistry.unregister(this);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 341
	// Method create = -1
	// Method destroy = 2
	// Method _send = 3
	// Method _header = 4
	// Method finish = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._finishRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in DownloadFile._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in DownloadFile._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[341] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_finishRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in DownloadFile.finish from command: " + cmd );
			return false;
		}
		
		obj[ "status" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "status" ] === undefined )
		{
			NgLogE("Could not parse status in DownloadFile.finish from command: " + cmd );
			return false;
		}
		
		obj[ "signature" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "signature" ] === undefined )
		{
			NgLogE("Could not parse signature in DownloadFile.finish from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":341,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":341,2," + this.__objectRegistryId );
	},
	
	/** @private */
	__sendSendGen: function( fileName, method, url, headers )
	{
		Core.Proc.appendToCommandString( ":341,3," + this.__objectRegistryId + "," + Core.Base64.encode( fileName ) + "," + Core.Base64.encode( method ) + "," + Core.Base64.encode( url ) + "," + headers  );
	},
	
	/** @private */
	__headerSendGen: function( item, content )
	{
		Core.Proc.appendToCommandString( "," + Core.Base64.encode( item ) + "," + Core.Base64.encode( content )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// _send: function( fileName, method, url, headers ) {}
	
	// _header: function( item, content ) {}
	
	// _finishRecv: function( cmd ) {}

// {{/Wg Generated Code}}
	
	_finishRecv: function( cmd )
	{
		this._destroySendGen();
		
		var obj = {};
		this._finishRecvGen(cmd, obj);

		if (this.mCB)
			this.mCB(obj.status, obj.signature);

		ObjectRegistry.unregister(this);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/Util'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/Util'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/Util'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Utilities for Network
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Caps = require('NGCore/Client/Core/Capabilities').Capabilities;
var Time = require('NGCore/Client/Core/Time').Time;
var LifecycleEmitter = require('NGCore/Client/Device/LifecycleEmitter').LifecycleEmitter;

////////////////////////////////////////////////////////////////////////////////

var urlPathServerSplit = /^(https?:\/\/)?([^\/]*)(.*[^\/])?.?/i;

var Util = exports.Util =
{
    /*
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	NormalizeUrl: function(url, keepTrailingSlash)
	{
		url = Util.buildRelativeUrl(url);

		// Now split it into parts and make server bits lower case
		var parsed = url.match(urlPathServerSplit);
		if (parsed && parsed[1])
		{
			// absolute path!
			url = parsed[1].toLowerCase() + parsed[2].toLowerCase() + (parsed[3] ? parsed[3] : "");
		}
		else
		{
			// Direct server, no path
			url = url.toLowerCase();
		}
		return url;
	},

	/*
	 * For a given game url, this returns the directory of that url on the SD card.
	 */
	GetMD5HashDirectoryFromUrl: function(url)
	{
		var name;
		if (url === Capabilities._getBootServer() + "/" + Capabilities._getBoot())
			name = Capabilities.getBootDir();
		else
			name = require('NGCore/Shared/Lib/md5').toMD5(url);

		return name;
	},

	buildRelativeUrl: function(url)
	{
		if (!url.match(/^(https?:\/\/)/))
		{
			// If the path is relative, then we append our server to the beginning of it
			if (url.charAt(0) == '/' || !url.length)
			{
				url = Caps.getServer() + url;
			}
			else
			{
				url = Caps.getServer() + "/" + Caps.getGame() + "/" + url;
			}
		}

		return url;
	},

	RetrySchedule: function(initialRetry, maxDuration)
	{
		var count = Math.floor(Math.log(maxDuration / initialRetry));
		var schedule = [initialRetry];
		for(var i=0; i < count + 1; ++i)
		{
			initialRetry *= 2;
			schedule.push(initialRetry);
		}
		return schedule;
	},
	
	OperationWithRetries: function(operationCb, failureCb, failEarly)
	{
		var abortAttempts;
		var abortTime;
		var abortTimeAttempts;
		
		if(failEarly)
		{
			abortAttempts = 3;
			abortTime = 10000;
			abortTimeAttempts = 1;
		}
		else
		{
			abortAttempts = Infinity;
			abortTime = 30000;
			abortTimeAttempts = 6;
		}
		
		// console.log('retry config abortAttempts:', abortAttempts, 'abortTime', abortTime, 'abortTimeAttempts', abortTimeAttempts);
		
		abortTime = Core.Time.getRealTime() + abortTime;
		var timeout = 250;
		var attemptCount = 1;
		
		var failed = false;
		var armed = true;
		
		var failureParam = function()
		{
			if(failed) return;
			
			if(!armed)
			{
				console.log('OperationWithRetries: failureParam called when not armed');
				return;
			}
			armed = false;
			
			if(attemptCount >= abortAttempts)
			{
				console.log('OperationWithRetries: too many retry attempts');
				var failed = true;
				failureCb();
				return;
			}
			
			if(Core.Time.getRealTime() >= abortTime && attemptCount >= abortTimeAttempts)
			{
				console.log('OperationWithRetries: retries took too long');
				console.log('OperationWithRetries: abortTime:', abortTime, 'realTime:', Core.Time.getRealTime());
				console.log('OperationWithRetries: attemptCount:', attemptCount, 'abortTimeAttempts:', abortTimeAttempts);
				var failed = true;
				failureCb();
				return;
			}
			
			console.log('OperationWithRetries: Failure, will retry in ' + timeout + 'ms');
			setTimeout(function()
			{
				if(failed) return;
				armed = true;
				operationCb(failureParam, abortParam);
			}, timeout);
			
			attemptCount += 1;
			timeout *= 2;
		};
		
		var abortParam = function()
		{
			var failed = true;
			failureCb();
		};
		
		operationCb(failureParam, abortParam);
		
		return abortParam;
	},
	
	showFatalErrorDialog: function(status)
	{
		// Set up info dialog
		var myAlert = new AlertDialog();
		myAlert.setTitle(Core.Localization.getString("Network failure"));
		myAlert.setChoices([Core.Localization.getString("Exit")]);

		myAlert.onchoice =
		function(ret)
		{
			myAlert.hide();
			LifecycleEmitter.exitProcess();
		};
		
		// TODO: Move this list somewhere localizable
		var commonErrors = {
			'302': "File location has changed (302)",
			'400': "Bad request to server (400)",
			'401': "Authorization failed (401)",
			'403': "Server permissions error (403)",
			'404': "Resource not found (404)",
			'408': "Request timed out (408)",
			'500': "Internal server error (500)",
			'501': "Cannot process request (501)",
			'502': "Bad Gateway (502)",
			'503': "Service overloaded / down for maintenance (503)",
			'504': "Timeout at intervening gateway (504)"
		};
		myAlert.setText( Core.Localization.getString( commonErrors[status] || "This application requires a working data connection." ) );
		myAlert.show();
	},

	showSimpleNetworkError: function(status)
	{
		// Set up info dialog
		var myAlert = new AlertDialog();
		myAlert.setTitle(Core.Localization.getString("Network failure"));
		myAlert.setChoices([Core.Localization.getString("OK")]);

		myAlert.onchoice =
		function(ret)
		{
			myAlert.hide();
		};

		// TODO: Move this list somewhere localizable
		var commonErrors = {
			'302': " File location has changed (302)",
			'400': " Bad request to server (400)",
			'401': " Authorization failed (401)",
			'403': " Server permissions error (403)",
			'404': " Resource not found (404)",
			'408': " Request timed out (408)",
			'500': " Internal server error (500)",
			'501': " Cannot process request (501)",
			'502': " Bad Gateway (502)",
			'503': " Service overloaded / down for maintenance (503)",
			'504': " Timeout at intervening gateway (504)"
		};
		var message = "Cannot download game without network connection.";
		if (commonErrors[status])
		{
			message += commonErrors[status];
		}
		myAlert.setText( Core.Localization.getString( message ) );
		myAlert.show();
	},
	
	getCacheBustingString: function()
	{
		return '?t=' + (new Date()).getTime();
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Network/_int_Util'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Network/_int_Util'] || {}; $MODULE_REGISTRY['NGCore/Client/Network/_int_Util'] = exports; ///////////////////////////////////////////////////////////////////////////////
// Class _int_Util
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Class = require('NGCore/Client/Core/Class').Class;
////////////////////////////////////////////////////////////////////////////////

exports._int_Util = Class.singleton(
/** @lends Network._int_Util.prototype */
{
	classname: '_int_Util',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this._callbackID = 0;
		this._callbacks = [];

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	ProcID:
	{ 
		/** High privilege proc */
		Persist: -1,
		/** Low priv */
		Game: -2,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 350
	// Method create = -1
	// Method destroy = 2
	// Method sign = 3
	// Method signCallback = 4
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._signCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in _int_Util._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in _int_Util._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[350] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_signCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in _int_Util.signCallback from command: " + cmd );
			return false;
		}
		
		obj[ "signature" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "signature" ] === undefined )
		{
			NgLogE("Could not parse signature in _int_Util.signCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in _int_Util.signCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":350,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":350,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_signSendGen: function( baseString, callbackID, environment )
	{
		Core.Proc.appendToCommandString( ":350,3," + this.__objectRegistryId + "," + Core.Base64.encode( baseString ) + "," + callbackID + "," + Core.Base64.encode( environment )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// sign: function( baseString, callbackID, environment ) {}
	
	// _signCallbackRecv: function( cmd ) {}

// {{/Wg Generated Code}}

	sign: function( baseString, environment, callback) {
		this._callbacks[this._callbackID] = callback;
		this._signSendGen(baseString,this._callbackID, environment);
		this._callbackID++;
	},
	_signCallbackRecv: function( cmd ) {
		var msg = {};
		if (! this._signCallbackRecvGen(cmd, msg)) {
			return;
		}
		var func = this._callbacks[parseInt(msg.callbackID)];
		if (func) {
			func(msg.signature);
		}
	}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/md5'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/md5'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/md5'] = exports; /*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  var hex_tab = "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

var toMD5 = function(s) { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return toMD5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

exports.toMD5 = toMD5;
exports.testMD5 = md5_vm_test;; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/MessageEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/MessageEmitter'] || {}; $MODULE_REGISTRY['NGCore/Shared/MessageEmitter'] = exports; var Class = require('NGCore/Shared/Class').Class;
var MessageListener = require('NGCore/Shared/MessageListener').MessageListener;

exports.MessageEmitter = Class.subclass(
/** @lends Core.MessageEmitter.prototype */
{
	classname: 'MessageEmitter',
	
	/**
	 * @status iOS, Android, Flash
	 * @class The <code>MessageEmitter</code> class constructs emitter objects that send messages to registered <code>{@link Core.MessageListener}</code> objects. 
	 * When a defined condition triggers an emitter, all registered listener objects are in turn triggered.
	 * <br><br>
	 * Emitter objects support two communication modes: emit and chain. When emitting, each listener is called in turn.
	 * When chaining, each listener can halt the propagation of a message to 
	 * other listeners by returning <code>true</code> from their callback.
	 * <br><br>
	 * Each listener can include an optional priority ranking. Priority determines the order
	 * in which an emitter calls each listener. 
	 * If two listener objects are registered with the same priority, the emitter calls them in the order they were registered. 
	 * The default priority is <code>0</code>. 
	 * <br><br>
	 * <b>Note:</b> Do not instantiate this class directly. Use classes derived from <code>MessageEmitter</code> for instantiation. This includes:
	 * <div class="ul">
	 * <li>{@link Core.Localization}</li>
	 * <li>{@link Core.UpdateEmitter}</li>
	 * <li>{@link Device.KeyEmitter}</li>
	 * <li>{@link Device.LifecycleEmitter}</li>
	 * <li>{@link Device.LocationEmitter}</li>
	 * <li>{@link Device.MemoryEmitter}</li>
	 * <li>{@link Device.MotionEmitter}</li>
	 * <li>{@link Device.NetworkEmitter}</li>
	 * <li>{@link Device.OrientationEmitter}</li>
	 * <li>{@link Device.ShakeEmitter}</li>
	 * </div>
	 * @constructs The default constructor.
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this._messageListenersCount = 0;
		this._messageListenerRecords = [];
		this._messageDeferredWork = [];
		this._messageShouldDefer = false;
	},
	
	/**
	 * Unregister all <code>MessageListener</code> objects from this <code>MessageEmitter</code>.<br><br>
	 * <b>Note:</b> Do not use the emitter after calling this.
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function($super)
	{
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._destroyActual.bind(this, $super));
		}
		else
		{
			this._destroyActual($super);
		}
	},
	
	_destroyActual: function(superDestroy)
	{
		// Unregister all listeners.
		var records = this._messageListenerRecords;
		while(records.length)
		{
			this.removeListener(records[0].l);
		}
		
		if(superDestroy)
			superDestroy();
	},
	
	/**
	 * Retrieve the number of <code>MessageListener</code> objects registered with this <code>MessageEmitter</code>.
	 * @returns {Number} The current number of <code>MessageListener</code> objects.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getListenerCount: function()
	{
		return this._messageListenersCount;
	},
	
	/**
	 * Add a <code>MessageListener</code> to this <code>MessageEmitter</code>. When an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * The parameters for the callback function are identical to parameters for <code>emit()</code> or
	 * <code>chain()</code>.
	 * <br><br>
	 * <b>Note:</b> Each listener can only listen to an emitter one time.<br><br>
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 *
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @param {Function} func The callback function.
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @throws {MessageEmitter.addListener: listener is already listening} Calling <code>addListener()</code> multiple times on the same emitter
	 * with the same listener.
	 * @throws {MessageEmitter.addListener: listener must be instances of MessageListener} Listener is not an instance of <code>MessageListener</code>.
	 * @see Core.MessageEmitter#removeListener,
	 * @see Core.MessageEmitter#emit,
	 * @see Core.MessageEmitter#chain
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	addListener: function(listener, func, priority)
	{
		if(!listener instanceof MessageListener)
			throw new Error('MessageEmitter.addListener: listener must be instances of MessageListener');
			
		if(!listener._startListeningEmitter(this))
			throw new Error('MessageEmitter.addListener: listener is already listening');
			
		if(!priority)
		{
			priority = 0;
		}
		
		this._messageListenersCount++;	
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._addListenerActual.bind(this, listener, func, priority));
		}
		else
		{
			this._addListenerActual(listener, func, priority);
		}
	},
	
	_addListenerActual: function(listener, func, priority)
	{
		//  The priority for default value is <code>0</code>
		if ((typeof priority) == 'undefined') {
			priority = 0;
		}
		// TODO Replace with binary search.
		var records = this._messageListenerRecords;
		var len = records.length;
		for(var i=0; i < len; ++i)
		{
			if(records[i].p <= priority)
				break;
		}
		records.splice(i, 0, {l: listener, f: func, p: priority});
	},
	
	/**
	 * Remove a <code>MessageListener</code> from this <code>MessageEmitter</code>.<br><br> 
	 * The following code examples illustrate different call styles for <code>removeListener</code>.
	 * @example
	 * emitter.removeListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.removeListener(myListener);
	 *
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener was removed. Returns <code>false</code> if the registered listener is not found 
	 * or is not registered with this emitter.
	 * @throws {MessageEmitter.removeListener: listener is not listening} Specified listener is not currently registered
	 * with this <code>MessageEmitter</code>.
	 * @see Core.MessageEmitter#addListener
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	removeListener: function(listener)
	{
		if(!listener._stopListeningEmitter(this))
			//throw new Error('MessageEmitter.removeListner: listener is not listening');
			return false;
		
		this._messageListenersCount--;
		if(this._messageShouldDefer)
		{
			// TODO Replace with binary search.
			var records = this._messageListenerRecords;
			var len = records.length;
			for(var i=0; i < len; ++i)
			{
				var record = records[i];
				if(record.l == listener)
				{
					record.f = null;
					break;
				}
			}
			
			this._messageDeferredWork.push(this._removeListenerActual.bind(this, listener));
		}
		else
		{
			this._removeListenerActual(listener);
		}
		
		return true;
	},
	
	_removeListenerActual: function(listener)
	{
		// TODO Replace with binary search.
		var records = this._messageListenerRecords;
		var len = records.length;
		for(var i=0; i < len; ++i)
		{
			var record = records[i];
			if(record.l == listener)
			{
				records.splice(i, 1);
				break;
			}
		}
	},
	
	/**
	 * Send a message to every registered <code>MessageListener</code>. This emitter will trigger all listeners
	 * in descending order based on the listener priority. All listener callback functions are generated
	 * with parameters passed to <code>emit()</code>.
	 * @param {Parameters} parameters Parameters to pass in the generated callback funtion.
	 * @see Core.MessageEmitter#chain
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	emit: function(params)
	{
		var handled = false;
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._emitActual.bind(this, arguments, false));
		}
		else
		{
			handled = this._emitActual(arguments, true);
		}
		return handled;
	},
	
	_emitActual: function(params, executeDeferred)
	{
		this._messageShouldDefer = true;
		
		var records = this._messageListenerRecords;
		var len = records.length;
		var handled = false;
		for(var i=0; i < len; ++i)
		{
			var record = records[i];
			if(!record.f) continue;
			
			if(record.f.apply(record.l, params))
				handled = true;
		}

		if(!handled)
		{
			//NgLogD("No listeners handling emitted key");
		}
		
		this._messageShouldDefer = false;
		
		if(this._messageDeferredWork.length && executeDeferred)
		{
			this._executeDeferred();
		}

		return handled;
	},
	
	/**
	 * Send a message to every registered <code>MessageListener</code> through a chain of command. 
	 * This emitter will trigger all listeners in descending order based on the listener priority.
	 * All listener callback functions are generated with parameters passed to <code>chain()</code>.	 
	 * <br><br>
	 * Unlike <code>emit()</code>, <code>chain()</code> allows a <code>MessageListener</code> to halt propagation of a message 
	 * to other listener objects by returning <code>true</code> for the callback function.
	 * This is useful for things like touch event handling. A <code>MessageListener</code> can respond to a touch event
	 * by returning <code>true</code>, masking the touch event from other listener objects.
	 *
	 * @param {Parameters} parameters Parameters to pass in the generated callback funtion.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener responded. Returns <code>false</code> in all other cases.
	 * <br><br>
	 * <b>Note:</b> If the application calls <code>chain()</code> recursively from
	 * within a message handler callback, it will always return <code>undefined</code>
	 * regardless of if a <code>MessageListener</code> responds or not.
	 * @see Core.MessageEmitter#emit
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	chain: function(params)
	{
		if(this._messageShouldDefer)
		{
			this._messageDeferredWork.push(this._chainActual.bind(this, arguments, false));
			return undefined;
		}
		else
		{
			return this._chainActual(arguments, true);
		}
	},
	
	_chainActual: function(params, executeDeferred)
	{
		var result = false;
		this._messageShouldDefer = true;
		
		var records = this._messageListenerRecords;
		var len = records.length;
		for(var i=0; i < len; ++i)
		{
			var record = records[i];
			if(!record.f) continue;
			
			if(record.f.apply(record.l, params))
			{
				result = true;
				break;
			}
		}
		
		this._messageShouldDefer = false;
		
		if(this._messageDeferredWork.length && executeDeferred)
		{
			this._executeDeferred();
		}
		
		return result;
	},
	
	_executeDeferred: function()
	{
		// NOTE: Don't factor out deferred.length. Deferred work can add more deferred work.
		var deferred = this._messageDeferredWork;
		for(var i=0; i < deferred.length; ++i)
		{
			deferred[i]();
		}
		this._messageDeferredWork = [];
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/MessageListener'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/MessageListener'] || {}; $MODULE_REGISTRY['NGCore/Shared/MessageListener'] = exports; var Class = require('NGCore/Shared/Class').Class;

exports.MessageListener = Class.subclass(
/** @lends Core.MessageListener.prototype */
{
	classname: 'MessageListener',
	
	/**
	 * @class The <code>MessageListener</code> class is a base class for constructing objects that listen for notifications from emitters 
	 * (see <code>{@link Core.MessageEmitter}</code>). Objects of this type are registered with emitters.
	 * When <code>{@link Core.MessageEmitter#emit}</code> or <code>{@link Core.MessageEmitter#chain}</code> is called on an emitter
	 * all registered listeners will generate a callback function.
	 * <br><br>
	 * Applications must unregister listener objects when they are no longer required in one of three ways: 
	 * <div class="ul"><font size="3">
	 * <li>Calling <code>{@link Core.MessageEmitter#removeListener}</code> on the <code>MessageEmitter</code>.</li>
	 * <li>Calling <code>{@link Core.MessageEmitter#destroy}</code> on the <code>MessageEmitter</code>.</li>
	 * <li>Calling <code>{@link Core.MessageListener#destroy}</code> on the <code>MessageListener</code></li>
	 * </font></div><br>
	 * <font size="3"><b>Note:</b> Applications should not attempt to register a listener with an emitter more than once. Registering a listener with an emitter
	 * multiple times results in exceptions. </font>
	 * @example
	 * var MyListener = Core.MessageListener.subclass(
	 * {
	 *     myCallback: function(verb, value)
	 *     {
	 *         console.log('MyListener.myCallback(' + verb + ', ' + value + ')');
	 *     },
	 * }
	 * var listener = new MyListener();
	 * emitter.addListener(listener, listener.myCallback);
	 * emitter.emit('fun', 5);
	 * @constructs The default constructor.
	 * @augments Core.Class
	 * @status iOS, Android, Flash
	 */
	initialize: function()
	{
		this._messageEmitters = [];
	},
	
	/**
	 * Unregister this <code>MessageListener</code> from all emitters.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
		// Unregister from all emitters.
		var emitters = this._messageEmitters;
		while(emitters.length)
			emitters[0].removeListener(this);
	},
	
	// Called by MessageEmitter when this receiver starts listening.
	_startListeningEmitter: function(emitter)
	{
		var emitters = this._messageEmitters;
		var index = emitters.indexOf(emitter);
		if(index !== -1)
			return false;
		
		emitters.push(emitter);
		return true;
	},
	
	// Called by MessageEmitter when this receiver stops listening.
	_stopListeningEmitter: function(emitter)
	{
		var emitters = this._messageEmitters;
		var index = emitters.indexOf(emitter);
		if(index === -1)
			return false;
		
		emitters.splice(index, 1);
		return true;
	},
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Core/_int_LGL'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Core/_int_LGL'] || {}; $MODULE_REGISTRY['NGCore/Client/Core/_int_LGL'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class _int_LGL
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var Proc = require('NGCore/Client/Core/Proc').Proc;
var Base64 = require('NGCore/Client/Core/Base64').Base64;

////////////////////////////////////////////////////////////////////////////////
function getCorrectedPlatformOS() {
	var os = Capabilities.getPlatformOS();
	switch (os) {
		case 'Android': return 'android';
		case 'iPhone OS': return 'ios';
	}
	return os;
};

function expandTexName(name)
{
	var list =
	{
		"pvr": "GL_IMG_texture_compression_pvrtc",
		"atc": "GL_AMD_compressed_ATC_texture",
		"etc1": "GL_OES_compressed_ETC1_RGB8_texture",
		"3dc": "GL_AMD_compressed_3DC_texture"
	};

	return list[name] || name;
};

var overridePropertyEvaluators = {
	isMatch: function(condition, value) {
		// Return true if the condition holds for the provided value
		// condition may be prefixed with an operator, so we extract it.
		var symbol;
		switch (condition.charAt(0)) {
		case '>':
			symbol = (condition.charAt(1) == '=') ? '>=' : '>';
			break;
		case '<':
			symbol = (condition.charAt(1) == '=') ? '<=' : '<';
			break;
		}
		// Consume any characters we detected, then set the default operation (equals)
		if (symbol) {
			condition = condition.slice(symbol.length);
		} else symbol = '=';

		if (condition == value) {
			return (symbol == '=' || symbol == '<=' || symbol == '>=');
		} else if (condition < value) {
			return (symbol == '<' || symbol == '<=');
		} else {
			return (symbol == '>' || symbol == '>=');
		}
	},

	isVersionMatch: function(condition, value) {
		// Return true if the condition holds for the provided value
		// condition may be prefixed with an operator, so we extract it.
		var symbol;
		if (condition.length > 0) switch (condition.charAt(0)) {
		case '>':
			symbol = (condition.charAt(1) == '=') ? '>=' : '>';
			break;
		case '<':
			symbol = (condition.charAt(1) == '=') ? '<=' : '<';
			break;
		case '=':
			symbol = (condition.charAt(1) == '=') ? '==' : '=';
			break;
		}
		// Consume any characters we detected, or set the default operation (equals)
		if (symbol) {
			condition = condition.slice(symbol.length);
		} else symbol = '=';

		var condition = condition.split('.');
		var value = value.split('.');

		var l = Math.max(condition.length, value.length);

		for (var i = 0; i < l; i++) {
			var ci = '0.' + (condition[i] || 0);
			var vi = '0.' + (value[i] || 0);
			if (ci == vi) continue;
			if (ci < vi) {
				return (symbol == '<' || symbol == '<=');
			} else {
				return (symbol == '>' || symbol == '>=');
			}
		}
		return true;
	},

	'sdkVersion': function(v) {
		return this.isVersionMatch('' + v, Capabilities.getSDKVersion());
	},

	'binaryVersion': function(v) {
		return this.isVersionMatch('' + v, Capabilities.getBinaryVersion());
	},

	'platformOS': function(v) {
		return v == getCorrectedPlatformOS();
	},

	'platformOSVersion': function(v) {
		return this.isVersionMatch('' + v, Capabilities.getPlatformOSVersion());
	},

	'platformHW': function(v) {
		return v == Capabilities.getPlatformHW();
	},

	'physicalMem': function(v) {
		return this.isMatch(v, Capabilities.getPhysicalMem());
	},

	'physicalCpus': function(v) {
		return this.isMatch(v, Capabilities.getPhysicalCpus());
	},

	'activeCpus': function(v) {
		return this.isMatch(v, Capabilities.getActiveCpus());
	},

	'language': function(v) {
		return v == Capabilities.getLanguage();
	},

	'textureMatch': "none",
	'textureCompression': function(v) {
		var matched = Capabilities.getOglExtensions().indexOf(expandTexName(v)) > -1;
		if (matched) this.textureMatch = v;
		return matched;
	},

	'screenWidth': function(v) {
		return this.isMatch(v, Capabilities.getScreenWidth());
	},

	'screenHeight': function(v) {
		return this.isMatch(v, Capabilities.getScreenHeight());
	},

	'screenResolution': function(v) {
		return v == (Capabilities.getScreenWidth() + 'x' + Capabilities.getScreenHeight());
	},

	'screenUnits': function(v) {
		return this.isMatch(v, Capabilities.getScreenUnits());
	},

	'screenPixelUnits': function(v) {
		return this.isMatch(v, Capabilities.getScreenPixelUnits());
	},

	'maxTextureSize': function(v) {
		return this.isMatch(v, Capabilities.getMaxTextureSize());
	},
	
	'reset': function(v) {
		this.textureMatch = "none";
	}
};

var _int_LGL = Class.singleton(
/** @lends Core._int_LGL.prototype */
{
	classname: '_int_LGL',

	launch: function(url, proc)
	{
		var Util = require('NGCore/Client/Network/Util').Util;
		// Default to game proc. Games should actually not be aware of the third option,
		//	as they cannot use it anyway.
		if (!proc)
			proc = _int_LGL.ProcID.Game;

		url = Util.NormalizeUrl(url);

		var run = (function()
		{
			gNgShutdownPending = true;
			this._launchSendGen(url,proc);
		}).bind(this);

		if (proc == _int_LGL.ProcID.Game)
		{
			this.updateGameUse(url, run);
		}
		else
		{
			run();
		}
	},

	updateAvailable: function(game, doneCB, errorCB)
	{
		// Normalize URL
		var url = game;
		if (! url.match(/^\//) && !url.match(/https?:\/\//))
			url = '/' + url;

		var caps = require('NGCore/Client/Core/Capabilities').Capabilities;

		// If we are testing ourselves, we don't to md5 our url
		var name = "";
		if (caps.getUrl() != game)
		{
			var Util = require('NGCore/Client/Network/Util').Util;
			url = Util.NormalizeUrl(url);
			name = Util.GetMD5HashDirectoryFromUrl(url);
		}

		// Get device-specific manifest directory
		var buildPath = {"Android" : "android", "iPhone OS" : "ios", "flash" : ""};
		// Get Device capabilities platformOs
		var build = "/" + buildPath[caps.getPlatformOS()];

		var DownloadManifest = require('NGCore/Client/Network/DownloadManifest').DownloadManifest;
		var dm = new DownloadManifest();

		dm.isUpdated(url + build, name, false, doneCB, errorCB);
	},

// Utility (non-generated) functionality
	updateGameUse: function(game, doneCB)
	{
		var Util = require('NGCore/Client/Network/Util').Util;
		var url = Util.NormalizeUrl(game);
		var name = Util.GetMD5HashDirectoryFromUrl(url);
		var self = this;
		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		this.mGameStore = KeyValueCache.global("Core.GameList");
		this.mActiveGameKey = "activeGames";

		// Get our list of games
		this.mGameStore.getItem(this.mActiveGameKey,
			function(error, value)
			{
				var list;
				if (value)
					list = JSON.parse(value);
				else
					list = [];

				var item;
				for (var i in list)
				{
					if (list[i].name == name)
					{
						item = list[i];
						break;
					}
				}

				if (!item)
				{
					item = {"name": name};
					list.push(item);
				}

				item.lastRun = (new Date()).getTime();
				item.url = game;

 				self.mGameStore.setItem(self.mActiveGameKey, JSON.stringify(list));

                LocalGameList.updateGameList(list);
 				doneCB();
			}, true
		);
	},
	
	getManifestName: function(config) {
		var manifestName = 'webgame.ngmanifest';

		if (config && config.manifestOverrides) {
			try {
				var overrides = config.manifestOverrides;

				for (var i = 0; i < overrides.length; i++) {
					var override = overrides[i];
					if (override && override.criteria) {
						// Clear any matched values...
						overridePropertyEvaluators.reset();

						var criteria = override.criteria;
						var overrideMatched = true;
						for (var key in criteria) {
							if (!criteria.hasOwnProperty(key)) continue;
							var value = criteria[key];

							var evaluator = overridePropertyEvaluators[key];
							if (typeof evaluator != 'function') {
								console.log("ERROR! Undefined criterion " + key + " in configuration.json");
								overrideMatched = false;
								break;
							}

							var criterionMatched = false;
							if (value instanceof Array) {
								for (vi = 0; vi < value.length; vi++) {
									criterionMatched |= evaluator.call(overridePropertyEvaluators, value[vi]);
									if (criterionMatched) break;
								}
							} else {
								criterionMatched = evaluator(value);
							}

							if (!criterionMatched) {
								overrideMatched = false;
								break;
							}
						}

						// At this point, the override has matched. Figure out its name and return the value.
						if (overrideMatched) {
							console.log("MATCHED Override: " + JSON.stringify(override));

							// Format the override manifest name:
							var format = override.manifest.slice(0);
							for (var fi = 1; fi < format.length; fi++) {
								var key = format[fi];
								switch (key) {
								case 'textureCompression':
									format[fi] = overridePropertyEvaluators.textureMatch;
									break;
								case 'platformOS':
									format[fi] = getCorrectedPlatformOS();
									break;
								default:
									// Look up the named property on Capabilities.
									var cap = Capabilities['get' + key.charAt(0).toUpperCase() + key.slice(1)]();
									format[fi] = cap.replace(' ', '_');
								}
							}

							return require('NGCore/Shared/Lib/sprintf').sprintf(format);
						} else {
							console.log("DID NOT MATCH Override: " + JSON.stringify(override));
						}
					}
				}
			} catch (e) {
				console.log("ERROR! Exception occurred in manifest overrides: " + e);
			}
		}

		return manifestName;
	},

// {{?Wg Generated Code}}
	
	// Enums.
	ProcID:
	{ 
		/** High privilege proc */
		Persist: -1,
		/** Low priv */
		Game: -2,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 342
	// Method launch = -1
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Proc.parseInt( cmd.shift(), 10 );
			var instance = ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in _int_LGL._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in _int_LGL._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[342] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_launchSendGen: function( url, proc )
	{
		Proc.appendToCommandString( ":342,-1," + Base64.encode( url ) + "," + proc  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $launch: function( url, proc ) {}
	

// {{/Wg Generated Code}}

});

exports._int_LGL = _int_LGL;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Storage/KeyValue'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Storage/KeyValue'] || {}; $MODULE_REGISTRY['NGCore/Client/Storage/KeyValue'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class KeyValue
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

function KeyValueCache() {
};
exports.KeyValueCache = KeyValueCache;
/** @private */
KeyValueCache.lruMeanCacheSize = 100;
/** @private */
KeyValueCache.instanceMap = {};
//TODO: rename this later
var StorageGlobalScopes = [];

KeyValueCache.optimizeCaches = function() 
{
	for (var storeKey in KeyValueCache.instanceMap) {
		if(KeyValueCache.instanceMap.hasOwnProperty(storeKey)) {
			KeyValueCache.instanceMap[storeKey].optimize();
		}
	}
};

KeyValueCache.lowMemoryWarning = function() 
{
	for (var storeKey in KeyValueCache.instanceMap) {
		if(KeyValueCache.instanceMap.hasOwnProperty(storeKey)) {
			var instance = KeyValueCache.instanceMap[storeKey];
			instance.data = {};

			//Purge entries in callbacks
			var newCallbacks = {};
			newCallbacks.uidGenerator = instance.callbacks.uidGenerator;
			for(var cbId in instance.callbacks)
			{
				if(instance.callbacks.hasOwnProperty(cbId)) {
					if(instance.callbacks[cbId]) {
						newCallbacks = instance.callbacks[cbId];
					}
				}
			}
			instance.callbacks = newCallbacks;
		}
	}
};

KeyValueCache.init = function()
{
	KeyValueCache.local = new Storage.KeyValue();
	KeyValueCache.local.registerForKey("local");
};

/**
 * @static Scopes this <code>KeyValueCache</code> object as global. A globally scoped KeyValueCache object can be used by multiple applications for the same data. 
 * @param {String} globalKey The store key for the <code>KeyValueCache</code> object.
 */
KeyValueCache.global = function(globalKey)
{
	if(StorageGlobalScopes[globalKey])
	{
		return StorageGlobalScopes[globalKey];
	}

	//Miss Global Table Cache.
	var scope = new Storage.KeyValue();
	scope.registerForKey(globalKey);
	StorageGlobalScopes[globalKey] = scope;
	return scope;
};

exports.KeyValue = Core.Class.subclass(
/** @lends Storage.KeyValue.prototype */
{
	classname: "KeyValue",
	/**
	 * @class The <code>KeyValue</code> class constructs objects that allow you to manage application key/value pairs in a datastore.
	 * <div class="ul">
	 * <li>Call <code>KeyValueCache.local()</code> to access the <code>local</code> datastore for your application.</li>
	 * <li>Call <code>KeyValueCache.global(globalKey)</code> to access a globally scoped datastore. Multiple applications can use a globally scoped
	 * datastore for the same data. The <code>globalKey</code> parameter is a string that uniquely identifies the datastore.</li>
	 * </div>
	 *
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		/** @private */
		this.initialized = false;
		/** @private */
		this.origin = null;
		/** @private */
		this.callbacks = {};
		/** @private */
		this.callbacks.uidGenerator = 0;
		/** @private */
		this.local = false;
		/** @private */
		this.lruCacheShrinkCounter = 0;
	
		/** @private */
		this.data = {};
		/** @private */
		this.usage = {};
		
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	/**
	 * Destroy this instance and release resources on the backend.
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},
    /*
	 * @private
	 * Call <code>registerForKey()</code> to access a datastore identified by the value of the <code>storeKey</code> parameter.
	 * @param {String} storeKey The unique identifier of the datastore.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	registerForKey: function(storeKey) 
	{
		this.origin = storeKey;
		KeyValueCache.instanceMap[storeKey] = this;

		//Push this instance across the native bridge
		this._registerCommandSendGen(this.origin,KeyValueCache.lruMeanCacheSize);
		
		return this;
	},
	/**
	 * Pass the value associated with the key to the callback function.
	 * @param {String} key The key that is associated with the value to pass to the callback function.
	 * @param {Function} callbackFunc The callback function that uses the value associated with the key.
	 * @param {Boolean} [ignoreCache=false] Set <code>ignoreCache</code> to <code>true</code> to force a read from storage.
	 * @example KeyValue.getItem(SomeKey, function(err){...})
     * @status iOS, Android, Test, iOSTested, AndroidTested     
	 */
	getItem: function(key,callbackFunc,ignoreCache /*defaults to false*/)
	{
		if(!ignoreCache)
		{
			if(this.data[key]) {
				callbackFunc(null,this.data[key],key);
				this.usage[key]++;
				return;
			}
			else
			{
				NgLogD("Value not found in cache for..falling back to native");
			}
		}

		//Generate unused callbackEntry
		var callbackId = this.callbacks.uidGenerator++;

		if(!!!callbackFunc) {
			callbackFunc = function(){};
		}
		this.callbacks[callbackId] = callbackFunc;

		this._getItemSendGen(this.origin,callbackId,key);
	},
	
	/**
	 * Associate a value with a key.
	 * @param {String} key The key to associate with the value.
	 * @param {String} value The value to associate with the key.
	 * @param {Function} [callbackFunc] A callback function with an error parameter. The error parameter is null when the <code>setItem()</code> function completes successfully.
	 * @example KeyValue.setItem(someKey, someValue, function(err){...})
     * @status iOS, Android, Test, iOSTested, AndroidTested          
	 */
	setItem: function(key,value,callbackFunc)
	{
		var value = value;
		this.data[key] = value;

		var callbackId = this.callbacks.uidGenerator++;
		if(!callbackFunc) {
			callbackFunc = function(){};
		}
		this.callbacks[callbackId] = callbackFunc;

		this._setItemSendGen(this.origin,callbackId,key,value);
	},
	
	/**
	 * Remove the value that is associated with a key.
	 * @param {String} key The key that is associated with the value to remove.
	 * @param {Function} [callbackFunc] A callback function with an error parameter. The error parameter is null when the <code>removeItem()</code> function completes successfully.
	 * @example KeyValue.removeItem(someKey, function(err){...})
     * @status iOS, Android, Test, iOSTested, AndroidTested     
	 */
	removeItem: function(key,callbackFunc)
	{
		var callbackId = this.callbacks.uidGenerator++;
		if(!!!callbackFunc) {
			callbackFunc = function(){};
		}
		this.callbacks[callbackId] = callbackFunc;

		this._removeItemSendGen(this.origin,callbackId,key);
	},

	/**
	 *  @private
	 * 	clear all key/value pairs stored within this store
	 *  @param {callbackFunc} The callback function to be called
     *  @status iOS, Android, Test, iOSTested, AndroidTested          
	 */
	clear: function(callbackFunc)
	{
		var callbackId = this.callbacks.uidGenerator++;
		if(!!!callbackFunc) {
			callbackFunc = function(){};
		}
		this.callbacks[callbackId] = callbackFunc;

		this._clearSendGen(this.origin,callbackId);
	},
    /*
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	enforceLRUCacheSize: function()
	{
		NgLogD("Enforcing KeyValue Cache Size");
		var tmp = [];
		for (var k in this.data) {
			if (this.data.hasOwnProperty(k)) {
				tmp.push(k);
			}
		}
		var usage = this.usage;
		tmp.sort(function(a,b) {
			var p1 = usage[a];
			if (!p1) {
				p1 = 0;
			}

			var p2 = usage[b];
			if (!p2) {
				p2 = 0;
			}

			if (p1 == p2) { return 0; }
			return p1 < p2 ? 1 : -1;
		});

		var oldData = this.data;
		this.data = {};
		//Copy over the lruMeanCache(number) most used entries
		var stopPoint = KeyValueCache.lruMeanCacheSize;
		for (var i = 0; i < stopPoint && i < tmp.length; i++)
		{
			if(!oldData[tmp[i]]) {
				//Case cache didn't contain that key at this point in time
				stopPoint++;
			}
			else {
				this.data[tmp[i]] = oldData[tmp[i]];
			}
		}
	},
	
	_getInstanceRecv : function(cmd)
	{
		var msg = {};
		if(!this._getInstanceRecvGen(cmd, msg))
			return;
			
		var storeKey = msg["storeKey"];

		var instance = KeyValueCache.instanceMap[storeKey];
		//NgLogD("Storage.getInstanceForCommand Found instance for key [" + storeKey + "]: " + instance + " (" + command + ")");
		return instance;
	},
	
	_registerCommandCbRecv : function(cmd)
	{		
		var msg = {};
		if(!this._registerCommandCbRecvGen(cmd, msg))
			return;
		
		//NgLogD("Storage registerCallback: "+command+"\n");
		if(msg["error"]){
			console.log("Storage: Error registering for KeyValue location '"+msg["error"]+"'");
			if(!this.initialized) {
				delete StorageGlobalScopes[msg["originalStoreKey"]];
			}
			return;
		}

		if(this.origin == "local") {
			this.local = true;
			StorageGlobalScopes[this.origin] = this;
		}

		this.origin = msg["storeKey"];
		this.initialized = true;
		
		for(var i=0; i < msg.preloadDataCount; ++i)
		{
			var preload = {};
			if(!this._preloadDataRecvGen(cmd, preload))
				return;
			
			this.data[preload.key] = preload.value;
		}
	},
	
	_getItemCommandCbRecv : function(cmd)
	{
		var msg = {};
		if(!this._getItemCommandCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];
		var key = msg["key"];
		var value = msg["value"];
		if (error) {
			value = null;
		}

		this.data[key] = value;
		if(!this.usage[key]) {
			this.usage[key] = 1;
		} else {
			this.usage[key]++;
		}

		cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			cb(error,value,key);
			this.callbacks[cbId] = null;
		}

		if(((this.lruCacheShrinkCounter++) % KeyValueCache.lruMeanCacheSize) === 0) {
			this.enforceLRUCacheSize();
		}
		return this;
	},
	
	_setItemCommandCbRecv : function(cmd)
	{
		var msg = {};
		if(!this._setItemCommandCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];
		var key = msg["key"];

		if(!this.usage[key]) {
			this.usage[key] = 1;
		} else {
			this.usage[key]++;
		}
		
		//NgLogD("Storage.setItemCommand Found instance for key [" + key + "]: " + " (" + cbId + ")");

		cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			//NgLogD("Storage.setItemCommand Found callback");
			cb(error,key);
			this.callbacks[cbId] = null;
		}
		if(((this.lruCacheShrinkCounter++) % KeyValueCache.lruMeanCacheSize) === 0) {
			this.enforceLRUCacheSize();
		}
	},
	
	_removeItemCbRecv : function(cmd)
	{
		var msg = {};
		if(!this._removeItemCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];
		var key = msg["key"];
		delete this.usage[key];
		delete this.data[key];

		cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			cb(error,key);
			this.callbacks[cbId] = null;
		}
	},
	
	_clearCommandCbRecv : function(cmd)
	{
		var msg ={};
		if(!this._clearCommandCbRecvGen(cmd, msg))
			return;
		
		var cbId = msg["callbackId"];
		var error = msg["error"];

		this.data = {};
		this.usage = {};

		cb = this.callbacks[cbId];
		if(typeof cb == "function") {
			cb(error,this.origin);
			this.callbacks[cbId] = null;
		}

	},

	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Enumeration for response types.
	 * @namespace
	 */
	Responses:
	{ 
		/** Register Storage */
		Register: 0,
		/** Get Item */
		GetItem: 1,
		/** Set Item */
		SetItem: 2,
		/** Remove Item */
		RemoveItem: 3,
		/** Clear All */
		Clear: 4,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 339
	// Method create = -1
	// Method destroy = 2
	// Method registerCommand = 3
	// Method getItem = 4
	// Method setItem = 5
	// Method removeItem = 6
	// Method clear = 7
	// Method getInstance = 8
	// Method registerCommandCb = 9
	// Method preloadData = 10
	// Method getItemCommandCb = 11
	// Method setItemCommandCb = 12
	// Method removeItemCb = 13
	// Method clearCommandCb = 14
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 8:
					instance._getInstanceRecv( cmd );
					break;
				case 9:
					instance._registerCommandCbRecv( cmd );
					break;
				case 10:
					instance._preloadDataRecv( cmd );
					break;
				case 11:
					instance._getItemCommandCbRecv( cmd );
					break;
				case 12:
					instance._setItemCommandCbRecv( cmd );
					break;
				case 13:
					instance._removeItemCbRecv( cmd );
					break;
				case 14:
					instance._clearCommandCbRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in KeyValue._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in KeyValue._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[339] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_getInstanceRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.getInstance from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_registerCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 5 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "originalStoreKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "originalStoreKey" ] === undefined )
		{
			NgLogE("Could not parse originalStoreKey in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "preloadDataCount" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "preloadDataCount" ] === undefined )
		{
			NgLogE("Could not parse preloadDataCount in KeyValue.registerCommandCb from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 5);
		return true;
	},
	
	/** @private */
	_preloadDataRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 2 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.preloadData from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.preloadData from command: " + cmd );
			return false;
		}
		
		obj[ "value" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "value" ] === undefined )
		{
			NgLogE("Could not parse value in KeyValue.preloadData from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 2);
		return true;
	},
	
	/** @private */
	_getItemCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 6 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "value" ] = Core.Proc.parseString( cmd[ 5 ] );
		if( obj[ "value" ] === undefined )
		{
			NgLogE("Could not parse value in KeyValue.getItemCommandCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_setItemCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 6 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "value" ] = Core.Proc.parseString( cmd[ 5 ] );
		if( obj[ "value" ] === undefined )
		{
			NgLogE("Could not parse value in KeyValue.setItemCommandCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_removeItemCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 5 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		obj[ "key" ] = Core.Proc.parseString( cmd[ 4 ] );
		if( obj[ "key" ] === undefined )
		{
			NgLogE("Could not parse key in KeyValue.removeItemCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_clearCommandCbRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 4 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "response" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "response" ] === undefined )
		{
			NgLogE("Could not parse response in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "storeKey" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "storeKey" ] === undefined )
		{
			NgLogE("Could not parse storeKey in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 3 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in KeyValue.clearCommandCb from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":339,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":339,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_registerCommandSendGen: function( storeKey, lruMeanCacheSize )
	{
		Core.Proc.appendToCommandString( ":339,3," + this.__objectRegistryId + "," + Core.Base64.encode( storeKey ) + "," + lruMeanCacheSize  );
	},
	
	/** @private */
	_getItemSendGen: function( storeKey, callbackId, key )
	{
		Core.Proc.appendToCommandString( ":339,4," + this.__objectRegistryId + "," + Core.Base64.encode( storeKey ) + "," + callbackId + "," + Core.Base64.encode( key )  );
	},
	
	/** @private */
	_setItemSendGen: function( storeKey, callbackId, key, value )
	{
		Core.Proc.appendToCommandString( ":339,5," + this.__objectRegistryId + "," + Core.Base64.encode( storeKey ) + "," + callbackId + "," + Core.Base64.encode( key ) + "," + Core.Base64.encode( value )  );
	},
	
	/** @private */
	_removeItemSendGen: function( storeKey, callbackId, key )
	{
		Core.Proc.appendToCommandString( ":339,6," + this.__objectRegistryId + "," + Core.Base64.encode( storeKey ) + "," + callbackId + "," + Core.Base64.encode( key )  );
	},
	
	/** @private */
	_clearSendGen: function( storeKey, callbackId )
	{
		Core.Proc.appendToCommandString( ":339,7," + this.__objectRegistryId + "," + Core.Base64.encode( storeKey ) + "," + callbackId  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// registerCommand: function( storeKey, lruMeanCacheSize ) {}
	
	// getItem: function( storeKey, callbackId, key ) {}
	
	// setItem: function( storeKey, callbackId, key, value ) {}
	
	// removeItem: function( storeKey, callbackId, key ) {}
	
	// clear: function( storeKey, callbackId ) {}
	
	// _getInstanceRecv: function( cmd ) {}
	// _registerCommandCbRecv: function( cmd ) {}
	// _preloadDataRecv: function( cmd ) {}
	// _getItemCommandCbRecv: function( cmd ) {}
	// _setItemCommandCbRecv: function( cmd ) {}
	// _removeItemCbRecv: function( cmd ) {}
	// _clearCommandCbRecv: function( cmd ) {}

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Lib/sprintf'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Lib/sprintf'] || {}; $MODULE_REGISTRY['NGCore/Shared/Lib/sprintf'] = exports; /**
sprintf() for JavaScript 0.6

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2007.04.03 - 0.1:
 - initial release
2007.09.11 - 0.2:
 - feature: added argument swapping
2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)
2007.10.21 - 0.4:
 - unit test and patch (David Baird)
2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license
2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.
**/



exports.sprintf = function() {
	str_repeat = function(i, m) {
		for (var o = []; m > 0; o[--m] = i);
		return o.join('');
	};

	var params = new Array();
	var outputArray = false;
	var paramsConsumed = 1;
	if (typeof(arguments[0]) == 'object' && arguments[0].length) {
		outputArray = true;
		for (var i = 0; i < arguments[0].length; ++i) {
			params[i] = arguments[0][i];
		}
	} else {
		for (var i = 0; i < arguments.length; ++i) {
			params[i] = arguments[i];
		}
	}

	var i = 0, a, f = params[i++], o = [], m, p, c, x, s = '';
	while (f) {
		if (m = /^[^\x25]+/.exec(f)) {
			o.push(m[0]);
		}
		else if (m = /^\x25{2}/.exec(f)) {
			o.push('%');
		}
		else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
			if (((a = params[m[1] || i++]) == null) || (a == undefined)) {
				throw('Too few arguments.');
			}
			if (/[^s]/.test(m[7]) && (typeof(a) != 'number')) {
				throw('Expecting number but found ' + typeof(a));
			}
			switch (m[7]) {
				case 'b': a = a.toString(2); break;
				case 'c': a = String.fromCharCode(a); break;
				case 'd': a = parseInt(a); break;
				case 'e': a = m[6] ? a.toExponential(m[6]) : a.toExponential(); break;
				case 'f': a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a); break;
				case 'o': a = a.toString(8); break;
				case 's': a = ((a = String(a)) && m[6] ? a.substring(0, m[6]) : a); break;
				case 'u': a = Math.abs(a); break;
				case 'x': a = a.toString(16); break;
				case 'X': a = a.toString(16).toUpperCase(); break;
			}
			a = (/[def]/.test(m[7]) && m[2] && a >= 0 ? '+'+ a : a);
			c = m[3] ? m[3] == '0' ? '0' : m[3].charAt(1) : ' ';
			x = m[5] - String(a).length - s.length;
			p = m[5] ? str_repeat(c, x) : '';
			o.push(s + (m[4] ? a + p : p + a));
			if (outputArray) ++paramsConsumed;
		}
		else {
			throw('Huh ?!');
		}
		f = f.substring(m[0].length);
	}
	if (outputArray && paramsConsumed > 0) {
		arguments[0].splice(0, paramsConsumed);
	}
	return o.join('');
};

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/LocationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/LocationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/LocationEmitter'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class LocationEmitter
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.LocationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.LocationEmitter.prototype */
{
	classname: 'LocationEmitter',

	Accuracy:
	{
		LOW:    0, // less power consumption. equivalent to "3km"  in iOS
		MEDIUM: 1, // equivalent to "100m" in iOS
		HIGH:   2  // most accurate, high power consumption. equivalent to "Best" in iOS
	},

	Elements:
	{
		LATITUDE:  1,
		LONGITUDE: 2,
		ALTITUDE:  4,
		HEADING:   8  // equivalent to "bearing" in Android
	},

	/**
	 * @class The <code>LocationEmitter</code> class constructs a singleton object that emits <a href="Device.LocationEmitter.Location.html">Location</a> objects.<br><br>
     * @constructs The default constructor. 
 	 * @see Device.LocationEmitter.Location
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._lastLocation = undefined;
		this._forceListeners = [];
	},

	/**
	 * @param {LocationEmitter#Accuracy} Accuracy accuracy of updates. The default value is HIGH.
	 * @param {Number} elements OR-ed <code>LocationEmitter.Elements</code>. Example: LATITUDE | LONGITUDE. The default value is LATITUDE | LONGITUDE | ALTITUDE | HEADING (i.e. listens to all elements).
	 * @status
	 */
	setProperties: function(accuracy, elements)
	{
		if (! accuracy) accuracy = this.Accuracy.HIGH;
		if (! elements) elements = this.Elements.LATITUDE | this.Elements.LONGITUDE | this.Elements.ALTITUDE | this.Elements.HEADING;
		this.accuracy = accuracy;
		this.elements = elements;
		this._setPropertiesSendGen(accuracy,elements);
	},

	/**
	 * Add a <code>MessageListener</code> to this emitter. When an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * The parameters for the callback function are identical to parameters for <code>emit()</code> or
	 * <code>chain()</code>.
	 * <br><br>
	 * <b>Note:</b> Each listener can only listen to an emitter one time.<br><br>
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @param {Function} func The callback function.
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @throws {MessageEmitter.addListener: listener is already listening} Calling <code>addListener()</code> multiple times on the same emitter
	 * with the same listener.
	 * @throws {MessageEmitter.addListener: listener must be instances of MessageListener} Listener is not an instance of <code>MessageListener</code>.
	 * @see Device.LocationEmitter#removeListener,
	 * @see Core.MessageEmitter#emit,
	 * @see Core.MessageEmitter#chain
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	addListener: function($super, listener, func, forceStart, priority) {
		if(forceStart == undefined)
		{
			this._startUpdatingSendGen(true);
			this._forceListeners.push(listener);
		}
		else
		{
			this._startUpdatingSendGen(forceStart);
			if(forceStart == true)
				this._forceListeners.push(listener);
		}

		$super(listener, func, priority);
	},
	
	/**
	 * Remove a <code>MessageListener</code> from this emitter.<br><br> 
	 * The following code examples illustrate different call styles for <code>removeListener()</code>.
	 * @example
	 * emitter.removeListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener was removed. Returns <code>false</code> if the registered listener is not found 
	 * or is not registered with this emitter.
	 * @throws {MessageEmitter.removeListener: listener is not listening} Specified listener is not currently registered
	 * with this emitter.
	 * @see Device.LocationEmitter#addListener
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	removeListener: function($super, listener) {
		$super(listener);

		var index = this._forceListeners.indexOf(listener);
		if(index != -1)
		{
			this._forceListeners.splice(index,1);
			if(this._forceListeners.length == 0)
				this._stopUpdatingSendGen();
		}
	},
    
	/**
	 * Retrieve the last location returned by this <code>LocationEmitter</code>.
	 * @returns {Device.LocationEmitter.Location} The last location returned.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getLastLocation: function()
	{
		if(this._lastLocation == undefined || !this._lastLocation.getPosition()) return undefined;
		
		return this._lastLocation;
	},
	
    _locationUpdatedRecv: function( cmd ) {
		var msg = {};
		if (!this._locationUpdatedRecvGen(cmd, msg))
		    return;
		
		if (((this.elements & this.Elements.LATITUDE) == 0)  &&
			((this.elements & this.Elements.LONGITUDE) == 0) &&
			((this.Elements & this.Elements.ALTITUDE) == 0))
			return;

		this._lastLocation = new this.Location(
			new Core.Point(msg["latitude"], msg["longitude"]),
			msg["altitude"],
			undefined,
			msg["accuracy"],
			msg["timestamp"]);

		this.emit(this._lastLocation);
    },
	
	_headingUpdatedRecv: function( cmd ) 
	{
		var msg = {};
		if (!this._headingUpdatedRecvGen(cmd, msg))
			return;
			
		if ((this.elements & this.Elements.HEADING) == 0)
			return;

		this._lastLocation = new this.Location(
			this._lastLocation ? this._lastLocation.getPosition() : undefined,
			this._lastLocation ? this._lastLocation.getAltitude() : undefined,
			msg['magneticHeading'],
			this._lastLocation ? this._lastLocation.getAccuracy() : undefined,
			msg['timestamp']);
		
		if(msg['magneticHeading']) {
			this.emit(this._lastLocation);
		}
	},
	
	Location: Core.Class.subclass(
	/** @lends Device.LocationEmitter.Location.prototype */
	{
		classname: 'Location',
		
		/**
		 * @class <code>Location</code> constructs objects that encapsulate the location of a device.
		 * <code>Location</code> objects contain spatial components, like position and heading information, and a timestamp that indicates when a location is measured.
		 * 
		 * @constructs The default constructor. 
		 * @param {Core.Point} position The latitude / longitude of the device.
		 * @param {Number} altitude The altitude of the device.
		 * @param {Number} heading The heading of the device.
		 * @param {Number} accuracy The accuracy of the measurement.
		 * @param {Number} timestamp The timestamp when the location was measured.
		 * @augments Core.Class
		 */
		initialize: function(position, altitude, heading, accuracy, timestamp)
		{
			this._position = position;
			this._altitude = altitude;
			this._accuracy = accuracy;
			this._heading = heading;
			this._timestamp = timestamp;
		},
		
		/**
		 * Return the position of this <code>Location</code> as latitude / longitude.
		 * @returns {Core.Point} The current latitude / longitude.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getPosition: function()
		{
			return this._position;
		},
		
		/**
		 * Return the altitude of this <code>Location</code> in feet (ft).
		 * @returns {Number} The current altitude.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getAltitude: function()
		{
			return this._altitude;
		},
		
		/**
		 * Return the heading of this <code>Location</code> in degrees east of north.
		 * @returns {Number} The current heading.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getHeading: function()
		{
			return this._heading;
		},
		
		/**
		 * Return the accuracy of the measurement for this <code>Location</code>.
		 * @returns {Number} The current location accuracy.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getAccuracy: function()
		{
			return this._accuracy;
		},
		
		/**
		 * Return the timestamp when this measurement was taken.
		 * Expressed in milliseconds since Epoch (Unix time).
		 * @returns {Number} The timestamp of the measurement.
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getTimestamp: function()
		{
			return this._timestamp;
		},
	}),
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 333
	// Method create = -1
	// Method destroy = 2
	// Method startUpdatingLocation = 3
	// Method stopUpdatingLocation = 4
	// Method locationUpdated = 5
	// Method startUpdatingHeading = 6
	// Method stopUpdatingHeading = 7
	// Method headingUpdated = 8
	// Method setProperties = 9
	// Method startUpdating = 10
	// Method stopUpdating = 11
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 5:
					instance._locationUpdatedRecv( cmd );
					break;
				case 8:
					instance._headingUpdatedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LocationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LocationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[333] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_locationUpdatedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 5 )
		{
			NgLogE("Could not parse due to wrong argument count in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "timestamp" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "timestamp" ] === undefined )
		{
			NgLogE("Could not parse timestamp in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "latitude" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "latitude" ] === undefined )
		{
			NgLogE("Could not parse latitude in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "longitude" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "longitude" ] === undefined )
		{
			NgLogE("Could not parse longitude in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "altitude" ] = Core.Proc.parseFloat( cmd[ 3 ] );
		if( obj[ "altitude" ] === undefined )
		{
			NgLogE("Could not parse altitude in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "accuracy" ] = Core.Proc.parseFloat( cmd[ 4 ] );
		if( obj[ "accuracy" ] === undefined )
		{
			NgLogE("Could not parse accuracy in LocationEmitter.locationUpdated from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_headingUpdatedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 4 )
		{
			NgLogE("Could not parse due to wrong argument count in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "timestamp" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "timestamp" ] === undefined )
		{
			NgLogE("Could not parse timestamp in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "magneticHeading" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "magneticHeading" ] === undefined )
		{
			NgLogE("Could not parse magneticHeading in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "trueHeading" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "trueHeading" ] === undefined )
		{
			NgLogE("Could not parse trueHeading in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		obj[ "accuracy" ] = Core.Proc.parseFloat( cmd[ 3 ] );
		if( obj[ "accuracy" ] === undefined )
		{
			NgLogE("Could not parse accuracy in LocationEmitter.headingUpdated from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":333,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":333,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_startUpdatingLocationSendGen: function( accuracy, distanceFilter )
	{
		Core.Proc.appendToCommandString( ":333,3," + this.__objectRegistryId + "," + accuracy + "," + distanceFilter  );
	},
	
	/** @private */
	_stopUpdatingLocationSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":333,4," + this.__objectRegistryId );
	},
	
	/** @private */
	_locationUpdatedSendGen: function( timestamp, latitude, longitude, altitude, accuracy )
	{
		Core.Proc.appendToCommandString( ":333,5," + this.__objectRegistryId + "," + timestamp + "," + latitude + "," + longitude + "," + altitude + "," + accuracy  );
	},
	
	/** @private */
	_startUpdatingHeadingSendGen: function( orientation, angularFilter )
	{
		Core.Proc.appendToCommandString( ":333,6," + this.__objectRegistryId + "," + orientation + "," + angularFilter  );
	},
	
	/** @private */
	_stopUpdatingHeadingSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":333,7," + this.__objectRegistryId );
	},
	
	/** @private */
	_headingUpdatedSendGen: function( timestamp, magneticHeading, trueHeading, accuracy )
	{
		Core.Proc.appendToCommandString( ":333,8," + this.__objectRegistryId + "," + timestamp + "," + magneticHeading + "," + trueHeading + "," + accuracy  );
	},
	
	/** @private */
	_setPropertiesSendGen: function( accuracy, elements )
	{
		Core.Proc.appendToCommandString( ":333,9," + this.__objectRegistryId + "," + accuracy + "," + elements  );
	},
	
	/** @private */
	_startUpdatingSendGen: function( force )
	{
		Core.Proc.appendToCommandString( ":333,10," + this.__objectRegistryId + "," + ( force ? 1 : 0 )  );
	},
	
	/** @private */
	_stopUpdatingSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":333,11," + this.__objectRegistryId );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// startUpdatingLocation: function( accuracy, distanceFilter ) {}
	
	// stopUpdatingLocation: function(  ) {}
	
	// _locationUpdatedRecv: function( cmd ) {}
	// locationUpdated: function( timestamp, latitude, longitude, altitude, accuracy ) {}
	
	// startUpdatingHeading: function( orientation, angularFilter ) {}
	
	// stopUpdatingHeading: function(  ) {}
	
	// _headingUpdatedRecv: function( cmd ) {}
	// headingUpdated: function( timestamp, magneticHeading, trueHeading, accuracy ) {}
	
	// setProperties: function( accuracy, elements ) {}
	
	// startUpdating: function( force ) {}
	
	// stopUpdating: function(  ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/MemoryEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/MemoryEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/MemoryEmitter'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.MemoryEmitter = Core.MessageEmitter.singleton(
/** @lends Device.MemoryEmitter.prototype */
{
	classname: 'MemoryEmitter',
		
	/**
	 * @class The <code>MemoryEmitter</code> class constructs a singleton object that emits messages
	 * when a low memory warning is received from the system.
	 * Applications can respond by releasing unused objects, allowing the system to re-allocate free memory.
	 * Failure to respond to low memory warnings may result in application 
	 * termination by the operating system.<br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_memoryEventRecv: function( cmd ) 
	{
		this.emit();
		
		//Cascade the original message back out to native for forwarding
		this._memoryEventSendGen();
	},
													  
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 331
	// Method create = -1
	// Method memoryEvent = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._memoryEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MemoryEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MemoryEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[331] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_memoryEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in MemoryEmitter.memoryEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":331,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_memoryEventSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":331,2," + this.__objectRegistryId );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _memoryEventRecv: function( cmd ) {}
	// memoryEvent: function(  ) {}
	

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/MotionEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/MotionEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/MotionEmitter'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.MotionEmitter = Core.MessageEmitter.singleton(
/** @lends Device.MotionEmitter.prototype */
{
	classname: 'MotionEmitter',
	
	/**
	 * @class The <code>MotionEmitter</code> class constructs a singleton object that tracks device movement through 3D space. 
	 * These objects emit <a href="Device.MotionEmitter.Motion.html">Motion</a> objects that retrieve spatial data for a given component from the device.<br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @see Device.MotionEmitter.Motion
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._lastAccel = null;
		this._lastGyro  = null;
		this._lastCompass = null;
	},

	Motion: Core.Class.subclass(
	/** @lends Device.MotionEmitter.Motion.prototype */
	{
		classname: 'Motion',
		
		/**
		 * @class <code>MotionEmitter</code> objects use <code>Motion</code> objects to indicate device movement through 3D space.
		 * These objects retrieve data from device components on how a device responds to 
		 * physical movement, as reported by the accelerometer, gyroscope and compass instruments.
		 * @constructs The default constructor. 
		 * @param {Object} accel accelerometer data for the device, indexed by "x", "y", and "z".
		 * @param {Object} gyro gyroscope accelerometer data for the device, indexed by "x", "y", and "z".
		 * @param {Object} compass compass data for the device, indexed by "x", "y", and "z".
		 * @see Device.MotionEmitter
		 * @augments Core.Class
		 */
		initialize: function(accel, gyro, compass)
		{
			this._accel = accel;
			this._gyro  = gyro;
			this._compass = compass;
		},
		
		/**
		 * Retrieve accelerometer data from the device. A call to <code>getAccelData()</code> on a device that contains an accelerometer
		 * returns an object that contains the accelerometer data. In all other cases,
		 * calling <code>getAccelData()</code> returns <code>undefined</code>.
		 * <b>Note:</b> Use a <code>{@link Core.Capabilities</code> object 
		 * to programmatically check a device for a accelerometer. 
		 * @returns {Object} An object that contains the accelerometer data for the device, indexed by "x", "y", and "z".
		 * @see Core.Capabilities#getHasAccel
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getAccelData: function()
		{
			return this._accel;
		},
		
		/**
		 * Retrieve gyroscope data from the device. A call to <code>getGyroData()</code> on a device that contains a gyroscope
		 * returns an object that contains the gyroscope data. In all other cases,
		 * this call returns <code>undefined</code>. <br><br>
		 * <b>Note:</b> Use a <code>{@link Core.Capabilities</code> object 
		 * to programmatically check a device for a gyroscope. 
		 * @returns {Object} An object that contains the gyroscope data for the device, indexed by "x", "y", and "z".
		 * @see Core.Capabilities#getHasGyro
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getGyroData: function()
		{
			return this._gyro;
		},
		
		/**
		 * Retrieve compass data from the device. A call to <code>getCompassData()</code> on a device that contains a magnetic compass
		 * returns an object that contains the compass data. In all other cases,
		 * this call returns <code>undefined</code>.<br><br>
		 * <b>Note:</b> Use a <code>Capabilities</code> object to programmatically check a device for a compass. 
		 * @returns {Object} An object that contains the compass data for the device, indexed by "x", "y", and "z".
		 * @see Core.Capabilities#getHasCompass
		 * @status iOS, Android, Test, iOSTested, AndroidTested
		 */
		getCompassData: function()
		{
			return this._compass;
		},
	}),

	/**
	 * Register a <code>MessageListener</code> object with this <code>MotionEmitter</code> object. If an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * The parameter for the callback function is a <code>Motion</code> object.<br><br>
	 * <b>Note:</b> Each listener can only listen to an emitter once.
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 *
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @param {Function} func The callback function.
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @see Core.MessageEmitter#emit,
	 * @see Core.MessageEmitter#chain
	 *
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	addListener: function($super, listener, func, priority)
	{
		if (this.getListenerCount() == 0) {
			// start the Accelerometer if this is the first listener
			this._startMotionSendGen();
		}

		$super(listener, func, priority);
	},

	/**
	 * Remove a <code>MessageListener</code> object from this <code>MotionEmitter</code> object. 
	 * The following code examples illustrate different call styles for <code>removeListener()</code>.
	 * @example
	 * emitter.removeListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.	 
	 * @returns {Boolean} Returns <code>true</code> when the registered listener was removed. Returns <code>false</code> in all other cases.
	 * @see Core.MessageEmitter#addListener
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	removeListener: function($super, listener)
	{
		$super(listener);

		if (this.getListenerCount() == 0) {
			// stop the Accelerometer if this is the last listener
			this._stopMotionSendGen();
		}
	},

	_emitMotion: function()
	{
		var motion = new Device.MotionEmitter.Motion(this._lastAccel, this._lastGyro, this._lastCompass);
		this.emit(motion);
	},

	_accelChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._accelChangedRecvGen(cmd, msg))
			return;

		this._lastAccel = msg;
		this._emitMotion();
		
		//Cascade the original message back out to native for forwarding
		this._accelChangedSendGen(msg.x, msg.y, msg.z);
	},

	_gyroChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._gyroChangedRecvGen(cmd, msg))
			return;

		this._lastGyro = msg;
		this._emitMotion();
		
		//Cascade the original message back out to native for forwarding
		this._gyroChangedSendGen(msg.x, msg.y, msg.z);
	},
	
	_magneticChangedRecv: function( cmd ) 
	{
		var msg = {};
		if(!this._magneticChangedRecvGen(cmd, msg))
			return;
		
 		this._lastCompass = msg;
		this._emitMotion();
		
		//Cascade the original message back out to native for forwarding
		this._magneticChangedSendGen(msg.x, msg.y, msg.z);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 330
	// Method create = -1
	// Method accelChanged = 2
	// Method gyroChanged = 3
	// Method magneticChanged = 4
	// Method startMotion = 5
	// Method stopMotion = 6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._accelChangedRecv( cmd );
					break;
				case 3:
					instance._gyroChangedRecv( cmd );
					break;
				case 4:
					instance._magneticChangedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in MotionEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in MotionEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[330] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_accelChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		obj[ "z" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "z" ] === undefined )
		{
			NgLogE("Could not parse z in MotionEmitter.accelChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_gyroChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		obj[ "z" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "z" ] === undefined )
		{
			NgLogE("Could not parse z in MotionEmitter.gyroChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_magneticChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		obj[ "z" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "z" ] === undefined )
		{
			NgLogE("Could not parse z in MotionEmitter.magneticChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":330,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_accelChangedSendGen: function( x, y, z )
	{
		Core.Proc.appendToCommandString( ":330,2," + this.__objectRegistryId + "," + x + "," + y + "," + z  );
	},
	
	/** @private */
	_gyroChangedSendGen: function( x, y, z )
	{
		Core.Proc.appendToCommandString( ":330,3," + this.__objectRegistryId + "," + x + "," + y + "," + z  );
	},
	
	/** @private */
	_magneticChangedSendGen: function( x, y, z )
	{
		Core.Proc.appendToCommandString( ":330,4," + this.__objectRegistryId + "," + x + "," + y + "," + z  );
	},
	
	/** @private */
	_startMotionSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":330,5," + this.__objectRegistryId );
	},
	
	/** @private */
	_stopMotionSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":330,6," + this.__objectRegistryId );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _accelChangedRecv: function( cmd ) {}
	// accelChanged: function( x, y, z ) {}
	
	// _gyroChangedRecv: function( cmd ) {}
	// gyroChanged: function( x, y, z ) {}
	
	// _magneticChangedRecv: function( cmd ) {}
	// magneticChanged: function( x, y, z ) {}
	
	// startMotion: function(  ) {}
	
	// stopMotion: function(  ) {}
	

// {{/Wg Generated Code}} }}}

});
// vim:set fdm=marker noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/NetworkEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/NetworkEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/NetworkEmitter'] = exports; var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.NetworkEmitter = Core.MessageEmitter.singleton(
/** @lends Device.NetworkEmitter.prototype */
{
	classname: 'NetworkEmitter',
	
	/**
	 * @class The <code>NetworkEmitter</code> class constructs a singleton object that tracks network connectivity status for a device.
	 * These objects emit a <a href="Device.NetworkEmitter.html#Status">Status</a> object when a change to device network connectivity status occurs.
	 * A change in network status is defined as:
	 * <div class="ul"><font size="3">
	 * <li>The device loses access to a network.</li>
	 * <li>The device gains access to a network.</li>
	 * <li>The device switches between cellular and Wi-Fi network access.</li>
	 * </font></div><br>
	 * <p><b>Note:</b> Applications should never directly allocate a singleton.</p>
	 * @constructs The default constructor. 
	 * @see Device.NetworkEmitter#Status
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._lastStatus = null;
    this._perfEmitter = null;
    this._connEmitter = null;
    this._minRate = 5*1024;  // B/s
    this._duration = 5000;   // in msec
    this._samples = [];
    this._sum = 0;
    this._unconformFor = 0;
    this._lastSampleAt = 0;
    this._maxConnTime = 5000; // in msec
	},

	/**
	 * Retrieve the network status of the device.
	 * @returns {Device.NetworkEmitter#Status} The current device network status.
	 * @status iOS, Android, Test
	 */
	getLastStatus: function()
	{
		return this._lastStatus;
	},

	/** 
	 * Enumeration values for device network status.
	 * @fieldOf Device.NetworkEmitter.prototype
	 */
	Status:
	{
		/** 
		* <code>0</code> = No network connectivity. 
		* @fieldOf Device.NetworkEmitter.prototype
		* @constant
		*/
		None: 0,
		
		/** 
		* <code>1</code> = Cellular network connectivity. 
		* @fieldOf Device.NetworkEmitter.prototype
		* @constant
		*/
		Cellular: 1,
		
		/** 
		* <code>2</code> = Wi-Fi network connectivity. 
		* @fieldOf Device.NetworkEmitter.prototype
		* @constant
		*/
		Wifi: 2,
	},

  /** private */
  _flags:
  {
    enable: 0x00000001
  },

	/**
	 * Add performance listener.
   * @example Device.NetworkEmitter.addPerformanceListener(perfListener, function(perfStatus) {...});
   * @param {Object} perfListener Performance listener.
   * @param {Function} perfCb Callback function made when performance does not conform to expectation defined internally.
   * The callback function passes perforamnce status object which has the following information:
   * <pre>
   *  {
   *    actReqs: {Number}, // Current number of active HTTP requests
   *    aveRate: {Number}, // Observerd average data traffic in B/s 
   *                       // (includes both inbound and outbound)
   *  }
   * </pre>
   * @type void
	 */
  addPerformanceListener: function(perfListener, perfCb)
  {
    if(!this._perfEmitter)
    {
      this._perfEmitter = new Core.MessageEmitter();
    }

    this._perfEmitter.addListener(perfListener, perfCb);
    NgLogD("addPerformanceListener: count=" + this._perfEmitter.getListenerCount());

    if(this._perfEmitter.getListenerCount() == 1)
    {
      // Tell native to report stats.
      this._enablePerfEmitterSendGen( this._flags['enable'], this._minRate, this._duration );
    }
  },

	/**
	 * Remove performance listener.
   * @param {Object} perfListener Performance listener.
   * @type void
	 */
  removePerformanceListener: function(perfListener)
  {
    if(this._perfEmitter)
    {
      this._perfEmitter.removeListener(perfListener);
      NgLogD("removePerformanceListener: count=" + this._perfEmitter.getListenerCount());

      if(this._perfEmitter.getListenerCount() == 0)
      {
        // Tell native to stop reporting stats.
        this._enablePerfEmitterSendGen( 0, 0, 0 );
        this._perfEmitter = null;
      }
    }
    else
    {
      NgLogD("removePerformanceListener: perf-emitter does not exist");
    }
  },

	/**
	 * Add connection listener.
   * @example Device.NetworkEmitter.addConnectionListener(connListener, function(connTime) {...});
   * @param {Object} connListener Connection listener.
   * @param {Function} connCb Callback function made when connection setup is taking longer than exceeded.
   * The callback function passes {Number}connTime, in milliseconds, which is the largest connection
   * setup time abserved amoung opening connections currently in progress. Once the first callback is made,
   * it will repeatedly reported every frame until the lingering connection is established, timed out or
   * the connection listener is removed by application.
   * @type void
	 */
  addConnectionListener: function(connListener, connCb)
  {
    if(!this._connEmitter)
    {
      this._connEmitter = new Core.MessageEmitter();
    }

    this._connEmitter.addListener(connListener, connCb);
    NgLogD("addConnectionListener: count=" + this._connEmitter.getListenerCount());

    if(this._connEmitter.getListenerCount() == 1)
    {
      // Tell native to report stats.
      this._enableConnEmitterSendGen( this._flags['enable'], this._maxConnTime );
    }
  },

	/**
	 * Remove connection listener.
   * @param {Object} connListener Connection listener.
   * @type void
	 */
  removeConnectionListener: function(connListener)
  {
    if(this._connEmitter)
    {
      this._connEmitter.removeListener(connListener);
      NgLogD("removeConnormanceListener: count=" + this._connEmitter.getListenerCount());

      if(this._connEmitter.getListenerCount() == 0)
      {
        // Tell native to stop reporting stats.
        this._enableConnEmitterSendGen( 0, 0 );
        this._connEmitter = null;
      }
    }
    else
    {
      NgLogD("removeConnectionListener: already removed");
    }
  },

	/**
   * @private
	 * Set performance threshold parameters.
   * @param {Object} params Performance threshold parameters. Following parameters are available:
   * <pre>
   *  {
   *    minRate: {Number},  // minimum rate in B/s.
   *    duration: {Number}, // duration in msec for which it waits
   *                        // before emitting event.
   *  }
   * </pre>
   * For example, if minRate = 5*1024 (bytes) and duration = 5000 (msec), a message is emitted
   * in 5 seconds since the actual transmission rate became blow the 'minRate'. If the 
   * trasmission rate recovers (becomes more than minRate), the duration will be reset.
   * @type void
	 */
  setPerformanceThreshold: function(params)
  {
    if(params['minRate'])
    {
      this._minRate = params['minRate'];
    }
    if(params['duration'])
    {
      this._duration = params['duration'];
    }

    if(this._perfEmitter)
    {
      // Tell native that thresholds are updated.
      this._enablePerfEmitterSendGen( this._flags['enable'], this._minRate, this._duration );
    }
  },

	/**
   * @private
	 * Set connection threshold parameters.
   * @param {Object} params Connection threshold parameters. Following parameters are available:
   * <pre>
   *  {
   *    maxConnTime: {Number},  // maximum connection setup time in milliseconds.
   *                            // Default is 5000, or 5 seconds.
   *  }
   * </pre>
   * @type void
	 */
  setConnectionThreshold: function(params)
  {
    if(params['maxConnTime'])
    {
      this._maxConnTime = params['maxConnTime'];
    }

    if(this._connEmitter)
    {
      // Tell native that thresholds are updated.
      this._enableConnEmitterSendGen( this._flags['enable'], this._maxConnTime );
    }
  },

	_statusChangedRecv: function( cmd )
	{
		var msg = {};
		if (!this._statusChangedRecvGen(cmd, msg))
		    return;

		this._lastStatus = msg['status'];
		this.emit(this._lastStatus);
	},

	_activityRecv: function( cmd )
 {
		var msg = {};
		if (!this._activityRecvGen(cmd, msg))
		    return;

    var actReqs = msg['numActiveReqs'];
    var actConns = msg['numActiveConns'];
    var opens = msg['numOpens'];
    var conns = msg['numConns'];
    var closes = msg['numCloses'];
    var sent = msg['bytesSent'];
    var rcvd = msg['bytesRcvd'];
    var connTime = msg['maxConnTime'];

    var now = Core.Time.getRealTime();

    //NgLogD('NetworkEmitter::_activityRecv: actReqs=' + actReqs + ' actConns=' + actConns + ' opens=' + opens + ' conns=' + conns + ' closes=' + closes + ' sent=' + sent + ' rcvd=' + rcvd + ' connTime=' + connTime);

    // Reset conditions
    // 1) actConns == conn: all new connections, and;
    // 2) !actConns: no connection, and;
    // 3) took more than the 'duration' since the last sampling.
    if(actConns == conns || !actConns)
    {
      if(now - this._lastSampleAt >= this._duration)
      {
        this._samples = [];
        this._sum = 0;
        this._unconformFor = 0;
      }
    }

    if(actConns > 0)
    {
      var latest = 0;
      if(this._samples.length == 150)
      {
        latest = this._samples.shift();
        if(this._sum >= latest)
        {
          this._sum -= latest;
        }
      }

      var dt = Core.Time.getFrameDelta();
      var rate = (sent + rcvd) / (dt / 1000);
      this._samples.push(rate);
      this._sum += rate;
      this._lastSampleAt = now;

      var ave = this._sum / this._samples.length;

      if(ave < this._minRate)
      {
        //NgLogD('NetworkEmitter::_activityRecv: aveRate=' + ave + ' sum=' + this._sum + ' numSamples=' + this._samples.length + ' since=' + this._unconformFor + ' now=' + now + ' deltaT=' + (now - this._unconformFor) + ' hasPerfEmitter=' + (this._perfEmitter? 'yes':'no'));
        this._unconformFor += dt;

        if(this._unconformFor >= this._duration)
        {
          if(this._perfEmitter)
          {
            NgLogD('NetworkEmitter::_activityRecv: emitting performance event');
            this._unconformFor = 0;
            this._perfEmitter.emit({ actReqs: actReqs, actConns: actConns, aveRate: ave });
          }
        }
      }
      else
      {
        // Now it conforms to the min rate. Reset the timestamp.
        this._unconformFor = 0;
      }
    }

    if(connTime >= this._maxConnTime)
    {
      if(this._connEmitter)
      {
        NgLogD('NetworkEmitter::_activityRecv: emitting connection event');
        this._connEmitter.emit(connTime);
      }
    }
 },

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 336
	// Method create = -1
	// Method statusChanged = 2
	// Method activity = 3
	// Method enablePerfEmitter = 4
	// Method enableConnEmitter = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._statusChangedRecv( cmd );
					break;
				case 3:
					instance._activityRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in NetworkEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in NetworkEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[336] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_statusChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in NetworkEmitter.statusChanged from command: " + cmd );
			return false;
		}
		
		obj[ "status" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "status" ] === undefined )
		{
			NgLogE("Could not parse status in NetworkEmitter.statusChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_activityRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 8 )
		{
			NgLogE("Could not parse due to wrong argument count in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numActiveReqs" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "numActiveReqs" ] === undefined )
		{
			NgLogE("Could not parse numActiveReqs in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numActiveConns" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "numActiveConns" ] === undefined )
		{
			NgLogE("Could not parse numActiveConns in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numOpens" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "numOpens" ] === undefined )
		{
			NgLogE("Could not parse numOpens in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numConns" ] = Core.Proc.parseInt( cmd[ 3 ] );
		if( obj[ "numConns" ] === undefined )
		{
			NgLogE("Could not parse numConns in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "numCloses" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "numCloses" ] === undefined )
		{
			NgLogE("Could not parse numCloses in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "bytesSent" ] = Core.Proc.parseInt( cmd[ 5 ] );
		if( obj[ "bytesSent" ] === undefined )
		{
			NgLogE("Could not parse bytesSent in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "bytesRcvd" ] = Core.Proc.parseInt( cmd[ 6 ] );
		if( obj[ "bytesRcvd" ] === undefined )
		{
			NgLogE("Could not parse bytesRcvd in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		obj[ "maxConnTime" ] = Core.Proc.parseInt( cmd[ 7 ] );
		if( obj[ "maxConnTime" ] === undefined )
		{
			NgLogE("Could not parse maxConnTime in NetworkEmitter.activity from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":336,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_enablePerfEmitterSendGen: function( flags, minRate, duration )
	{
		Core.Proc.appendToCommandString( ":336,4," + this.__objectRegistryId + "," + flags + "," + minRate + "," + duration  );
	},
	
	/** @private */
	_enableConnEmitterSendGen: function( flags, maxConnTime )
	{
		Core.Proc.appendToCommandString( ":336,5," + this.__objectRegistryId + "," + flags + "," + maxConnTime  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _statusChangedRecv: function( cmd ) {}
	// _activityRecv: function( cmd ) {}
	// enablePerfEmitter: function( flags, minRate, duration ) {}
	
	// enableConnEmitter: function( flags, maxConnTime ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/OrientationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/OrientationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/OrientationEmitter'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class OrientationEmitter
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.OrientationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.OrientationEmitter.prototype */
{
	classname: 'OrientationEmitter',
		
	/**
	 * @class <code>OrientationEmitter</code> constructs a singleton object that tracks the physical orientation of the device.
	 * These objects emit an <code><a href="Device.OrientationEmitter.html#Orientation">Orientation</a></code> object when a change in device orientation occurs.<br><br>
	 * Rotating the device does not necessarily rotate the 
	 * interface presented to the user. Applications must
	 * explicitly call <code><a href="Device.OrientationEmitter.html#setInterfaceOrientation">setInterfaceOrientation()</a></code> to rotate the interface.
	 * This allows an application to selectively choose a supported device orientation.
	 * For example, an application can observe orientation change events and change the interface orientation only if the application suppoorts it.<br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @constructs The default constructor. 	 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);

		this._lastDeviceOrientation    = this.Orientation.Portrait;
		this._lastInterfaceOrientation = this.Orientation.Portrait;
	},
	
	/**
	 * Retrieve the device orientation.
	 * @returns {Device.OrientationEmitter#Orientation} The current device orienation.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getDeviceOrientation: function()
	{
		return this._lastDeviceOrientation;
	},
	
	/**
	 * Retrieve the interface orientation. Initially, this is the same
	 * as the device orientation.
	 * @returns {Device.OrientationEmitter#Orientation} The current interface orientation.
	 * @see Device.OrientationEmitter#setInterfaceOrientation
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getInterfaceOrientation: function()
	{
		return this._lastInterfaceOrientation;
	},
	
	/**
	 * Set the interface orientation.
	 * @example var orientation = new Device.OrientationEmitter(Device.OrientationEmitter.Orientation.Portrait, true);
	 * @param {Device.OrientationEmitter#Orientation} orientation The new device orientation.
	 * @param {Boolean} [animated] Set as <code>true</code> to render the orientation change with an animated effect.
	 * @see Device.OrientationEmitter#getInterfaceOrientation
	 * @status iOS, Test
	 */
	setInterfaceOrientation: function(orientation, animated)
	{
		if (orientation != this._lastInterfaceOrientation)
		{
			NgLogD("setInterfaceOrientation to " + orientation);
			this._setInterfaceOrientationSendGen(orientation,animated);
			this._lastInterfaceOrientation = orientation;
		}
	},
	
	/**
	 * Enumeration for device orientation.
	 * @fieldOf Device.OrientationEmitter.prototype
	 */
	Orientation:
	{ 
		/** 
		* Portrait orientation. 
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		Portrait: 0,
		/** 
		* Portrait orientation, but rotated 180 degrees. 
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		PortraitUpsideDown: 1,
		/** 
		* Landscape orientation with the top of the device to the left. 
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		LandscapeLeft: 2,
		/** 
		* Landscape orientation with the top of the device to the right. 
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		LandscapeRight: 3,
		/** 
		* Oriented with the face of the device up. 
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		FaceUp: 4,
		/** 
		* Oriented with the face of the device down. 
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		FaceDown: 5,
	},

	/**
	 * Enumeration for orientation type.
	 * It can be used to identify which event happens.
	 * @filedOf Device.OrientationEmitter.prototype
	 */
	OrientationType:
	{
		/**
		* Device orientation has changed.
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		Device: 0,
		/**
		* Interface orientation has changed.
		* @fieldOf Device.OrientationEmitter.prototype
		* @constant
		*/
		Interface: 1
	},

	_orientationChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._orientationChangedRecvGen(cmd, msg))
			return;
 
 		this._lastDeviceOrientation = msg['orientation'];
		this.emit({type: this.OrientationType.Device, orientation:msg['orientation']});
		
		//Cascade the original message back out to native for forwarding
		this._orientationChangedSendGen(msg.orientation);
	},
	
	_interfaceOrientationChangedRecv: function( cmd )
	{
		var msg = {};
		if(!this._interfaceOrientationChangedRecvGen(cmd, msg))
			return;
 
 		this._lastInterfaceOrientation = msg['orientation'];
		this.emit({type: this.OrientationType.Interface, orientation:msg['orientation']});
		
		//Cascade the original message back out to native for forwarding
		this._interfaceOrientationChangedSendGen(msg.orientation);
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 335
	// Method create = -1
	// Method orientationChanged = 2
	// Method setInterfaceOrientation = 3
	// Method interfaceOrientationChanged = 4
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._orientationChangedRecv( cmd );
					break;
				case 4:
					instance._interfaceOrientationChangedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in OrientationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in OrientationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[335] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_orientationChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in OrientationEmitter.orientationChanged from command: " + cmd );
			return false;
		}
		
		obj[ "orientation" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "orientation" ] === undefined )
		{
			NgLogE("Could not parse orientation in OrientationEmitter.orientationChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_interfaceOrientationChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in OrientationEmitter.interfaceOrientationChanged from command: " + cmd );
			return false;
		}
		
		obj[ "orientation" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "orientation" ] === undefined )
		{
			NgLogE("Could not parse orientation in OrientationEmitter.interfaceOrientationChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":335,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_orientationChangedSendGen: function( orientation )
	{
		Core.Proc.appendToCommandString( ":335,2," + this.__objectRegistryId + "," + orientation  );
	},
	
	/** @private */
	_setInterfaceOrientationSendGen: function( orientation, animated )
	{
		Core.Proc.appendToCommandString( ":335,3," + this.__objectRegistryId + "," + orientation + "," + ( animated ? 1 : 0 )  );
	},
	
	/** @private */
	_interfaceOrientationChangedSendGen: function( orientation )
	{
		Core.Proc.appendToCommandString( ":335,4," + this.__objectRegistryId + "," + orientation  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _orientationChangedRecv: function( cmd ) {}
	// orientationChanged: function( orientation ) {}
	
	// setInterfaceOrientation: function( orientation, animated ) {}
	
	// _interfaceOrientationChangedRecv: function( cmd ) {}
	// interfaceOrientationChanged: function( orientation ) {}
	

// {{/Wg Generated Code}} }}}

});
// vim:set fdm=marker noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/ShakeEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/ShakeEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/ShakeEmitter'] = exports; var Core = require('NGCore/Client/Core').Core;
var MotionEmitter = require('NGCore/Client/Device/MotionEmitter').MotionEmitter;

var ProxyListener = Core.MessageListener.subclass(
{
	onUpdate: function() {}
});

exports.ShakeEmitter = Core.MessageEmitter.singleton(
/** @lends Device.ShakeEmitter.prototype */
{
	classname: 'ShakeEmitter',
		
	/**
	 * @class The <code>ShakeEmitter</code> class constructs a singleton object that tracks when users physically shake the device. 
	 * These objects emit messages when the device recognizes a shake gesture.<br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @status iOS, Android
	 */
	
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._proxyListener = new ProxyListener();
		
	},
	
	/**
	 * Add a <code>MessageListener</code> to this emitter. When an application calls <code>emit()</code> 
	 * or <code>chain()</code> 
	 * on this emitter, a callback function passed as a parameter is called on the specified listener.
	 * The parameters for the callback function are identical to parameters for <code>emit()</code> or
	 * <code>chain()</code>.
	 * <br><br>
	 * <b>Note:</b> Each listener can only listen to an emitter one time.<br><br>
	 * The following code examples illustrate different call styles for <code>addListener()</code>.
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onCallback);
	 *
	 * @example
	 * emitter.addListener(myListener, myListener.onEvent, 200);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to add.
	 * @param {Function} func The callback function.
	 * @param {Number} [priority=0] The priority for this <code>MessageListener</code>.
	 * @throws {MessageEmitter.addListener: listener is already listening} Calling <code>addListener()</code> multiple times on the same emitter
	 * with the same listener.
	 * @throws {MessageEmitter.addListener: listener must be instances of MessageListener} Listener is not an instance of <code>MessageListener</code>.
	 * @see Device.ShakeEmitter#removeListener,
	 * @see Core.MessageEmitter#emit,
	 * @see Core.MessageEmitter#chain
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	addListener: function($super, listener, func, priority)
	{
		if (this.getListenerCount() == 0) {
			MotionEmitter.addListener(this._proxyListener, function(){});
		}

		$super(listener, func, priority);
	},
	
	/**
	 * Remove a <code>MessageListener</code> from this emitter.<br><br> 
	 * The following code examples illustrate different call styles for <code>removeListener()</code>.
	 * @example
	 * emitter.removeListener(myListener, myListener.onCallback);
	 * @example
	 * emitter.removeListener(myListener);
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.MessageListener} listener The <code>MessageListener</code> to remove.
	 * @returns {Boolean} Returns <code>true</code> if the registered listener was removed. Returns <code>false</code> if the registered listener is not found 
	 * or is not registered with this emitter.
	 * @throws {MessageEmitter.removeListener: listener is not listening} Specified listener is not currently registered
	 * with this emitter.
	 * @see Device.ShakeEmitter#addListener
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	removeListener: function($super, listener)
	{
		$super(listener);

		if (this.getListenerCount() == 0) {
			MotionEmitter.removeListener(this._proxyListener);
		}
	},
	
	_shakeRecv: function( cmd )
	{
		this.emit();
		
		//Cascade the original message back out to native for forwarding
		this._shakeSendGen();
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 332
	// Method create = -1
	// Method shake = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._shakeRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in ShakeEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in ShakeEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[332] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_shakeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in ShakeEmitter.shake from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":332,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_shakeSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":332,2," + this.__objectRegistryId );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _shakeRecv: function( cmd ) {}
	// shake: function(  ) {}
	

// {{/Wg Generated Code}}	

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/KeyEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/KeyEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/KeyEmitter'] = exports; var Core = require('NGCore/Client/Core').Core;
var UI = require('NGCore/Client/UI').UI;

////////////////////////////////////////////////////////////////////////////////

// Private Class Statics
var keyCodeReverseMap = null;

exports.KeyEmitter = Core.MessageEmitter.singleton(
/** @lends Device.KeyEmitter.prototype */
{
	classname: 'KeyEmitter',

	/**
	 * @class The <code>KeyEmitter</code> class constructs a singleton object that emits a <code><a href="Device.KeyEmitter.KeyEvent.html">KeyEvent</a></code> object 
	 * when the user presses or releases a device hardware key.<br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @augments Core.MessageEmitter
	 * @require Device
	 * @example
	 *
	 * var KeyListener = Core.MessageListener.subclass({
	 *   onUpdate: function(keyEvent) {
	 *     // back to the launcher when the back button is pressed
	 *     if (keyEvent.code === Device.KeyEmitter.Keycode.back) {
	 *        this.destroy();
	 *        LGL.runUpdatedGame('/Samples/Launcher');
	 *        return;
	 *     }
	 *
	 *     var text = '';
	 *     switch (keyEvent.type) {
	 *        case Device.KeyEmitter.EventType.onDown:
	 *           text += 'onDown :'
	 *           break;
	 *        case Device.KeyEmitter.EventType.onUp:
	 *           text += 'onUp :'
	 *           break;
	 *     }
	 *
	 *     text += Device.KeyEmitter.keyCodeToSymbol(keyEvent.code);
	 *     console.log(text);
	 *   }
	 * };
	 *
	 * var keyListener = new KeyListener();
	 * Device.KeyEmitter.addListener(keyListener, keyListener.onUpdate);
	 *
	 * @status Android, Test, AndroidTested
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * Convert a keycode into the equivalent human-readable symbol. The keycode to convert is passed in as a parameter.
	 * The following code example illustrates how to convert a keycode into a human-readable symbol.
	 * @param {String} keyCode The keycode to convert.
	 * @static
	 *
	 * @example
	 *   var symbol = Device.KeyEmitter.keyCodeToSymbol(0x1d);
	 *   // symbol => 'a'
	 *
	 * @status
	 */
	keyCodeToSymbol: function(keyCode)
	{
		if (!keyCodeReverseMap) {
			keyCodeReverseMap = {};
			for (var codename in this.Keycode) {
				keyCodeReverseMap[this.Keycode[codename]] = codename;
			}
		}
		return keyCodeReverseMap[keyCode] || '';
	},

	KeyEvent: Core.Class.subclass(
	/** @lends Device.KeyEmitter.KeyEvent.prototype */
	{
		classname: 'KeyEvent',

		/**
		 * @class <code>KeyEvent</code> constructs objects that contain the parcel of a keyboard event. 
		 * The keycode of the key that triggered the event is passed in as a parameter.
		 * @constructs The default constructor. 
		 * @augments Core.Class
		 * @param {Device.KeyEmitter.EventType} type The type of the keyboard event.
		 * @param {Integer} modifiers the bit-and of {@link Device.KeyEmitter#Modifier} combination.
		 * @param {Device.KeyEmitter.Keycode} code The actual keycode.
		 */
		initialize: function(type, modifiers, code)
		{
			this.type      = type;
			this.modifiers = modifiers;
			this.code      = code;
		}
	}),

	_onKeyEventRecv: function( cmd )
	{
		var msg = {};
		if(!this._onKeyEventRecvGen(cmd, msg))
			return;

		var keyEvent = new Device.KeyEmitter.KeyEvent(msg.type, msg.modifiers, msg.code);
		
		if(!this.chain(keyEvent)) {
			//Noone handled this keyEvent. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._onKeyEventSendGen(msg.type, msg.modifiers, msg.code);
		}
	},

// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Event type Enums.
	 * Currently we only have onUp and onDown events.
	 *
	 * @namespace
	 * */
	EventType:
	{ 
		/** the key is hooked up. */
		onUp: 0,
		/** the key is pressed down. */
		onDown: 1,
	},
	
	/** 
	 * Enums for modifiers that are being pressed.
	 * They are passed as bit-and-ed.
	 *
	 * @namespace
	 * @example
	 *
	 * var keyEvent; // emitted from KeyEmitter
	 * if (keyEvent.modifiers & Device.KeyEmitter.Modifier.ALT && 
	 *     keyEvent.modifiers & Device.KeyEmitter.Modifier.SHIFT)
	 *    console.log("ALT+SHIFT");
	 * */
	Modifier:
	{ 
		/** no modifiers */
		NONE: 0,
		/** SYMBOL modifier */
		SYMBOL: 1 << 0,
		/** ALT modifier */
		ALT: 1 << 1,
		/** ALT_LEFT modifier */
		ALT_LEFT: 1 << 2,
		/** ALT_RIGHT modifier */
		ALT_RIGHT: 1 << 3,
		/** SHIFT modifier */
		SHIFT: 1 << 4,
		/** SHIFT_LEFT modifier */
		SHIFT_LEFT: 1 << 5,
		/** SHIFT_RIGHT modifier */
		SHIFT_RIGHT: 1 << 6,
	},
	
	/** 
	 * Keycode Enums.
	 * Define bunch of key codes.
	 * @namespace
	 * */
	Keycode:
	{ 
		/** * */
		a: 0x1d,
		/** * */
		b: 0x1e,
		/** * */
		c: 0x1f,
		/** * */
		d: 0x20,
		/** * */
		e: 0x21,
		/** * */
		f: 0x22,
		/** * */
		g: 0x23,
		/** * */
		h: 0x24,
		/** * */
		i: 0x25,
		/** * */
		j: 0x26,
		/** * */
		k: 0x27,
		/** * */
		l: 0x28,
		/** * */
		m: 0x29,
		/** * */
		n: 0x2a,
		/** * */
		o: 0x2b,
		/** * */
		p: 0x2c,
		/** * */
		q: 0x2d,
		/** * */
		r: 0x2e,
		/** * */
		s: 0x2f,
		/** * */
		t: 0x30,
		/** * */
		u: 0x31,
		/** * */
		v: 0x32,
		/** * */
		w: 0x33,
		/** * */
		x: 0x34,
		/** * */
		y: 0x35,
		/** * */
		z: 0x36,
		/** TBD */
		up: 0x13,
		/** TBD */
		down: 0x14,
		/** TBD */
		left: 0x15,
		/** TBD */
		right: 0x16,
		/** * */
		enter: 0x42,
		/** * */
		backspace: 0x43,
		/** * */
		back: 0x04,
		/** backunhandled: 0x54, Special KeyCode to tell MobageService that the back was unhandled by the game, after the service declined first dibs. Stole MAX_KEYCODE (deprecated constant). */
		backunhandled: 0x54,
		/** * */
		menu: 0x52,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 343
	// Method create = -1
	// Method onKeyEvent = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._onKeyEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in KeyEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in KeyEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[343] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onKeyEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		obj[ "type" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "type" ] === undefined )
		{
			NgLogE("Could not parse type in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		obj[ "modifiers" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "modifiers" ] === undefined )
		{
			NgLogE("Could not parse modifiers in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		obj[ "code" ] = Core.Proc.parseInt( cmd[ 2 ] );
		if( obj[ "code" ] === undefined )
		{
			NgLogE("Could not parse code in KeyEmitter.onKeyEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":343,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_onKeyEventSendGen: function( type, modifiers, code )
	{
		Core.Proc.appendToCommandString( ":343,2," + this.__objectRegistryId + "," + type + "," + modifiers + "," + code  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _onKeyEventRecv: function( cmd ) {}
	// onKeyEvent: function( type, modifiers, code ) {}
	

// {{/Wg Generated Code}}

});
// vim:set fdm=marker noexpandtab:
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_PushNotificationEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_PushNotificationEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_PushNotificationEmitter'] = exports; var Core = require('NGCore/Client/Core').Core;

/*
	NOTE: 	THIS IS FOR INTERNAL USE ONLY AND WILL BE DEPRECATED IN THE FUTURE.
			DO NOT USE IT IN ANY OF YOUR CODE.
*/

exports.PushNotificationEmitter = Core.MessageEmitter.singleton(
/** @lends Device.PushNotificationEmitter.prototype */
{
	classname: 'PushNotificationEmitter',
		
	/**
	 * @class Emits when native code recieves a push notification
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 */
	
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_onPushNotificationRecv: function( cmd )
	{
		var msg = {};
		if (!this._onPushNotificationRecvGen(cmd, msg))
			return;
			
		this._lastMsgPayload = msg.msgPayload;
		
		if(!this.chain(msg.msgPayload))	{
			//Noone handled this keyEvent. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._onPushNotificationSendGen(msg.msgPayload);
		}
		
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 345
	// Method create = -1
	// Method onPushNotification = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._onPushNotificationRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in PushNotificationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in PushNotificationEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[345] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onPushNotificationRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in PushNotificationEmitter.onPushNotification from command: " + cmd );
			return false;
		}
		
		obj[ "msgPayload" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "msgPayload" ] === undefined )
		{
			NgLogE("Could not parse msgPayload in PushNotificationEmitter.onPushNotification from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":345,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_onPushNotificationSendGen: function( msgPayload )
	{
		Core.Proc.appendToCommandString( ":345,2," + this.__objectRegistryId + "," + Core.Base64.encode( msgPayload )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _onPushNotificationRecv: function( cmd ) {}
	// onPushNotification: function( msgPayload ) {}
	

// {{/Wg Generated Code}}	

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_InAppPurchaseEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchaseEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchaseEmitter'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class InAppPurchaseEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.InAppPurchaseEmitter = Core.MessageEmitter.singleton(
/** @lends Device.InAppPurchaseEmitter.prototype */
{
	classname: 'InAppPurchaseEmitter',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_onPurchaseEventRecv: function( cmd ) {
		var msg = {};
		if (!this._onPurchaseEventRecvGen(cmd, msg))
			return;
		if(!this.chain(msg.err, msg.data, msg.verificationToken))	{
			//Noone handled this keyEvent. Cascade the original back out to native for forwarding
			//	to the next interpreter in the chain.
			this._onPurchaseEventSendGen(msg.err, msg.data, msg.verificationToken);
		}
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 347
	// Method create = -1
	// Method onPurchaseEvent = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._onPurchaseEventRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in InAppPurchaseEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in InAppPurchaseEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[347] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onPurchaseEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		obj[ "err" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "err" ] === undefined )
		{
			NgLogE("Could not parse err in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		obj[ "data" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "data" ] === undefined )
		{
			NgLogE("Could not parse data in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		obj[ "verificationToken" ] = Core.Proc.parseString( cmd[ 2 ] );
		if( obj[ "verificationToken" ] === undefined )
		{
			NgLogE("Could not parse verificationToken in InAppPurchaseEmitter.onPurchaseEvent from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":347,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_onPurchaseEventSendGen: function( err, data, verificationToken )
	{
		Core.Proc.appendToCommandString( ":347,2," + this.__objectRegistryId + "," + Core.Base64.encode( err ) + "," + Core.Base64.encode( data ) + "," + Core.Base64.encode( verificationToken )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _onPurchaseEventRecv: function( cmd ) {}
	// onPurchaseEvent: function( err, data, verificationToken ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_InAppPurchase'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchase'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_InAppPurchase'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class InAppPurchase
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;
var DeviceReq = require('NGCore/Client/Device');
var Localization = require('NGCore/Client/Core/Localization').Localization;

////////////////////////////////////////////////////////////////////////////////

exports.InAppPurchase = Class.singleton(
/** @lends Device.InAppPurchase.prototype */
{
	classname: 'InAppPurchase',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	initService: function(ordercb, donecb) {
		if ((!this._isIOS()) && (!this._isAndroid())) {
			NgLogE("ERROR: Neither Android nor iOS platform, IAP will not work");
			donecb();
			return;
		}
		if (!this._iapInited) {
			var IAPListener = Core.MessageListener.subclass({
				onPurchaseEvent: this._iapCallback.bind(this)
			});
			// Register for Android / iOS IAP callbacks the same way
			this.listener = new IAPListener();
	        DeviceReq.Device.InAppPurchaseEmitter.addListener(
				this.listener, this.listener.onPurchaseEvent);
	    	// listener will be called when purchase state changes
		}
		this._initDonecb = donecb;
		this._initOrdercb = ordercb;
		if (this._isAndroid()) {
			this._iapCallback('morenonces', '', '');
			/*
			 * Gets persisted unfulfilled orders, calls back ordercb for each
			 * unfulfilled order.
			 */
			var self = this;
			Storage.KeyValueCache.local.getItem(this._IAB_ORPHANED,
			function(err, currorders) {
	   			if (currorders && (currorders.length > 0)) {
					var orders = JSON.parse(currorders);
   					// _restoreOrders eventually calls _initService when fully
					// done.
					self._restoreOrders(orders);
				} else {
					self._initService();
				}
			});
		} else {
			// _isIOS - call _initService directly.  It will call back with
			// orphaned order if any.
			this._initService();
		}
	},

	launchPurchaseView: function(productID, quantity, purchasecb, failcb, cancelcb) {
		if (!this._iapInited) {
			NgLogE("ERROR: function initService must be called and its donecb " +
			"called back, before launchPurchaseView may be used.");
			failcb(false, "failed:initservice_not_done");
			return;
		}

		this._currentOrderProductID = productID;

		this._currentOrderCancelcb = cancelcb;
		this._currentOrderFailcb = failcb;
		this._currentOrderPurchasecb = purchasecb;

		// Android IAB currently only supports quantity of 1
		if (quantity !== 1 && this._isAndroid()) {
			failcb(false, "failed:unsupported_quantity");
			return;
		}

		// Place progress dialog underneath the IAB view first
        if(this._isIOS()) {
	        this._currentOrderProgressDialog = (new UI.ProgressDialog()).retain();
	        this._currentOrderProgressDialog.setText(Localization.getString("Processing Order"));
        } else if(!this._isIOS()) {
	        this._currentOrderProgressDialog = (new UI.AlertDialog()).retain();
	        this._currentOrderProgressDialog.setTitle(Localization.getString("Processing Order"));
            this._currentOrderProgressDialog.setText(
                Localization.getString("Your order is being processed. You will receive a confirmation momentarily."));
            this._currentOrderProgressDialog.setChoices([Localization.getString("OK")]);
            this._currentOrderProgressDialog.onchoice = function(event) {
                this._currentOrderProgressDialog.release();
                this._currentOrderProgressDialog = null;
            };
        }

	    this._currentOrderProgressDialog.show();

		if (this._isIOS() || this._isAndroid()) {
	        DeviceReq.Device.InAppPurchase._requestPurchase(productID, quantity);
			// Note that _iapCallback will call the *cb callback function(s)
			return;
		}
	    this._currentOrderProgressDialog.hide();
        this._currentOrderProgressDialog.release();
	    this._currentOrderProgressDialog = undefined;
		NgLogE('launchPurchaseView failed: only Android and iOS platforms are currently supported.');
		failcb(false, "failed:unsupported_platform");
		return;
	},

	pushSingleNonce: function(nonce){
		var noncePool = [];
		noncePool.push(nonce);
		this._fillIABNoncePool(JSON.stringify(noncePool));
	},

	/**
	 * get a product information specified by productId.
	 * @param {String} productId the product ID registered at iTunes connect.
	 * @param {Function} callback called back when it gets a response. The signature for the callback is equivalent to:<br><br>
	 * <pre>function(productData, err)</pre><br>
	 * The <code>productData</code> is an product information like "JPY,115.000000".
	 * When something bad happenes, <code>err</code> is set to the error message. Otherwise, err will be null or undefined.
	 * @status iOS, iOSTested
	 */
	getProductInformation: function(productId, callback) {
		this._getProductInformationCB = callback;
		this._getProductInformationSendGen(productId);
	},

	/*
	 * For Google IAB, these constants come from
	 * Consts.java in IAB sample code
	 *
	 *	public enum PurchaseState {
     *   PURCHASED,   // User was charged for the order. -- 0
     *   CANCELED,    // The charge failed on the server. -- 1
	 *   REFUNDED;    // User received a refund for the order. -- 2
	 */
	_IAB_PURCHASED: 0,
	_IAB_CANCELED: 1,
	_IAB_REFUNDED: 2,
	_IAB_ORPHANED: "com.ngmoco.in_app_purchase.iab_orphaned_orders",

	_capIsAndroid: undefined,
	_capIsIOS: undefined,

	// at most one outstanding order is supported
	_currentOrderCancelcb : undefined,
	_currentOrderFailcb : undefined,
	_currentOrderProductID : undefined,
	_currentOrderProgressDialog : undefined,
	_currentOrderPurchasecb : undefined,

	_initDonecb : undefined,
	_initOrdercb : undefined,
	_iapInited: false,

	_generateIABNonce: function(){
		var timestamp = new Date().getTime();
		var random = Math.floor(Math.random() * 1000);
		var nonce = (timestamp * 1000) + random;
		NgLogD("Generated nonce: " + nonce);
		return nonce;
	},

	_iapCallback: function( err, data, verificationToken ) {
        NgLogD("8 _iapCallback with err: "+err + " data: "+data);
		if (err == 'morenonces') {
			var count = 10;
			var noncePool = [];
			while(noncePool.length < count){
				noncePool.push(this._generateIABNonce());
			}
			this._fillIABNoncePool(JSON.stringify(noncePool));
			return true;
		}
		if ((err == 'initdone') || (err == 'initcheckdone')) {
			if (typeof this._initDonecb == 'function') {
				this._iapInited = true;
				this._initDonecb();
				this._initDonecb = undefined;
				this._initOrdercb = undefined;
			} else {
				NgLogW("WARN: " + err + " callback with empty donecb");
			}
	        // at most one listener gets iap events
	        return true;
		}
		if (err == 'getProductInformationDone') {
			if (data && data.length > 0) {
				var datajsonp = JSON.parse(data);
				this._getProductInformationCB(datajsonp.productId);
			} else {
				this._getProductInformationCB('', "no information on this product");
			}
			this._getProductInformationCB = undefined;
			return true;
		}
		var orderId = undefined;
		var prodId = "";
	    var firstOrder = undefined;
	    var datajson = undefined;
		if (data && data.length > 0) {
		    datajson = JSON.parse(data);
		    if ((typeof datajson.orders == 'undefined') ||
		        (datajson.orders.length <= 0)) {
		        // callback with no orders, try to get prodId
                if(!this._isAndroid()) {
			        if (typeof datajson.productId != 'undefined') {
					    prodId = datajson.productId.toUpperCase();
				    }
                }
		    } else {
 				if (this._isAndroid() &&
				 	(typeof this._currentOrderProgressDialog == 'undefined')) {
						// this callback comes in 'out of band', when user did
						// not attempt a purchase.  This happens on Android
						// when async callbacks are not confirmed due to
						// connectivity issue.  This callback is persisted for
						// the next 'initService' call to pick up. Only
						// successful orders will be used in callbacks.
						// Failed order and refunds are ignored.
						//
						// Note also that Android IAB could callback with
						// duplicate order numbers.  In other words, the same
						// order number could come back twice in 2 different
						// callbacks.  There is no code on client to detect
						// such duplicate.  It is up to the server to detect
						// orders which have already been fulfilled.
						//
					var successOrders = this._filterSuccessOrders(datajson, verificationToken, data);
						if (successOrders.length > 0) {
							this._persistOrphanedOrders(successOrders);
						}
						return true;
				} else if (datajson.orders.length === 1) {
					// on iOS, and in common cases on Android, there is at
					// most one order
				    firstOrder = datajson.orders[0];
                    if(!this._isAndroid()) {
					    prodId = firstOrder.productId.toUpperCase();
                    }
					orderId = firstOrder.orderId;
				} else {
					var successOrders2 = this._filterSuccessOrders(datajson, verificationToken, data);
					// on Android, get the first match.  Then add any orphaned
					// orders to existing list of persisted
					// orders.  These will be processed during next initService
					if (successOrders2.length > 0) {
					    firstOrder = successOrders2.shift();
                        if(!this._isAndroid()) {
						    prodId = firstOrder.productId.toUpperCase();
                        }
						orderId = firstOrder.orderId;
						if (successOrders2.length > 0) {
							this._persistOrphanedOrders(successOrders2);
						}
					}
				}
			}
		}
		if (this._currentOrderProductID != prodId) {
			NgLogW("iapCallback: product id mismatch in callback.  Req: '" +
					this._currentOrderProductID + "' CB:'" + prodId + "'");
		}
		if ((err && (err.length > 0)) || (firstOrder && firstOrder.purchaseState &&
			(firstOrder.purchaseState !== this._IAB_PURCHASED))) {
			if (firstOrder && firstOrder.purchaseState &&
				(firstOrder.purchaseState === this._IAB_REFUNDED)) {
				// refunds are generated 'out of the blue' by merchant and is
				// not part of normal flow.  Hence it is ignored.  Code now
				// continues to wait for actual purchase callback
				NgLogD("iapCallback: ignoring refunded order: " +
						JSON.stringify(firstOrder));
				return true;
			}
			if (typeof this._currentOrderProgressDialog != 'undefined') {
				this._currentOrderProgressDialog.hide();
                this._currentOrderProgressDialog.release();
				this._currentOrderProgressDialog = undefined;
			}

			if (err == 'cancelled') {
				if ((typeof this._currentOrderCancelcb) == 'function') {
					this._currentOrderCancelcb();
					this._currentOrderCancelcb = undefined;
				}
			} else {
				if (err) {
					NgLogD("DEBUG: iapCallback: got error: " + err);
				} else {
					// _IAB_CANCELED
					NgLogD("DEBUG: iapCallback: got canceled purchaseState.");
				}
				if ((typeof this._currentOrderFailcb) == 'function') {
					this._currentOrderFailcb(false, err);
					this._currentOrderFailcb = undefined;
				}
			}

	        // at most one listener gets iap events
	        return true;
	    }
		if (typeof firstOrder == 'undefined') {
			// there was no (non-refunded) order in callback
			return true;
		}
	    var nextcb2 = function(cbIsDone) {
			if (typeof this._currentOrderProgressDialog != 'undefined') {
				this._currentOrderProgressDialog.hide();
		        this._currentOrderProgressDialog.release();
				this._currentOrderProgressDialog = undefined;
			}
		    if (cbIsDone !== false) {
				return;
			}
			// Currently, fail if the first try is not done, no retry
			if ((typeof this._currentOrderFailcb) == 'function') {
				this._currentOrderFailcb(true, "failed:no_more_retry");
				this._currentOrderFailcb = undefined;
			}
	    };
		if ((typeof this._currentOrderPurchasecb) == 'function') {
			var receipt = verificationToken;
			if (this._isAndroid()) {
				// on Android, both the data and signature are required
				// for verification
				var receiptj = {
					data: data,
					signature: verificationToken
				};
				receipt = JSON.stringify(receiptj);
			}
		    this._currentOrderPurchasecb(prodId, orderId, receipt, firstOrder, nextcb2.bind(this));
			this._currentOrderPurchasecb = undefined;
		} else if ((!this._iapInited) && ((typeof this._initOrdercb) ==
		 			'function')) {
			var initcb2 = function(){
				// Do nothing on iOS as Store Observer simply emits
				// asychronously until done.
			};
			// part of initService flow
		    this._initOrdercb(prodId, orderId, verificationToken, firstOrder,
			initcb2);
		}
        // at most one listener gets iap events
        return true;
    },

	_isAndroid: function() {
		if (typeof this._capIsAndroid != 'undefined') {
			return this._capIsAndroid;
		}
		// Find out from capabilities
	    var capabilities = Core.Capabilities;
	    if ((typeof capabilities.getPlatformOS() != "undefined") &&
	        (capabilities.getPlatformOS().toLowerCase() == 'android')) {
	        this._capIsAndroid = true;
	    } else {
	        this._capIsAndroid = false;
		}
		return this._capIsAndroid;
	},

	_isIOS: function() {
		if (typeof this._capIsIOS != 'undefined') {
			return this._capIsIOS;
		}
		// Find out from capabilities
	    var capabilities = Core.Capabilities;
	    if ((typeof capabilities.getPlatformOS() != "undefined") &&
	        (capabilities.getPlatformOS().toLowerCase() == 'iphone os')) {
	        this._capIsIOS = true;
	    } else {
	        this._capIsIOS = false;
		}
		return this._capIsIOS;
	},

	_fillIABNoncePool: function(nonces) {
		this._fillIABNoncePoolSendGen(nonces);
	},
	_filterSuccessOrders: function(datajson, verificationToken, data) {
		var successOrders = [];
		for (var kdx in datajson.orders) {
			if (datajson.orders[kdx].purchaseState === this._IAB_PURCHASED) {
				var theorder = datajson.orders[kdx];
	            if(this._isAndroid()) {
			        var receiptj = {
					    data: data,
					    signature: verificationToken
				    };
				    theorder.receipt = JSON.stringify(receiptj);
                } else {
                    theorder.verificationToken = verificationToken;
                }
				successOrders.push(theorder);
			}
		}
        NgLogD("successOrders length = "+successOrders.length);
		return successOrders;
	},
	_persistOrphanedOrders: function(successOrders) {
		// add orders to existing list of persisted orders
		Storage.KeyValueCache.local.getItem(this._IAB_ORPHANED,
			(function(err, currorders){
				if (currorders && (currorders.length > 0)) {
					var orderlist = JSON.parse(currorders);
					for (var idx in orderlist) {
						successOrders.push(orderlist[idx]);
					}
				}
			    Storage.KeyValueCache.local.setItem(this._IAB_ORPHANED,
					JSON.stringify(successOrders), function(){
					NgLogD("Orphaned orders added to persistent store: " + JSON.stringify(successOrders));
			    });
			}).bind(this));
	},
	_initService: function() {
		this._initServiceSendGen();
	},

	_requestPurchase: function( sku, quantity ) {
		this._requestPurchaseSendGen(sku, quantity);
	},

	/*
	 * Given unfulfilled orders, calls back ordercb for each unfulfilled order.
	 * Resets persisted store using removeItem when done, then call
	 * _initService to continue init process.
	 */
	_restoreOrders: function(orders) {
		var self = this;
		if (orders.length <= 0) {
			// No more unfulfilled orders
			Storage.KeyValueCache.local.removeItem(this._IAB_ORPHANED,
			function() {
				self._initService();
			});
			return;
		}
		var order = orders.pop();
		var cb = function() {
			self._restoreOrders(orders);
		};
		// part of initService flow
        NgLogD("restore persist order");
        if(this._isAndroid()) {
		    this._initOrdercb(order.productId, order.orderId, order.receipt, order, cb.bind(this));
        } else {
		    this._initOrdercb(order.productId.toUpperCase(), order.orderId, order.verificationToken, order, cb.bind(this));
        }
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 348
	// Method create = -1
	// Method initService = 2
	// Method requestPurchase = 3
	// Method fillIABNoncePool = 4
	// Method getProductInformation = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in InAppPurchase._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in InAppPurchase._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[348] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":348,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_initServiceSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":348,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_requestPurchaseSendGen: function( sku, quantity )
	{
		Core.Proc.appendToCommandString( ":348,3," + this.__objectRegistryId + "," + Core.Base64.encode( sku ) + "," + quantity  );
	},
	
	/** @private */
	_fillIABNoncePoolSendGen: function( nonces )
	{
		Core.Proc.appendToCommandString( ":348,4," + this.__objectRegistryId + "," + Core.Base64.encode( nonces )  );
	},
	
	/** @private */
	_getProductInformationSendGen: function( productId )
	{
		Core.Proc.appendToCommandString( ":348,5," + this.__objectRegistryId + "," + Core.Base64.encode( productId )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// initService: function(  ) {}
	
	// requestPurchase: function( sku, quantity ) {}
	
	// fillIABNoncePool: function( nonces ) {}
	
	// getProductInformation: function( productId ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/IPCEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/IPCEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/IPCEmitter'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class IPCEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;
var Class          = require('NGCore/Client/Core/Class').Class;
var Proc           = require('NGCore/Client/Core/Proc').Proc;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Base64         = require('NGCore/Client/Core/Base64').Base64;
var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var DownloadFile   = require('NGCore/Client/Network/DownloadFile').DownloadFile;
var Util           = require('NGCore/Client/Network/Util').Util;
var FileSystem     = require('NGCore/Client/Storage/FileSystem').FileSystem;

////////////////////////////////////////////////////////////////////////////////

exports.IPCEmitter = MessageEmitter.singleton(
/** @lends Device.IPCEmitter.prototype */
{

	classname: 'IPCEmitter',

	/**
	 * @class The IPCEmitter class constructs a singleton object that handles Inter-Process Communication. 
	 * These objects emit events when a specified application is launched from within another application.
	 * @constructs The default constructor.
	 * @augments Core.MessageEmitter
	 */
	initialize: function()
	{
		console.log('IPCEmitter.initialize');
		this._callbackID = 0;
		this._callbacks = [];
		
		this._shouldEmitIntents = false;

		ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * Check whether the host OS can launch the provided URL asynchronously.
	 * @example var appToLaunch = 'mobage//auth?packageName=xxx.xxx&className=xxx.xxx';
	 * Device.IPCEmitter.canLaunch(appToLaunch, function(canLaunch) {
	 * 	if (canLaunch) {
	 * 		console.log('launching... ' + canLaunch);
	 * 		Device.IPCEmitter.launch(appToLaunch, function(error) {
	 * 			label.setText('failed in launching the URL:' + appToLaunch);
	 * 		});
	 * 	} else {
	 * 		label.setText('cannot launch the URL:' + appToLaunch);
	 * 	}
	 * });
	 * @param {String} url A URL to test
	 * @param {Function} callback A callback function that passes a Boolean value when a result is returned. 
	 * If the URL is OK to launch, the callback returns <code>true</code>.
	 * @status
	 */
	canLaunch: function(url, callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._canLaunchSendGen(url,this._callbackID);
		this._callbackID++;
	},

	/**
	 * Request that the host OS launch the provided URL.
	 * @example var appToLaunch = 'mobage//auth?packageName=xxx.xxx&className=xxx.xxx'
	 * Device.IPCEmitter.launch(appToLaunch, function(error) {
	 * 	label.setText('failed in  launching the URL:' + appToLaunch);
	 * });
	 * @param {String} url A URL to launch
	 * @param {Function} errCallback A callback function that passes an error object when an error occurs. 
	 * If the URL is successfully launched, no callback. Otherwise, the callback returns an error.
	 */
	launch: function(url, callback)
	{
		 this._callbacks[this._callbackID] = callback;
		 this._launchSendGen(url,this._callbackID);
		 this._callbackID++;
	},

	launchIntent: function( intent, extras, packageName )
	{
		// Similar to launchService, stash the packageName in extras.
		if (typeof(packageName) == "string")
		{
			var extrasObj;
			if (typeof(extras) == "string")
			{
				extrasObj = JSON.parse(extras);
			}
			else
			{
				extrasObj = {};
			}
			extrasObj["packageName"] = packageName;
			extras = JSON.stringify(extrasObj);
		}
		this._launchIntentSendGen(intent, extras);
	},
	
	launchService: function( intent, extras, packageName )
	{
		//This function originally did not take a "packageName" parameter, it was part of the extrasObj.
		//The separate parameter is added to make it a bit more clear that it is necessary to pass in a packageName.
		//Not sure it's going to help though, because we're trying to preserve backwards compatibility here.
		if (typeof(packageName) == "string")
		{
			var extrasObj;
			if (typeof(extras) == "string")
			{
				extrasObj = JSON.parse(extras);
			}
			else
			{
				extrasObj = {};
			}
			extrasObj["packageName"] = packageName;
			extras = JSON.stringify(extrasObj);
		}
		this._launchServiceSendGen(intent,extras);
	},

	/**
	 * Launch a Single Sign-on URL.
	 * @example var appToLaunch = 'mobage//auth?packageName=xxx.xxx&className=xxx.xxx';
	 * Device.IPCEmitter.launchForSSO(appToLaunch, function(error) {
	 * 	label.setText('failed in  launching the URL:' + appToLaunch);
	 * });
	 * @param {String} url The URL to launch. The URL must include the following as part of the query string: packageName=xxxx&className=yyyy.
	 * @param {Function} callback The callback function. 
	 * @status
	 */
	launchForSSO: function(url, callback)
	{
		url += '&sso_auth';
		this.launch(url, callback);
	},

	/**
	 * Return an array of signatures for the packageName.
	 * @param {String} packageName packageName is like "com.ngmoco.gamejs"
	 * @param {Function} callback callback function signature: function(signatures) { }
	 * @status Android
	 */
	getAppSignatures: function(packageName, callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._getAppSignaturesSendGen(packageName,this._callbackID);
		this._callbackID++;
	},

	/**
	 * Return the package name that invokes this ngCore app.
	 * @param {Function} callback The current callback function. Below is the callback signature. 
	 * @example function(packageName) { }
	 * @status Android
	 */
	getCallingPackage: function(callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._getCallingPackageSendGen(this._callbackID);
		this._callbackID++;
	},
	
	/**
	 * Return whether the service .
	 * @param {Function} callback The current callback function. Below is the callback signature. 
	 * @example function(packageName) { }
	 * @status Android
	 */
	getIsServiceRunning: function(serviceEnum, callback)
	{
		this._callbacks[this._callbackID] = callback;
		this._getIsServiceRunningSendGen(serviceEnum, this._callbackID);
		this._callbackID++;
	},


	app: function()
	{
		return this._app;
	},

	App: Class.subclass(
	/** @lends Device.IPCEmitter.App.prototype */
	{
		classname: 'App',

		/**
		 * @class Information about the app.
		 */
		initialize: function(sourceAppID, intentURL)
		{
			this._sourceAppID   = sourceAppID;
			this._intentURL     = intentURL;
		},

		/**
		 * information for checking if application has launched or resumed with custom URL scheme.
		 * @type String
		 */
		getID: function()
		{
			return this._sourceAppID;
		},

		/**
		 * Returns the URL used to launch this app, or an empty string if not launched via URL
		 * @type String
		 */
		getURL: function()
		{
			return this._intentURL;
		}
	}),

	Intent: Class.subclass(
	/** @lends Device.IPCEmitter.App.prototype */
	{
		classname: 'Intent',

		/**
		 * @class Information about the app.
		 */
		initialize: function(action, extras)
		{
			this._action   = action;
			this._extras   = extras;
		},

		/**
		 * information for checking if application has launched or resumed with custom URL scheme.
		 * @type String
		 */
		getAction: function()
		{
			return this._action;
		},

		/**
		 * Returns the URL used to launch this app, or an empty string if not launched via URL
		 * @type String
		 */
		getExtras: function()
		{
			return this._extras;
		}
	}),

	/**
	 * Create home screen shortcut icon.
	 * @param {String} name Displayed shortcut name
	 * @param {String} url Invoked url when icon clicked. 
	 * @param {String} icon_path Local file path that stores icon file.
	 * @status Android
	 */
	createShortcut: function( name, url, icon_path )
	{
		this._createShortcutSendGen(name, url, icon_path);
	},

	/**
	 * Create home screen shortcut icon with downloading its image.
	 * @param {String} name Displayed shortcut name.
	 * @param {String} url Invoked url when icon clicked. 
	 * @param {String} icon_url Icon image url.
	 * @param {Function} callback Callback function that passes a Boolean value whether download succeed. Below is the callback signature.
	 * @example function(hasDownloadError) { }
	 * @status Android
	 */
	createShortcutByIconUrl: function( name, url, icon_url, callback )
	{
                NgLogD("createShortcutByIconUrl called", name, url, icon_url);

                var df = new DownloadFile();
                var filename = 'shortcut_icon_image'+(new Date().getTime());
                var self = this;
                NgLogD("Icon download begin");
		Util.OperationWithRetries(function(failCb, abortCb) {
			df.start(filename, 'GET', icon_url, [], function( statusCode, fileSignature ) {
				NgLogD("Icon download finished status="+statusCode);
				if(statusCode == 200) {
					self.createShortcut( name, url, filename );
					FileSystem.deleteFile( filename, function() {
						if(callback)
							callback(false);
					});
				}
				else if(statusCode == 404)
				{
					NgLogE("Unable download icon file: icon_url="+icon_url+", status="+statusCode);
					abortCb();
				}
				else
				{
					NgLogE("Unable download icon file: icon_url="+icon_url+", status="+statusCode);
					failCb();
				}
			});
		},
		function() {
			NgLogE("Unable download icon file");
			if(callback)
				callback(true);
		}, 
		true);
	},

	// ------------------------------------------------------------------
	// private
	//

	/**
	 * invoked from native when the app is resumed back from other app.
	 */
	_onResumedFromOthers: function (url, sourceAppID)
	{
		this._app = new Device.IPCEmitter.App(sourceAppID, url);
		this.emit(this._app);

		//Cascade the original message back out to native for forwarding
		this._onResumeFromOthersSendGen(url, sourceAppID);
	},
	
	// Should only be called by privileged callers
	_setEmitIntents: function ( emit ) {
		this._shouldEmitIntents = Boolean(emit);
	},

	_onIntentReceived: function (action, extras)
	{
		console.log("On IntentReceived: " + action + " / " + JSON.stringify(extras));
		if (this._shouldEmitIntents) {
			this.emit( new exports.IPCEmitter.Intent(action, extras) );
		}
	},

	// private
	_canLaunchCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._canLaunchCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.canLaunch);
		}
	},

	_onResumeFromOthersRecv: function(cmd)
	{
		var msg = {};
		if (! this._onResumeFromOthersRecvGen(cmd, msg))
			return;

		this._onResumedFromOthers(msg.url, msg.sourceAppID);
	},

	_launchFailedRecv: function( cmd )
	{
		var msg = {};
		if (! this._launchFailedRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.canLaunch);
		}
	},

	_getAppSignaturesCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._getAppSignaturesCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.signatures.split(','));
		}
	},

	_getCallingPackageCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._getCallingPackageCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.packageName);
		}
	},
	
	
	_getIsServiceRunningCallbackRecv: function( cmd )
	{
		var msg = {};
		if (! this._getIsServiceRunningCallbackRecvGen(cmd, msg))
			return;

		var func = this._callbacks[parseInt(msg.callbackID, 10)];
		if (func) {
			func(msg.running);
		}
	},
	
	_onIntentReceivedRecv: function( cmd )
	{
		var msg = {};
		if (! this._onIntentReceivedRecvGen(cmd, msg))
			return;
		
		this._onIntentReceived( msg.action, JSON.parse(msg.extras, 10) );
	},

// {{?Wg Generated Code}}
	
	// Enums.
	/** 
			* Enumeration for services whose status may be queried.
			* @namespace
			 */
	Service:
	{ 
		/** * */
		SystemDownloadProvider: 1,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 349
	// Method create = -1
	// Method canLaunch = 2
	// Method launch = 3
	// Method onResumeFromOthers = 4
	// Method launchFailed = 5
	// Method canLaunchCallback = 6
	// Method getAppSignatures = 7
	// Method getAppSignaturesCallback = 8
	// Method getCallingPackage = 9
	// Method getCallingPackageCallback = 10
	// Method launchIntent = 11
	// Method launchService = 12
	// Method onIntentReceived = 13
	// Method getIsServiceRunning = 14
	// Method getIsServiceRunningCallback = 15
	// Method createShortcut = 16
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._onResumeFromOthersRecv( cmd );
					break;
				case 5:
					instance._launchFailedRecv( cmd );
					break;
				case 6:
					instance._canLaunchCallbackRecv( cmd );
					break;
				case 8:
					instance._getAppSignaturesCallbackRecv( cmd );
					break;
				case 10:
					instance._getCallingPackageCallbackRecv( cmd );
					break;
				case 13:
					instance._onIntentReceivedRecv( cmd );
					break;
				case 15:
					instance._getIsServiceRunningCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in IPCEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in IPCEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[349] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onResumeFromOthersRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.onResumeFromOthers from command: " + cmd );
			return false;
		}
		
		obj[ "url" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "url" ] === undefined )
		{
			NgLogE("Could not parse url in IPCEmitter.onResumeFromOthers from command: " + cmd );
			return false;
		}
		
		obj[ "sourceAppID" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "sourceAppID" ] === undefined )
		{
			NgLogE("Could not parse sourceAppID in IPCEmitter.onResumeFromOthers from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_launchFailedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.launchFailed from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in IPCEmitter.launchFailed from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.launchFailed from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_canLaunchCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.canLaunchCallback from command: " + cmd );
			return false;
		}
		
		obj[ "canLaunch" ] = Core.Proc.parseBool( cmd[ 0 ] );
		if( obj[ "canLaunch" ] === undefined )
		{
			NgLogE("Could not parse canLaunch in IPCEmitter.canLaunchCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.canLaunchCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getAppSignaturesCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.getAppSignaturesCallback from command: " + cmd );
			return false;
		}
		
		obj[ "signatures" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "signatures" ] === undefined )
		{
			NgLogE("Could not parse signatures in IPCEmitter.getAppSignaturesCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.getAppSignaturesCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getCallingPackageCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.getCallingPackageCallback from command: " + cmd );
			return false;
		}
		
		obj[ "packageName" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "packageName" ] === undefined )
		{
			NgLogE("Could not parse packageName in IPCEmitter.getCallingPackageCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.getCallingPackageCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onIntentReceivedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.onIntentReceived from command: " + cmd );
			return false;
		}
		
		obj[ "action" ] = Core.Proc.parseString( cmd[ 0 ] );
		if( obj[ "action" ] === undefined )
		{
			NgLogE("Could not parse action in IPCEmitter.onIntentReceived from command: " + cmd );
			return false;
		}
		
		obj[ "extras" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "extras" ] === undefined )
		{
			NgLogE("Could not parse extras in IPCEmitter.onIntentReceived from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_getIsServiceRunningCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in IPCEmitter.getIsServiceRunningCallback from command: " + cmd );
			return false;
		}
		
		obj[ "running" ] = Core.Proc.parseBool( cmd[ 0 ] );
		if( obj[ "running" ] === undefined )
		{
			NgLogE("Could not parse running in IPCEmitter.getIsServiceRunningCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackID" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "callbackID" ] === undefined )
		{
			NgLogE("Could not parse callbackID in IPCEmitter.getIsServiceRunningCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":349,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_canLaunchSendGen: function( url, callbackID )
	{
		Core.Proc.appendToCommandString( ":349,2," + this.__objectRegistryId + "," + Core.Base64.encode( url ) + "," + callbackID  );
	},
	
	/** @private */
	_launchSendGen: function( url, callbackID )
	{
		Core.Proc.appendToCommandString( ":349,3," + this.__objectRegistryId + "," + Core.Base64.encode( url ) + "," + callbackID  );
	},
	
	/** @private */
	_onResumeFromOthersSendGen: function( url, sourceAppID )
	{
		Core.Proc.appendToCommandString( ":349,4," + this.__objectRegistryId + "," + Core.Base64.encode( url ) + "," + Core.Base64.encode( sourceAppID )  );
	},
	
	/** @private */
	_getAppSignaturesSendGen: function( packageName, callbackID )
	{
		Core.Proc.appendToCommandString( ":349,7," + this.__objectRegistryId + "," + Core.Base64.encode( packageName ) + "," + callbackID  );
	},
	
	/** @private */
	_getCallingPackageSendGen: function( callbackID )
	{
		Core.Proc.appendToCommandString( ":349,9," + this.__objectRegistryId + "," + callbackID  );
	},
	
	/** @private */
	_launchIntentSendGen: function( intent, extras )
	{
		Core.Proc.appendToCommandString( ":349,11," + this.__objectRegistryId + "," + Core.Base64.encode( intent ) + "," + Core.Base64.encode( extras )  );
	},
	
	/** @private */
	_launchServiceSendGen: function( intent, extras )
	{
		Core.Proc.appendToCommandString( ":349,12," + this.__objectRegistryId + "," + Core.Base64.encode( intent ) + "," + Core.Base64.encode( extras )  );
	},
	
	/** @private */
	_getIsServiceRunningSendGen: function( serviceEnum, callbackID )
	{
		Core.Proc.appendToCommandString( ":349,14," + this.__objectRegistryId + "," + serviceEnum + "," + callbackID  );
	},
	
	/** @private */
	_createShortcutSendGen: function( name, url, icon_path )
	{
		Core.Proc.appendToCommandString( ":349,16," + this.__objectRegistryId + "," + Core.Base64.encode( name ) + "," + Core.Base64.encode( url ) + "," + Core.Base64.encode( icon_path )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// canLaunch: function( url, callbackID ) {}
	
	// launch: function( url, callbackID ) {}
	
	// _onResumeFromOthersRecv: function( cmd ) {}
	// onResumeFromOthers: function( url, sourceAppID ) {}
	
	// _launchFailedRecv: function( cmd ) {}
	// _canLaunchCallbackRecv: function( cmd ) {}
	// getAppSignatures: function( packageName, callbackID ) {}
	
	// _getAppSignaturesCallbackRecv: function( cmd ) {}
	// getCallingPackage: function( callbackID ) {}
	
	// _getCallingPackageCallbackRecv: function( cmd ) {}
	// launchIntent: function( intent, extras ) {}
	
	// launchService: function( intent, extras ) {}
	
	// _onIntentReceivedRecv: function( cmd ) {}
	// getIsServiceRunning: function( serviceEnum, callbackID ) {}
	
	// _getIsServiceRunningCallbackRecv: function( cmd ) {}
	// createShortcut: function( name, url, icon_path ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/LayoutEmitter'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/LayoutEmitter'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/LayoutEmitter'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class LayoutEmitter
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Core = require('NGCore/Client/Core').Core;

////////////////////////////////////////////////////////////////////////////////

exports.LayoutEmitter = Core.MessageEmitter.singleton(
/** @lends Device.LayoutEmitter.prototype */
{
	classname: 'LayoutEmitter',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	_layoutChangedRecv: function( cmd ) 
	{
		var msg = {};
		if(!this._layoutChangedRecvGen(cmd, msg))
			return;

 		this._width = msg['width'];
 		this._height = msg['height'];
 		//NgLogD("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++JS received width as :"+ this._width + " and height as :" + this._height); 
		this.emit(msg);
		this._layoutChangedSendGen(msg.width, msg.height);
	},
	
	$getWidth: function()
	{
		return this._width;
	},
	
	$getHeight: function()
	{
		return this._height;
	},
	
	/**
	 * @private
	 */
	setWidthAndHeight: function(width, height) {
		//NgLogD("---------------------------------Setting width and height for LayoutEmitter directly from native ......... width is " + width + " and height is " + height );
		this._width = width;
		this._width = height;
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 352
	// Method create = -1
	// Method layoutChanged = 2
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._layoutChangedRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LayoutEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LayoutEmitter._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[352] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_layoutChangedRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in LayoutEmitter.layoutChanged from command: " + cmd );
			return false;
		}
		
		obj[ "width" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "width" ] === undefined )
		{
			NgLogE("Could not parse width in LayoutEmitter.layoutChanged from command: " + cmd );
			return false;
		}
		
		obj[ "height" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "height" ] === undefined )
		{
			NgLogE("Could not parse height in LayoutEmitter.layoutChanged from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":352,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_layoutChangedSendGen: function( width, height )
	{
		Core.Proc.appendToCommandString( ":352,2," + this.__objectRegistryId + "," + width + "," + height  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _layoutChangedRecv: function( cmd ) {}
	// layoutChanged: function( width, height ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Device/_LocalNotification'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Device/_LocalNotification'] || {}; $MODULE_REGISTRY['NGCore/Client/Device/_LocalNotification'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class LocalNotification
//
// Copyright (C) 2011 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Client/Core/Class').Class;

////////////////////////////////////////////////////////////////////////////////

exports.LocalNotification = Class.singleton(
/** @lends Device.LocalNotification.prototype */
{
	classname: 'LocalNotification',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},

	/**
	 * showLocalNotification is called with JSON options.  Currently, these
	 * JSON options are supported: {
	 * openurl : "mobage-ww-mobageBoot://mobageBoot/1/ServiceUI/Catalog",
	 * aps : {
	 *    alert: "Text to show in notification area"
	 *  }
	 * // optional, Android-only, string tag to control how the notifications
	 * // are stacked in the tray
	 * tag : "tray_tag_1"
	 * }
	 *    
	 * This function may only be invoked by a privileged process. 
	 *
	 * @augments options - json options to describe how to show local
	 *  notification
	 */
	showLocalNotification: function( options ) {
		this._showLocalNotificationSendGen(options);
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 354
	// Method create = -1
	// Method destroy = 2
	// Method showLocalNotification = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in LocalNotification._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in LocalNotification._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[354] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":354,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":354,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_showLocalNotificationSendGen: function( options )
	{
		Core.Proc.appendToCommandString( ":354,3," + this.__objectRegistryId + "," + Core.Base64.encode( JSON.stringify( options ) )  );
	}
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// showLocalNotification: function( options ) {}
	

// {{/Wg Generated Code}}

});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/_Internal/_RequireLoader'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/_Internal/_RequireLoader'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/_Internal/_RequireLoader'] = exports; /** RequireLoader.js
	Include files lazily, using throwaway property getters.
*/

function _generateGetter(name, requireFn) {
	// Need this for scoping
	return function() {
		// Remove the getter on first access and replace it with the evaluated require.
		delete this[name];
		return this[name] = requireFn();
	};
}

exports.RequireLoader = function(map) {
	if (map instanceof Object) {
		for (var req in map) {
			this.__defineGetter__(req, _generateGetter(req, map[req]));
		}
	}
	return this;
};

exports.RequireLoader.prototype = {
	load: function(name) {
		// A little syntactic sugar if things need to be loaded.
		// requires.load("Thing") explains what is happening pretty well.
		this[name];
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Appdata'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Appdata'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Appdata'] = exports; var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

/**
 * @class 
 * @name Social.Common.Appdata
 * @description
 * Mobage provides a common API for application data, which you can use for both Japan and the US. 
 * <code>Appdata</code> is consistent with the Open Social <code>osapi.appdata</code> interface, 
 * and enables the application to store name/value pairs for arbitrary application data.
 * To add or update application data, call <code>updateEntries()</code>. To retrieve entries, call <code>getEntries()</code>. 
 * To delete entries, call <code>deleteEntries()</code>.
 * @see Social.US.AppData for additional Mobage persistence facilities.
 * @see Storage.KeyValue for additional ngCore persistence facilities.
 * @see Storage.FileSystem for additional ngCore persistence facilities.
 */
exports.Appdata = {
		
	/**
	 * Retrieves a hash of one or more key/value pairs.
	 * If the <code>keys</code> parameter is <code>null</code>, <code>undefined</code> or an empty array, <code>getEntries()</code> 
	 * returns all key/value pairs to the callback function.
	 *
	 * @name Social.Common.Appdata.getEntries
	 * @function
	 * @public
	 * 
	 * @param {Array} keys Set as an array of key names. For example, <code>['key1', 'key2']</code>.
	 * @param {Function} callback Retrieves a hash of key/value pairs. If an error occurs, retursn an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var entries = {"key1": "value1", "key2": "value2"};
     * ...
     * function(error, entries){
     * &nbsp;&nbsp;   if (error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorDesc = error.description;
     * &nbsp;&nbsp;   } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var retrievedEntries = entries;
     * &nbsp;&nbsp;   }
	 * }
	 * </pre>
	 * @see Social.Common.Appdata.updateEntries
	 * @example 
	 * Appdata.getEntries(['key1', 'key2'], callback );
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	getEntries: function(keys, callback) {
		var cmd = {apiURL:"Common.Appdata.getEntries", keys:keys, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
	},
	
	/**
	 * Inserts or updates the submitted key/value pairs. 
	 * <b>Note:</b> Limited to 30 key/value pairs per user, per game. 
	 * Maximum key name limited to 32 bytes. Maximum value limited to 1,024 bytes.
     * To use key/value pairs without the foregoing constraints, use <code>Storage.KeyValue</code>
     * in ngCore.
	 *
	 * @name Social.Common.Appdata.updateEntries
	 * @function
	 * @public
	 * 
	 * @param {Hash} entries Takes a hash of key/value pairs. For example, <code>{"favoriteMovie": "Pulp Fiction", "petName": "Rover"}</code>.
	 * @param {Function} callback Retrieves the updated entries. If an error occurs, returns an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var entries = {"favoriteMovie": "Pulp Fiction", "petName": "Rover"};
     * ...
     * function(error, entries){
     * &nbsp;&nbsp;   if (error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorDesc = error.description;
     * &nbsp;&nbsp;   } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var updatedEntries = entries;
     * &nbsp;&nbsp;   }
	 * }
	 * </pre>
	 * @see Social.Common.Appdata.getEntries
	 * @example
	 * Appdata.updateEntries(
	 *              {   'favoriteMovie':'Pulp Fiction',    
	 *                  'petName':'Rover' }, 
	 *              callback );
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     * @see Social.US.AppData for additional Mobage persistence facilities.
     * @see Storage.KeyValue for additional ngCore persistence facilities.
     * @see Storage.FileSystem for additional ngCore persistence facilities.
	 */		
	updateEntries: function(entries, callback) {
		if(entries) {
			var cmd = {apiURL:"Common.Appdata.updateEntries", entries:entries, callbackFunc:callback};
			GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
		} else {
			if(typeof callback === 'function') {
				callback({ 
						errorCode: 400,
						description: "Entries to update are a required parameter"
					}, null);
			}
		}
	},
	
	
	/**
	 * Deletes one or more key/value pairs.
	 *
	 * @name Social.Common.Appdata.deleteEntries
	 * @function
	 * @public
	 * 
	 * @param {Array} keys Takes an array of key names. For example, <code>['petName']</code>. 
     * If <code>null</code>, the return object in the callback is not defined.
	 * @param {Function} callback  Retrieves a hash of the deleted entries. If an error occurs, returns an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var keys = {"petName"};
     * ...
     * function(error, keys){
     * &nbsp;&nbsp;   if (error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorDesc = error.description;
     * &nbsp;&nbsp;   } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var deletedKeys = keys;
     * &nbsp;&nbsp;   }
	 * }
	 * </pre>
	 * @example
	 * Appdata.deleteEntries(['petName'], callback );
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	deleteEntries: function(keys, callback) {
		if(keys && keys.length > 0) {
			var cmd = {apiURL:"Common.Appdata.deleteEntries", keys:keys, callbackFunc:callback};
			GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
		} else {
			if(typeof callback === 'function') {
				callback({ 
						errorCode: 400,
						description: "Keys to delete are a required parameter"
					}, null);
			}
		}
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Auth'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Auth'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Auth'] = exports; var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

/**
 * @class
 * @name Social.Common.Auth
 * @description
 * Retrieves a verification code.
 * Games call <code>Auth.authorizeToken()</code> if the game server is using the Mobage REST API.
 * For more information, refer to the Mobage RESTful API Conventions section of the developer's guide.
 */
exports.Auth = {
		
		
	/**
	 * Authorizes a temporary credential and returns a verification code.
	 *
	 * 
	 * @name Social.Common.Auth.authorizeToken
	 * @function
	 * @public
	 *
	 * @param {String} token The temporary credential identifier. 
	 * @param {Function} callback The callback function that handles the verification code and errors.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 *  <pre class="code">
     *  var verifier = "jklmnop";
	 *  function(error, verifier){
     *  &nbsp;&nbsp; if (error){
	 *  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 *  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 *  &nbsp;&nbsp; } else {
     *  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var verificationCode = verifier;    
     *  &nbsp;&nbsp; }
     *  }
	 * </pre>
	 * @example
	 * var token = "abcdefghi";
     * ...
	 * Social.Common.Auth.authorizeToken (token, callback);
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	authorizeToken: function(token, callback) {
		var cmd = {apiURL:"Common.Auth.authorizeToken", token:token, callbackFunc: callback };
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
		//callback(error, verifier)
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Blacklist'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Blacklist'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Blacklist'] = exports; var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

/**
 * @class 
 * @name Social.Common.Blacklist
 * @description
 * Provides an interface for checking the user's blacklist.
 */
exports.Blacklist = {

	/**
	 * Retrieves the target user ID from the specified user's blacklist.
	 * This call passes a user ID and a target user ID to determine if the specified target user is blacklisted. 
	 * If the target user ID parameter is <code>null</code>, this call retrieves the entire blacklist. The callback function also receives the total number of 
	 * target user IDs, the starting index, and the number of target IDs returned for paging the results.
	 *
	 * @name Social.Common.Blacklist.checkBlacklist
	 * @function
	 * @public
	 *
	 * @param {String} userId The user ID for the user who owns the blacklist. 
	 * @param {String} targetUserId The target user ID to check in the blacklist. <br/>If <code>null</code>, it checks the entire blacklist.
	 * @param {Hash} opt Takes a hash containing the start index and count for pagination. <br/>E.g., <code>{'start': 1, 'count': 100}</code> 
     * Requires start index and count. The minimum start index is 1. 
     * If <code>null</code>, undefined or an empty array, the start index is 1 and the count is 50.
	 * @param {Function} callback Retrieves an array of user IDs found in the blacklist. Otherwise, it retrieves an empty array.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var listedUsers = ['user1', 'user2'];
     * ...
     * function(error, listedUsers, result)
	 * &nbsp;&nbsp;		{
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			var blackListedUsers = listedUsers;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			var total = result.total;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			var start = result.start;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			var count = result.count;
  	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			var errorCode = error.errorCode;
  	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;			var errorDesc = error.description;
  	 * &nbsp;&nbsp;	}
  	 * </pre>
  	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */			
	checkBlacklist: function(userId, targetUserId, opt, callback) {
		var cmd = {apiURL:"Common.Blacklist.checkBlacklist", userId:userId, targetUserId:targetUserId, opt:opt, callbackFunc: function(error, args) {
			callback(error, args.users, args.result);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Config'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Config'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Config'] = exports; var Session = require('NGCore/Client/Social/US/Data/Session').Session;

/**
 * @class 
 * @name Social.Common.Config
 * @description
 * Mobage provides a common API to determine if the server is a sandbox server or a production server. 
 */
exports.Config = {

    /**
    * Returns whether the server is a sandbox server or a production server. 
    * Returns "unknown" if it cannot retrieve the current session
    * or if the server mode is not "sandbox" or "production."
    * 
    * @name Social.Common.Config.getServerEnvironment
    * @public
    * @function
    * @returns {String} "sandbox," "production" or "unknown."
    * @see Social.US.Session.serverModes
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */
	getServerEnvironment: function(){
		var session = Session.getCurrentSession();
		if(!session){
			return "unknown";
		}
		
		var serverMode = Session.getCurrentSession().serverMode();
		if(serverMode == Session.serverModes.production){
			return "production";
		}else if(serverMode == Session.serverModes.sandbox){
			return "sandbox";
		}else{
			return "unknown";
		}
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/People'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/People'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/People'] = exports; var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

/**
 * @class 
 * @name Social.Common.People
 * @description
 * The social API for returning user objects with their social graphs. The user object
 * retrieved varies from platform to platform. US platform required fields are <code>id</code>, <code>displayName</code>, <code>hasApp</code> 
 * and <code>thumbnailUrl</code> of the <code>Person</code> data type.
 */
exports.People = {
	
	/**
	 * Retrieves fields for the specified user from the <code>Person</code> data type. The specified user corresponds to the user ID parameter.
	 * Below are the fields returned by this call:
	 * <ul>
	 * <li><code>id</code></li>
	 * <li><code>displayName</code></li>
	 * <li><code>hasApp</code></li>
	 * <li><code>thumbnailUrl</code></li>
	 * </ul>
	 * Use the <code>fields</code> parameter to retrieve non-required fields of the <code>Person</code> data type.
	 *
	 * @name Social.Common.People.getUser
	 * @function 
	 * @public 
	 *
	 * @param {String} userId The user ID of the user to retrieve.
	 * @param {Array} fields An array of non-required fields of the <code>Person</code> data type to include in the response to the callback. 
     * <br/>For example, <code>['nickname','aboutMe']</code>. If <code>null</code>, <code>undefined</code> or an empty array, this call only retrieves the required fields.
	 * @param {Function} callback Retrieves the user specified by the <code>userId</code> parameter. If an error occurs, returns an error code and error description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, user){
     * &nbsp;&nbsp; if (error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     * &nbsp;&nbsp; } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var retrievedUser = user;
     * &nbsp;&nbsp;}
	 * }</pre>
	 * @see Social.Common.People.getCurrentUser
	 * @example
	 * var recordID = 2;
	 *
	 * Social.Common.People.getUser(recordID, 
	 *                              ['id','nickname','aboutMe'], 
	 *                              callback
	 *		});
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */						
	getUser: function(userId, fields, callback) {
		var cmd = {apiURL:"Common.People.getUser", userId:userId, fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Retrieves an array of users.
	 * Takes one or more user IDs and retrieves an array of users with the callback. 
	 * Retrieves up to 100 users, with no guarantee of retrieving the user array 
	 * in the order specified.
	 * Retrieves the <code>id</code>, <code>displayName</code>, <code>hasApp</code> 
	 * and <code>thumbnailUrl</code> fields of the <code>Person</code> data type for each user.
	 * To retrieve non-required fields of the <code>Person</code> data type, specify the non-required fields 
	 * desired in the <code>fields</code> parameter.
	 *	 
	 * @name Social.Common.People.getUsers
	 * @function 
	 * @public
	 * 
	 * @param {Array} userIds An array of user IDs of the users to retrieve. Minimum array size is 1, and maximum is 100.
	 * @param {Array} fields An array of non-required fields of the <code>Person</code> data type to include in the callback. <br/>For example, <code>['nickname','aboutMe']</code>.
     * <br/>If <code>null</code>, <code>undefined</code> or an empty array, it retrieves only the required fields.
	 * @param {Function} callback Retrieves an array of users specified by the <code>userIds</code> parameter and/or an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, users){
     * &nbsp;&nbsp; if (error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     * &nbsp;&nbsp; } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var retrievedUsers = users;
     * &nbsp;&nbsp;}
	 * }</pre>
	 * @see Social.Common.People.getUser
	 * @example
	 * People.getUsers([1,2,3],null, callback);
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */				
	getUsers: function(userIds, fields, callback) {
		var cmd = {apiURL:"Common.People.getUsers", userIds:userIds, fields:fields, callbackFunc:function(errors, args) {
			callback(errors, args.users, args.results);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	
	/**
	 * Retrieves fields for the current user from the <code>Person</code> data type. Below are the fields returned by this call:
	 * <ul>
	 * <li><code>id</code></code>
	 * <li><code>displayName</code></li>
	 * <li><code>hasApp</code></li>
	 * <li><code>thumbnailUrl</code></li>
	 * </ul>
	 *
	 * @name Social.Common.People.getCurrentUser
	 * @function
	 * @public
	 *
	 * @param {Array} fields An array of non-required fields of the <code>Person</code> data type to include in the callback. <br/>For example, <code>['nickname','aboutMe']</code>.
     * <br/>If <code>null</code>, <code>undefined</code> or an empty array, this call only retrieves the required fields.
	 * @param {Function} callback Retrieves the current user. If an error occurs, returns an error code and error description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, user){
     * &nbsp;&nbsp; if (error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     * &nbsp;&nbsp; } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var currentUser = user;
     * &nbsp;&nbsp;}
	 * }</pre>
	 * @see Social.Common.People.getUser
	 * @example
	 * People.getCurrentUser(null, callback);
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */				
	getCurrentUser: function(fields, callback) {
		var cmd = {apiURL:"Common.People.getCurrentUser", fields:fields, callbackFunc:callback};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	
	/**
	 * Retrieves fields for friends of a specified user. Below are the fields returned by this call:
	 * <ul>
	 * <li><code>id</code></li>
	 * <li><code>displayName</code></li>
	 * <li><code>hasApp</code></li> 
	 * <li><code>thumbnailUrl</code></li>
	 * </ul>
	 *
	 * @name Social.Common.People.getFriends
	 * @function
	 * @public
	 * 
	 * @param {String} userId The user ID of the user whose friends are retrieved by the callback function. 
	 * @param {Array} [fields] An array of non-required fields of the <code>Person</code> data type to include in the response to the callback. 
     * <br/>For example, <code>['nickname','aboutMe']</code>.
     * <br/> If <code>null</code>, <code>undefined</code> or an empty array, this call only retrieves the required fields.
	 * @param {Hash} [opt] A hash containing the start index and count for pagination. <br/>For example, <code>{'start': 1, 'count': 100}</code> 
	 * @param {Function} callback Retrieves the friends of the given user. If an error occurs, returns an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, friends){
     * &nbsp;&nbsp; if (error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     * &nbsp;&nbsp; } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var retrievedFriends = friends;
     * &nbsp;&nbsp;}
	 * }</pre>
	 * @see Social.Common.People.getFriendsWithGame
	 * @example
	 * People.getFriends(4, null, {'start': 2}, callback);
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */					
	getFriends: function(userId, fields, opt, callback) {
		var cmd = {apiURL:"Common.People.getFriends", userId:userId, fields:fields, opt:opt, callbackFunc: function(errors, args) {
			callback(errors, args.users, args.results);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	
	/**
	 * Retrieves a list of the user's friends playing the current game.
	 *
	 * @name Social.Common.People.getFriendsWithGame
	 * @function
	 * @public
	 *
	 * @param {String} userId The user ID of the person whose friends play the current game.
	 * @param {Array} fields An array of non-required fields of the <code>Person</code> data type to include in the response to the callback. 
     * <br/>For example, <code>['nickname','aboutMe']</code>.
     * <br/> If <code>null</code>, <code>undefined</code> or an empty array, this call retrieves only the required fields.
	 * @param {Hash} opt A hash containing the start index and count for pagination. <br/>For example, <code>{'start': 1, 'count': 100}</code> 
	 * @param {Function} callback Retrieves the friends of the specified user. If an error occurs, returns an error code and error description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, friends){
     * &nbsp;&nbsp; if (error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     * &nbsp;&nbsp; } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var retrievedFriends = friends;
     * &nbsp;&nbsp;}
	 * }</pre>
	 * @see Social.Common.People.getFriends
	 * @example 
	 * People.getFriendsWithGame(4, null, null, callback);
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */						
	getFriendsWithGame: function(userId, fields, opt, callback) {
		var cmd = {apiURL:"Common.People.getFriendsWithGame", userId:userId, fields:fields, opt:opt, callbackFunc: function(errors, args) {
			callback(errors, args.users, args.results);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
	
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Profanity'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Profanity'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Profanity'] = exports; var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');	

/**
 * @class 
 * @name Social.Common.Profanity
 * @description
 * Provides an interface to check games for profanity.
 */
exports.Profanity = {
	
	/**
	 * Checks a text string to determine if it contains profanity.
	 * This call only conducts a check and does not attempt to cleanup the string.<br><br>
	 * <b>Note:</b> The server handles locale and language automatically.
	 *
	 * @name Social.Common.Profanity.checkProfanity
	 * @function
	 * @public
	 * 
	 * @param {String} text The string to check for profanity.
	 * @param {Function} callback Retrieves any profane words or phrases in the text parameter. 
     * The result of checking is either <code>true</code> or <code>false</code>. If the result is <code>false</code>, the text string contains profanity. 
     	 * If an error occurs, returns an error code and error description to the callback.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class='code'>function(error, args){
     * &nbsp;&nbsp; if(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorDesc = error.description;
     * &nbsp;&nbsp;} else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var profanity = args.profanity;
     * &nbsp;&nbsp;}
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	checkProfanity: function(text, callback) {
		var cmd = {apiURL:"Common.Profanity.checkProfanity", text:text, callbackFunc:function(error, args) {
			callback(error, args.profanity);
		}};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);		
	}	
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Request'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Request'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Request'] = exports; var Class = require('NGCore/Client/Core/Class').Class;


//Don't need to document
exports.Request = Class.subclass({
	execute: function(callback) {
		// [call US function here]	
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Service'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Service'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Service'] = exports; var UI = require('NGCore/Client/UI').UI;

var RouterInited = require('NGCore/Client/Social/_Internal/RouterInit');
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;

var ButtonOverlays = require('NGCore/Client/Social/US/Service/ButtonOverlays').ButtonOverlays;
var Friends = require('NGCore/Client/Social/US/Service/Friends').Friends;
var Profile = require('NGCore/Client/Social/US/Service/Profile').Profile;
var User    = require('NGCore/Client/Social/US/Models/User').User;

/**
 * @class 
 * @name Social.Common.Service
 * @description
 * This interface provides the following social game services: <br/>
 * <div class="ul">
 * <li>Balance Button</li>
 * <li>Community Button</li>
 * <li>Friend Picker</li>
 * <li>User Finder</li>
 * <li>User Profile</li>
 * </div>
 */
exports.Service = {

	
	/**
	* Opens the user finder screen.
	* The user finder provides a way for users to find other users using the following filters:
	* <ul>
	* <li>Suggested Friends</li>
	* <li>Contacts</li> 
	* <li>Requests</li>
	* <li>Search</li>
	* </ul>
	*
	* @name Social.Common.Service.openUserFinder 
	* @function
	* @public
	* @status iOS, Android, Test, iOSTested, AndroidTested
    */		
	openUserFinder: function() {
		Friends.showFindFriends(undefined);
	},

	
	/**
	* Opens the friend picker.
	*
	* @name Social.Common.Service.openFriendPicker 
	* @function
	* @public 
	* 
	* @param {Number} maxFriendsToSelect The maximum number of friends the user may select.
	* @param {Function} callback The callback function called after the view closes. Returns an array of friends.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error, friendUserIds){
	* 	&nbsp;&nbsp;&nbsp;if (error){
	* 	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  		var errorCode = error.errorCode;
	*   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  		var errorDesc = error.description;
	* 	&nbsp;&nbsp;&nbsp;} else {
	*   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  		var pickedFriends = friendUserIds;
	*   &nbsp;&nbsp;&nbsp;  	}
	*   &nbsp;&nbsp;  }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	openFriendPicker: function(maxFriendsToSelect, callback) {
		Friends.showFriendPicker(maxFriendsToSelect, function(err, friends){
			var userIDs = [];
			friends = friends || [];
			for(var idx = 0; idx < friends.length; idx++){
				userIDs.push(friends[idx].recordID);
			}
			callback( userIDs );
		});
	},

	
	/**
	* Opens the specified profile page.
	*
	* @name Social.Common.Service.openUserProfile 
	* @function
	* @public 
	* 
	* @param {String} userId The user ID or gamer name of the profile page to open.
	* @param {Function} callback The callback function if there is an error with the user ID or gamer name.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	openUserProfile: function(userId, callback) {
		if(typeof userId == "string"){
			// if the userId string contains no non-numeral characters:
			//   parse it into a number
			// else null it out, because it's not a valid userId
			if(userId.match(/[^0-9]/) === null){
				userId = parseInt(userId, 10);
			}else{
				userId = null;
			}
		}
		
		if( !userId ){
			callback({errorCode: 400, description: "userid is invalid"});
		}
		else{
			User.getUserWithID(userId, function(err, user){
				if(err){
					if( err==="Sorry, we can't find anyone with that name." ){
						callback({errorCode: 404, description: err});
					} else {
						callback({errorCode: 500, description: err});
					}
				}else if(!user){
					callback({errorCode: 404, description: "User not found"});
				}else{
					Profile.showUserProfile(user, undefined);
				}
			});
	}
	},


	/**
	* Displays the <b>Mobage Community</b> button.
	*	
	* @name Social.Common.Service.showCommunityButton
	* @function
	* @public 
	* 
	* @param {exports.Gravity} gravity Displays the button in the specified corner. 
    * <b>Note:</b> Only supported for the US. Japan uses the top-left corner only.
	* @param {String} theme Displays the theme for the button (for example, "default", "dark", "light"). 
    * <b>Note:</b> Only supported for Japan. You can specify <code>null</code> for the US region.
	* @param {Function} callback The callback function if there is an error related
    * to <code>gravity</code> or <code>theme</code> usage.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @see exports.Gravity
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/           
	showCommunityButton: function(gravity, theme, callback) {
		ButtonOverlays.showCommunityButton(gravity, callback);
	},

	/**
	* Hides the <b>Mobage Community</b> button.
	*
	* @name Social.Common.Service.hideCommunityButton
	* @function
	* @public 
	*	
	* @param {Function} callback The callback function if there is an error hiding the button.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/		
	hideCommunityButton: function(callback) {
		ButtonOverlays.hideCommunityButton(callback);
	},

	
	/**
	* A message emitter object for adding a message emitter when inviting a user.
	*
	* @name Social.Common.Service.invitedUserEmitter
	* @field
	* @public
	* @example 
	* Social.Common.Service. ...
	* ... invitedUserEmitter.addListener(
	*			new Core.MessageListener(), 
	*			function(userId){
	*				NgLogD("New Emitter! " + userId);
	*			}
	*		);
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	invitedUserEmitter : new MessageEmitter(),

	
	/**
	 * Shows the balance button where the <code>rect</code> parameter 
	 * determines the size and position of the button.
     * The minimum size of the button is:<br/>
     * <ul>
     * <li>10% of height in Landscape, and the absolute minimum size is 150 x 50.</li>
     * <li>6% of height in Portrait, and the absolute minimum size is 150 x 50.</li>
     	 * </ul>
	 *
	 * @name Social.Common.Service.showBalanceButton
	 * @function
	 * @public
	 *	 
	 * @param {UI.ViewGeometry.Rect} rect Determines the size and position of the balance button.
	 * @param {Function} callback The callback function if there is an error with the <code>rect</code> parameter.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 * &nbsp;&nbsp;   }
	 * </pre>
	 * @see UI.ViewGeometry.Rect
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	showBalanceButton: function(rect, callback) {		
		ButtonOverlays.showBalanceButton(rect, callback);
	},
	
	/**
	 * Hides the balance button.	
	 * @name Social.Common.Service.hideBalanceButton
	 * @function
	 * @public 
	 * 
	 * @param {Function} callback The callback function called after the view closes.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 * &nbsp;&nbsp;   }
     * </pre>
     * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	hideBalanceButton: function(callback) {
		ButtonOverlays.hideBalanceButton(callback);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Common/Analytics'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Analytics'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Common/Analytics'] = exports; var SessionReq = require('NGCore/Client/Social/US/Data/Session');

/**
 * @private
 * @name Social.Common.Analytics
 * @description Private interface for analytics data
 *
 * TODO: These should be going into the priv interpreter. But need to check with Japan.
 */
exports.Analytics = {
  getUserId: function() {
	var cur_sess =	this._getSession(), cur_u = null;
	if (cur_sess) {
	  cur_u = (cur_sess.user() || {}).recordID;
	}
	return cur_u;
  },
  getUsername: function() {
	var cur_sess =	this._getSession(), cur_u = null;
	if (cur_sess) {
	  cur_u = (cur_sess.user() || {}).gamertag;
	}
	return cur_u;
  },
  getPlatformVersion: function() {
	var cur_sess =	this._getSession(), cur_pver = null;
	if (cur_sess) {
	  cur_pver = cur_sess.platformVersion();
	}
	return cur_pver;
  },
  getServiceId: function() { 
	return "US"; 
  },
  _getSession: function() {
	return SessionReq.Session.getCurrentSession();
  }
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/DataModel'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/DataModel'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/DataModel'] = exports; var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;
var SocialR = require('NGCore/Client/Social');
var SessionR        = require('NGCore/Client/Social/US/Data/Session');
var DispatcherR     = require('NGCore/Client/Social/US/Data/Dispatcher');

/**
 * <code>DataModel</code> constructs objects that emit messages when properties of an object change, and provides automatic caching,
 * serialization and deserialization between interpreters. 
 * <br/><br/>
 * <b>Note:</b> Do not instantiate this class directly. Use classes derived from <code>DataModel</code> for instantiation. These include:
 * <div class="ul">
 * <li>{@link Social.US.User}</li>
 * <li>{@link Social.US.AppData}</li>
 * <li>{@link Social.US.Game}</li>
 * <li>{@link Social.US.Score}</li>
 * <li>{@link Social.US.Leaderboard}</li>
 * </div>
 * @class 
 * @name Social.US.DataModel
 */
var DataModel = exports.DataModel = MessageEmitter.subclass({
		
	/**
	 * The default constructor.
	 * @constructs
	 * @private
	 */		
	initialize: function(recordID){
		this.recordID = recordID;

		this._cache();
	},
	beginChanges: function(){
		DispatcherR.Dispatcher.beginBatching();
	},
	endChanges: function(){
		DispatcherR.Dispatcher.endBatching();
	},
	_classname: function(){
		var classname = this.classname;
		return classname;
	},
	_cache: function(){
		if(!this._dataCache){
			var session = SessionR.Session.getCurrentSession();
			if(session){
				var cache = session.dataCache();
				if(cache){
					cache.addObject(this);
					this._dataCache = cache;
				}
			}
		}
		return this._dataCache;
	},
	$_serializedDataModel: function(obj){
		if(obj instanceof(DataModel)){
			obj = {
				classname: obj.classname,
				recordID:  obj.recordID
			};
		}
		return obj;
	},
	$_deserializedDataModel: function(value, cache){
		if(value && value.hasOwnProperty && value.hasOwnProperty("classname") && value.hasOwnProperty("recordID")){
			var theClassname = value.classname;
			var theClass = SocialR.Social.US[theClassname];
			var theRecordID = value.recordID;
			if(theClass && theRecordID){
				var theInstance = cache.getObjectWithRecordID(theClassname, theRecordID);
				if(!theInstance){
					theInstance = new theClass(theRecordID);
				}
				
				theInstance._deserializeFromHash(value.data);
				cache.addObject(theInstance);
    
				value = theInstance;
			}
		}
		return value;
	},
	_serializedHash: function(full){
		var theClass = this.constructor;
		var hash = {classname: theClass.classname, recordID: this.recordID};
		if(full === false){
			return hash; // if it's undefined, assume we want all the data
		}
		
		hash.data = {};
		
		var properties = this.constructor.properties || [];
		for(var idx = 0; idx < properties.length; idx++){
			var propertyName = properties[idx];
			var propertyValue = this[propertyName];

			if(propertyValue instanceof(Array)){
				for(var propertyIndex = 0; propertyIndex < propertyValue.length; propertyIndex++){
					propertyValue[propertyIndex] = DataModel._serializedDataModel(propertyValue[propertyIndex]);
				}
			}else{
				propertyValue = DataModel._serializedDataModel(propertyValue);
			}
			
			hash.data[propertyName] = propertyValue;
		}
		
		return hash;
	},
	_deserializeFromHash: function(data){
		if(!data){
			NgLogD("No public hash data for " + this.classname + " " + this.recordID);
			return;
		}
		
		var cache = this._cache();
		for(var key in data){
			var value = data[key];
			if(value instanceof(Array)){
				for(var propertyIndex = 0; propertyIndex < value.length; propertyIndex++){
					value[propertyIndex] = DataModel._deserializedDataModel(value[propertyIndex], cache);
				}
			}else{
				value = DataModel._deserializedDataModel(value, cache);
			}
			this[key] = value;
		}
	}
});

DataModel._oldSubclass = DataModel.subclass;
DataModel.subclass = function(contents){
	var theClass = DataModel._oldSubclass(contents);
	var properties = contents.properties || [];
	for(var idx = 0; idx < properties.length; idx++){
		var propertyName = properties[idx];
		
		(function(name){
			theClass.prototype.__defineSetter__(name, function(value){
				this["___" + name] = value;
				
				var msg = {};
				msg[""+name] = value;
				
				this.emit(msg);
			});
			theClass.prototype.__defineGetter__(name, function(value){
				return this["___" + name];
			});
		})(propertyName);
	}
	return theClass;
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/User'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/User'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/User'] = exports; var DataModelR  = require('NGCore/Client/Social/US/Models/DataModel');
var Dispatcher  = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;
var OrderedList = require('NGCore/Client/Social/US/Models/OrderedList').OrderedList;
var Social      = require('NGCore/Client/Social').Social;

/**
* <code>User</code> constructs objects that provide a service interface for the current user. 
* <code>User</code> objects enable the current user to retrieve:
* <div class="ul">
* <li>user details</li>
* <li>a list of friends</li>
* <li>games</li>
* </div>
* @class
* @name Social.US.User
* @augments Social.US.DataModel
*/
var User = exports.User = DataModelR.DataModel.subclass({
		
    /**
    * @constructs
    * @ignore
    */
	classname: "User",

	 /**
	 * The user's gamer tag. Read-only.
	 * @name Social.US.User.gamertag
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The user's avatar ID. Read-only.
	 * @name Social.US.User.avatarId
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's motto. Read-only.
	 * @name Social.US.User.motto
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The relation to this user. Read-only.
	 * @name Social.US.User.relation
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Sparse limits attributes in search results. Read-only.
	 * @name Social.US.User.sparse
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The user's photo ID. Read-only.
	 * @name Social.US.User.photoId
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's email address. Read-only.
	 * @name Social.US.User.emailAddress
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A hash of the user's email address. Read-only.
	 * @name Social.US.User.emailHash
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The user's phone number. Read-only.
	 * @name Social.US.User.phoneNumber
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */


	 /**
	 * The user's password. Read-only.
	 * @name Social.US.User.password
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The user's first name. Read-only.
	 * @name Social.US.User.firstName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */


	 /**
	 * The user's last name. Read-only.
	 * @name Social.US.User.lastName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * Whether to hide the user's full name. Read-only.
	 * @name Social.US.User.hideFullName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * Whether the user is age restricted. Read-only.
	 * @name Social.US.User.ageRestricted
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Whether the relationship to the user is new. Read-only.
	 * @name Social.US.User.isNewRelationship
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Whether the user is a mutual friend. Read-only.
	 * @name Social.US.User.isMutualFriend
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * Whether the user shows his/her presence. Read-only.
	 * @name Social.US.User.showsPresence
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * Whether the user only shows friend notifications. Read-only.
	 * @name Social.US.User.setOnlyShowFriendNotifications
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	 

	 /**
	 * The user's capabilities. Read-only.
	 * @name Social.US.User.capabilities
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's gamer score. Read-only.
	 * @name Social.US.User.gamerscore
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	 

	 /**
	 * The user's gamer level. Read-only.
	 * @name Social.US.User.gamerLevel
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	 

	 /**
	 * The user's gamer level name. Read-only.
	 * @name Social.US.User.gamerLevelName
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The gamer level score. Read-only.
	 * @name Social.US.User.gamerLevelScore
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The gamer score for the next level. Read-only.
	 * @name Social.US.User.gamerNextLevelScore
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The user's games. Read-only.
	 * @name Social.US.User.games
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	properties: [
		// public
		"gamertag",
		"avatarId",
		"motto",
		"relation",
		"sparse",
		"photoId",
		"emailHash",
		"ageRestricted",
		"isMutualFriend",
		
		// private
		"phoneNumber",
		"password",
		"firstName",
		"lastName",
		"hideFullName",
		"emailAddress",
		"isNewRelationship",
		"showsPresence",
		"onlyShowFriendNotifications",
		"capabilities",
		"gamerscore",
		"gamerLevel",
		"gamerLevelName",
		"gamerLevelScore",
		"gamerNextLevelScore",
		"games"
	],
	
	/**
	 * @constructs The default constructor constructs <code>User</code> objects.
	 * @name Social.US.User.initialize 
	 * @private
	 */
	initialize: function($super, recordID){
		$super(recordID);
		NgLogD("User Public! " + recordID + " " + this.recordID);
	},
	
	
	/**
	* Adds a user to the buddies list and ensures the added user is not on the blocked users list.
	* @name Social.US.User.addBuddy
	* @function
	* @private
	*
	* @param {Social.US.User} buddy The user to add to the buddies list. If not a user, the callback error is "No user."
	* @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error, data){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var buddyData = data;
    * &nbsp;&nbsp;  }
	* }
	* </pre>	
	*/	
	addBuddy: function(buddy, cb){
		Dispatcher.callMethodOnRemoteObject(this, "addBuddy", [buddy, cb]);
	},
	
	
	/**
	* Removes a user from the buddies list.
	* @name Social.US.User.removeBuddy
	* @function
	* @private
	*
	* @param {User} buddy The user to remove from the buddies list. If not a user, the callback error is "No user."
	* @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b>
	* <pre class="code">function(error, data){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var buddyData = data;
    * &nbsp;&nbsp;  }
	* }
	* </pre>
	*/		
	removeBuddy: function(buddy, cb){
		Dispatcher.callMethodOnRemoteObject(this, "deleteBuddy", [buddy, cb]);
	},
	
	
	/**
	* Retrieves a user object with all of the this user's details.
	*
	* @name Social.US.User.getUserDetails
	* @function
	* @public
	* 
	* @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error, user){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var userWithDetails = user;
    * &nbsp;&nbsp;  }
	* }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/			
	getUserDetails: function(cb){
		Dispatcher.callMethodOnRemoteObject(this, "getUserDetails", [cb]);		
	},
	
	/**
	* Retrieves an ordered list of the user's friend requests on Mobage.
	* @name Social.US.User.getMobageFriendRequestLists
	* @function
	* @public
	*
	* @return {Social.US.OrderedList} A list of the user's friend requests.
    * @example
    * var myMobageFriendRequests = userA.getMobageFriendRequestsList();
    * @see Social.US.OrderedList for more information on iterating over the Mobage Friend Requests list.
	*/			
	getMobageFriendRequestsList: function(){
		return OrderedList.getObjectPublicInterface(this, "getInvitesList", "_followersListInterface");
	},
	
	/**
	* Returns the user's friends list on Mobage.
	* @name Social.US.User.getMobageFriendsList
	* @function
	* @public	
	*
	* @return {Social.US.OrderedList} The user's friend list on Mobage.
    * @example
    * var myMobageFriendsList = userA.getMobageFriendsList();
    * @see Social.US.OrderedList for more information on iterating over the Mobage friends list.
    * @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	getMobageFriendsList: function(){
		return OrderedList.getObjectPublicInterface(this, "getFriendsList", "_friendsListInterface");
	},
	
	/**
	* Returns the user's blocked user list.
	* @name Social.US.User.getMobageBlockedUserList
	* @function
	* @public	
	*
	* @return {Social.US.OrderedList} The user's blocked user list on Mobage.
	* @see Social.US.OrderedList
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	getMobageBlockedUserList: function(){
		return OrderedList.getObjectPublicInterface(this, "getBlockedUserList", "_enemyListInterface");
	},
	
	/**
	* Returns the user's games list.
	* @name Social.US.User.getOwnedGamesList
	* @function
	* @public	
	*
	* @return {Social.US.OrderedList} The user's Mobage game list.
    * @example
    * var myGamesList = userA.getOwnedGamesList();
    * @see Social.US.OrderedList for more information on iterating over the games list.
    * @status iOS, Android, Test, iOSTested, AndroidTested
	*/			
	getOwnedGamesList: function(){
		return OrderedList.getObjectPublicInterface(this, "getOwnedGamesList", "_ownedGamesListInterface");
	},
	
	/**
	* Returns the list of "featured" users.
	* @name Social.US.User.getFeaturedUsersList
	* @function
	* @public	
	*
	* @return {Social.US.OrderedList} The list of "featured" users.
    * @example
    * var mobageFeaturedUsers = userA.getFeaturedUsersList();
    * @see Social.US.OrderedList for more information on iterating over the Mobage Featured Users list.
    * @status iOS, Android, Test, iOSTested, AndroidTested
	*/	
	getFeaturedUsersList: function(){
		return OrderedList.getObjectPublicInterface(this, "getFeaturedUsersList", "_featuredUsersListInterface");
	},

	/**
	* Invites the user to the current game.
	* @name Social.US.User.inviteToCurrentGame
	* @public
	* @function
	* 
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/
	inviteToCurrentGame: function(cb){
		var user = this;
		Dispatcher.callMethodOnRemoteObject(this, "inviteToCurrentGame", [function(err){
			if(!err){
				Social.Common.Service.invitedUserEmitter.emit({userId: user.recordID});
				Social.US.Service.Friends.invitedUserEmitter.emit({user: user});
			}
			cb.apply(this, Array.apply(null, arguments));
		}]);		
	},
	
	/**
	 * Send a Push notification to this user through the GameService back end.
	 * @name Social.US.User.sendNotificationToUser
	 * @public
	 * @function
	 *
	 * @param {Alert Text} alertText The displayed message when the push is received.
	 * @param {Badge ID} badgeId Badge displayed on the push.
	 * @param {Sound} sound Sound played when push is received.
	 * @param {Extra Data} extraData Additional payload.
	 *
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	sendNotificationToUser: function(alertText, badgeId, sound, extraData) {
		Dispatcher.callMethodOnRemoteObject(this, "sendNotificationToUser", [alertText, badgeId, sound, extraData]);
	},

    /**
    * Adds a user to the current user's friend list for the current game. Implies a one-directional relationship or "follower" model.
    * Takes an optional group parameter to add the user to a particular group. Current user can only 
    * add the user to one group. If the current user adds the user to a second group in the friend list, 
    * the user is moved from the first group.
    *
    * A group is an arbitrary classification of friends. The <code>group</code> parameter is a string, which 
    * takes the name of the group. You may allow users to manage their own groups, create game-level groups, 
    * or omit groups altogether. A user may only reside in one group of another user's friend list.<br><br>
    * <b>Note:</b> This is part of the Game Graph API. 
    *
    * @example
    * //Retrieve a user and set up a follower relationship.
    * var userA = Social.US.User; 
    * Social.US.User.getUserWithGamertag("chuck", function(error, user){
    *   if(!user) {
    *       var errorCode = error.errorCode;
    *       var errorDesc = error.description;
    *   } else {
    *        userA = user;
    *   }
    * });
    * var userB = Social.US.Session.getCurrentSession().user();
    * userB.addFriend(userA, callback);
    * //...
    * @example
    * //To make the relationship bi-directional, 
    * //you must make the same call for the other user.
    * userA.addFriend(userB, callback);
    *
    * @name Social.US.User.addFriend
    * @public
    * @function
    *
    * @param user The user to add to the current user's friend list. If <code>null</code>, <code>undefined</code> or not a 
    * <code>Social.US.User</code> object, the callback error is "No user."
    * @param {String} [group] An optional parameter for adding the friend into a group within the friend list.
    * @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error, data){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var appData = data;
    * &nbsp;&nbsp;  }
	* } </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
    */	
	addFriend: function(user, group, cb){
		if(typeof arguments[1] == "function" && !arguments[2]){
			cb = arguments[1];
			group = undefined;
		}
		Dispatcher.callMethodOnRemoteObject(this, "addGameFriend", [user, group, cb]);
	},

    /**
    * Removes a user from the current user's friend list for the current game.<br><br>
    * Does not require a group parameter, friends are only associated to one group in a friend list.
    * @name Social.US.User.removeFriend
    * @public
    * @function
    *
    * @param {Social.US.User} user The user to remove from the current user's friend list. If <code>null</code>, <code>undefined</code> or not a 
    * <code>Social.US.User</code> object, the callback error is "No user."
    * @param {Function} cb The callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error, data){
    * &nbsp;&nbsp;  if (error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var appData = data;
    * &nbsp;&nbsp;  }
	* } </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
    */		
	removeFriend: function(user, cb){
		Dispatcher.callMethodOnRemoteObject(this, "removeGameFriend", [user, cb]);
	},
	
	report: function(reason, cb){
		Dispatcher.callMethodOnRemoteObject(this, "report", [reason, cb]);
	},

    /**
    * Returns the user's friend list for the current game. If you specify the <code>group</code>
    * parameter, this call only returns friends within the group.<br><br>
    * <b>Note:</b> This is part of the Game Graph API.
    * @name Social.US.User.getFriendsList
    * @public
    * @function
    *
    * @param {String} group If specified, returns only friends in the group.
    * @return {Social.US.OrderedList} The user's friend list for the current game.
    * @example
    * var myFriendsList = userA.getFriendsList ("Best Buddies");
    * @see Social.US.OrderedList for more information on iterating over the friends list.
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */	
	getFriendsList: function(group){
		return OrderedList.getObjectPublicInterface(this, "getGameFriendsList", (group ? ("_gameFriendsList-friends-" + group ) : "_gameFriendsList-friends"), "friends", group);
	},


    /**
    * Returns the user's mutual friends.
    * Mutual friends result when two users add each other to their respective friend list.<br><br>
    * <b>Note:</b> This is part of the game graph API.
    * @name Social.US.User.getMutualFriendsList
    * @public
    * @function
    *
    * @param {String} group The group within the friend list. If specified, returns only mutual friends within the group.
    * @return {Social.US.OrderedList} The user's mutual friend list.
    * @example
    * userA.addFriend(userB);
    * userB.addFriend(userA);
    * var myMutualFriends = userA.getMutualFriendsList();
    * //userA appears in userB's mutual friends list, 
    * //because they are in each other's friend lists.
    * @see Social.US.OrderedList for more information on iterating over the mutual friends list.
    * @status iOS, Android, Test, iOSTested, AndroidTested    
    */	
	getMutualFriendsList: function(group){
		return OrderedList.getObjectPublicInterface(this, "getGameFriendsList", (group ? ("_gameFriendsList-mutual-" + group) : "_gameFriendsList-mutual"), "mutual", group);
	},


    /**
    * Returns the user's friend requests list. If the <code>group</code> parameter is specified, returns
    * only friends within the group.
    * @name Social.US.User.getFriendRequestsList
    * @public
    * @function
    *
    * @param {String} group The group within the friend request list.
    * @return {Social.US.OrderedList} The user's friend requests list.
    * @example
    * var myFriendRequestsList = userA.getFriendRequestsList ();
    * @see Social.US.OrderedList for more information on iterating over the friend requests list. 
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */	
	getFriendRequestsList: function(group){
		return OrderedList.getObjectPublicInterface(this, "getGameFriendsList", (group ? ("_gameFriendsList-invitation-" + group) : "_gameFriendsList-invitation"), "invitation", group);
	},

	/**
	* Updates the email address for the current user.
	* @name Social.US.User.setEmailAddress
	* @function
	* @private
	*
	* @param {String} newAddress The email address for the current user.
	* @param {Function} cb The callback function if an error occurs (for example, invalid email address format).
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setEmailAddress:function(newAddress,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setEmailAddress", [newAddress, cb]);
	},
	
	/**
	* Sets whether the current user will receive notifications from other Mobage users or just from Mobage friends.
	* @name Social.US.User.setOnlyShowFriendNotifications
	* @function
	* @private
	*
	* @param {Boolean} isFriendsOnly Set to <code>true</code> if the current user will only receive notifications from Mobage users who are also Mobage friends. 
    * If set to <code>false</code>, the user receives notifications from all Mobage users. 
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setOnlyShowFriendNotifications:function(isFriendsOnly,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setOnlyShowFriendNotifications", [isFriendsOnly, cb]);
	},
	
	/**
	* Sets whether the current user will receive game news and updates from Mobage.
	* @name Social.US.User.setOptsIn
	* @function
	* @private
	*
	* @param {Boolean} optIn Set to <code>true</code> if the current user will receive news and updates from Mobage. 
    * If set to <code>false</code>, the user will not receive news or updates from Mobage. 
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	setOptsIn:function(optIn,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setOptsIn", [optIn, cb]);
	},

	/**
	* Sets a motto for the current user. In other words, the user's "about me" text string.
	* @name Social.US.User.setMotto
	* @function
	* @private
	*
	* @param {String} motto The motto for the current user.
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setMotto:function(motto,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setMotto", [motto, cb]);
	},
	
	/**
	* Updates the first name for the current user.
	* @name Social.US.User.setFirstName
	* @function
	* @private
	*
	* @param {String} firstName The first name for the current user.
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setFirstName:function(firstName,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setFirstName", [firstName, cb]);
	},
	
	/**
	* Updates the last name for the current user.
	* @name Social.US.User.setLastName
	* @function
	* @private
	*
	* @param {String} lastName The last name for the current user.
	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	setLastName:function(lastName,cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setLastName", [lastName, cb]);
	},
	

	/**
	* Sets a password for the current user.
	* @name Social.US.User.setPassword
	* @function
	* @private
	*
	* @param {String} password The password for the current user.
    * @param {String} confirmation The password confirmation for the current user.
	* @param {Function} cb The callback function if an error occurs. For example, password does not meet requirements; password and confirmation do not match, and so on.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/
	setPassword:function(password,confirmation, cb) {
		Dispatcher.callMethodOnRemoteObject(this, "setPassword", [password, confirmation, cb]);
	},

	/**
	* Sets whether the target user is in the logged-in user's blocked user list.
	* @name Social.US.User.setBlocked
	* @function
	* @private
	*
	* @param {Social.US.User} user The user that is the subject of blocking or unblocking.
    * @param {Boolean} blocked Whether the current user blocks the specified user. If <code>true</code>, the specified user is blocked.
    	* @param {Function} cb The callback function if an error occurs.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
    * @status iOS, Android, Test, iOSTested, AndroidTested	
	*/	
	setBlocked:function(blocked, cb){
		Dispatcher.callMethodOnRemoteObject(this, "setBlocked", [blocked, cb]);
	},
	
	/**
	 * Gets the origin of the user's registration.
	 * Mobage records the origin of a user's registration. The "origin" may be the name of an alliance partner.
	 * The origin is typically used as a means of tracking revenue sharing events, such as the promotional activity 
	 * of an alliance partner that attracts new users to Mobage and thereby entitles the alliance partner 
	 * to share in revenue generated by the application.  
	 *
	 * @name Social.US.User.getOriginOfRegistration
	 * @private
	 * @static
	 * @function
	 *
	 * @param {Function} cb The callback function returns the origin of registration, or an error code and description.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, originOfRegistration){
	 *     if(!originOfRegistration) {
	 *          var errorCode = error.errorCode;
	 *          var errorDesc = error.description;
	 *     } else {
	 *          var origin = originOfRegistration;
	 *     }
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getOriginOfRegistration: function(cb) {
		Dispatcher.callMethodOnRemoteObject(this, "getOriginOfRegistration", [cb]);
	}
});

User.GamertagKey = "gamertag";
User.AvatarKey = "badge_id";
User.MottoKey = "motto";
User.RelationKey = "relation";
User.FirstNameKey = "first_name";
User.LastNameKey = "last_name";
User.BirthdateKey = "birth_date";
User.GenderKey = "gender";
User.PrivacyKey = "fullname_privacy";
User.PhotoKey = "photo_url";
User.EmailAddressKey = "email";
User.EmailHashKey = "email_hash";
User.PhoneNumberKey = "phone_number";
User.AgeRangeKey = "age_restricted";
User.SpamKey = "opt_in";

User.PasswordKey = "password";
User.PasswordConfirmKey = "password_confirmation";
User.GamesKey = "games";
User.CapabilitiesKey = "capabilities";
User.NewBuddyKey = "new_buddy";
User.IsMutualFriendKey = "mutual_friends";
User.HidePresenceKey = "hide_presence";
User.OnlyShowFriendNotificationsKey = "friend_only_notification";

User.GamerScoreKey = "gamerscore";
User.LevelNumberKey = "level_position";
User.LevelNameKey = "level_name";
User.CurrentLevelScoreKey = "level_points";
User.NextLevelScoreKey = "level_next_points";

// properties that are not returned in sparse search results
User.NonSparseKeys = [User.PhotoKey, User.EmailAddressKey,
User.EmailHashKey, User.PhoneNumberKey, User.PasswordKey,
User.FirstNameKey, User.LastNameKey, User.PrivacyKey,
User.NewBuddyKey, User.CapabilitiesKey, User.HidePresenceKey,
User.OnlyShowFriendNotificationsKey, User.GamerScoreKey,
User.LevelNumberKey, User.LevelNameKey, User.CurrentLevelScoreKey,
User.NextLevelScoreKey, User.GamesKey];


/**
* Retrieves the user corresponding to the <code>userID</code> parameter.
* @name Social.US.User.getUserWithID
* @public
* @static
* @function
* 
* @param {String} userID The ID for the user.
* @param {Function} cb The callback function if an error occurs.
* <br/> 
* <b>Callback Example:</b><br/>
* <pre class="code">function(error, user){
* &nbsp;&nbsp;  if(!user) {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
* &nbsp;&nbsp;  } else {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var userWithID = user;
* &nbsp;&nbsp;  }
* }
* </pre>
* @status iOS, Android, Test, iOSTested, AndroidTested
*/	
User.getUserWithID = function(userID, cb){
	Dispatcher.callClassMethodOnRemoteObject(User, "getUserWithID", [userID, cb]);
};

/**
* Retrieves the user corresponding to the <code>gamertag</code> parameter.
* @name Social.US.User.getUserWithGamertag
* @public
* @static
* @function
* 
* @param {String} gamertag The user's gamertag.
* @param {Function} cb The callback function if an error occurs.
* <br/> 
* <b>Callback Example:</b><br/>
* <pre class="code">function(error, user){
* &nbsp;&nbsp;  if(!user) {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
* &nbsp;&nbsp;  } else {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var userWithGamertag = user;
* &nbsp;&nbsp;  }
* }
* </pre>
* @status iOS, Android, Test, iOSTested, AndroidTested
*/	
User.getUserWithGamertag = function(gamertag, cb){
	Dispatcher.callClassMethodOnRemoteObject(User, "getUserWithGamertag", [gamertag, cb]);
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Game'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Game'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Game'] = exports; var DataModelR = require('NGCore/Client/Social/US/Models/DataModel');
var OrderedList = require('NGCore/Client/Social/US/Models/OrderedList').OrderedList;
var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;

/**
 * <code>Game</code> objects identify a game and its properties.
 * Game properties include: 
 * <div class="ul">
 * <li><code>name</code></li>
 * <li><code>publisher</code></li>
 * <li><code>category</code></li>
 * <li><code>featured</code></li>
 * <li><code>numberOfLeaderboards</code></li> 
 * <li><code>numberOfAchievements</code></li>
 * <li><code>masterProductID</code></li>
 * <li><code>iconURL</code></li>
 * <li><code>AppStoreURL</code></li>
 * <li><code>feedURL</code></li>
 * <li><code>catalogURL</code></li>
 * </div>
 * <code>Game</code> objects provide static functions to return all games in a catalog or games associated to a user profile.
 * 
 * @class 
 * @name Social.US.Game
 * @augments Social.US.DataModel
 */
var Game = exports.Game = DataModelR.DataModel.subclass({
	classname: "Game",
	
	
	 //Game is a subclass of data model, and the getter/setter methods are generated by defineSetterCallbacks. The following
	 //comments document the generated methods.
	 /**
	 * The game name. Read-only.
	 * @name Social.US.Game.name
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The publisher name. Read-only.
	 * @name Social.US.Game.publisher
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The game category name. Read-only.
	 * @name Social.US.Game.category
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * Whether the game is featured. Read-only.
	 * @name Social.US.Game.featured
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The number of leaderboards for the game. Read-only.
	 * @name Social.US.Game.numberOfLeaderboards
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The number of achievements. Read-only.
	 * @name Social.US.Game.numberOfAchievements
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The master product ID. Read-only.
	 * @name Social.US.Game.masterProductID
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A URL to the icon for a game. Read-only.
	 * @name Social.US.Game.iconURL
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A URL to the store or marketplace for a game. Read-only.
	 * @name Social.US.Game.appStoreURL
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * A URL to the RSS feed for a game. Read-only.
	 * @name Social.US.Game.feedURL
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * Sets a catalog URL for the catalog of game items. Read-only.
	 * @name Social.US.Game.catalogURL
	 * @field
	 * @private
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	properties: [
		// public
		"name",
		"publisher",
		"category",
		"numberOfLeaderboards",
		"iconURL",
		
		// private
		"numberOfAchievements",
		"featured",
		"masterProductID",
		"appStoreURL",
		"feedURL",
		"catalogURL",
		"description",
		"phone_screenshot_urls",
		"ngcore_url"
	]
});

/**
 * Returns an ordered list interface to the Mobage game catalog.
 * 
 * @name Social.US.Game.getAllGamesList
 * @function
 * @private 
 * @static
 *
 * @returns {Social.US.OrderedList} An ordered list interface to the catalog of games.
 * @see Social.US.OrderedList
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Game.getAllGamesList = function(){
		
	return OrderedList.getClassPublicInterface(Game, "getAllGamesList", "_allGamesInterface");
};

/**
 * Returns the current game. 
 *
 * @name Social.US.Game.getCurrentGame
 * @function
 * @public 
 * @static
 *
 * @param {Function} cb The callback function returns the current game or an error code and description.
 * <br/> 
 * <b>Callback Example:</b><br/>
 * <pre class="code">function(error, game){
 * &nbsp;&nbsp; if(!game){
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
 * &nbsp;&nbsp;} else {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var currentGame = game;
 * &nbsp;&nbsp;}
 * }
 * </pre>
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Game.getCurrentGame = function(cb){
	Dispatcher.callClassMethodOnRemoteObject(Game, "getCurrentGame", [cb]);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Leaderboard'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Leaderboard'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Leaderboard'] = exports; var DataModelR = require('NGCore/Client/Social/US/Models/DataModel');
var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;
var OrderedList = require('NGCore/Client/Social/US/Models/OrderedList').OrderedList;

/**
 * <code>Leaderboard</code> objects enable the current user to get friend scores, top scores, and submit a score.
 * To return a leaderboard, you must set up at least one leaderboard for your game in the Mobabe Sandbox or Production environment.
 * @class 
 * @name Social.US.Leaderboard
 * @augments Social.US.DataModel
 */
var Leaderboard = exports.Leaderboard = DataModelR.DataModel.subclass({

	 
	classname: "Leaderboard",
	properties: [
	"level",
	"title",
	"game",
	"iconURL"
	],

	
	/** 
	 * @constructs Constructs a <code>Leaderboard</code> object identified by the record ID. 
	 * @private
	 *
	 * @param {Type} $super A reference to the DataModel superclass.
	 * @param {String} recordId The record ID of the object.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	initialize: function($super, recordID){
		$super(recordID);
		NgLogD("Leaderboard Public! " + recordID + " " + this.recordID);
	},
	
	
	/**
	* Submits a score to the leaderboard.
	*
	* @name Social.US.Leaderboard.submitScore
	* @function
	* @public
	*
	* @param {Numeric} points The score points. If <code>null</code> or <code>undefined</code>, the callback error is "No score."
	* @param {Function} cb The callback function.
	* <br/> 
    * <b>Callback Example:</b><br/>
    * <pre class='code'>function(error, score){
    * &nbsp;&nbsp;  if(error) {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
    * &nbsp;&nbsp;  } else {
    * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var setScore = score;
    * }
    * </pre>
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */
	submitScore: function(points, cb){
		Dispatcher.callMethodOnRemoteObject(this, "submitScoreWithPoints", [points, cb]);
	},	
	
	/**
	* Returns an <code>OrderedList</code> with the user's score and the highest scores.
	* 
	* @name Social.US.Leaderboard.getTopScoresList
	* @function
	* @public
	*
	* @return {Social.US.OrderedList} The list of highest scores.
	* @see Social.US.OrderedList
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/		
	getTopScoresList: function(){
		return OrderedList.getObjectPublicInterface(this, "getTopScoresList", "_leaderboardTopScoresInterface");
	},
	
	/**
	* Returns an <code>OrderedList</code> of scores for the user's friends.
	* 
	* @name Social.US.Leaderboard.getFriendsScoresList
	* @function
	* @public
	*
	* @return {Social.US.OrderedList} The list of scores for the user's friends.
	* @see Social.US.OrderedList
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/		
	getFriendsScoresList: function(){
		return OrderedList.getObjectPublicInterface(this, "getFriendsScoresList", "_leaderboardFriendsScoresInterface");
	}

	 /**
	 * The user's level in the game. Read-only.
	 * @name Social.US.Leaderboard.level
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * The leaderboard title. Read-only.
	 * @name Social.US.Leaderboard.title
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */

	 /**
	 * The game name. Read-only.
	 * @name Social.US.Leaderboard.game
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	 /**
	 * A URL to the leaderboard icon. Read-only.
	 * @name Social.US.Leaderboard.iconURL
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
		 
});

/**
* Returns the leaderboard(s) for the current game.
* To return a leaderboard, you must set up at least one leaderboard for your game in the Mobabe Sandbox or Production environment.
*
* @name Social.US.Leaderboard.getLeaderboards
* @function
* @public
* @static
*
* @param cb Retrieves the leaderboard(s) for the current game. If an error occurs, returns an error code and error description.
* <br/> 
* <b>Callback Example:</b><br/>
* <pre class='code'>function(error, leaderboards){
*     if(error) {
*          var errorCode = error.errorCode;
*          var errorDesc = error.description;
*     } else {
*          var retrievedLeaderboards = leaderboards;
* }
* </pre>
* @status iOS, Android, Test, iOSTested, AndroidTested
*/
Leaderboard.getLeaderboards = function(cb){
	Dispatcher.callClassMethodOnRemoteObject(Leaderboard, "getLeaderboards", [cb]);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Score'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Score'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Score'] = exports; var DataModel 	  = require('NGCore/Client/Social/US/Models/DataModel').DataModel;

/**
 * <code>Score</code> constructs objects that reflect a user's score for the current game.
 * @class 
 * @name Social.US.Score
 * @augments Social.US.DataModel
 */
var Score = exports.Score = DataModel.subclass({
	
    classname: "Score",
    	
	 /**
	 * A user's score. Read-only.
	 * @name Social.US.Score.score
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 

	 /**
	 * The score as formatted for display. Read-only.
	 * @name Social.US.Score.displayScore
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	
	 /**
	 * The user's rank. Read-only.
	 * @name Social.US.Score.rank
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	 
	
	 /**
	 * The user's level in the current game. Read-only.
	 * @name Social.US.Score.level
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
    
	 /**
	 * A <code>Social.US.User</code> reference to the user associated to the score. Read-only.
	 * @name Social.US.Score.user
	 * @field
	 * @public
     * @see Social.US.User
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */    
	 
    properties: [
	"points",
	"displayScore",
	"rank",
	"level",
	"user"
	]
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/AppData'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/AppData'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/AppData'] = exports; var DataModelReq = require('NGCore/Client/Social/US/Models/DataModel');
var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;

/**
 * <code>AppData</code> constructs objects that get and set a user's properties, 
 * and provides permissions for sharing the user's properties with other users.
 * @class 
 * @name Social.US.AppData
 * @see Social.Common.Appdata for additional Mobage persistence facilities;
 * @see Storage.KeyValue for additional ngCore persistence facilities; and,
 * @see Storage.FileSystem for additional ngCore persistence facilities. 
 */
var AppData = exports.AppData = DataModelReq.DataModel.subclass({
		
	classname: "AppData",
	properties: [
		"data",
		"key",
		"user",
		"permissions"
	],
	
	/**
	 * The application data for the user. Limited to 1024 bytes.
	 * 
	 * @name Social.US.AppData.data
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	/**
	 * The key describing the application data. Limited to 32 bytes.
	 * 
	 * @name Social.US.AppData.key
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	/**
	 * The name of the user who owns the data.
	 * 
	 * @name Social.US.AppData.name
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	/**
	 * The permissions for the application data.<br/><br/>
	 * <code>Private</code>: only the user can read and write the user data.<br/>
	 * <code>FriendsReadOnly</code>: friends can read the user data, but cannot write it.<br/>
	 * <code>PublicReadOnly</code>: all users can read the user data, but cannot write it.     
	 * 
	 * @name Social.US.AppData.permissions
	 * @field
	 * @public
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	
	
	
    /**
     * The default constructor.
     * @constructs 
     * @name Social.US.AppData.initialize
     * @private
     *
     * @param recordID A unique ID for the <code>AppData</code> object.
     *
     * @augments Social.US.DataModel
     * @status iOS, Android, Test, iOSTested, AndroidTested
     */	
    initialize: function($super, recordID) {
        $super(recordID);
    }
});

/**
* Takes a user reference and returns key/value pairs of the user for the current game.
* @name Social.US.AppData.getKeysForUser
* @function
* @public
* @static
*
* @param {Social.US.User} user A reference to the user.
* @param {Function} callback The callback function returns key/value pairs for the user and/or and error code and description.
* <br/> 
* <b>Callback Example:</b><br/>
* <pre class="code">var entries = {"key1": "value1", "key2": "value2"};
* ...
* function(error, entries){
* &nbsp;&nbsp;   if (error){
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorCode = error.errorCode;
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorDesc = error.description;
* &nbsp;&nbsp;   } else {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var retrievedEntries = entries;
* &nbsp;&nbsp;   }
* }
* </pre>
* @example
* var user = Social.US.Session.getCurrentSession().user();
* var AppData = Social.US.AppData;
* var retrievedEntries = null;
* AppData.getKeysForUser(user, function(error, entries){
*				retrievedEntries = entries;
*			});
* @status iOS, Android, Test, iOSTested, AndroidTested
*/
AppData.getKeysForUser = function(user, cb){
	Dispatcher.callClassMethodOnRemoteObject(AppData, "getKeysForUser", [user, cb]);
};

/**
* Takes a user, a key (the name of the key for a name/value pair) and returns the key/value pair for the user for the current game.
* @name Social.US.AppData.getDataForUserWithKey
* @function
* @public
* @static
*
* @param {Social.US.User} user A reference to the user.
* @param {String} key The name of the key.
* @param {Function} callback Retrieves the key/value pair for the user and/or an error code and description.
* <br/> 
* <b>Callback Example:</b><br/>
* <pre class="code">function(error, response){
* &nbsp;&nbsp;   if (error){
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorCode = error.errorCode;
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var errorDesc = error.description;
* &nbsp;&nbsp;   } else {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       var fetchedData = response.data;
* &nbsp;&nbsp;   }
* }
* </pre>
* @example
* var user = Social.US.Session.getCurrentSession().user();
* var AData = Social.US.AppData;
* var errorCode = null;
* var errorDesc = null;
* var fetchedData = null;
* AData.getDataForUserWithKey( user, 
*                              key, 
*                              function(error, response){
*                                   errorCode = error.errorCode;
*                                   errorDesc = error.description;
*                                   fetchedData = response.data;
*                              }
*                            );
* @status iOS, Android, Test, iOSTested, AndroidTested
*/
AppData.getDataForUserWithKey = function(user, key, cb){
	Dispatcher.callClassMethodOnRemoteObject(AppData, "getDataForUserWithKey", [user, key, cb]);
};


/**
* Takes data, a user, a key (the name of the key for a name/value pair) and permissions for the data and sets the application data for the user.
* <b>Note:</b> Limited to 30 key/value pairs per user, per game. 
* Maximum key name limited to 32 bytes. Maximum value limited to 1,024 bytes.
* To use key/value pairs without the foregoing constraints, use <code>Storage.KeyValue</code>
* in ngCore.
* @name Social.US.AppData.setDataForUserWithKeyAndPermissions
* @function
* @public
* @static 
*
* @param {String} data The data to set.
* @param {Social.US.User} user A reference to the user.
* @param {String} key The name of the key.
* @param {Social.US.AppData.Permissions} permission The permissions for the data.
* @param {Function} cb The callback function if there is an error with the parameters.
* <br/> 
* <b>Callback Example:</b><br/>
* <pre class="code">function(error){
* &nbsp;&nbsp;  if(!response) {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorCode = error.errorCode;
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var errorDesc = error.description;
* &nbsp;&nbsp;   } else {
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    var responseValues = response;
* &nbsp;&nbsp;   }
* }
* </pre>
* @example
* var user = Social.US.Session.getCurrentSession().user();
* var data = "some data";
* var key = "some key";
* var errorCode = null;
* var errorDesc = null;
* var result = null; 
*
* var AData = Social.US.AppData;
* 
* AData.setDataForUserWithKeyAndPermissions(data, 
*                                           user, 
*                                           key, 
*                                           AppData.Permissions.Private, 
*                                           function(error, response){
*                                             errorCode = error.errorCode;
*                                             errorDesc = error.description;
*                                             result = response;
*                                           }
*                                         );
* @status iOS, Android, Test, iOSTested, AndroidTested
* @see Social.US.AppData.Permissions for permission settings;
* @see Social.Common.Appdata for additional Mobage persistence facilities;
* @see Storage.KeyValue for additional ngCore persistence facilities; and,
* @see Storage.FileSystem for additional ngCore persistence facilities.
*/
AppData.setDataForUserWithKeyAndPermissions = function(data, user, key, permissions, cb){
	Dispatcher.callClassMethodOnRemoteObject(AppData, "setDataForUserWithKeyAndPermissions", [data, user, key, permissions, cb]);
};



/**
* Defines permissions for viewing user data.<br/><br/>
* <code>Private</code>: only the user can read and write the user data.<br/>
* <code>FriendsReadOnly</code>: friends can read the user data, but cannot write it.<br/>
* <code>PublicReadOnly</code>: all users can read the user data, but cannot write it. 
* @name Social.US.AppData.Permissions
* @field
* @public
* @status iOS, Android, Test, iOSTested, AndroidTested
*/
AppData.Permissions = {
	Private: 0,
	FriendsReadOnly: 1,
	PublicReadOnly: 2
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/Cache'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Cache'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/Cache'] = exports; var Class = require('NGCore/Client/Core/Class').Class;
var SocialR = require('NGCore/Client/Social');

/**
 * <code>Cache</code> provides caching for a user's objects residing in the local interpreter.
 * @class 
 * @name Social.US.Cache
 * @private
 */
var Cache = exports.Cache = Class.subclass({


	classname: "Cache",
	inMemoryObjects: {},
	caches: {},
	
	/**
	 * Initializes a cache object upon instantiation. 
	 * @name Social.US.Cache.initialize
	 * @constructs
	 * @private
	 */			
	initialize: function(){
	},

	
	/**
	* Takes a classname and a unique record ID and returns the object or <code>null</code> if it doesn't find the object.
	*
	* @name Social.US.Cache.getObjectWithRecordID
	* @function
	* @private
	*
	* @param {String} classname The name of the class.
	* @param {Number} recordID The object ID.
	*
	* @return Returns the object corresponding to the <code>recordID</code> parameter or <code>null</code> if it doesn't find the object.
	*/
	getObjectWithRecordID: function(classname, recordID){
		var category = this.inMemoryObjects[classname];
		if(category){
			return category[recordID] || null;
		}else{
			return null;
		}
	},
	
	/**
	* Takes an object and adds it to the cache.
	* <code>addObject()</code> takes an object, ensures that it is not already in the cache, and adds it to the cache.
	*
	* @name Social.US.Cache.addObject
	* @function
	* @private
	*	
	* @param {Object} obj The object to add to the cache.
	* @return Returns the record ID of the object added to the cache.
	*/	
	addObject: function(obj){
		var classname = obj._classname();
		var category = this.inMemoryObjects[classname];
		if(!category){
			category = {};
			this.inMemoryObjects[classname] = category;
		}

		var object = category[obj.recordID];
		if(object){
			return object;
		}else{
			category[obj.recordID] = obj;
			return obj;
		}
	},
	
	/**
	* Takes an object reference and removes the object from the cache.
	* 
	* @name Social.US.Cache.removeObject
	* @function
	* @private
	*	
	* @param {Object} obj The object to remove from the cache.
	*/	
	removeObject: function(obj){
		var classname = obj._classname();
		var category = this.inMemoryObjects[classname];
		if(category){
			delete category[obj.recordID]; // ZOMG THE DELETE OPERATOR
		}
	},
	
	/**
	* Takes an object reference and returns whether the object is in the cache.
	* 
	* @name Social.US.Cache.isObjectCached
	* @function
	* @private
	*	
	* @param {Object} obj The object to select in the cache.
	*
	* @return Returns <code>true</true> if the object is in the cache; otherwise, it returns <code>false</code>.
	*/		
	isObjectCached: function(obj){
		var classname = obj._classname();
		var category = this.inMemoryObjects[classname];
		return (category && (category[obj.recordID] == obj));
	},
	
	
	saveCache: function(){
		
	},
	
	
	loadCache: function(){
		
	},
	
	/**
	* Takes a JSON array of objects and loads them into the cache.
	*
	* @name Social.US.Cache.loadCacheFromJSONArray
	* @function
	* @private
	*
	* @param {JSON} jsonArray The JSON object array to load into the cache.
	* @param {function} cb <code>loadCacheFromJSONArray()</code> takes an optional callback function.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <code>function(error){<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;<br/>
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;<br/>
	* &nbsp;&nbsp;   }<br/>
	* </code>
	*/			
	loadCacheFromJSONArray: function(jsonArray, cb){
		var objects = [];
        
		for(var idx = 0; idx < jsonArray.length; idx++){
			var hash = jsonArray[idx];
			if(hash && hash.hasOwnProperty("classname") && hash.hasOwnProperty("recordID")){
				var theClassname = hash.classname;
				var theClass = SocialR.Social.US[theClassname];
				var theRecordID = hash.recordID;
				if(theClass && theRecordID){
					var theInstance = this.getObjectWithRecordID(theClassname, theRecordID);
					if(!theInstance){
						theInstance = new theClass(theRecordID, {});
					}
        
					theInstance._deserializeFromHash(hash);
					this.addObject(theInstance);
				}
			}
		}
        
		cb(null, this);
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Data/Session'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Session'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Session'] = exports; var CoreReq = require('NGCore/Client/Core');
//var UserReq = require('../Models/User');
var MessageEmitterReq = require('NGCore/Client/Core/MessageEmitter');
var CacheReq = require('NGCore/Client/Social/US/Models/Cache');
var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;

/**
 * <code>Session</code> manages a user's game sessions.
 * @class 
 * @name Social.US.Session
 */
var Session = exports.Session = MessageEmitterReq.MessageEmitter.subclass({
		
	classname: "Session",
	
	/**
	 * Constructs a session object.
	 * @name Social.US.Session.initialize
	 * @private
	 * @constructs 
	 */	
	initialize: function(gameData){
		if(gameData){
			this._loadSessionData(gameData);
		}
	},
	
	/**
	 * Loads the user's game data into the current session.
	 *
	 * @name Social.US.Session._loadSessionData
	 * @function
	 * @private
	 *
	 * @param {Type} gameData Takes game data and loads it into the current session.
	 */		
	_loadSessionData: function(gameData){
		this._appKey = gameData.appId || this._appKey || null;
		this._appVersion = gameData.appVersion || this._appVersion || null;
		this._platformVersion = gameData.platformVersion || this._platformVersion || "1.0";
		this._serverMode = gameData.serverMode || this._serverMode || null;

		this._user = (gameData.userID ? this.dataCache().getObjectWithRecordID("User", gameData.userID) : null);		
		this.emit({user: this._user});
	},
	
	/**
	 * Returns the cache for the current session. If a session cache does not exist, this call creates a new cache, loads it and returns it.
	 *
	 * @name Social.US.Session.dataCache
	 * @function
	 * @private
	 *
	 * @return {Social.US.Cache} The cache for the current session.
	 */			
	dataCache: function(){
		if(!this._cache){
			this._cache = new CacheReq.Cache();
			this._cache.loadCache(function(err){
				NgLogD("Loaded cache: " + err);
			});
		}
		return this._cache;
	},
	
	
	/**
	 * Returns the user for this session.
	 *
	 * @name Social.US.Session.user
	 * @function
	 * @public
	 *
	 * @return {Social.US.User} The user for the current session.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */					
	user: function(){
		return this._user;
	},
	
	

	// data you probably don't need
	/**
	 * Returns the name of the game for this session.
	 *
	 * @name Social.US.Session.appKey
	 * @function
	 * @public
	 *
	 * @return {String} The application name.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */						
	appKey: function(){
		return this._appKey;
	},
	
	/**
	 * Returns the version of the game for this session.	 
	 *
	 * @name Social.US.Session.appVersion
	 * @function
	 * @public
	 *
	 * @return {String} The application version.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	appVersion: function(){
		return this._appVersion;
	},
	
	/**
	 * Returns the server mode of the game for this session.
	 *
	 * @name Social.US.Session.serverMode
	 * @function
	 * @public
	 *
	 * @return {String} The server mode.
	 * <b>Note:</b> Valid settings for the server mode include:<br/>
	 * <ul>
	 * <li>staging</li>
	 * <li>integration</li>
	 * <li>sandbox</li>
	 * <li>production</li>
	 * <li>unknown</li>
	 * </ul>
	 * @see Social.US.Session.serverModes
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	serverMode: function(){
		return this._serverMode;
	},
	
	/**
	 * Returns the platform version of the game for this session.
	 *
	 * @name Social.US.Session.platformVersion
	 * @function
	 * @public
	 *
	 * @return {String} The platform version.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	platformVersion: function(){
		return this._platformVersion;
	},
	

	/**
	 * Takes a consumer key and retrieves the session tokens for the the consumer key.
	 *
	 * @name Social.US.Session.getSessionTokensForConsumerKey
	 * @function
	 * @public
	 * 
     * @param {String} consumerKey The consumer key.
	 * @param {Function} cb A callback that retrieves the session tokens for the consumer key. If an error occurs, returns an error code 
	 * and error description.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */	
	getSessionTokensForConsumerKey: function(consumerKey, cb){
		Dispatcher.callClassMethodOnRemoteObject("Session", ["getCurrentSession", "getSessionTokensForConsumerKey"], [[], [consumerKey, cb]]);
	}
});


/**
 * The session modes for the server. Session modes include:
 * <ul>
 * <li><code>staging</code></li>
 * <li><code>integration</code></li>
 * <li><code>sandbox</code></li>
 * <li><code>production</code></li>
 * <li><code>unknown</code></li>
 * </ul>
 * @name Social.US.Session.serverModes
 * @field
 * @public
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Session.serverModes = {
	staging: "staging",
	integration: "integration",
	partner: "sandbox",
	sandbox: "sandbox",
	production: "production",
	unknown: "unknown"
};

/**
 * Returns the current session.  
 * @name Social.US.Session.getCurrentSession
 * @function
 * @public 
 * @static
 *
 * @return {Social.US.Session} The current session.
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */	
Session.getCurrentSession = function(){
	return Session._currentSession;
};



Session._emitter = null;

/**
 * Adds a listener to the current session.
 *
 * @name Social.US.Session.addCurrentSessionListener
 * @function
 * @public
 * @static
 *  
 * @param {Core.MessageListener }listener The listener to add to the current session.
 * @param {Function} callback The callback function.
 * @param priority The priority for this <code>MessageListener</code>.
 *
 * @see Core.MessageListener
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Session.addCurrentSessionListener = function(listener, callback, priority){	
	if(!Session._emitter){
		Session._emitter = new MessageEmitterReq.MessageEmitter();
	}
	
	Session._emitter.addListener(listener, callback, priority);
};

/**
 * Removes the listener from the current session.
 *
 * @name Social.US.Session.removeCurrentSessionListener 
 * @function
 * @public 
 * @static
 *
 * @param {Core.MessageListener} listener The listener for the current session.
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
Session.removeCurrentSessionListener = function(listener){
	if(Session._emitter){
		Session._emitter.removeListener(listener);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Data/Dispatcher'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Dispatcher'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Data/Dispatcher'] = exports; var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

var Core = require('NGCore/Client/Core').Core;
var CacheR = require('NGCore/Client/Social/US/Models/Cache');

var SocialR = require('NGCore/Client/Social');
var SessionR = require('NGCore/Client/Social/US/Data/Session');

/**
 * <code>Dispatcher</code> objects know about <code>DataModel</code> objects and can "push" <code>DataModel</code> objects between interpreters.
 * <code>Dispatcher</code> objects can find classes and specific instances of objects, and may invoke their functions.
 * <code>Dispatcher</code> objects also provide a series of convenience functions to facilitate communication between interpreters.
 * @class 
 * @name Social.US.Dispatcher
 * @private
 */
var Dispatcher = exports.Dispatcher = {
				
	classname: "Dispatcher",
	callbackUIDCounter: 0,
	callbacks: {
		"-2": {},
		"-1": {}
	},
	
	/**
	 * Returns the data cache for the current session.
	 * @name Social.US.Dispatcher.cache
	 * @function
	 * @private
	 *
	 * @return {Social.US.Cache} The data cache for the current session.
	 * @see Social.US.Cache
	 */		
	cache: function(){		
		try {		
			return SessionR.Session.getCurrentSession().dataCache();
		}
		catch (err) {
			NgLogD("Mobage/Dispatcher/cache-Warning: cannot get cache. NOTE: This may be expected behavior if early on in initialization. Err=" 
				+ err);

			return null;
		}
	},
	
	
	/**
	 * Gets the current session and loads session data.
	 * If there is no current session, <code>receiveSession()</code> creates a new session.
	 *	 
	 * @name Social.US.Dispatcher.receiveSession
	 * @function
	 * @private
	 *
	 * @param {Type} command Takes a command, which may include the platform version, server mode, application name and application version. 
	 */		
	receiveSession: function(command){		
		var session = SessionR.Session.getCurrentSession();
		if(!session){
			session = new SessionR.Session();
			SessionR.Session._currentSession = session;
		}
		
		var userData = command.data.userData;
		if(userData){
			// the User object will be cached implicitly, then loaded in _loadSessionData
			Dispatcher.receiveObject({data: userData});
		}
		
		session._loadSessionData(command.data);
		
		if(SessionR.Session._emitter){
			SessionR.Session._emitter.emit({session: session});
		}
	},
	
	// DataModel communication
	/**
	 * Finds a particular instance of an object in the local interpreter and calls a method on the object.
	 *	 
	 * @name Social.US.Dispatcher.callMethodOnLocalObject
	 * @function
	 * @private
	 *
	 * @param {Command} command Takes a command object that identifies the class name of the object, 
     * its record ID, the method name to call, and any parameters for the method.
	 * The command object takes an optional callback and <code>callMethodOnLocalObject()</code> returns returns the result 
     * and/or any error code and description to the callback function.
	 */		
	callMethodOnLocalObject: function(command){		
		var recordID = command.recordID;
		var classname = command.classname;
		
		var object = Dispatcher.cache().getObjectWithRecordID(classname, recordID);
		if(object){
			var methodName = command.methodName;

			var error = false;
			var args;
			var retVal;
			if(methodName instanceof Array) {
				var methodOwner = object;
				for(var idx = 0; idx < methodName.length; idx++) {
					if(typeof methodOwner[methodName[idx]] == "function") {
						args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments[idx] || []);
						retVal = methodOwner[methodName[idx]].apply(methodOwner, args);
						methodOwner = retVal;						
					}
					else {
						error = true;
						break;
					}
				}
			}
			else {
				if(typeof object[methodName] == "function") {
					args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments || []);
					retVal = object[methodName].apply(object, args);
				}
				else {
					error = true;
				}
			}
			
			if(error) {
				NgLogD("ERROR: Invalid methods for calling on local object: " + command.recordID + " " + methodName);
			}
			else if(command.callback){
				var callback = Dispatcher.convertFunctionFromJSON({callbackUID: command.callback});
				if(callback){
					callback(retVal);
				}
			}
		}
	},
	
	
	/**
	 * Finds a particular instance of an object in a remote interpreter and calls a method on the remote object.
	 *	 
	 * @name Social.US.Dispatcher.callMethodOnRemoteObject
 	 * @function
 	 * @private
 	 *
	 * @param {Number} object The object reference (i.e., typically the keyword 'this').
	 * @param {String} method The method name to call.
	 * @param {Array} args An array of parameters for the method, including other <code>DataModel</code> objects or functions.
	 * @param {Function} cb Returns the result and/or any error code and description to the callback function.
	 *
	 * <b>Note:</b> If the target method wants a callback as one/more of its arguments, supply it as an element in the argument array, <b>NOT</b> as the fourth parameter.
	 */			
	callMethodOnRemoteObject: function(object, method, args, cb){		
		if(!object || !method){
			NgLogD("Public.Dispatcher.callMethodOnRemoteObject - bailing");
			if(cb){
				cb();
			}
			return;
		}

		args = Dispatcher.convertArgumentsArrayToJSON(args || []);
		
		var cmd = {
			apiURL: "US.Dispatcher.callMethodOnLocalObject",
			recordID: object.recordID,
			classname: object._classname(),
			methodName: method,
			arguments: args,
			callback: Dispatcher.convertFunctionToJSON(cb)
		};
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Calls a static method on a class in the local interpreter.
	 *	 
	 * @name Social.US.Dispatcher.callClassMethodOnLocalObject	
	 * @function
	 * @private
	 *
	 * @param {Command} command Takes a command object that identifies the class name of the object, the method name to call, and any parameters for the method.
	 * The command parameter takes an optional callback function and <code>callMethodOnLocalObject()</code> returns returns the result and/or any error code and description to the callback function.
	 */		
	callClassMethodOnLocalObject: function(command){		
		Dispatcher.beginBatching();
		
		var classname = command.classname;
		var methodName = command.methodName;
		if(classname && methodName){
			var theClass = SocialR.Social.US[classname];
			if(!theClass){
				theClass = SocialR.Social.US.Service[classname];
			}
			
			if(theClass){
				var error = false;
				var args;
				var retVal;
				if(methodName instanceof Array) {
					var methodOwner = theClass;
					for(var idx = 0; idx < methodName.length; idx++) {
						if(typeof methodOwner[methodName[idx]] == "function") {
							args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments[idx] || []);
							retVal = methodOwner[methodName[idx]].apply(methodOwner, args);
							methodOwner = retVal;						
						}
						else {
							error = true;
							break;
						}
					}
				}
				else {
					if(typeof theClass[methodName] == "function") {
						args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments || []);
						retVal = theClass[methodName].apply(theClass, args);
					}
					else {
						error = true;
					}
				}
				
				if(error) {
					NgLogD("ERROR: Invalid methods for calling on local Class: " + classname + " " + methodName);
				}
				else if(command.callback){
					var callback = Dispatcher.convertFunctionFromJSON({callbackUID: command.callback});
					if(callback){
						callback(retVal);
					}
				}				
			}
		}
		
		Dispatcher.endBatching();
	},

	/**
	 * Calls a static method on a class in a remote interpreter.
	 *	 
	 * @name Social.US.Dispatcher.callClassMethodOnRemoteObject
	 * @function
	 * @private
	 *
	 * @param {String} theClass The name of the class.
	 * @param {String} method The method name to call.
	 * @param {Array} args An array of parameters for the method.
	 * @param {Function} cb <code>callClassMethodOnRemoteObject()</code> returns returns the result and/or any error code and description to the callback function.
	 * 
	 */			
	callClassMethodOnRemoteObject: function(theClass, methodName, args, cb){		
		if(!theClass || !methodName){
			NgLogD("Public.Dispatcher.callClassMethodOnRemoteObject - bailing");
			if(cb){
				cb();
			}
			return;
		}

		args = Dispatcher.convertArgumentsArrayToJSON(args || []);
		
		var cmd = {
			apiURL: "US.Dispatcher.callClassMethodOnLocalObject",
			classname: (theClass.classname ? theClass.classname : theClass),
			methodName: methodName,
			arguments: args,
			callback: (cb ? Dispatcher.convertFunctionToJSON(cb) : null)
		};
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},


	// callback communication

	/**
  	 * Takes a callback and sends it to a remote interpreter.
	 *	 
	 * @name Social.US.Dispatcher.sendCallbackToRemote
	 * @function
	 * @private
	 *
	 * @param {String} callbackUID The user ID of the user receiving the callback.
	 * @param {Array} args An array of parameters for the callback function.
	 */		
	sendCallbackToRemote: function(callbackUID, args){		
		args = Dispatcher.convertArgumentsArrayToJSON(args || []);
		
		var cmd = {
			apiURL: "US.Dispatcher.receiveCallbackFromRemote",
			callbackUID: callbackUID,
			arguments: args,
			zone: GSGlobals.getRouterInstance().zone
		};

		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Receives a callback from a remote interpreter and provides the arguments to the local callback function.
	 *	 
	 * @name Social.US.Dispatcher.receiveCallbackFromRemote
	 * @function
	 * @private
	 *
	 * @param {Type} command A JSON object containing the user ID of the user receiving the callback and the callback arguments array.
	 */			
	receiveCallbackFromRemote: function(command){
		var callback = Dispatcher.callbacks[GSGlobals.getRouterInstance().zone][command.callbackUID]; //Dispatcher.convertFunctionFromJSON(command);
		if(!callback){
			return;
		}

		var args = Dispatcher.convertArgumentsArrayFromJSON(command.arguments || []);
		
		callback.apply(callback, args);
	},
	

	// convenience functions to facilitate communication of all objects
	
	/**
	 * Parses a JSON array of function parameters and returns an array of function parameters.
	 *	 
	 * @name Social.US.Dispatcher.convertArgumentsArrayFromJSON
	 * @function
	 * @private
	 * 
	 * @param {Array} args An array of function parameters in JSON format.
	 * @return {Array} Returns an array of function parameters.
	 */	
	convertArgumentsArrayFromJSON: function(args){		
		var newArgs = [];
		for(var idx=0; idx < args.length; idx++){
			var arg = args[idx];
			
			if(arg && ((arg.recordID && arg.classname) || arg instanceof Array)){
				newArgs[idx] = Dispatcher.convertModelObjectFromJSON(arg);
			}else if(arg && arg.callbackUID){
				newArgs[idx] = Dispatcher.convertFunctionFromJSON(arg);
			}else{
				newArgs[idx] = arg;
			}
		}
		return newArgs;
	},

	/**
	 * Parses an array of function parameters and returns the array in JSON format.	 
	 * @name Social.US.Dispatcher.convertArgumentsArrayToJSON
	 * @function
	 * @private
	 *
	 * @param {Array} args An array of function parameters.
	 * 
	 * @returns {JSON} An array of function parameters in JSON format.
	 */
	convertArgumentsArrayToJSON: function(args){		
		var newArgs = [];
		for(var idx=0; idx < args.length; idx++){
			var arg = args[idx];
			if(arg && (arg.recordID && arg._classname && typeof arg._classname == "function" && arg._classname())){
				Dispatcher.sendObjectImmediately(arg);

				arg = Dispatcher.convertModelObjectToJSON(arg);
				newArgs[idx] = arg;
			}else if(arg && arg instanceof Array){
				arg = Dispatcher.convertArgumentsArrayToJSON(arg);
				newArgs[idx] = arg;
			}else if(arg && typeof arg == "function"){
				newArgs[idx] = Dispatcher.convertFunctionToJSON(arg);
			}else{
				newArgs[idx] = arg;
			}
		}
		return newArgs;
	},

	// convenience functions to facilitate communication of DataModel objects
	
	/**
	 * Takes a <code>DataModel</code> object and returns the object in JSON format.
	 *	 
	 * @name Social.US.Dispatcher.convertModelObjectToJSON
	 * @function
	 * @private
	 * 
	 * @param {Social.Models.DataModel} object A reference to a <code>DataModel</code> object (i.e., typically a subclass of <code>Models.DataModel</code>).
	 *
	 * @return {JSON} A <code>DataModel</code> object in JSON format.
	 */		
	convertModelObjectToJSON: function(object){		
		if(object && object.recordID && object._classname()){
			object = {
				classname: object._classname(),
				recordID:  object.recordID
			};
		}
		return object;
	},


	/**
	 * Takes a <code>DataModel</code> object in JSON format and returns the object.
	 *	 
	 * @name Social.US.Dispatcher.convertModelObjectFromJSON
 	 * @function
 	 * @private
 	 *
	 * @param {JSON} json A <code>DataModel</code> object in JSON format.
	 * 
	 * @return {Social.US.DataModel} A <code>DataModel</code> object.
	 */		
	convertModelObjectFromJSON: function(json){		
		var object = json;
		if(json.recordID && json.classname){
			var obj = Dispatcher.cache().getObjectWithRecordID(json.classname, json.recordID);
			if(obj){
				object = obj;
				if(json.data){
					object._deserializeFromHash(json.data);
				}
			}
		}else if(json instanceof Array){
			for(var idx=0; idx < json.length; idx++){
				var arg = json[idx];
				json[idx] = Dispatcher.convertModelObjectFromJSON(arg);
			}
		}
		return object;
	},

	// convenience functions to facilitate communication of functions
	
	/**
	 * Takes a function and returns the function in JSON format.
	 *	 
	 * @name Social.US.Dispatcher.convertFunctionToJSON
	 * @function
	 * @private	 
	 * 
	 * @param {function} The function to conver to JSON format.
	 * 
	 * @return {JSON} Returns a function in JSON format.
	 */		
	convertFunctionToJSON: function(fn){		
		if(fn && typeof fn == "function"){
			
			var callbackUID = ++Dispatcher.callbackUIDCounter;
			var zone = GSGlobals.getRouterInstance().zone;
			Dispatcher.callbacks[zone][callbackUID] = fn;

			fn = {
				callbackUID: callbackUID,
				zone: zone
			};
		}
		return fn;
	},


	
	/**
 	 * Takes a function expressed in JSON format and returns the function.
	 * @name Social.US.Dispatcher.convertFunctionFromJSON
	 * @function
	 * @private
	 * 
	 * @param {JSON} A function in JSON format.
	 * 
	 * @return {Function} Returns a function.
	 */	
	convertFunctionFromJSON: function(json){		
		var fn = json;
		var callbackUID = fn.callbackUID;
		var zone = fn.zone;
		
		if(callbackUID){
			var callback = Dispatcher.callbacks[zone][callbackUID];
			if(callback){
				fn = callback;
				delete Dispatcher.callbacks[zone][callbackUID];
			}else{
				fn = Dispatcher.generateCallbackForUID(callbackUID);
			}
		}
		return fn;
	},


	
	/**
	 * Takes a user ID and sends the callback to the remote interpreter.
	 *
	 * @name Social.US.Dispatcher.generateCallbackForUID
	 * @function
	 * @private
	 *	 
	 * @param {Number} The user ID.
	 * @return {Function} Returns a callback to the remote interpreter.
	 */	
	generateCallbackForUID: function(uid){		
		if(uid.callbackUID){
			uid = uid.callbackUID;
		}
		
		return function(){
			Dispatcher.sendCallbackToRemote(uid, arguments);
		};
	},
	
	
	// object sending and batching
	_batchCount: 0,
	_queuedObjects: [],
	
	/**
	 * <code>beginBatching()</code> increments the batch count.
	 * 
	 * @name Social.US.Dispatcher.
	 * @function
	 * @private
	 */	
	beginBatching: function(){		
		++Dispatcher._batchCount;
	},

	/**
	 * Decrements the batch count.
	 * Decrements the batch count and sends any objects remaining in the queue immediately.
	 *
	 * @name Social.US.Dispatcher.endBatching
	 * @function
	 * @private
	 */	
	endBatching: function(){		
		if((--Dispatcher._batchCount) === 0){
			for(var objKey in Dispatcher._queuedObjects){
				var obj = Dispatcher._queuedObjects[objKey];
				Dispatcher._queuedObjects[objKey] = undefined;
				Dispatcher.sendObjectImmediately(obj);
			}
		}
	},

	/**
	 * Takes an object and adds it to a queue, which pushes the object to the remote interpreter.
	 *
	 * @name Social.US.Dispatcher.sendObject
	 * @function
	 * @private
	 */
	sendObject: function(obj){		
		if(Dispatcher._queuedObjects.indexOf(obj) == -1){
			Dispatcher.beginBatching();
			
			var key = "" + obj.classname + "---" + obj.recordID;
			Dispatcher._queuedObjects[key] = obj;
			
			Dispatcher.endBatching();
		}
	},

	/**
	 * Takes an object and pushes it to the remote interpreter immediately (i.e., bypassing the queue).
	 *
	 * @name Social.US.Dispatcher.sendObjectImmediately
	 * @function
	 * @private
	 */
	sendObjectImmediately: function(obj){		
		if(!obj){
			return;
		}
		
		var cmd = {
			apiURL: "US.Dispatcher.receiveObject",
			data:   obj._serializedHash()
		};
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Receives a serialized object from the remote interpreter, retrieves the local version of the same object from the cache, and deserializes the received object to the local object.
	 * If there is no local version of the received object, <code>receiveObject()</code> creates a local version and adds it to the cache; then, it deserializes the received object to the newly created local object.
	 *
	 * @name Social.US.Dispatcher.receiveObject
	 * @function
	 * @private
	 */
	receiveObject: function(command){		
		var data = command.data;
		var theRecordID  = data.recordID;
		var theClassname = data.classname;
		var theData      = data.data;
		
		if(theRecordID && theClassname && Dispatcher.cache()){
			var obj = Dispatcher.cache().getObjectWithRecordID(theClassname, theRecordID);
			if(!obj){
				var theClass = SocialR.Social.US[theClassname];
				obj = new theClass(theRecordID);
				
				Dispatcher.cache().addObject(obj);
			}

			// TODO disable emitting somehow
			if(theData){
				obj._deserializeFromHash(theData);
			}
		}
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Friends'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Friends'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Friends'] = exports; var RouterInited = require('NGCore/Client/Social/_Internal/RouterInit');
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;

var DataModelR = require('NGCore/Client/Social/US/Models/DataModel');
var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;

/**
 * @class 
 * @name Social.US.Service.Friends
 */
var Friends = exports.Friends = DataModelR.DataModel.subclass({
    classname: "Friends"
});

/**
 * Opens the "Find Friends" view.
 *
 * @name Social.US.Service.Friends.showFindFriends
 * @function
 * @public
 * @static
 *
 * @param selectedTab Takes an optional tab reference.
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */		
Friends.showFindFriends = function(selectedTab) {
		NgLogD("Public call showFindFriends");
	
		var cmd = {
			apiURL:"US.Service.Friends.showFindFriends"
		};
		
		if(selectedTab){
			cmd.data.tab = selectedTab;
		}
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
};

/**
 * Opens the "Friend Picker" view.
 * 
 * @name Social.US.Service.Friends.openFriendPicker
 * @function
 * @public 
 * @static
 * 
 * @param maxFriendsToPick The maximum number of friends to pick. <code>0</code> for unlimited.
 * @param {Function} callback Retrieves an array of picked users.
 * 
 * <br/> 
 * <b>Callback Example:</b><br/>
 * <pre class="code">function(error, pickedUsers){
 * &nbsp;&nbsp; if(error){
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
 * &nbsp;&nbsp; } else {
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var users = pickedUsers;
 * &nbsp;&nbsp;}
 * }
 * </pre>
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */		
Friends.showFriendPicker = function(maxFriendsToPick, callback) { 
    Dispatcher.callClassMethodOnRemoteObject(Friends, "showFriendPicker", [maxFriendsToPick, callback]);
};

/**
* <code>Social.US.Service.Friends</code> has an invited user message emitter. 
* To add a message listener to the message emitter, see the example below.
*
* @name Social.US.Service.Friends.invitedUserEmitter
* @field
* @public
* @example
* 
* Social.US.Service.Friends.invitedUserEmitter.addListener(
*				new Core.MessageListener(), 
*				function(user){ 
*				// do sth. w/ User object 
*				}
* Social.US.Service.Friends.invitedUserEmitter.emit({user: user});
* @see Core.MessageListener
* @see Core.MessageEmitter
* @status iOS, Android, Test, iOSTested, AndroidTested
*/
Friends.invitedUserEmitter = new MessageEmitter();; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Profile'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Profile'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Profile'] = exports; var RouterInited = require('NGCore/Client/Social/_Internal/RouterInit');
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

/**
 * @class
 * @name Social.US.Service.Profile
 */

exports.Profile = {
	
	/**
	 * Shows the user profile of the user specified by the <code>userOrGamertag</code> parameter.
	 * 
	 * @name Social.US.Service.Profile.showUserProfile
	 * @function
	 * @public
	 * 
	 * @param userOrGamertag Identifies the user or gamertag corresponding to the user profile.
	 * @param tab Specifies the name of the tab to show when the UI opens. If <code>null</code>, it opens the default tab.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */			
	showUserProfile:function(userOrUserGamertag,tab){		
		var cmd = {
			apiURL:"US.Service.Profile.showUserProfile", 
			data:{
				user:userOrUserGamertag
			}
		};
		if(tab){cmd.tab = tab;}
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/ButtonOverlays'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/ButtonOverlays'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/ButtonOverlays'] = exports; var UI = require('NGCore/Client/UI').UI;

var RouterInited = require('NGCore/Client/Social/_Internal/RouterInit');
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;

var Friends = require('NGCore/Client/Social/US/Service/Friends').Friends;
var Profile = require('NGCore/Client/Social/US/Service/Profile').Profile;
var User    = require('NGCore/Client/Social/US/Models/User').User;

/**
 * @class 
 * @name Social.US.Service.ButtonOverlays
 */
exports.ButtonOverlays = {
	/**
	* Displays the "Mobage Community" button.
	*	
	* @name Social.US.Service.ButtonOverlays.showCommunityButton
	* @function
	* @public 
	* 
	* @param {exports.Gravity} gravity Displays the button in the specified corner.
	* @param {Function} callback The callback function if there is an error related to <code>gravity</code> or <code>theme</code> usage.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @see exports.Gravity
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/   
	showCommunityButton: function(gravity, callback) {
		NgLogD("Public - showCommunityButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.showCommunityButton"
		};
		
		cmd["gravity"] = gravity;
		
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	* Hides the "Mobage Community" button.
	*
	* @name Social.US.Service.ButtonOverlays.hideCommunityButton
	* @function
	* @public 
	*	
	* @param {Function} callback The callback function if there is an error hiding the button.
	* <br/> 
	* <b>Callback Example:</b><br/>
	* <pre class="code">function(error){
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	* &nbsp;&nbsp;   }
	* </pre>
	* @status iOS, Android, Test, iOSTested, AndroidTested
	*/	
	hideCommunityButton: function(callback) {
		NgLogD("Public - hideCommunityButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.hideCommunityButton"
		};
		
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
		
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Shows the balance button.
	 * Shows the balance button where the <code>rect</code> parameter 
	 * determines the size and position of the button.
	 *
	 * @name Social.US.Service.ButtonOverlays.showBalanceButton
	 * @function
	 * @public
	 *	 
	 * @param {UI.ViewGeometry.Rect} rect Determines the size and position of the balance button.
	 * @param {Function} callback The callback function if there is an error with the <code>rect</code> parameter.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 * &nbsp;&nbsp;   }
	 * </pre>
	 * @see UI.ViewGeometry.Rect
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	showBalanceButton: function(rect, callback) {
		NgLogD("Public - showBalanceButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.showBalanceButton"
		};
		
		if (rect != undefined) {
			cmd["rect"] = rect;
		} else {
			cmd["rect"] = new UI.ViewGeometry.Rect(50, 50, 0, 0);
		}
		
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
	
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Hides the balance button.	
	 * @name Social.US.Service.ButtonOverlays.hideBalanceButton
	 * @function
	 * @public 
	 * 
	 * @param {Function} callback The callback function called after the view closes.
	 * <br/> 
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error){
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
	 * &nbsp;&nbsp;   }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */		
	hideBalanceButton: function(callback) {
		NgLogD("Public - hideBalanceButton");
		
		var cmd = {
			apiURL:"US.Service.ButtonOverlays.hideBalanceButton"
		};

		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		} else {
			cmd["callbackFunc"] = null;
		}
	
		GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/GameLaunchPayload'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/GameLaunchPayload'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/GameLaunchPayload'] = exports; var RouterInited = require('NGCore/Client/Social/_Internal/RouterInit');
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

var MessageEmitter = require('NGCore/Client/Core/MessageEmitter').MessageEmitter;

/**
* Provides an interface for retrieving a game's last payload from the game service. The game
* payload is returned as a string.
* @name Social.US.Service.GameLaunchPayload
*/

var GameLaunchPayload = exports.GameLaunchPayload = {


	/**
	 * @name Social.US.Service.GameLaunchPayload.getLastPayload
	 * @function
	 * @public
	 * 
	 * @param {Function} callback Retrieves the last payload generated by the game client from the game service 
     * as a string (e.g., JSON) and/or any error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, payload){
     *      if(error) {
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorCode = error.errorCode;
	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var errorDesc = error.description;
     *      } else {
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   	var pl = payload;     
     *      }
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */
	getLastPayload:function(callback)
	{
        if(callback != undefined && typeof callback == "function")
		{
			var cmd = {
				apiURL:"US.Service.GameLaunchPayload.getLastPayload"
			};

            cmd["callbackFunc"] = callback;

			GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
		}
	},
	
	// private, automatically called when new payload arrives. Do not call.
	onGameLaunchPayload:function(data)
	{
		GameLaunchPayload.newGamePayloadEmitter.emit(data);
	}
};

GameLaunchPayload.newGamePayloadEmitter = new MessageEmitter();; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Service/Bank'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Bank'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Service/Bank'] = exports; // Bank Public Interface
var RouterInited 	= require('NGCore/Client/Social/_Internal/RouterInit');
var GSGlobals 		= require('NGCore/Client/Social/_Internal/GSGlobals');
var UI 				= require('NGCore/Client/UI').UI;

/**
* @ignore
* @private
*/
exports.Bank = {
};


/**
 * @class 
 * @name Bank.Debit
 * @description
 * Bank.Debit is an interface for in-game item purchasing. A transaction begins with a call to <code>createTransaction()</code>, which presents
 * a user interface to the user. If the user follows through with a purchase, the <code>transaction.state</code> property changes from 
 * <code>new</code> to <code>authorized</code>. Once <code>createTransaction()</code> executes its callback, the game may call 
 * <code>openTransaction()</code>, which changes the state from <code>authorized</code> to <code>open</code> and puts funds into escrow. 
 * At this point, the game/game server should deliver the purchased items. Once the items have been delivered, the game should call   
 * <code>closeTransaction()</code>. If there is a problem at any point in the transaction lifecycle, call <code>cancelTransaction()</code>,
 * which sets the <code>transactionState</code> property to <code>canceled</code> and restores funds from escrow back to the user.
 */
exports.Bank.Debit = {
	
		
	/**
	 * Creates a transaction. Initially, it sets the <code>transaction.state</code> to <code>new</code>.
     * Mobage presents a dialog that prompts the user to confirm the transaction. 
	 * If the user decides not to proceed with the transaction, the callback error returns as "usercanceled."
	 * In the client-only flow, this call checks inventory and sets the state to <code>authorized</code>.
	 * 
	 * @name Bank.Debit.createTransaction
	 * @function
	 * @public
	 * 
	 * @param {Array} billingItems The billing items for the transaction. <br/><b>Note:</b> The array is limited to one item for this release.
     * <br/><b>Array Example:</b><br/>
     * <pre class="code"> var billingItems = [{
     *     "item": {
     *           "id": "iceCastle",
     *          },
     *     "quantity": 1
     *    },
     *    {
     *     "item": {
     *           "id": "cobbleStoneRoad",
     *          },
     *     "quantity": 3
     *    } 
     * ];
     * </pre>
	 * @param {String} comment A comment about the transaction.
	 * @param {Function} callback Retrieves the transaction details and/or any error code and description.
	 * <br/> 
     * <b>Callback Example:</b><br/>
	 * <pre class="code">var createTxCallback = function (error, transaction){
	 *     if (error === 'usercanceled'){
     *         var userCanceledDlg = new UI.AlertDialog();
     *         userCanceledDlg.setTitle("Cancel Transaction");
     *         userCanceledDlg.setText("User canceled transaction.");
     *         userCanceledDlg.setChoices([('OK')]);
     *         userCanceledDlg.show();
     *     } else if(error){
     *         var errorCode = error.errorCode;
     *         var errorDesc = error.description;
     *         Bank.Debit.cancelTransaction(transaction.id);
     *     } else {
     *         txId = transaction.id;
     *         Bank.Debit.openTransaction(txId, openTxCallback)
     * };
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */				
    createTransaction: function(billingItems, comment, callback) {
		NgLogD("Public call createTransaction");
		
		
	var data = {
	    billingItems: billingItems,
	    comment: comment
	};
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.createTransaction",
			data: data
		};

		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}    
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Places funds into escrow and begins processing the transaction. 
	 * Indicates the game server needs to deliver the purchased item.
	 * The <code>transaction.state</code> transitions from <code>authorized</code> to <code>open</code>.
	 *
	 * @name Bank.Debit.openTransaction
	 * @function
	 * @public
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @param {Function} callback Retrieves the transaction details and/or any error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var openTxCallback = function (error, transaction){
	 *      if (error){
	 *          var errorCode = error.errorCode;
     *          var errorDesc = error.errorDescription;
     *          Bank.Debit.cancelTransaction( transaction.id, 
     *                                        cancelTxCallback );
     *      } else {
     *          var txId = transaction.id;
     *          var txState = transaction.state;
     *          var txComment = transaction.comment;
     *          //You are responsible for delivering items to the client.
     *          MyGameTxClass.deliverItems(transaction.items);
     *          //If you do not close the tx, you do not get paid.
     *          Bank.Debit.closeTransaction( transaction.id, 
     *                                       closeTxCallback );
     *      }	
     * };
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */
	openTransaction: function(transactionId, callback) {
		NgLogD("Public call openTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.openTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Continues processing a transaction.
	 * Checks the inventory to verify the item is valid, available, and so on. After verification, the <code>transaction.state</code> chranges from <code>new</code> to <code>authorized</code>,
	 * and funds are placed in escrow. The <code>transaction.state</code> transitions from <code>authorized</code> to <code>open</code>, which 
	 * indicates the game server needs to deliver the purchased item. 
	 * 	 
	 *
	 * @name Bank.Debit.continueTransaction
	 * @function
	 * @public
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @param {Function} callback Retrieves the transaction details and/or any error code and description.
	 * <br/>
     * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, transaction){
     *      if(error) {
	 *           var errorCode = error.errorCode;
	 *           var errorDesc = error.description;
     *           Bank.Debit.cancelTransaction( transaction.id, 
     *                                         cancelTxCallback );
     *      } else {
     *           var tx = transaction;
     *           Bank.Debit.openTransaction( transaction.id, 
     *                                       openTxCallback );
     *      }
	 * };
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
    continueTransaction: function(transactionId, callback) {
		NgLogD("Public call continueTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.continueTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	

    /**
     * Cancels the transaction. The transaction was canceled or the purchased item was not delivered and the game
     * needs to return the user's funds. The <code>transaction.state</code> transitions to <code>canceled</code>.
     *
     * @name Bank.Debit.cancelTransaction
     * @function
     * @public 
     * 
     * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
     * @param {Function} callback Retrieves the transaction ID and/or an error code and description.
     * <br/>
     * <b>Callback Example:</b><br/>
	 * <pre class="code">var cancelTxCallback = function (error, transaction){
     *     if (error){
     *        var errorCode = error.errorCode;
     *        var errorDesc = error.errorDescription;
     *        NgLogD('Time to freak out!: ' + errorCode+ ': ' + errorDesc);
     *     } else {
     *        var txId = transaction.id;
     *        var txState = transaction.state;
     *        var txComment = transaction.comment;
     *        if (txState === 'canceled'){
     *          NgLogD('Sniff, sniff... Whaaaaahhhh!!!');
     *        }	
	 *     }	
     * };
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
     */
    cancelTransaction: function(transactionId, callback) {
		NgLogD("Public call cancelTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.cancelTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = callback;
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
    },


	/**
	 * Closes the transaction. The virtual item was delivered.
	 * The <code>transaction.state</code> transitions from <code>open</code> to <code>closed</code>.
	 *
	 * @name Bank.Debit.closeTransaction
	 * @function
	 * @public
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @param {Function} callback Retrieves the transaction details and/or an error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var closeTxCallback = function (error, transaction){
     *     if (error){
     *          var errorCode = error.errorCode;
     *          var errorDesc = error.errorDescription;
     *          NgLogD('Oh my goodness! A transaction error: ' +
     *                  errorCode + ': ' + errorDesc);
     *          Bank.Debit.cancelTransaction( transaction.id, 
     *                                        cancelTxCallback );
	 *     } else {
     *          var txId = transaction.id;
     *          var txState = transaction.state;
     *          var txComment = transaction.comment;
     *          if (txState === 'closed'){
     *              NgLogD('I'm rich! I'm rich!');
     *          }	
     *     }	
     * };
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	closeTransaction: function(transactionId, callback) {
		NgLogD("Public call closeTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.closeTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},
	
	/**
	 * Retrieves the transaction corresponding to the given transaction ID parameter.
	 *
	 * @name Bank.Debit.getTransaction
	 * @function
	 * @public
	 * 
	 * @param {String} transactionId The <code>transactionId</code> identifying this transaction.
	 * @param {Function} callback Retrieves the transaction details and/or an error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, transaction){
     *      if(error) {
	 *            var errorCode = error.errorCode;
	 *            var errorDesc = error.description;
     *      } else {
     *            var tx = transaction;     
     *      }
	 *   }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getTransaction: function(transactionId, callback) {
		NgLogD("Public call getTransaction");
		
		var cmd = {
			apiURL:"US.Service.Banking.Purchase.getTransaction",
			data:{}
		};
		
		if (transactionId) {
			cmd.data.transactionId = transactionId;
		}
		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = this._getCallBackFunc(callback);
		}
        
        GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	/**
	 * Retrieves the user's transactions where the state is <code>new</code>, <code>authorized</code> or <code>open</code>.
     * See the Game Service Programming Guide for details.
	 *
	 * @name Bank.Debit.getPendingTransactions
	 * @function
	 * @public
	 * 
	 * @param {Function} callback Retrieves the user's pending transactions and/or an error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">function(error, transaction){
     *      if(error) {
	 *         var errorCode = error.errorCode;
	 *         var errorDesc = error.description;
     *      } else {
     *         var tx = transaction;     
     *      }
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getPendingTransactions: function(callback) {
		NgLogD("Public call getPendingTransactions");

		var cmd = {
			apiURL:"US.Service.Banking.Purchase.getPendingTransactions",
			data:{}
		};

		if (callback != undefined && typeof callback == "function") {
			cmd["callbackFunc"] = function(err, data) {
				callback(err.error, data.openTransactions);
			};
		}

	    GSGlobals.getRouterInstance().sendCommandToGameService(cmd);
	},

	_getCallBackFunc : function(callback) {
			return function(err, data) {
				if(err) {
					callback(err, undefined);
				} else {
					callback(err, data.transaction);					
				}
			};
	}
};

/**
 * @class 
 * @name Bank.Inventory
 * @description
 * Provides an interface to retrieve items from inventory. The Mobage platform
 * server is responsible for managing item inventory in games.
 */
exports.Bank.Inventory = {


	/**
	 * Retrieves the item identified by its product ID from inventory on the Mobage platform server.
	 *
	 * @name Bank.Inventory.getItem
	 * @function
	 * @public
	 * 
	 * @param {Number} itemId The product ID for the item.
     * @param {Function} callback Retrieves the item from inventory on the Mobage platform server and/or an error code and description.
	 * <br/>
	 * <b>Callback Example:</b><br/>
	 * <pre class="code">var item = {
     *      "id" : "XXXXXXXXX",
     *      "name" : "Tractor",
     *      "price" : 350,
     *      "description" : "Tractor conveys huge amount of equipment.",
     *      "imageUrl" : "http://someurl.com"
     * }
     *function(error, item){
     *      if(error) {
	 *         var errorCode = error.errorCode;
	 *         var errorDesc = error.description;
     *      } else {
     *         var itemData = item;
     *      }
	 * }
	 * </pre>
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */    
    getItem: function(itemId,callback) {
	NgLogD("Public call Inventory getItem");

	var data = {
	    itemId: itemId
	};

	var cmd = {
	    apiURL:"US.Service.Banking.Purchase.getItem",
	    data:data
	};

	if (callback != undefined && typeof callback == "function") {
	    cmd["callbackFunc"] =  function(err, data) {
		if(err) {
		    callback(err, undefined);
		} else {
		    callback(err, data.item);					
		}
	    };
	}

	GSGlobals.getRouterInstance().sendCommandToGameService(cmd);

    }


};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/GSGlobals'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSGlobals'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSGlobals'] = exports; /**
 * Annoyingly necessary file to break circular dependencies.
 */
var theRouter = null;
exports.setRouterInstance = function(router){
	theRouter = router;
};
exports.getRouterInstance = function(){
	return theRouter;
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/RouterInit'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/RouterInit'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/RouterInit'] = exports; var Router = require('NGCore/Client/Social/_Internal/_Router').Router;
var GSGlobals = require('NGCore/Client/Social/_Internal/GSGlobals');

//Generate 1 instance of our router now and treat as the global instance!
GSGlobals.setRouterInstance(new Router());; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/_Router'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/_Router'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/_Router'] = exports; ////////////////////////////////////////////////////////////////////////////////
// Class Router INTERNAL ROUTING CLASS
//
// Copyright (C) 2010 ngmoco:) inc.  All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////


var Class = require('NGCore/Shared/Class').Class;
var Core = require('NGCore/Client/Core').Core;
var GSCommand = require('NGCore/Client/Social/_Internal/GSCommand');
var Public = require('NGCore/Client/Social').Social;

////////////////////////////////////////////////////////////////////////////////
var RouterVerbose = false;

exports.Router = Class.subclass(
/** @lends GameService.Router.prototype */
{
	classname: 'Router',
	
	/**
	 * Function.
	 * @constructs
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
	},
	
	/** Member var to help shortcircuit uneccessary bounces out to native. */
	zone:-2,
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
			* Zone for this Router Singleton (per-process)
			* @private */
	Zone:
	{ 
		/** Public Zone */
		Public: -2,
		/** GameService Zone */
		GameService: -1,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 346
	// Method create = -1
	// Method sendToOtherProcess = 2
	// Method onCreate = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 2:
					instance._sendToOtherProcessRecv( cmd );
					break;
				case 3:
					instance._onCreateRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Router._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Router._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[346] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_sendToOtherProcessRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Router.sendToOtherProcess from command: " + cmd );
			return false;
		}
		
		obj[ "gsCommand" ] = Core.Proc.parseJSONString( cmd[ 0 ] );
		if( obj[ "gsCommand" ] === undefined )
		{
			NgLogE("Could not parse gsCommand in Router.sendToOtherProcess from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/** @private */
	_onCreateRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Router.onCreate from command: " + cmd );
			return false;
		}
		
		obj[ "zone" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "zone" ] === undefined )
		{
			NgLogE("Could not parse zone in Router.onCreate from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":346,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_sendToOtherProcessSendGen: function( gsCommand )
	{
		Core.Proc.appendToCommandString( ":346,2," + this.__objectRegistryId + "," + Core.Base64.encode( JSON.stringify( gsCommand ) )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// _sendToOtherProcessRecv: function( cmd ) {}
	// sendToOtherProcess: function( gsCommand ) {}
	
	// _onCreateRecv: function( cmd ) {}

// {{/Wg Generated Code}}
	_onCreateRecv:function(cmd) {
		if (!this._onCreateRecvGen(cmd,this)){
			return;
		}
		NgLogD("_Router/_onCreateRecv: "+this.zone);
		//We already stored the zone directly in ourselves (by passing in 'this').
	},
	_sendToOtherProcessRecv: function( cmd )
	{
		var decodedCommand = {};
		if(!this._sendToOtherProcessRecvGen(cmd,decodedCommand)){
			NgLogE("Decode of data for router, failed.");
			return;
		}
		
		var commandObject = decodedCommand["gsCommand"];
		
		//Incoming commands all get executed immediately.
		if(this.zone == this.Zone.Public) {
			if(RouterVerbose) {
				NgLogD("_Router/_sendToOtherProcessRecv - in public");
			}
			
			this.dispatchGameCommand(commandObject);
		}
		else if(this.zone == this.Zone.GameService) {
			if(RouterVerbose) {
				NgLogD("_Router/ _sendToOtherProcessRecv - in privileged");
			}
			
			// Dispatch Immediately, because we are in the right interpreter
			this.dispatchGameServiceCommand(commandObject);
		}
		else {
			NgLogE("Unknown Command Zone for the GameService Router.");
			// Assume public
			this.dispatchGameCommand(commandObject);
		}
	},
 	sendToOtherProcess: function( gsCommand ) 
	{
		var jsonCommand = GSCommand.makeSafe(gsCommand);
		if(!jsonCommand) {
			NgLogD("Couldn't prep GSCommand message for sending!");
			return;
		}
		
		if(RouterVerbose) {
			NgLogD("_Router.js/sendToOtherProcess: " + JSON.stringify(jsonCommand));
		}
		
		this._sendToOtherProcessSendGen(jsonCommand);
	},
	sendCommandToGameService:function(gsCommand) 
	{		
		if(this.zone == this.Zone.Public) {
			if(RouterVerbose) {
				NgLogD("_Router: sendCommandToGameService - in public");
			}
			
			// In the Public Interface, this is an alias for sendToOtherProcess
			this.sendToOtherProcess(gsCommand);
		}
		else if(this.zone == this.Zone.GameService) {
			if(RouterVerbose) {
				NgLogD("_Router: sendCommandToGameService - in privileged");
			}
			
			// Dispatch Immediately, because we are in the right interpreter
			this.dispatchGameServiceCommand(gsCommand);
		}
		else {
			NgLogE("Unknown Command Zone for the GameService Router.");
			// Assume public
			this.sendToOtherProcess(gsCommand);
		}
	},
	sendCommandToGame:function(gsCommand)
	{
		if(this.zone == this.Zone.GameService) {
			// In the GameService Interface, this is an alias for sendToOtherProcess
			this.sendToOtherProcess(gsCommand);
		}
		else if(this.zone == this.Zone.Public) {
			// Dispatch Immediately, because we are in the right interpreter
			this.dispatchGameCommand(gsCommand);
		}
		else {
			NgLogE("Unknown Command Zone for the GameService Router.");
			// Assume Privileged
			this.sendToOtherProcess(gsCommand);
		}
	},
	dispatchGameCommand:function(jsonCommand) 
	{
		var tCommand = GSCommand.makeExecutable(jsonCommand);
		//For the time being we expect this to almost always be callbacks
		if(tCommand && tCommand.hasOwnProperty("callbackFunc")) {	
			if( typeof tCommand["callbackFunc"] == "function" ) {
				var args = null;
				var error = null;
				if(tCommand.hasOwnProperty("error")) {
					error = tCommand["error"];
				}
				if(tCommand.hasOwnProperty("callbackData")) {
					args = tCommand["callbackData"];
				}

				//Time to execute the callback function!
				tCommand["callbackFunc"](error,args);
			}
		}
		else if(tCommand) {
			// Case there was no callbackFunc this is odd!!
			var apiURL = null;
			if(tCommand && tCommand.hasOwnProperty("apiURL") ) {
				apiURL = tCommand["apiURL"];

				var apiPieces = apiURL.split(".");
				var curPackage = Public;

				for ( var i = 0; i < apiPieces.length; i++ )
				{
					if(curPackage.hasOwnProperty(apiPieces[i])) {
						curPackage = curPackage[apiPieces[i]];
					}
					else {
						//Total Fail
						NgLogE("Cannot find namespace " + apiURL + " in GameService");
						curPackage = null;
						break;
					}
				}

				if(curPackage && typeof curPackage == "function" ) {			
					curPackage(tCommand);

					return; //done dispatching!
				}else{
					NgLogE("GameService Public cannot dispatch game command " + JSON.stringify(tCommand));
				}
			}
		}
	},
	dispatchGameServiceCommand:function(jsonCommand) 
	{
		//Don't decode the callbackId into a func when on a different interpreter!
		var apiURL = null;
		if(jsonCommand && jsonCommand.hasOwnProperty("apiURL") ) {
			apiURL = jsonCommand["apiURL"];

			var apiPieces = apiURL.split(".");
			var curPackage = require('NGCore/Client/Social/_Internal/Privileged').Social;

			for ( var i = 0; i < apiPieces.length; i++ )
			{
				if(curPackage.hasOwnProperty(apiPieces[i])) {
					curPackage = curPackage[apiPieces[i]];
				}
				else {
					//Total Fail
					NgLogE("Cannot find namespace " + apiURL + " in GameService");
					curPackage = null;
					break;
				}
			}

			if(curPackage && typeof curPackage == "function" ) {
				try {
					curPackage(jsonCommand);
				} catch(gsException) {
					NgLogException(gsException);
				}

				return; //done dispatching!
			}
		}
		else {
			NgLogE("Someone called GameService without the proper parameters.\n");
		}
	},
	setVerboseLogging:function(useVerbose)
	{
		RouterVerbose = useVerbose;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/GSCommand'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSCommand'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/GSCommand'] = exports; /**
 * GSCommand.js
 * GameService Command Helper
 *
 * @summary Converts hashes for sending across the interpreter bounds, specifically:
 *		- Takes a hash with a callbackFunc
 * 			- Takes callbackFunc and converts to callbackId
 *		- Takes a hash with a callbackId
 *			- Takes the callbackId and looks up a callbackFunc from the local cache
 */
 
var GameServiceCommandCallbackStore = {};
GameServiceCommandCallbackStore.uidGenerator = 0;

/* @private */
var storeCallbackIdForFunc = function(callbackFunc) {
	var uid = GameServiceCommandCallbackStore.uidGenerator++;
	GameServiceCommandCallbackStore[uid] = callbackFunc;
	return uid;
};
/* @private */
var extractFuncForCallbackId = function(callbackId) {
	if(GameServiceCommandCallbackStore.hasOwnProperty(callbackId)){
		var callbackFunc = GameServiceCommandCallbackStore[callbackId];
		delete GameServiceCommandCallbackStore[callbackId];
		return callbackFunc;
	}
	return null;
};

var blindConvert = function(hash) {
	if ( typeof hash == "object" ) {
		// Case we have a hash
		if ( hash.hasOwnProperty("callbackFunc") ) {
			//	with a callback func to convert
			hash["callbackId"] = storeCallbackIdForFunc(hash["callbackFunc"]);
			
			delete hash["callbackFunc"];
		}
		else if (hash.hasOwnProperty("callbackId")) {
			hash["callbackFunc"] = extractFuncForCallbackId(hash["callbackId"]);
			delete hash["callbackId"];
		}
		return hash;
	}
	
	NgLogD("Error: invalid or non-object passed to gsCmdConvert.");
	return null;
};
exports.makeSafe = function(hash) {
	if (hash && typeof hash == "object" && hash.hasOwnProperty("callbackFunc"))
	{
		return blindConvert(hash);
	}
	return hash;
};
exports.makeExecutable = function(hash) {
	if (hash && typeof hash == "object" && hash.hasOwnProperty("callbackId"))
	{
		return blindConvert(hash);
	}
	return hash;
};

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/_Internal/Privileged'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/_Internal/Privileged'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/_Internal/Privileged'] = exports; /**
 * Privileged API for GameService (Public Stub)
 * 
 * Access this file as NGCore/Client/Social.js
 */
exports.Social = {
	// stubbed out for the SDK
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Social/US/Models/OrderedList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Social/US/Models/OrderedList'] || {}; $MODULE_REGISTRY['NGCore/Client/Social/US/Models/OrderedList'] = exports; var Dispatcher = require('NGCore/Client/Social/US/Data/Dispatcher').Dispatcher;

/**
 * @class 
 * @name Social.US.OrderedList
 * @description
 * Do not instantiate <code>OrderedList</code> objects directly. This description is for information purposes only. 
 * <code>DataModel</code> subclasses that return <code>OrderedList</code> interfaces include:<br/><br/>
 * <div class="ul">
 * <li>{@link Social.US.User}</li>
 * <li>{@link Social.US.Leaderboard}</li>
 * </div><br/>
 * Some <code>DataModel</code> subclasses can return an <code>OrderedList</code>,
 * which is an interface for iterating over a range of values. You determine the iteration range by
 * selecting one of three common functions: <br/><br/>
 * <div class="ul">
 * <li><code>forAll(iterCb, doneCb):</code> Iterates over all values.</li>
 * <li><code>forRange(start, count, iterCb, doneCb):</code> Iterates from the starting index to the count.</li>
 * <li><code>forItem(index, iterCb, doneCb):</code> Iterates over a particular item given by its index.</li>
 * </div>
 * Each of the functions calls an iteration callback (iterCb) for every available item. 
 * When the function iterates over all items or an error occurs, it calls the done callback (doneCb). You <b>MUST</b> provide both callbacks.
 * <br/><br/>
 * <b>Note:</b> The <code>OrderedList</code> interface invokes an iterator on the server. Do NOT assume it will execute your callback functions immediately.
 *
 * @example
 * //NOTE: You MUST provide both callback functions.
 * userBuddiesList.forAll( 
 *      function(error, details){//per item cb body}, 
 *      function(error, details){//done cb body}
 * );
 *
 * @example
 * //Callback examples
 * var done = false;
 * var err = null;
 *
 * currentUser.getFriendsList().forAll(
 *          function(continueCb, user, index){
 *				if(user == otherUser){
 *					foundBuddy = true;
 *					continueCb(false);
 *				}else{
 *					continueCb(true);
 *				}
 *			}, 
 *          function(error){
 *                  if (!error){
 *                      done = true;
 *                   } else {
 *                      err = error;
 *                   }
 *          }
 * );
 * @status iOS, Android, Test, iOSTested, AndroidTested
 */
var OrderedList = {

    /**
    * Returns a public interface for an object.
    * 
    * To expose a privelegee ordered list of a <code>DataModel</code> object in the public interface, 
    * add a function to the object of the corresponding <code>DataModel</code>
    * subclass in the public interface.
    * @example
    * getFollowersList: function(cb){
 	* 	return OrderedList.getObjectPublicInterface(this, "getFollowersList", "_followersListInterface");
	* },
    *
    * @name Social.US.OrderedList.getObjectPublicInterface
    * @function    
    * @private
    *
    * @param {Object} ownerObject The object that will "own" the public interface.
    * @param {Function} getListFn The function that returns a list of values to the <code>OrderedList</code>.
    * @param interfaceName The name of the interface.
    *
    * @return {Social.US.OrderedList} The public interface.
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */
    getObjectPublicInterface: function(ownerObject, getListFn, interfaceName) {
		if(ownerObject[interfaceName]) {
			return ownerObject[interfaceName];
		}
		
		var args = Array.apply(null, arguments);
		if(args && args.length > 3){
			args.splice(0, 3);
		}else{
			args = [];
		}
		
		var newInterface = {
			forAll: function(perItemCb, doneCb) {
				Dispatcher.callMethodOnRemoteObject(ownerObject, [getListFn, "forAll"], [args,[perItemCb, doneCb]]);		
			},
			forRange: function(start, count, perItemCb, doneCb) {
				Dispatcher.callMethodOnRemoteObject(ownerObject, [getListFn, "forRange"], [args,[start, count, perItemCb, doneCb]]);
			},
			forItem: function(index, perItemCb, doneCb) {
				Dispatcher.callMethodOnRemoteObject(ownerObject, [getListFn, "forItem"], [args,[index, perItemCb, doneCb]]);
			}
		};
		
		ownerObject[interfaceName] = newInterface;
		
		return newInterface;
	},

    /**
    * Returns a public interface for a class.
    * To expose a priveleged ordered list of a <code>DataModel</code> subclass in the public interface, 
    * add a function to the subclass of the corresponding <code>DataModel</code>
    * subclass in the public interface.
    * @example
    * getFollowersList: function(cb){
 	* 	return OrderedList.getClassPublicInterface(this, "getFollowersList", "_followersListInterface");
	* },    
    *
    * @name Social.US.OrderedList.getClassPublicInterface
    * @function
    * @private
    *
    * @param {Object} owner The owner of the the public interface.
    * @param {Function} getListFn The function to call on each iteration.
    * @param interfaceName The name of the interface.
    * 
    * @return {Social.US.OrderedList} The public interface.
    * @status iOS, Android, Test, iOSTested, AndroidTested
    */
    getClassPublicInterface: function(owner, getListFn, interfaceName) {
		if(owner[interfaceName]) {
			return owner[interfaceName];
		}
		
		var newInterface = {
			forAll: function(perItemCb, doneCb) {
				Dispatcher.callClassMethodOnRemoteObject(owner, [getListFn, "forAll"], [[],[perItemCb, doneCb]]);
			},
			forRange: function(start, count, perItemCb, doneCb) {
				Dispatcher.callClassMethodOnRemoteObject(owner, [getListFn, "forRange"], [[],[start, count, perItemCb, doneCb]]);
			},
			forItem: function(index, perItemCb, doneCb) {
				Dispatcher.callClassMethodOnRemoteObject(owner, [getListFn, "forItem"], [[],[index, perItemCb, doneCb]]);
			}
		};
		
		owner[interfaceName] = newInterface;
		
		return newInterface;
	}
};

exports.OrderedList = OrderedList;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Color'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Color'] || {}; $MODULE_REGISTRY['NGCore/Shared/Color'] = exports; var Class = require('NGCore/Shared/Class').Class;

exports.Color = Class.subclass(
/** @lends Core.Color.prototype */
{
	classname: 'Color',
	
	/**
	 * @class The <code>Color</code> class constructs objects that control the RGB components of a device. 
	 * RGB is a color model used for rendering objects on-screen and is derived 
	 * from the three primary colors used in the model: red, green, and blue.
	 * Each value ranges from <code>(0-1)</code> and determines the color saturation level.	 
	 * @constructs The default constructor.<br><br>
	 * <b>Example:</b> The following code examples illustrate different call styles for <code>Color</code> objects.<br><br>
	 * A new color with all components set to one (1 = white).
	 * <pre class="code">var style1 = new Core.Color();</pre>
	 *
	 * Copy an existing color.
	 * <pre class="code">var style2 = new Core.Color(style1);</pre>
	 *
	 * Specify all three components.
	 * <pre class="code">var style3 = new Core.Color(1.0, 1.0, 1.0);</pre>
	 *
	 * Specify the color as solid blue.
	 * <pre class="code">var style4 = new Core.Color([0, 0, 1.0]);</pre>
	 *
	 * Specify the color as solid red.
	 * <pre class="code">var style5 = new Core.Color([1.0, 0, 0]);</pre>
	 * 
	 * Specify the color as a dark shade of red.
	 * <pre class="code">var style6 = new Core.Color([.5, 0, 0]);'</pre>
	 * @augments Core.Class
	 * @param {Number} [red=1] The red component.
	 * @param {Number} [green=1] The green component.
	 * @param {Number} [blue=1] The blue component.
	 * @throws {Wrong number of arguments for a Color} Number of parameters passed by this call is invalid.
	 */
	initialize: function(red, green, blue)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._red = 1.0;
				this._green = 1.0;
				this._blue = 1.0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._red = 1.0;
					this._green = 1.0;
					this._blue = 1.0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (color)
					this._red = rhs.getRed();
					this._green = rhs.getGreen();
					this._blue = rhs.getBlue();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._red = 1.0;
							this._green = 1.0;
							this._blue = 1.0;
							break;
						case 1:
							// ([color])
							rhs = rhs[0];
							this._red = rhs.getRed();
							this._green = rhs.getGreen();
							this._blue = rhs.getBlue();
							break;
						case 3:
							// ([red, green, blue])
							this._red = rhs[0];
							this._green = rhs[1];
							this._blue = rhs[2];
							break;
						default:
							throw new Error('Wrong number of arguments for a Color');
					}
				}
				break;
			case 3:
				// (red, gree, blue)
				this._red = arguments[0];
				this._green = arguments[1];
				this._blue = arguments[2];
				break;
			default:
				throw new Error('Wrong number of arguments for a Color');
		}
		return this;
	},
	
	/**
	 * Set the saturation level for all three color components.
	 * @example Core.Color.setAll(0.5, 0.5, 1.0);
	 * @param {Number} [red=1] The red component.
	 * @param {Number} [green=1] The green component.
	 * @param {Number} [blue=1] The blue component.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Color for a full list of supported calling styles.
	 */
	setAll: function(red, green, blue)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Retrieve the saturation level for the red component of this <code>Color</code>.
	 * @returns {Number} The current saturation level for the red component.
	 */
	getRed: function()
	{
		return this._red;
	},
	
	/**
	 * Retrieve the saturation level for the green component of this <code>Color</code>.
	 * @returns {Number} The current saturation level for the green component.
	 */
	getGreen: function()
	{
		return this._green;
	},
	
	/**
	 * Retrieve the saturation level for the blue component of this <code>Color</code>.
	 * @returns {Number} The current saturation level for the blue component.
	 */
	getBlue: function()
	{
		return this._blue;
	},
	
	/**
	 * Set the saturation level for the red component of this <code>Color</code>.
	 * @example Core.Color.setRed(0.7);
	 * @param {Number} red The new saturation level for the red component.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Color#getRed
	 */
	setRed: function(red)
	{
		this._red = red;
		return this;
	},
	
	/**
	 * Set the saturation level for the green component of this <code>Color</code>.
	 * @example Core.Color.setGreen(0.3);
	 * @param {Number} green The new saturation level for the green component.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Color#getGreen
	 */
	setGreen: function(green)
	{
		this._green = green;
		return this;
	},
	
	/**
	 * Set the saturation level for the blue component of this <code>Color</code>.
	 * @example Core.Color.setBlue(1.0);
	 * @param {Number} blue The new saturation level for the blue component.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Color#getBlue
	 */
	setBlue: function(blue)
	{
		this._blue = blue;
		return this;
	},
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Vector'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Vector'] || {}; $MODULE_REGISTRY['NGCore/Shared/Vector'] = exports; var Class = require('NGCore/Shared/Class').Class;

exports.Vector = Class.subclass(
/** @lends Core.Vector.prototype */
{
	classname: 'Vector',
	
	/**
	 * @class The <code>Vector</code> class constructs objects that define vector point values for the <i>x</i> and <i>y</i> components. 
	 * Supported values range between <code>(0-1)</code>.
	 * @constructs The default constructor. <br><br>
	 * The following code examples illustrate a variety of different calling styles for <code>Vector</code> objects.<br><br>
	 * All components are set to zero.
	 * <pre class="code">var style1 = new Core.Vector();</pre>
	 *
	 * Copy an existing vector.
	 * <pre class="code">var style2 = new Core.Vector(style1);</pre>
	 *
	 * Specify a value for both components.
	 * <pre class="code">var style3 = new Core.Vector(1.0, 1.0);</pre>
	 *
	 * Specify a value for both components.
	 * <pre class="code">var style4 = new Core.Vector([1.0, 1.0]);</pre>
	 * @augments Core.Class
	 * @param {Number} [x=0] The <i>x</i> component.
	 * @param {Number} [y=0] The <i>y</i> component.
	 * @throws {Wrong number of arguments for a Vector} Number of parameters passed by this call is invalid.
	 * @status iOS, Android, Flash
	 */
	initialize: function()
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._x = 0;
				this._y = 0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._x = 0;
					this._y = 0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (vector)
					this._x = rhs.getX();
					this._y = rhs.getY();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._x = 0;
							this._y = 0;
							break;
						case 1:
							// ([vector])
							rhs = rhs[0];
							this._x = rhs.getX();
							this._y = rhs.getY();
							break;
						case 2:
							// ([x, y])
							this._x = rhs[0];
							this._y = rhs[1];
							break;
						default:
							throw new Error('Wrong number of arguments for a Vector');
					}
				}
				break;
			case 2:
				// (x, y)
				this._x = arguments[0];
				this._y = arguments[1];
				break;
			default:
				throw new Error('Wrong number of arguments for a Vector');
		}
	},
	
	/**
	 * Set the value of both components for this <code>Vector</code>. 
	 * @param {Number} [x=0] The new <i>x</i> coordinate.
	 * @param {Number} [y=0] The new <i>y</i> coordinate.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Vector for examples of supported calling styles.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setAll: function()
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate this <code>Vector</code>.
	 * @returns {Core.Vector} A new vector with identical coordinates to the duplicated vector.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the value of the <i>x</i> component for this <code>Vector</code>.
	 * @returns {Number} The current <i>x</i> coordinate.
	 * @see Core.Vector#setX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getX: function()
	{
		return this._x;
	},
	
	/**
	 * Set the value of the <i>x</i> component for this <code>Vector</code>.
	 * @param {Number} <i>x</i> The new <i>x</i> coordinate.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Vector#getX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setX: function(x)
	{
		this._x = x;
		return this;
	},
	
	/**
	 * Retrieve the value of the <i>y</i> component for this <code>Vector</code>.
	 * @returns {Number} The current <i>y</i> coordinate.
	 * @see Core.Vector#setY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getY: function()
	{
		return this._y;
	},
	
	/**
	 * Set the value of the <i>y</i> component for this <code>Vector</code>.
	 * @param {Number} <i>y</i> The new <i>y</i> coordinate.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Vector#getY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setY: function(y)
	{
		this._y = y;
		return this;
	},
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Point'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Point'] || {}; $MODULE_REGISTRY['NGCore/Shared/Point'] = exports; var Class = require('NGCore/Shared/Class').Class;

exports.Point = Class.subclass(
/** @lends Core.Point.prototype */
{
	classname: 'Point',
	
	/**
	 * @class The <code>Point</code> class defines a 2D point coordinate (<i>x</i> and <i>y</i>). 
	 * @status iOS, Android, Flash, Test
	 * @constructs The default constructor. <br><br>
	 * <b>Example:</b>The following code examples illustrate a variety of different calling styles for <code>Point</code> objects.<br><br>
	 * All components are set to zero.
	 * <pre class="code">var style1 = new Core.Point();</pre>
	 *
	 * Copy an existing point.
	 * <pre class="code">var style2 = new Core.Point(style1);</pre>
	 *
	 * Specify a value for both components.
	 * <pre class="code">var style3 = new Core.Point(1.0, 1.0);</pre>
	 *
	 * Specify a value for both components.
	 * <pre class="code">var style4 = new Core.Point([1.0, 1.0]);</pre>
	 * @augments Core.Class
	 * @param {Number} [x=0] The <i>x</i> coordinate.
	 * @param {Number} [y=0] The <i>y</i> coordinate.
	 * @throws {Wrong number of arguments for a Point} Number of parameters passed by this call is invalid.
	 */
	initialize: function(x, y)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._x = 0;
				this._y = 0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._x = 0;
					this._y = 0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (point)
					this._x = rhs.getX();
					this._y = rhs.getY();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._x = 0;
							this._y = 0;
							break;
						case 1:
							// ([point])
							rhs = rhs[0];
							this._x = rhs.getX();
							this._y = rhs.getY();
							break;
						case 2:
							// ([x, y])
							this._x = rhs[0];
							this._y = rhs[1];
							break;
						default:
							throw new Error('Wrong number of arguments for a Point');
					}
				}
				break;
			case 2:
				// (x, y)
				this._x = arguments[0];
				this._y = arguments[1];
				break;
			default:
				throw new Error('Wrong number of arguments for a Point');
		}
	},
	
	/**
	 * Set the value of both the <i>x</i> and <i>y</i> components. 
	 * @param {Number} [<i>x</i>=0] The new <i>x</i> coordinate.
	 * @param {Number} [<i>y</i>=0] The new <i>y</i> coordinate.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Point for examples of supported calling styles.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setAll: function(x, y)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate this <code>Point</code>.
	 * @returns {Core.Point} A new point with identical <i>x</i> and <i>y</i> coordinates to the cloned point.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the value of the <i>x</i> component of this <code>Point</code>.
	 * @returns {Number} The current <i>x</i> coordinate.
	 * @see Core.Point#setX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getX: function()
	{
		return this._x;
	},
	
	/**
	 * Set the value of the <i>x</i> component for this <code>Point</code>.
	 * @param {Number} <i>x</i> The new <i>x</i> coordinate.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Point#getX
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setX: function(x)
	{
		this._x = x;
		return this;
	},
	
	/**
	 * Retrieve the value of the <i>y</i> component of this <code>Point</code>.
	 * @returns {Number} The current <i>y</i> coordinate.
	 * @see Core.Point#setY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getY: function()
	{
		return this._y;
	},
	
	/**
	 * Set the value of the <i>y</i> component for this <code>Point</code>.
	 * @param {Number} <i>y</i> The new <i>y</i> coordinate.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Point#getY
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setY: function(y)
	{
		this._y = y;
		return this;
	},
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Size'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Size'] || {}; $MODULE_REGISTRY['NGCore/Shared/Size'] = exports; var Class = require('NGCore/Shared/Class').Class;

exports.Size = Class.subclass(
/** @lends Core.Size.prototype */
{
	classname: 'Size',
	
	/**
	 * @class The <code>Size</code> class constructs objects that define size values for the <i>height</i> and <i>width</i> components. 
	 * @status iOS, Android, Flash
	 * Supported values range between <code>(0-1)</code>.
	 * @constructs The default constructor. <br><br>
	 * The following code examples illustrate a variety of different calling styles for <code>Size</code> objects.<br><br>
	 * Set both component values to 0.
	 * <pre class="code">var style1 = new Core.Size();</pre>
	 *
	 * Copy an existing size.
	 * <pre class="code">var style2 = new Core.Size(style1);</pre>
	 *
	 * Specify a value for both components.
	 * <pre class="code">var style3 = new Core.Size(1.0, 1.0);</pre>
	 *
	 * Specify a value for both components.
	 * <pre class="code">var style4 = new Core.Size([1.0, 1.0]);</pre>
	 * @augments Core.Class
	 * @param {Number} [width=0] The <i>width</i> component.
	 * @param {Number} [height=0] The <i>height</i> component.
	 */
	initialize: function(width, height)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._width = 0;
				this._height = 0;
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._width = 0;
					this._height = 0;
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (size)
					this._width = rhs.getWidth();
					this._height = rhs.getHeight();
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._width = 0;
							this._height = 0;
							break;
						case 1:
							// ([size])
							rhs = rhs[0];
							this._width = rhs.getWidth();
							this._height = rhs.getHeight();
							break;
						case 2:
							// ([x, y])
							this._width = rhs[0];
							this._height = rhs[1];
							break;
						default:
							throw new Error('Wrong number of arguments for a Size');
					}
				}
				break;
			case 2:
				// (x, y)
				this._width = arguments[0];
				this._height = arguments[1];
				break;
			default:
				throw new Error('Wrong number of arguments for a Size');
		}
	},
	
	/**
	 * Set the value of all components for this <code>Size</code>. 
	 * @param {Number} [width=0] The new <i>width</i>.
	 * @param {Number} [height=0] The new <i>height</i>.
	 * @throws {Wrong number of arguments for a Size} Number of parameters passed by this call is invalid.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Size for examples of supported calling styles.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setAll: function(width, height)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate this <code>Size</code>.
	 * @returns {Core.Size} A new size with identical <i>height</i> and <i>width</i> components.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the value of the <i>width</i> component for this <code>Size</code>.
	 * @returns {Number} The current <i>width</i>.
	 * @see Core.Size#setWidth
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getWidth: function()
	{
		return this._width;
	},
	
	/**
	 * Set the value of the <i>width</i> component for this <code>Size</code>.
	 * @param {Number} width The new <i>width</i>.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Size#getWidth
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setWidth: function(width)
	{
		this._width = width;
		return this;
	},
	
	/**
	 * Retrieve the value of the <i>height</i> component for this <code>Size</code>.
	 * @returns {Number} The current <i>height</i>.
	 * @see Core.Size#setHeight
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getHeight: function()
	{
		return this._height;
	},
	
	/**
	 * Set the value of the <i>height</i> component for this <code>Size</code>.
	 * @param {Number} height The new <i>height</i>.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Size#getHeight
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setHeight: function(height)
	{
		this._height = height;
		return this;
	},
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Shared/Rect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Shared/Rect'] || {}; $MODULE_REGISTRY['NGCore/Shared/Rect'] = exports; var Class = require('NGCore/Shared/Class').Class;
var Point = require('NGCore/Shared/Point').Point;
var Size = require('NGCore/Shared/Size').Size;

exports.Rect = Class.subclass(
/** @lends Core.Rect.prototype */
{
	classname: 'Rect',
	
	/**
	 * @class The <code>Rect</code> class constructs a rectangle object that is derived from two values: a point of origin  
	 * and a size.	 
	 * @status iOS, Android, Flash
	 * @constructs The default constructor. <br><br>
	 * The following code examples illustrate a variety of different calling styles for <code>Rect</code> objects.<br><br>
	 * All components set to zero.
	 * <pre class="code">var style1 = new Core.Rect();</pre>
	 *
	 * Copy an existing <code>rect</code>.
	 * <pre class="code">var style2 = new Core.Rect(style1);</pre>
	 *
	 * Specify a point and size.
	 * <pre class="code">var style3 = new Core.Rect(new Core.Point(), new Core.Size());</pre>
	 *
	 * Specify four components.
	 * <pre class="code">var style4 = new Core.Rect(0, 0, 100, 100);</pre>
	 * @augments Core.Class
	 * @param {Core.Point} [origin=0] The rectangle point of origin.
	 * @param {Core.Size} [size=0] The rectangle size.
	 * @throws {Wrong number of arguments for a Rect} Number of parameters passed by this call is invalid.
	 */
	initialize: function(origin, size)
	{
		switch(arguments.length)
		{
			case 0:
				// ()
				this._origin = new Point();
				this._size = new Size();
				break;
			case 1:
				var rhs = arguments[0];
				if(rhs === undefined)
				{
					// (undefined)
					this._origin = new Point();
					this._size = new Size();
				}
				else if(!rhs.hasOwnProperty('length'))
				{
					// (rect)
					this._origin = new Point(rhs.getOrigin());
					this._size = new Size(rhs.getSize());
				}
				else
				{
					switch(rhs.length)
					{
						case 0:
							// ([])
							this._origin = new Point();
							this._size = new Size();
							break;
						case 1:
							// ([rect])
							rhs = rhs[0];
							this._origin = new Point(rhs.getOrigin());
							this._size = new Size(rhs.getSize());
							break;
						case 2:
							// ([point, size])
							// ([[x, y], [width, height]])
							this._origin = new Point(rhs[0]);
							this._size = new Size(rhs[1]);
							break;
						case 4:
							// ([x, y, width, height])
							this._origin = new Point(rhs[0], rhs[1]);
							this._size = new Size(rhs[2], rhs[3]);
							break;
						default:
							throw new Error('Wrong number of arguments for a Rect');
					}
				}
				break;
			case 2:
				// (point, size)
				this._origin = new Point(arguments[0]);
				this._size = new Size(arguments[1]);
				break;
			case 4:
				// (x, y, width, height)
				this._origin = new Point(arguments[0], arguments[1]);
				this._size = new Size(arguments[2], arguments[3]);
				break;
			default:
				throw new Error('Wrong number of arguments for a Rect');
		}
	},
	
	/**
	 * Set the value of all components for this <code>rect</code>. 
	 * @param {Core.Point} [origin=0] The new point of origin.
	 * @param {Core.Size} [size=0] The new rectangle size.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Rect for examples of supported calling styles.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setAll: function(origin, size)
	{
		this.constructor.apply(this, arguments);
		return this;
	},
	
	/**
	 * Duplicate the point of origin of this <code>rect</code>.
	 * @returns {Core.Point} A new rectangle with an identical origin and size.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	clone: function()
	{
		return new this.constructor(this);
	},
	
	/**
	 * Retrieve the point of origin for this <code>rect</code>.
	 * @returns {Core.Point} The current point of origin.
	 * @see Core.Rect#setOrigin
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getOrigin: function()
	{
		return this._origin;
	},
	
	/**
	 * Set the point of origin for this <code>rect</code>.
	 * @param {Core.Point} origin The new point of origin.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Rect#getOrigin
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setOrigin: function(origin)
	{
		this._origin.setAll(origin);
		return this;
	},
	
	/**
	 * Change the point of origin so that the center of this <code>rect</code> is at the specified location.
	 * @param {Core.Point} origin The new point of origin that results in a rectangle with a center position at the specified location.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Rect#setSizeCentered,
	 * @see Core.Rect#setOrigin
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setOriginCentered: function(origin)
	{
		origin = new Core.Point(origin);
		this._origin.setX(origin.getX() - this._size.getWidth()/2);
		this._origin.setY(origin.getY() - this._size.getHeight()/2);
		return this;
	},
	
	/**
	 * Retrieve the size of this <code>rect</code>.
	 * @returns {Core.Size} The current rectangle size.
	 * @see Core.Rect#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getSize: function()
	{
		return this._size;
	},
	
	/**
	 * Set the size of this <code>rect</code>.
	 * @param {Core.Size} size The new rectangle size.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Rect#getSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setSize: function(size)
	{
		this._size.setAll(size);
		return this;
	},
	
	/**
	 * Set the size of this <code>rect</code> and preserve the current center position.
	 * @param {Core.Size} size The new rectangle size that retains the current center position.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Rect#setOriginCentered,
	 * @see Core.Rect#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setSizeCentered: function(size)
	{
		var oldWidth = this._size.getWidth();
		var oldHeight = this._size.getHeight();
		
		this._size.setAll(size);

		this._origin.setX(this._origin.getX() + oldWidth/2 - this._size.getWidth()/2);
		this._origin.setY(this._origin.getY() + oldHeight/2 - this._size.getHeight()/2);
		return this;
	},
	
	/**
	 * Retrieve the minimum value for <i>x</i>. This is represented by the left coordinate.
	 * @returns {Number} The current minimum value of  the <i>x</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getMinX: function()
	{
		return this._origin.getX();
	},
	
	/**
	 * Retrieve the average of the minimum and maximum <i>x</i> values. This is the middle coordinate.
	 * @returns {Number} The current average of the minimum and maximum <i>x</i> coordinate values. 
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getMidX: function()
	{
		return this._origin.getX() +  this._size.getWidth()/2;
	},
	
	/**
	 * Retrieve the maximum value for <i>x</i>. This is the right coordinate.
	 * @returns {Number} The current maximum value of the <i>x</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getMaxX: function()
	{
		return this._origin.getX() + this._size.getWidth();
	},
	
	/**
	 * Retrieve the minimum value for <i>y</i>. This is the top coordinate.
	 * @returns {Number} The current minimum value of the <i>y</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getMinY: function()
	{
		return this._origin.getY();
	},
	
	/**
	 * Retrieve the average of the minimum and maximum <i>y</i> values. This is the middle coordinate.
	 * @returns {Number} The current average of the minimum and maximum <i>y</i> coordinate values.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getMidY: function()
	{
		return this._origin.getY() + this._size.getHeight()/2;
	},
	
	/**
	 * Retrieve the maximum value for <i>y</i>. This is the bottom coordinate.
	 * @returns {Number} The current maximum value of the <i>y</i> coordinate.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getMaxY: function()
	{
		return this._origin.getY() + this._size.getHeight();
	},
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/AbstractView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/AbstractView'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/AbstractView'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var Commands = require('NGCore/Client/UI/Commands').Commands;
var Rect = require('NGCore/Client/UI/ViewGeometry').Rect;
var ObjectRegistry = require('NGCore/Client/Core/ObjectRegistry').ObjectRegistry;
var Style = require('NGCore/Client/UI/Style').Style;

var stateMap = {
	'normal': Commands.State.Normal,
	'focused': Commands.State.Focused,
	'pressed': Commands.State.Pressed,
	'disabled': Commands.State.Disabled,
	//** extra-deprecated */
	'selected': Commands.State.Focused,
	'highlighted': Commands.State.Pressed
};

var AbstractView = exports.AbstractView = Element.subclass(
/** @lends UI.AbstractView.prototype */
{
	'type':'<com.ngmoco.view.abstract>',
	/**
	* @class The <code>AbstractView</code> class is a base class for derived classes that handle and manage application views.<br><br>
	* <b>Caution!:</b> This base class is not exported in the UI module. Do not access it or subclass it at runtime. 
	* Derived classes from <code>AbstractView</code> include:
	* <div class="ul">
	 * <li>{@link UI.Button}</li>
	 * <li>{@link UI.CellView}</li>
	 * <li>{@link UI.CheckBox}</li>
	 * <li>{@link UI.CheckoutView}</li>
	 * <li>{@link UI.DocumentView}</li>
	 * <li>{@link UI.EditText}</li>
	 * <li>{@link UI.GLView}</li>
	 * <li>{@link UI.Image}</li>
	 * <li>{@link UI.Label}</li>
	 * <li>{@link UI.Spinner}</li>
	 * <li>{@link UI.View}</li>
	 * <li>{@link UI.WebView}</li>
	 * </div>
	* @constructs The default constructor.
	* @augments UI.Element
	* @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	* @param {String} properties Object properties.
	*/
	initialize: function($super, properties) {
		if (AbstractView._init) AbstractView._init();
		
		this._assignedVisible = true;
		$super(properties);
	},
	
	/** @private */
	destroy: function($super){
		this.removeFromParent();
		$super();
	},
	
	/**
	 * @function 
	 * @description Retrieve the parent node for this view.
	 * @returns Returns the parent if this view is a child of another element. Otherwise, returns undefined.
	 * @see UI.AbstractView#addToParent,
	 * @see UI.AbstractView#removeFromParent
	 */    
	getParent: function(){
		return this._parent;
	},
    
	/**
	 * Add a node at the specified index to the specified parent node.
	 * @example var myParent = new UI.View({
	 * 	...
	 * });
	 * var childNode = new UI.View({
	 *	...
	 * });
	 * ...
	 * childNode.addToParent(myParent); 
	 * @function
	 * @param {Object} parentNode The parent node.
	 * @param {Number} [index] The parent node index location.
	 * @see UI.AbstractView#getParent,
	 * @see UI.AbstractView#removeFromParent
	 */    
	addToParent: function(parentNode, index){
		parentNode.addChild(this, index);
	},
    
	/**
	 * Remove a node from the parent node.
	 * @example childNode.removeFromParent(myParent);
	 * @function 
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see UI.AbstractView#getParent,
	 * @see UI.AbstractView#addToParent
	 */    
	removeFromParent: function(){
		if (this._parent && !this._parent._destroyed) {
			this._parent.removeChild(this);
			this._parent = null;
		}
		return this;
	},
	
	
	/**
	 * Add a new view state.
	 * @function 
	 * @example this.addState(UI.State.Disabled);
	 * @param {UI.State} flags View state flags supported by the new view state.
	 * @see UI.AbstractView#getState,
	 * @see UI.AbstractView#setState,
	 * @see UI.AbstractView#clearState
	 */  
	addState: function(flags) {
		this.setState(this._state | flags);
	},
	
	/**
	 * Clear the view state and set view state flags to the default value.
	 * @function 
	 * @example this.clearState(UI.State.Disabled);
	 * @param {UI.State} flags
	 * @see UI.AbstractView#getState,
	 * @see UI.AbstractView#setState,
	 * @see UI.AbstractView#addState
	 */  
	clearState: function(flags) {
		this.setState(this._state & ~flags);
	},
    
	/**
	 * Retrieve the root node for this object.
	 * @function 
	 * @returns Returns the root node if this is a child node. Otherwise, returns undefined.
	 */
	getRoot: function() {
		return this._parent ? this._parent.getRoot() : undefined;
	},
    

	/** @protected */
	_setVisible: function(makeVisible) {
		var willBeVisible = makeVisible && this._assignedVisible && this._parent && this._parent._visible;
		if (this._visible != willBeVisible) {
			this._visible = willBeVisible;
			var fn = (makeVisible ? this.getOnAppear() : this.getOnDisappear());
			if (typeof fn == 'function') fn.call(this);
		}
	},
	
	/**
	 * Cancel any running animations that apply to this object.
	 * @function
	 */
	clearAnimations: Commands.clearAnimations,
	
	/** Internal Use */
	$synthesizePropertyWithState: function(propName, commandsFn) {
		function doSynthesis(caseAdjusted, stateName, stateFlags) {
			var gName = 'get' + caseAdjusted;
			var sName = 'set' + caseAdjusted;
			var getterFn = function() {
				return this[gName].call(this, stateFlags);
			};
			var setterFn = function(val) {
				return this[sName].call(this, val, stateFlags);
			};

			this.registerAccessors( stateName + caseAdjusted, getterFn, setterFn );
		}
		Element.synthesizePropertyWithState.call(this, propName, commandsFn);
		// Synthesize stateful accessors.
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);
		for (var stateName in stateMap) {
			doSynthesis.call(this, caseAdjusted, stateName, stateMap[stateName]);
		}
	}
});

// Properties
AbstractView._init = function() {
	delete AbstractView._init;
	if (Element._init) Element._init();
	
	var getVisible = function() {
		return this._visible;
	};
	var setVisible = function(makeVisible) {
		this._assignedVisible = makeVisible;
		Commands.setIsVisible.call(this, makeVisible);
		this._setVisible(makeVisible);
	};
	/**
	 * @name UI.AbstractView#setVisible
	 * @description Set the visibility for this object.
	 * @example SomeView = new UI.View();
	 * ...
	 * SomeView.setVisible(true);
	 * @function 
	 * @param {boolean} makeVisible Set as <code>true</code> if this object is visible.
	 * @see UI.AbstractView#getVisible
	 */
	/**
	 * @name UI.AbstractView#getVisible
	 * @description Retrieve the state of visibility for this object.
	 * @function
	 * @returns {boolean} Returns <code>true</code> if this object is visible.
	 * @see UI.AbstractView#setVisible
	 */
	AbstractView.registerAccessors('visible', getVisible, setVisible);
	
	/**
	 * @name UI.AbstractView#setBackgroundColor
	 * @description Set the value for the <code>backgroundColor</code> property. This property defines the color of the background for an object when rendered.
	 * @example SomeView = new UI.View();
	 * ...
	 * SomeView.setBackgroundColor("FF000000");
	 * @param {String} backgroundColor The new background color.
	 * @see UI.AbstractView#getBackgroundColor
	 * @type Color
	 * @function
	 */
	/**
	 * @name UI.AbstractView#getBackgroundColor
	 * @description Retrieve the value of the <code>backgroundColor</code> property.
	 * @returns {String} The current background color.
	 * @see UI.AbstractView#setBackgroundColor
	 * @function
	 */
	AbstractView.synthesizeProperty('backgroundColor', Commands.setBackgroundColor);
	/**
	 * @name UI.AbstractView#setEnabled
	 * @description Set the value for the <code>enabled</code> property. This property defines an object as active or inactive.
	 * @param {Boolean} enabled Set as <code>true</code> if this view state is enabled.
	 * @see UI.AbstractView#getEnabled
	 * @function
	 */
	/**
	 * @name UI.AbstractView#getEnabled
	 * @description Retrieve the value of the <code>enabled</code> property. 
	 * @returns {Boolean} Returns <code>true</code> if this view state is enabled.
	 * @see UI.AbstractView#setEnabled
	 * @function
	 */
	
	AbstractView.synthesizeProperty('enabled', function(enable) {
		this[ (enable ? 'clearState' : 'setState') ](Commands.State.Disabled);
	});
	/**
	 * @name UI.AbstractView#setState
	 * @description Set the value for the <code>state</code> property. This property defines the view state for an object.
	 * @example cellView.setState(UI.State.Normal);
	 * @param {Number} state The new view state.
	 * @see UI.AbstractView#getState
	 * @type State
	 * @function
	 */
	/**
	 * @name UI.AbstractView#getState
	 * @description Retrieve the value of the <code>state</code> property.
	 * @returns {Number} The current view state.
	 * @see UI.AbstractView#setState
	 * @function
	 */
	AbstractView.synthesizeProperty('state', Commands.setState);

	
	/**
	 * @name UI.AbstractView#getFrame
	 * @description Retrieve the value of the <code>frame</code> property.
	 * @param {Number, Array (Number)} frame Individual components or a component array (<i>x</i>,<i>y</i>,<i>w</i>,<i>h</i>).
	 * @see UI.AbstractView#setFrame
	 * @function
	 */
	var getFrame = function() {
		return this._frame;
	};
	/**
	 * @name UI.AbstractView#setFrame
	 * @function 
	 * @description Set the value of the <code>frame</code> property. This property defines the size of <code>frame</code> objects.
	 * @example var back = new UI.Button();
	 * ...
	 * back.setFrame([10, 10, 64, 64]);
	 * @param {Number, Array (Number), Object} arg0 This parameter will pass in values in one of three ways:
	 * <div class="ul">
	 * <li>Four float values (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>).</li>
	 * <li>Single array containing the above four values.</li>
	 * <li>A rect specifying the frame (see <code>{@link UI.ViewGeometry.Rect}</code>).</li>
	 * </div>
	 * @see UI.AbstractView#getFrame
	 * @function
	 */
	var setFrame = function(arg0) {
		if (this.sizeChanged) {
			var w0 = this._frame ? this._frame[2] : 0;
			var h0 = this._frame ? this._frame[3] : 0;
		}
		
		if( arg0 instanceof Rect ){
			this._frame = arg0.array();
		}
		else if( arg0 instanceof Array ){
			this._frame = arg0;
		}
		else {
			this._frame = Array.prototype.slice.call(arguments);
		}
		//Don't allow this error to be thrown out of this method, as we are close to release and some code may be relying on the old behavior.  However, it would be worthwile to have a log of the error.
		try {
			if (!this._frame || isNaN(this._frame[0]) || isNaN(this._frame[1]) || isNaN(this._frame[2]) || isNaN(this._frame[3])) {
				throw new Error("Attempt to call setFrame with at least one undefined element: " + this._frame);
			}
		} catch (e) {
			NgLogException(e);
		}
		
		Commands.setFrame.apply(this, this._frame);
		
		if (this.sizeChanged && ((w0 ^ this._frame[2]) | (h0 ^ this._frame[3]))) {
			this.sizeChanged( this._frame[2], this._frame[3], w0, h0 );
		}
	};
	AbstractView.registerAccessors('frame', getFrame, setFrame);

	/**
	 * @name UI.AbstractView#setGradient
	 * @description Set the value of the <code>gradient</code> property for a view state. This property defines an image gradient for the object when rendered.
	 * @example label.setGradient({
	 *	corners: '11 11 11 11',
	 *	gradient: ['FFFF8000 0.0', 'FF703300 1.0']
	 * }, UI.State.Selected);
	 * @param {Object} gradient The new gradient. 
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @see UI.AbstractView#getGradient
	 * @function
	 */
	/**
	 * @name UI.AbstractView#getGradient
	 * @description Retrieve the value of the <code>gradient</code> property for a view state.
	 * @param {UI.State} [flags=UI.State.Normal] The UI view state.
	 * @returns {Object} The current gradient.
	 * @see UI.AbstractView#setGradient
	 * @function	
	 */
	AbstractView.synthesizePropertyWithState('gradient', Commands.setGradient);	
	/**
	 * @name UI.AbstractView#setBlockTouchEvents
	 * @description Set the value of the <code>blockTouchEvents</code> property.
	 * @param {Object} blockTouchEvents The new value for <code>blockTouchEvents</code>.
	 * @see UI.View#getBlockTouchEvents
	 * @function
	 */
	/**
	 * @name UI.AbstractView#getBlockTouchEvents
	 * @description Retrieve the value of the <code>blockTouchEvents</code> property.
	 * @returns {Object} The current value of <code>blockTouchEvents</code>.
	 * @see UI.View#setBlockTouchEvents
	 * @function
	 */
	AbstractView.synthesizeProperty('touchable', Commands.setTouchable);
	/**
	 * @name UI.AbstractView#setAlpha
	 * @function
	 * @description Set the value of the <code>alpha</code> property. This property defines the level of alpha composting for a specified object when rendered.
	 * @example this._node.setAlpha(1);
	 * @param {Number} decimal Alpha value ranging between <code>(0.0-1.0)</code>.
	 * @see UI.AbstractView#getAlpha
	 * @type Float
	 * @status iOS
	 */
	/**
	 * @name UI.AbstractView#getAlpha
	 * @function
	 * @description Retrieve the value of the <code>alpha</code> property.
	 * @returns {Number} Alpha value ranging between </code>(0.0-1.0)</code>.
	 * @see UI.AbstractView#setAlpha
	 * @type Float
	 * @status
	 */
	AbstractView.synthesizeProperty('alpha', Commands.setAlpha);

	AbstractView.synthesizeProperty('style', function(newStyle) {
		if (newStyle instanceof Style) {
			Commands.setStyle.call(this, ObjectRegistry.objectToId(newStyle));
		}
	});

	// Event Handlers
	/**
	 * @name UI.AbstractView#setOnAppear
	 * @description Set a function to call when the <code>appear</code> event occurs.
	 * @param {Function} appearCallback The new callback function. <br><br><b>Note:</b> The <code>appear</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example function() { 
	 *	onAppear.appear = true; 
	 * };
	 * @see UI.AbstractView#event:getOnAppear
	 * @event
	 */
	/**
	 * @name UI.AbstractView#getOnAppear
	 * @description Retrieve the function to call when the <code>appear</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnAppear
	 * @event
	 */
	AbstractView.registerEventType('appear');
	/**
	 * @name UI.AbstractView#setOnDisappear
	 * @description Set a function to call when the <code>disappear</code> event occurs.
	 * @param {Function} disappearCallback The new callback function. <br><br><b>Note:</b> The <code>disappear</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example function() { 
	 *	onDisappear.disappear = true; 
	 * };
	 * @see UI.AbstractView#event:getOnDisappear
	 * @event
	 */
	/**
	 * @name UI.AbstractView#getOnDisappear
	 * @description Retrieve a function to call when the <code>disappear</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnDisappear
	 * @event
	 */
	AbstractView.registerEventType('disappear');
	/**
	 * @name UI.AbstractView#setOnClick
	 * @description Set a function to call when the <code>click</code> event occurs.
	 * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The <code>click</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @example function() { 
	 *	onClick.clicked = true; 
	 * };
	 * @see UI.AbstractView#event:getOnClick
	 * @event
	 */
	/**
	 * @name UI.AbstractView#getOnClick
	 * @description Retrieve a function to call when the <code>click</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnClick
	 * @event
	 */
	AbstractView.registerEventType('click');
	
	AbstractView.registerEventType('clickDown');
	AbstractView.registerEventType('clickCancel');

	/**
	 * @name UI.AbstractView#setOnSwipe
	 * @description Set a function to call when a <code>swipe</code> event occurs. 
	 * This is when the user swipes a finger across this view, similar to how a user indicatea a "delete row"
	 * request on a table view.  The function gets the <code>UI.Commands.SwipeDirection</code> from 
	 * the first <code>parameter.direction</code>.  
	 * @example
	 * view.setOnSwipe( function(params) { 
	 *	NgLogD("swipe code "+params.direction) 
	 *   } 
	 * );
	 * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The <code>swipe</code> event is disabled 
	 * if the value of this parameter is not a function.
	 * @see UI.AbstractView#event:getOnSwipe
	 * @event
	 */
	/**
	 * @name UI.AbstractView#getOnSwipe
	 * @description Retrieve a function to call when the <code>swipe</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnSwipe
	 * @event
	 */
	AbstractView.registerEventType('swipe');
	/**
	 * @name UI.AbstractView#setOnLongPress
	 * @description Set a function to call when a user taps and holds on a view. 
	 * @param {Function} clickCallback The new callback function. <br><br><b>Note:</b> The event is disabled 
	 * if the value of this parameter is not a function.
	 * @example function() { 
	 *	onLongPress.longpress = true; 
	 * };
	 * @see UI.AbstractView#event:getOnLongPress
	 * @event
	 */
	/**
	 * @name UI.AbstractView#getOnLongPress
	 * @description Retrieve a function to call when a <code>tap and hold</code> event occurs.
	 * @returns {Function} The current callback function.
	 * @see UI.AbstractView#event:setOnLongPress
	 * @event
	 */
	AbstractView.registerEventType('longPress');

	/** @private NOT IMPLEMENTED */
	/*
		AbstractView.registerEventType('touchdown');
		AbstractView.registerEventType('touchup');
		AbstractView.registerEventType('touchmove');
		AbstractView.registerEventType('touchcancel');
	*/
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/WindowLayer'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/WindowLayer'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/WindowLayer'] = exports; var Element = require('NGCore/Client/UI/Element').Element;
var ViewParent = require('NGCore/Client/UI/ViewParent').ViewParent;
var Commands = require('NGCore/Client/UI/Commands').Commands;

/** @private
 * 	This ENTIRE CLASS is private.
 */
var WindowLayer = exports.WindowLayer = Element.subclass( {
	'type':'windowlayer',
	initialize: function($super, props) {
		if (WindowLayer.init) WindowLayer.init();
		$super(props);
		if (WindowLayer._init) WindowLayer._init();
		ViewParent.initialize.call(this);
		this._visible = true;
	},
	getRoot: function(){
		return this;
	},
	getParent: function(){
		return undefined;
	},
	
	getChildCount: ViewParent.getChildCount,
	getChildren: ViewParent.getChildren,
	addChild: ViewParent.addChild,
	removeChild: ViewParent.removeChild
});

WindowLayer.init = function() {
	delete WindowLayer._init;
	if (Element._init) Element._init();
	
	WindowLayer.synthesizeProperty('level', Commands.setIntValue);
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/UI/ViewParent'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/UI/ViewParent'] || {}; $MODULE_REGISTRY['NGCore/Client/UI/ViewParent'] = exports; var Commands = require('NGCore/Client/UI/Commands').Commands;
var AbstractView = require('NGCore/Client/UI/AbstractView').AbstractView;

// CAREFUL! THIS IS NOT A CLASS!
exports.ViewParent = {
	initialize : function() {
		this._children = [];
	},

	getChildCount : function() {
		return this._children.length;
	},

	getChildren : function() {
		return this._children.slice();
	},

	addChild : function(childNode,index) {
		if (childNode === this) throw new Error("Cannot add " + childNode + " as a child of itself!");
		if (childNode instanceof AbstractView) {
			if (childNode._parent) childNode.removeFromParent();

			if (index === 0 || index > 0) {
				index = +index;
				this._children.splice(index, 0, childNode);
			} else {
				index = -1;
				this._children.push(childNode);
			}

			// Must populate parent before setting visibility
			childNode._parent = this;
			childNode._setVisible(this._visible);

			Commands.addSubview.call(this, childNode.__objectRegistryId, index);

		} else throw new Error(this.type + ".addChild: " + childNode + " is not a view!");
		return this;
	},

	removeChild : function(childNode) {
		if (childNode instanceof AbstractView) {
			if (childNode._parent == this) {
				childNode._setVisible(false);

				// Remove this node from parent's child list
				var nodeIndex = this._children.indexOf(childNode);
				if (nodeIndex != -1) {
					this._children.splice(nodeIndex, 1);
				}
			}
			// Clear parent value
			childNode._parent = undefined;

			// Remove from the parent at the system level
			Commands.removeFromSuperview.call(childNode);
		} else throw {message: this.type + ".removeChild: " + childNode + " is not a view!"};
		return childNode;
	}

};; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeMath'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeMath'] || {}; $MODULE_REGISTRY['weEngine/WeMath'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-11-18
 *  @file:      WeMath.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by ngmoco:) llc
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:     We math defines some base types for us to use and to basically
 *              make my life a little easier
 */
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;

var _Vec2D = Core.Class.subclass({
	classname : 'Vec2D',

	initialize : function(X, Y) {
		this.x = X || 0;
		this.y = Y || 0;
	},

	length : function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	lengthSqr : function() {
		return this.x * this.x + this.y * this.y;
	},
	scale : function(scale) {
		return new _Vec2D(this.x * scale, this.y * scale);
	},
	scaleThis : function(scale) {
		this.x *= scale;
		this.y *= scale;
		return this;
	},
	floor : function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
	},

	toString : function() {
		return "Vec2D(" + this.x + ", " + this.y + ")";
	}
});

exports.Vec2D = _Vec2D;

exports.SubVec2D = function(lhs, rhs) {
	return new _Vec2D(lhs.x - rhs.x, lhs.y - rhs.y);
};

exports.AddVec2D = function(lhs, rhs) {
	return new _Vec2D(lhs.x + rhs.x, lhs.y + rhs.y);
};

exports.Distance2D = function(p0, p1) {
	var x = p1.x - p0.x;
	var y = p1.y - p0.y;
	return Math.sqrt(x * x + y * y);
};

exports.DistanceSqr2D = function(p0, p1) {
	var x = p1.x - p0.x;
	var y = p1.y - p0.y;
	var res = (x * x + y * y);
	return res;
};

exports.DistanceSqrRaw = function(p0x, p0y, p1x, p1y) {
	var x = p1x - p0x;
	var y = p1y - p0y;
	var res = (x * x + y * y);
	return res;
};

/**
 * For this function we are checking if a point is in bounds based on "Screen"
 * vector space. This assumes that 0,0 is at the upper Left hand side of the
 * world and X,Y is in the lower right hand side of the the world
 * @param {Vec2D} lowerRight point of the bounding square
 * @param {Vec2D} upperLeft point of the bounding square
 * @return {boolean} is the point in the box
 */
exports.IsInScreenBounds2D = function(lowerRight, upperLeft, point) {
	return lowerRight && upperLeft && point && lowerRight.x && lowerRight.y
			&& upperLeft.x && upperLeft.y && point.x && point.y
			&& lowerRight.x <= point.x && lowerRigth.y >= point.y
			&& upperleft.x >= point.x && lowerRight.y <= point.Y;
};

exports.Lerp = function(pOut, p0, p1, t) {
	pOut.x = p0.x + (p1.x - p0.x) * t;
	pOut.y = p0.y + (p1.y - p0.y) * t;
};

exports.FindParametricPoint2D = function(p0, p1, t) {
	return new _Vec2D(p0.x - p0.x * t + p1.x * t, p0.y - p0.y * t + p1.y * t);
};

exports.MidPoint2D = function(p0, p1) {
	// stop crash.
	p1 = p1 || p0;
	var t = 0.5;
	return new _Vec2D(p0.x - p0.x * t + p1.x * t, p0.y - p0.y * t + p1.y * t);
};

exports.Vec3D = Core.Class.subclass({
	classname : 'Vec3D',

	initialize : function(X, Y, Z) {
		this.x = X || 0;
		this.y = Y || 0;
		this.z = Z || 0;
	},

	toString : function() {
		return "x = " + this.x + ", y = " + this.y + ", z = " + this.z;
	},

	floor : function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeUiMgr'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeUiMgr'] || {}; $MODULE_REGISTRY['weEngine/WeUiMgr'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeUiMgr.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     Basic Singleton object that manages the loading and creation
///             of all game UI.  These UI defs are downloaded from a JSON object
///             located on the server.
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Bank = require('NGCore/Client/Bank').Bank;
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var WeScreen = require('weEngine/WeScreen2D').WeScreen;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var WeImageFactory = require('weEngine/WeImageFactory').WeImageFactory;
var WeCompositeFactory = require('weEngine/WeCompositeFactory').WeCompositeFactory;
var WeLabelFactory = require('weEngine/WeLabelFactory').WeLabelFactory;
var WeNode2D = require('weEngine/WeNode2D').WeNode2D;
var WeBoundaries = require('weEngine/WeBoundaries').WeBoundaries;
var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var WeRuleHome = require('weEngine/RulePlusHome').RuleHome;
var Storage = require('NGCore/Client/Storage').Storage;
var Social = require('NGCore/Client/Social').Social;
var UI = require('NGCore/Client/UI').UI;
var WeComposite  = require('weEngine/WeComposite').WeComposite;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry').ViewGeometry;

//////////////////////////////////////////////////////////////////////////////
/**
 * Class WeUiMgrDef
 */
var WeUiMgrDef = Core.Class.subclass(
{
	classname: 'WeUiMgr',
	
    initialize: function()
    {
        this.mActiveScreen = "IntroScreen";
        this.mJSONDef = null;
        this.mJSONGlobals = null;
        this.mIAPData = null;
		this.mSavedScrollPositions = {};
        this.mImageFactory = new WeImageFactory();
        this.mLabelFactory = new WeLabelFactory();
        this.mCompositeFactory = new WeCompositeFactory();
        this.mScreen = new WeScreen();
        this.mLoadingShown = false;
        this.mLoadingProgress = "";
        this.mMojoButton = false;
		this.mPercentRefs = {};	//object
    },

	addPercentRef : function(object)
	{
		if (!object.tag)
			return;
		this.mPercentRefs[object.tag] = object;
	},

	setPositionByPercent : function(objDef)
	{
		/* control position by percent */
		if (Exists(objDef.pos_x_percent) && !Exists(objDef.pos_x))
		{
			if (objDef.percent_parent_tag && this.mPercentRefs && this.mPercentRefs[objDef.percent_parent_tag])
			{
				var refObj = this.mPercentRefs[objDef.percent_parent_tag];
				objDef.pos_x = refObj.x_left + Math.floor(objDef.pos_x_percent * refObj.w + 0.5);
			}
			else
			{
				objDef.pos_x = Math.floor(objDef.pos_x_percent * gRawWidth + 0.5);
			}
		}
		if (Exists(objDef.pos_y_percent) && !Exists(objDef.pos_y))
		{
			if (objDef.percent_parent_tag && this.mPercentRefs && this.mPercentRefs[objDef.percent_parent_tag])
			{
				var refObj = this.mPercentRefs[objDef.percent_parent_tag];
				objDef.pos_y = refObj.y_top + Math.floor(objDef.pos_y_percent * refObj.h + 0.5);
			}
			else
			{
				objDef.pos_y = Math.floor(objDef.pos_y_percent * gRawHeight + 0.5);
			}
		}
		if (Exists(objDef.size_x_percent) && !Exists(objDef.size_x))
		{
			if (objDef.percent_parent_tag && this.mPercentRefs && this.mPercentRefs[objDef.percent_parent_tag])
			{
				var refObj = this.mPercentRefs[objDef.percent_parent_tag];
				objDef.size_x = Math.floor(objDef.size_x_percent * refObj.w + 0.5);
			}
			else
			{
				objDef.size_x = Math.floor(objDef.size_x_percent * gRawWidth + 0.5);
			}
		}
		if (Exists(objDef.size_y_percent) && !Exists(objDef.size_y))
		{
			if (objDef.percent_parent_tag && this.mPercentRefs && this.mPercentRefs[objDef.percent_parent_tag])
			{
				var refObj = this.mPercentRefs[objDef.percent_parent_tag];
				objDef.size_y = Math.floor(objDef.size_y_percent * refObj.h + 0.5);
			}
			else
			{
				objDef.size_y = Math.floor(objDef.size_y_percent * gRawHeight + 0.5);
			}
		}
	},

    GetMojoButtonClicked : function()
    {
    	var click =  this.mMojoButton;
    	this.mMojoButton = false;
    	return click;
    },

    GetImageFactory : function() { return this.mImageFactory; },
        
    GetLabelFactory : function() { return this.mLabelFactory; },
        
    GetCompositeFactory : function() { return this.mCompositeFactory; },
        
    GetJSONDef : function() { return this.mJSONDef; },
    
    GetJSONGlobals : function() {return this.mJSONGlobals; },
        
    GetScreen : function() { return this.mScreen; },

    GetActiveScreen : function() { return this.mActiveScreen; },

	SetLastScrollPosition : function(id, position) { this.mSavedScrollPositions[id] = position; },

	GetLastScrollPosition : function(id) { return this.mSavedScrollPositions[id]; },
	
	GetTouchLeeway : function()
	{ 
		this.kTouchLeeway = this.kTouchLeeway || 10 * Core.Capabilities.getScreenUnits(); // high pixels per inch gives more leeway on touch vs. drag
		return this.kTouchLeeway; 
	},
	
	InGameScreen_enter : function(lastScreen)
	{
		 WeGameStateMgr.ShowGameUI(true);
/*		//var gravity = UI.ViewGeometry.Gravity.TopLeft; 
		//var theme = "dark";
		Social.Common.Service.showCommunityButton([0.0,0.0], "dark", function(error)
		{
			NgLogD("ERROR showCommunityButton: "+error);
		}		
		);
*/	},
	
	InGameScreen_exit : function(lastScreen)
	{
/*		Social.Common.Service.hideCommunityButton(function(error)
				{
					NgLogD("ERROR hideCommunityButton: "+error);
				});
*/		
		 WeGameStateMgr.SetActiveObject(null);
	     WeGameStateMgr.SetPendingObject(null);
	     if(WeGameStateMgr.GetGameLotInfo())
	     {
	    	 WeGameStateMgr.GetGameLotInfo().ReleaseShellObject();
	     }
	},
	
	SocialMapScreen_enter : function(lastScreen)
	{
		Social.Common.Service.showCommunityButton([1.0,0.0], "dark", function(error)
		{
			NgLogD("ERROR showCommunityButton: "+error);
		}		
		);
	},
	
	SocialMapScreen_exit : function(lastScreen)
	{
		Social.Common.Service.hideCommunityButton(function(error)
				{
					NgLogD("ERROR hideCommunityButton: "+error);
				});
	},	
	
    IntroScreen_enter : function(lastScreen)
	{
		Social.Common.Service.showCommunityButton([1.0,0.0], "dark", function(error)
		{
			NgLogD("ERROR showCommunityButton: "+error);
		}		
		);
	},
	
	IntroScreen_exit : function(lastScreen)
	{
		Social.Common.Service.hideCommunityButton(function(error)
				{
					NgLogD("ERROR hideCommunityButton: "+error);
				});
	},
	
	BuildBuyScreen_enter : function(lastScreen)
	{
		/*
		var rect = new UI.ViewGeometry.Rect(10, 160, 58, 10);
		
		Social.Common.Service.showBalanceButton(rect, function(error)
		{
			NgLogD("ERROR showBalanceButton: "+error);
		}		
		);
		*/
		
	},
	
	BuildBuyScreen_exit : function(lastScreen)
	{
		Social.Common.Service.hideBalanceButton( function(error)
		{
			NgLogD("ERROR hideBalanceButton: "+error);
		}		
		);
		
		this.mLabelFactory.ShowLabels();
	},
	
	BuyMojoScreen_exit : function(lastScreen)
	{
		Social.Common.Service.hideBalanceButton( function(error)
		{
			NgLogD("ERROR hideBalanceButton: "+error);
		}		
		);
	},
	
	ObjectiveScreen_enter : function(lastScreen)
    {
    	if (WeGameStateMgr.IsCompletedObjective())
    	{
    		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.ObjectiveComplete);
    	}
    	else
    	{
    		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.NewObjective);
    	}
    },
    
    TransitionScreenTo : function(screenName)
    {
		// don't allow a screen transition if we don't have game lot data
		if (!Exists(WeGameStateMgr.mLot) || !Exists(WeGameStateMgr.GetGameLotInfo()))		
		{
			return; 
		}
        this.lastScreen = this.mActiveScreen;
        this.mActiveScreen = screenName;
        var gameFuncs = false; 
        if(Exists(this))
        {
            gameFuncs = true;
            var exitMethod = this.lastScreen + "_exit";
            if(Exists(this[exitMethod]))
            {
                this[exitMethod](screenName);
            }
        }

        if (screenName == "SpecialEventScreen") {	
			WeEventGame.refreshEventItems();
		}

        if (screenName == "RedesignScreen") {
        	WeGameStateMgr.GetCountLimits();
        }
        
        if (screenName !== "GiftingScreen")
        {
            WeGameStateMgr.mGiftingOpen = false;
        }
        
		if (screenName == "BuyMojoScreen")
		{
			if (this.mJSONDef["BuildBuyScreen"])
			{
				this.mJSONDef[screenName] = this.mJSONDef["BuildBuyScreen"];
			}
		}

        // Since the news web view is preloaded, we need to close it on every transition.  
        if(!this.IsNewsWindowClosed() && Exists(this.mNewsWebView))
        {
           NGWindow.document.removeChild(this.mNewsWebView);          
        }

        NgLogD("GO TO " + screenName);
        if(Exists(this.mJSONDef) && Exists(this.mJSONDef[screenName]))
        {
			//hack: it now shows "InGameScreen" then "ObjectiveScreen" is presented, no need to remove background screen
			if ((!(screenName  == "ObjectiveScreen" && this.lastScreen == "InGameScreen"))
			// && (!(screenName  == "GiftingScreen" && this.lastScreen == "InGameScreen"))
			)
			{
				this.DestroyUI();
			}
			this.CreateUI();  
        }

        if(gameFuncs)
        {
            var enterMethod = this.mActiveScreen + "_enter";
            if(Exists(this[enterMethod]))
            {
                this[enterMethod]();
            }
        }

        if (screenName == "BuyMojoScreen")
        {
        	Core.Analytics.reportNavigation("Main HUD", "Mojo Store", "Mojo Store Button");
        	
        	this.mMojoButton = true;
            var image = this.GetImageFactory().FindImageOfName("tab_mojo_store");
            image.OnTapEvent(null);
        }
        
        if (screenName == "SpecialEventScreen")
        {
            if (WeEventGame.isSpinnerEnabled() == false)
            {
                NgLogD("@@@ SWTICH TO STORE");
                WeUiMgr.switchToGameEventTab("se_store_tab");
            }
        }
        WeUiMgr.ShowLoading(false);
    },

	LoadJSONGlobals : function ()
	{
		var self = this;
        var fs = Storage.FileSystem;
		NgLogD('load screendef from: ' + GameSpecificVariables.Paths.screenDefFileDir + GameSpecificVariables.Paths.globalsFile);
		ReadFile(fs, GameSpecificVariables.Paths.screenDefFileDir + GameSpecificVariables.Paths.globalsFile, {'blocking': false}, function(err, data)
        {
            if (!err )
            {
                if (!Exists(self.mJSONGlobals))
                {
					self.mJSONGlobals = JSON.parse(data);
                }
            }
            else
            {
            	NgLogD ("Error loading global definitions from file!");
				WeUiMgr.ShowNetworkErrorPopUp();
            }
        });		
	},
	
	GetMTXForProtoId : function (protoId)
	{
		if(!Exists(	WeUiMgr.mIAPData ))
		{
			return null;
		}
	     var size = WeUiMgr.mIAPData.length;
         for(var index = 0; index < size; ++index)
         {
             if (Exists(WeUiMgr.mIAPData[index].entity) && WeUiMgr.mIAPData[index].entity == protoId)
             {
                 return WeUiMgr.mIAPData[index];
             }
         }
         
         return null;
	},

    RequestScreenInfo : function(cb)
    {
        cb = cb || null;
        var self = this;
        
        var screenInfo = WeRenderDevice.GetScreenInfo();
//        NgLogD("########  Screen Info");
//        objDump(screenInfo);
        var iWantWidth=screenInfo.mWidth;
        var iWantHeight=screenInfo.mHeight;
        if( iWantHeight > iWantWidth)
        {
            iWantWidth=screenInfo.mHeight;
            iWantHeight=screenInfo.mWidth;
        }

        var obj= GameSpecificVariables.SupportedResolutions;
        
    	var iMinX=Number.MAX_VALUE;
		var iMinY=Number.MAX_VALUE; 
		var iMinXYSum = Number.MAX_VALUE;
		var current=null;
		for(var i in obj)
		{
			var width= new Number( obj[i].match(/\d+/) );
			//NgLogD("########  width : " + width);
			var height= new Number( obj[i].slice(obj[i].indexOf("x")+1) );
			//NgLogD("########  height : " + height);
			
//			//if( (Math.abs( width - iWantWidth  ) <=  iMinX) && (Math.abs( height - iWantHeight  ) <=  iMinY) )
//			{
//				iMinX = Math.abs( width - iWantWidth  );
//				NgLogD("########  iMinX : " + iMinX);
//				iMinY = Math.abs( height - iWantHeight  );
//				NgLogD("########  iMinY : " + iMinY);
//				current=i;
//				NgLogD("########  current : " + current);
//				
//			}
			if( (Math.abs( width - iWantWidth  ) + Math.abs( height - iWantHeight  )) <=  iMinXYSum)
			{
				iMinXYSum = Math.abs( width - iWantWidth  ) + Math.abs( height - iWantHeight  );
				//NgLogD("########  iMinXYSum : " + iMinXYSum);
				iMinX = Math.abs( width - iWantWidth  );
				//NgLogD("########  iMinX : " + iMinX);
				iMinY = Math.abs( height - iWantHeight  );
				//NgLogD("########  iMinY : " + iMinY);
				current=i;
				//NgLogD("########  current : " + current);
			}	

		}
		
		GameSpecificVariables.GameResolution = getResolutionString();
		
		this.LoadJSONGlobals();
		    	
		var screenDefFile = GameSpecificVariables.Paths.screenDefFileStart + "" + gFixedWidth + "x" + gFixedHeight +".json";
		
        var fs = Storage.FileSystem;
        ReadFile(fs, GameSpecificVariables.Paths.screenDefFileDir + screenDefFile, {'blocking': false}, function(err, data)
        {

            if (!err )    // present, do comparison with downloaded proto config version.
            {
                //self.mScreen.HideLoadingImage();
                var results = WeUiMgr.LoadJSONDef(data); 
                if(cb && results)
                {
                    cb();
                }
            }
  
        });

    },

    DownloadScreenDef : function(screenDefFile, cb)
    { 
        var self = this;
        var theCB = cb;
        WeProtocol.getScreenDef(GameSpecificVariables.Paths.screenDefFileDirFromServer  + screenDefFile, function ( request )
        {
            try 
            {
                if ( request.readyState == 4 )
                { 
                    //  self.mScreen.HideLoadingImage();
                    var results = WeUiMgr.LoadJSONDef(request.responseText); 
                    if(theCB && results)
                    {
                        theCB();
                    }
                }
            }
            catch ( ex )
            {
                NgLogException ( ex );
                WeUiMgr.ShowNetworkErrorPopUp();
            }
        });
    },

    LoadJSONDef : function(text)
    {
        // Parse the json object
        try
        {
            var theJSON = JSON.parse(text);
            if(Exists(theJSON.tunable))
            {
                gTunables = theJSON.tunable;
            }
            if(Exists(theJSON.assets))
            {	// merge the theJSON.assets into gAssets ( a flat merge, not recursive), theJSON's values will override the default values
				for (var attrname in theJSON.assets)
				{
					gAssets[attrname] = theJSON.assets[attrname];
				}
            }
            if(this.mJSONDef)
            {
                this.DestroyUI();
            }
            this.mJSONDef = theJSON;
            this.CreateUI();
            return true;
        }
        catch ( ex )
        {
            NgLogException ( ex );
            NgLogD("TEXT = ");
            NgLogD(text);
            return false;
        }
    },

    LoadScreenArgs : function(args)
    {
        if(Exists(args.CameraMovable) && args.CameraMovable)
        {
            WeGameStateMgr.SetCameraMovable(true);
        }
        else
        {
            WeGameStateMgr.SetCameraMovable(false);
        }

        if(Exists(args.LotEditable) && args.LotEditable)
        {
            WeGameStateMgr.SetLotObjectsMovable(true);
        }
        else
        {
            WeGameStateMgr.SetLotObjectsMovable(false);
        }

        if(Exists(args.ShowChrome) && args.ShowChrome === 1)
        {
            //plus_chromeShow(true);
            NgLogD("Show chrome");
        }
        else
        {
            //plus_chromeHide(true);
            NgLogD("Hide chrome");
        }
    },
    
    LoadDefaultScreenArgs : function()
    {
        // by default the chrome is always showing
    },

	CreateView : function(view, screen)
	{
        var len = 0;
        var idx = 0;
      
		//get the reference frames for positioning images
		var percentRefArray = this.mJSONDef[view].percentRefs;
		if (Exists(percentRefArray))
		{
			for (var i = 0; i < percentRefArray.length; i++)
			{
				this.addPercentRef(percentRefArray[i]);
			}
		}

        var compositeArray = this.mJSONDef[view].composite;
        if(Exists(compositeArray))
        {
           for(var idx in compositeArray)
           {
        	   NgLogD("Creating CreateView "+compositeArray[idx].name);
               var composite = this.mCompositeFactory.CreateComposite(compositeArray[idx], screen.GetNode());
               this.mCompositeFactory.ManageComposite(composite);
           }
        }
        
        //REMOVE
        var compositesArray = this.mJSONDef[view].composites;
        if(compositesArray)
        {
            for(var idx in compositesArray)
            {
            	//NgLogD("CreateView composite "+compositesArray[idx].name );
            	var composite = WeUiMgr.CreateGameWidget(compositesArray[idx], null, screen.GetNode());
                // Construct the composite object
            	 this.mCompositeFactory.ManageComposite(composite);
            }
        }
		
               // first lets build out all the sprites
        var imageArray = this.mJSONDef[view].images;
        if(Exists(imageArray))
        {
            len = imageArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var image = this.mImageFactory.CreateImage(imageArray[idx], screen.GetNode(), null);
                if(image)
                {
	                this.mImageFactory.ManageImage(image);
	                
	                if(!screen.xChildren)
	                {
	                	screen.xChildren=[];
	                }
	                screen.xChildren.push(image);
	            	image.xParent=screen;
	
					if(this.mJSONDef[view]["args"] && this.mJSONDef[view]["args"]["EnabledTab"])
					{
						if (this.mJSONDef[view]["args"]["EnabledTab"] == imageArray[idx].name)
						{
							image.OnTapEvent(null);
						}
					}
                }
            }
        }
        
        var labelArray = this.mJSONDef[view].labels;
        if(Exists(labelArray))
        {
            len = labelArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var label = this.mLabelFactory.CreateLabel(labelArray[idx], screen.GetNode(), null);
                if(label)
                {
                    this.mLabelFactory.ManageLabel(label);
                }
            }
        }		
	},
	
	DestroyView : function (view)
	{
        var len = 0;
        var idx = 0;
        
        var compositeArray = this.mJSONDef[view].composite;
        if(Exists(compositeArray))
        {
            len = compositeArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var composite = this.mCompositeFactory.FindCompositeOfName(compositeArray[idx].name);
        		if (composite)
        		{
            		this.mCompositeFactory.ReleaseComposite(composite);
            		composite.destroy();
            	}
            }
        }
       
        var imageArray = this.mJSONDef[view].images;
        if(Exists(imageArray))
        {
            len = imageArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var image = this.mImageFactory.FindImageOfName(imageArray[idx].name);
        		if (image)
        		{
            		this.mImageFactory.ReleaseImage(image);
            		image.destroy();
            	}
            }
        }
        
        var labelArray = this.mJSONDef[view].labels;
        if(Exists(labelArray))
        {
            len = labelArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var label = this.mLabelFactory.FindLabelOfName(labelArray[idx].name);
                if(label)
                {
                	this.mLabelFactory.ReleaseLabel(label);
                    label.destroy();
                }
            }
        }		
	},

    CreateUI : function()
    {
    	var itemDef=this.mJSONDef[this.mActiveScreen];
		if(!Exists(itemDef))
			return;

		//get the reference frames for positioning images
		var percentRefArray = itemDef.percentRefs;
		if (Exists(percentRefArray))
		{
			for (var i = 0; i < percentRefArray.length; i++)
			{
				this.addPercentRef(percentRefArray[i]);
			}
		}

        var len = 0;
        var idx = 0;
        var compositeArray = itemDef.composite;
        if(Exists(compositeArray))
        {
           len = compositeArray.length;
           for(idx = 0; idx < len; ++idx)
           {
               // Construct the composite object
               var composite = this.mCompositeFactory.CreateComposite(compositeArray[idx], this.mScreen.GetNode());
               this.mCompositeFactory.ManageComposite(composite);
           }
        }
        
        var compositesArray = itemDef.composites;
        if(compositesArray)
        {
            for(var idx in compositesArray)
            {
            	NgLogD("CreateUI composite "+compositesArray[idx].name );
            	var composite = WeUiMgr.CreateGameWidget(compositesArray[idx], null, this.mScreen.GetNode());
                // Construct the composite object
            	 this.mCompositeFactory.ManageComposite(composite);
            }
        }
       
               // first lets build out all the sprites
        var imageArray = itemDef.images;
        if(Exists(imageArray))
        {
            len = imageArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var image = this.mImageFactory.CreateImage(imageArray[idx], this.mScreen.GetNode(), null);
                if(image)
                {
	                this.mImageFactory.ManageImage(image);
	                
	                if(!this.mScreen.xChildren)
	                {
	                	this.mScreen.xChildren=[];
	                }
	                
	                this.mScreen.xChildren.push(image);
	            	image.xParent=this.mScreen;
                }
            }
        }
        
        var labelArray = itemDef.labels;
        if(Exists(labelArray))
        {
            len = labelArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var label = this.mLabelFactory.CreateLabel(labelArray[idx], this.mScreen.GetNode(), null);
                if(label)
                {
                    this.mLabelFactory.ManageLabel(label);
                }
            }
        }
		
		var nativeArray = itemDef.nativeUI;
		if(Exists(nativeArray))
		{
			if(Core.Capabilities.getPlatformOS() != "flash")
			{
				len = nativeArray.length;
				for(idx = 0; idx < len; ++idx)
				{
					// for now we will handle this directly
					if(nativeArray[idx].tag == 'ad_view')
					{
							WeRuleHome.showAdWithArgs(	nativeArray[idx].pos_x,
														nativeArray[idx].pos_y,
														nativeArray[idx].size_x,
														nativeArray[idx].size_y);
					}
				}
			}
		}
		

        // Load the default args
        this.LoadDefaultScreenArgs();
        var args = itemDef.args;
        if(Exists(args))
        {
            this.LoadScreenArgs(args);
        }

        // Create the bounds and stop drawing the game screen if its not required
        if (this.mActiveScreen == "InGameScreen" || (this.mActiveScreen == "ObjectiveScreen" && this.lastScreen != "InGameScreen") || //it now shows "InGameScreen" then "ObjectiveScreen" is presented, no need to redraw  GetGameLot. Tadas R.
            /*(this.mActiveScreen == "GiftingScreen" && this.lastScreen != "InGameScreen") ||*/ this.mActiveScreen == "LevelUpScreen" || this.mActiveScreen == "RedesignScreen" ||
            this.mActiveScreen == "InGameScreen_Friend") // ObjectiveScreen too because the realm draws in the background.
        {
            var multiplier = WeGameStateMgr.GetGameLot().calculateLotMultiplier();
			this.mKingdomBoundaries = new WeBoundaries(WeRenderDevice.GetGameRoot(), multiplier);
			WeRenderDevice.GetScaleRoot().GetNode().setVisible(true);
        }
		else if (this.mActiveScreen == "IntroScreen" || (this.mActiveScreen == "ObjectiveScreen" && this.lastScreen == "InGameScreen") //HACK special case, this prevents a flicker when transitioning screens
		//		|| (this.mActiveScreen == "GiftingScreen" && this.lastScreen == "InGameScreen")
		) 
		{
			WeRenderDevice.GetScaleRoot().GetNode().setVisible(true);
		}
		else
		{
			// no reason to draw the game assets on any but the above screens
			WeRenderDevice.GetScaleRoot().GetNode().setVisible(false);
		}
		
		//play sound for objective screen
		if(this.mActiveScreen == "ObjectiveScreen"){
			WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.NewObjective);
		}

		// Force BuildBuy screen to have higher depth, in order to obscure
		// any popups
		if(this.mActiveScreen == "BuildBuyScreen")
		{
	//		this.mScreen.GetNode().setDepth(1);	
		}
		
		// process any pending jobs...
		if (WeGameStateMgr.IsCurrentUser() && this.mActiveScreen == "InGameScreen")
		{
			WeGameStateMgr.GetGameLotInfo().DisplayJobsReadyForPickup();
		}
    },

    DestroyUI : function()
    {
        if(Core.Capabilities.getPlatformOS() != "flash")
        {
            WeRuleHome.removeAd();
        } 

        this.ForceHideRealmsNavigation();
        // Clear out the global game widget 
        WeGameStateMgr.SetGlobalGameWidget(null);
        this.mLabelFactory.ReleaseLabels();
        this.mImageFactory.ReleaseImages();
        this.mCompositeFactory.ReleaseComposites();
        
        if(this.mKingdomBoundaries)
        {
            this.mKingdomBoundaries.destroy();
            this.mKingdomBoundaries = null;
        }
    },

    GetItemDef : function(itemName)
    {
        var itemDef = null;
        if( Exists(this.mJSONDef) && Exists(this.mJSONDef.items) && Exists(this.mJSONDef.items[itemName]))
        {
            itemDef = this.mJSONDef.items[itemName];
            itemDef.mItemName = itemName;
        }
        return itemDef;
    },
    
    CreateGameWidget : function(itemDef, args, parent)
    {
        if(!Exists(itemDef))
        {
            return null;
        }
		//get the reference frames for positioning images
		var percentRefArray = itemDef.percentRefs;
		if (Exists(percentRefArray))
		{
			for (var i = 0; i < percentRefArray.length; i++)
			{
				this.addPercentRef(percentRefArray[i]);
			}
		}

        if(!Exists(parent))
        {
            parent = WeRenderDevice.GetUiRoot();
        }
    
        var itemGroup = new WeComposite(parent);

        itemGroup.mX = 0;
        itemGroup.mY = 0;
        itemGroup.mZ = 0;
		itemGroup.mItemName = itemDef.mItemName;
         
        if(Exists(itemDef.pos_x))
        {
            itemGroup.mX = itemDef.pos_x;
        } 
        if(Exists(itemDef.pos_y))
        {
            itemGroup.mY = itemDef.pos_y;
        }
        if(Exists(itemDef.pos_z))
        {
            itemGroup.mZ = itemDef.pos_z;
            itemGroup.mTouchPriority = itemDef.pos_z;
        }
        
        if (Exists(itemDef.hide_idle))
        {
            itemGroup.hide_idle = itemDef.hide_idle;
        }
        else
        {
            itemGroup.hide_idle = false;
        }

        itemGroup.setPosition(itemGroup.mX, itemGroup.mY, itemGroup.mZ);

        if (Exists(itemDef.scale_x) && Exists(itemDef.scale_y))
        {
            itemGroup.setScale(itemDef.scale_x, itemDef.scale_y);
        }
        
        itemGroup.xWidth = 0;
        itemGroup.xHeight = 0;
        itemGroup.xItemDef = itemDef;
        itemGroup.xArgs = args;
		itemGroup.xCallbackList = [];
		itemGroup.xChildren = [];

        var len = 0;
        var compositeArray = itemDef.composite;

        if(Exists(compositeArray))
        {
            len = compositeArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                // Construct the composite object
                var composite = this.mCompositeFactory.CreateComposite(compositeArray[idx], itemGroup.GetGL2(), args);
                if(Exists(composite))
                {
					itemGroup.xChildren.push(composite);
                    if(Exists(composite.xController) && Exists(composite.xController.Display))
                    {
                        composite.xController.Display();
                    }
                }
            }
        }
        
        var len = 0;
        var compositeArray = itemDef.composites;

        if(Exists(itemDef.composites))
        {
            for(var idx in itemDef.composites)
            {
            	NgLogD("CreateGameWidget composite "+itemDef.composites[idx].name );
            	var composite = WeUiMgr.CreateGameWidget(itemDef.composites[idx], args, itemGroup.GetGL2());
                // Construct the composite object
                if(Exists(composite))
                {
					itemGroup.xChildren.push(composite);
                }
            }
        }

        // first lets build out all the sprites
        var imageArray = itemDef.images;
        if(Exists(imageArray))
        {
            len = imageArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var image = this.mImageFactory.CreateImage(imageArray[idx], itemGroup.GetGL2(), args);
                if(image)
                {
                	//REMOVE
                	//NgLogD("Adding to widget xChildren "+imageArray[idx].name);
					itemGroup.xChildren.push(image);
					image.xParent=itemGroup;
					// This allows composite controls to hook back into the sub-objects
					if (Exists(image.Callback))
					{
						itemGroup.xCallbackList.push(image);
					}
					
                    var boundsWidth = (Math.abs(image.GetX()) + image.GetWidth() * 0.5) * 1;
                    if(boundsWidth > itemGroup.xWidth)
                    {
                        itemGroup.xWidth = boundsWidth;
                    }
                    
                    var boundsHeight = (Math.abs(image.GetY()) + image.GetHeight() * 0.5) * 1;
                    if(boundsHeight > itemGroup.xHeight)
                    {
                        itemGroup.xHeight = boundsHeight;
                    }
                }
            }
        }


        var labelArray = itemDef.labels;
        if(Exists(labelArray))
        {
            len = labelArray.length;
            for(idx = 0; idx < len; ++idx)
            {
                var label = this.mLabelFactory.CreateLabel(labelArray[idx], itemGroup.GetGL2(), args);
				if (label)
				{
					itemGroup.xChildren.push(label);
					label.xParent=itemGroup;
				}
            }
        }

        // HACK - used by the harvest_item to de-highlight unavailable selections
        if (args && args.enabled === false)
        {
            itemGroup.setAlpha(0.5);
        }
        
        return itemGroup;
    },
    
    ShowLoading : function(flag)
    {
    	if (this.mLoadingShown && flag && this.loadingWidget) {
    		return;
    	}
    	WeUiMgr.mLoadingProgress = "";
    	this.mLoadingShown = flag;
    	
        NgLogD("SHOW LOADING " + flag);
       	// MEGA HACK to remove Building buble
    	if(WeGameStateMgr.GetActiveObject())
    	{
            WeGameStateMgr.GetActiveObject().CloseLotActionMenu();
    	}
    	if(WeGameStateMgr.GetGameLotInfo() !==null && WeGameStateMgr.GetGameLotInfo().mShellObject)
    	{
    		WeGameStateMgr.GetGameLotInfo().mShellObject.CloseLotActionMenu();
    	}
    	
        if (flag)
        {
            var args = {};
            var itemDef = WeUiMgr.GetItemDef("LoadingOverlay");
            var widget = WeUiMgr.CreateGameWidget(itemDef, args, WeRenderDevice.GetUiRoot());
			if (!widget)
			{
				return;
			}
            widget.setPosition(gRawWidth*0.5, gRawHeight*0.5); 

            this.loadingWidget = widget;
            
            this.spinner = new NGUI.Spinner();
            this.spinner.setFrame([gRawWidth*0.5-25,gRawHeight*0.5-25,50,50]);
			NGWindow.document.addChild(this.spinner);
        }
        else
        {
            if (Exists(this.loadingWidget))
            {
                NGWindow.document.removeChild(this.spinner);
				this.spinner = null;
                this.loadingWidget.destroy();
                this.loadingWidget = null;
                
            }
        }
    },
    
    SetRealmsNavigationTab: function(tab)
    {
    	this.mRealmsNavigationState=this.WindowState.CLOSED;
    	this.mRealmsNavigationClose=false;
    	this.mRealmsNavigationTab=tab;
    	
    	 tab.Olddestroy=tab.destroy;
    	 tab.destroy=function()
        {
        	if(this.mNumberAnimation)
        	{
				this.mNumberAnimation.Stop();
				this.mNumberAnimation=null;
        	}
        	this.Olddestroy();
        };
        
    },

    SetNewsTab: function(tab)
    {
    	this.SetNewsWindowState(this.WindowState.CLOSED);
    	this.mNewsWindowClose=false;
    	this.mNewsTab=tab;
    	
    	 tab.Olddestroy=tab.destroy;
    	 tab.destroy=function()
        {
        	if(this.mNumberAnimation)
        	{
				this.mNumberAnimation.Stop();
				this.mNumberAnimation=null;
        	}
        	this.Olddestroy();
        };
        
    },

    SetNewsTabLabel: function(label)
    {
        var self = this;
        this.mNewsTabLabel=label;

        label.Olddestroy=label.destroy;
        label.destroy=function()
        {
            if(this.mNumberAnimation)
            {
                this.mNumberAnimation.StopNoCallBack();
                this.mNumberAnimation=null;
            }
            if(self.mNewsWindow && self.mNewsWindow.mNumberAnimation)
            {
                self.mNewsWindow.mNumberAnimation.StopNoCallBack();
                self.mNewsWindow.mNumberAnimation=null;
            }
            if(self.mNewsTab && self.mNewsTab.mNumberAnimation)
            {
                self.mNewsTab.mNumberAnimation.StopNoCallBack();
                self.mNewsTab.mNumberAnimation=null;
            }
            if(self.mNewsWebView && self.mNewsWebView.mNumberAnimation)
            {
                self.mNewsWebView.mNumberAnimation.StopNoCallBack();
                self.mNewsWebView.mNumberAnimation=null;
            }
            this.Olddestroy();
            WeGameStateMgr.mGlobalGameWidget=null;
            if(self.mNewsWindow)
            {
                self.mNewsWindow.destroy();
                delete self.mNewsWindow;
                self.mNewsWindow=null;
            }
        };
    },

    SetNewsWebView: function(webView)
    {
        this.mNewsWebView=webView;

        webView.Olddestroy=webView.destroy;
        webView.destroy=function()
        {
            if(this.mNumberAnimation)
            {
                this.mNumberAnimation.Stop();
                this.mNumberAnimation=null;
            }
        };
    },
    
    WindowState :  
    { 
    	CLOSED : 0,
    	CLOSING : 1,
    	OPENED : 2,
    	OPENING : 3
    },

    ShowNewsWindow : function()
    {
    	if(this.mNewsWindowState==this.WindowState.CLOSED)
    	{	
	    	var itemDef=WeUiMgr.GetItemDef("news_window");
	        var gameWidget=WeUiMgr.CreateGameWidget(itemDef, null);
            var webView=this.mNewsWebView;
            var webViewFrame=webView.getFrame();
	        var nWidth=itemDef.args.size_x;
	        this.mNewsWindowWidth=nWidth;

	        var self=this;

	        var cNumberAnimation=new NumberAnimation(0.5, 0-nWidth*0.5, 0+nWidth*0.5);
	        var cNumberAnimation2=new NumberAnimation(0.5, self.mNewsTab.GetX(), self.mNewsTab.GetX()+nWidth);
            var cNumberAnimation3=new NumberAnimation(0.5, self.mNewsTabLabel.GetX(), self.mNewsTabLabel.GetX()+nWidth);
            var cNumberAnimation4=new NumberAnimation(0.5, webViewFrame[0], webViewFrame[0]+nWidth);
	        
    	    if(self.mNewsTab.mNumberAnimation)
    	    {
    	    	delete self.mNewsTab.mNumberAnimation;
    	    	self.mNewsTab.mNumberAnimation=null;
    	    }

            if(self.mNewsTabLabel.mNumberAnimation)
            {
                delete self.mNewsTabLabel.mNumberAnimation;
                self.mNewsTabLabel.mNumberAnimation=null;
            }

            if(self.mNewsWebView.mNumberAnimation)
            {
                delete self.mNewsWebView.mNumberAnimation;
                self.mNewsWebView.mNumberAnimation=null;
            }
	        
	        gameWidget.mNumberAnimation=cNumberAnimation;
	        self.mNewsTab.mNumberAnimation=cNumberAnimation2;
            self.mNewsTabLabel.mNumberAnimation=cNumberAnimation3;
            self.mNewsWebView.mNumberAnimation=cNumberAnimation4;
	        
	    	cNumberAnimation2.SetNumber=function(value)
		    {
                self.mNewsTab.SetPosition(value, self.mNewsTab.GetY());
		    };

            cNumberAnimation3.SetNumber=function(value)
            {
                self.mNewsTabLabel.SetPosition(value, self.mNewsTabLabel.GetY());
            };

            cNumberAnimation4.SetNumber=function(value)
            {
                webViewFrame[0]=value;
                NGWindow.document.removeChild(webView);
                webView.setFrame(webViewFrame);
                NGWindow.document.addChild(webView);
            };

	        cNumberAnimation.OnStop=function()
	        {
	        	self.SetNewsWindowState(self.WindowState.OPENED);
	        	
	        	if(self.mNewsWindowClose)
	        	{
	        		self.HideNewsWindow();
	        	}
	        };

	        cNumberAnimation.SetNumber=function(value)
	        {
                self.mNewsWindow.setPosition(value, gRawHeight*0.5); 
	        };
	        
	        this.mNewsWindow=gameWidget;
	
	        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
	        this.SetNewsWindowState(this.WindowState.OPENING);

	        self.mNewsWindow.OnExit(function()
	    	{
	        	if(cNumberAnimation)
	        	{
	        		cNumberAnimation.StopNoCallBack();
	        	}
	        	self.mNewsWindowState=self.WindowState.CLOSED;
	    	});	
        }
    },

    IsNewsWindowClosed : function()
    {
    	return this.mNewsWindowState==this.WindowState.CLOSED;
    },

    HideNewsWindow : function()
    {
    	if(this.mNewsWindowState==this.WindowState.OPENING)
    	{		
    		this.mNewsWindowClose=true;
    	}

    	if(this.mNewsWindowState==this.WindowState.OPENED)
    	{
    		var nWidth=this.mNewsWindowWidth;
            var webView=this.mNewsWebView;
            var webViewFrame=webView.getFrame();
    		var self=this;
    		
	        var cNumberAnimation=new NumberAnimation(0.5, 0+nWidth*0.5, 0-nWidth*0.5);
	        var cNumberAnimation2=new NumberAnimation(0.5, self.mNewsTab.GetX(), self.mNewsTab.GetX()-nWidth);
            var cNumberAnimation3=new NumberAnimation(0.5, self.mNewsTabLabel.GetX(), self.mNewsTabLabel.GetX()-nWidth);
            var cNumberAnimation4=new NumberAnimation(0.5, webViewFrame[0], webViewFrame[0]-nWidth);
	       
    	    if(self.mNewsWindow.mNumberAnimation)
    	    {
    	    	delete self.mNewsWindow.mNumberAnimation;
    	    	self.mNewsWindow.mNumberAnimation=null;
    	    }
    	    
    	    if(self.mNewsTab.mNumberAnimation)
    	    {
    	    	delete self.mNewsTab.mNumberAnimation;
    	    	self.mNewsTab.mNumberAnimation=null;
    	    }

            if(self.mNewsTabLabel.mNumberAnimation)
            {
                delete self.mNewsTabLabel.mNumberAnimation;
                self.mNewsTabLabel.mNumberAnimation=null;
            }

            if(self.mNewsWebView.mNumberAnimation)
            {
                delete self.mNewsWebView.mNumberAnimation;
                self.mNewsWebView.mNumberAnimation=null;
            }
    	    
    	    self.mNewsWindow.mNumberAnimation=cNumberAnimation;
	        self.mNewsTab.mNumberAnimation=cNumberAnimation2;
            self.mNewsTabLabel.mNumberAnimation=cNumberAnimation3;
            self.mNewsWebView.mNumberAnimation=cNumberAnimation4;
    	    
	    	cNumberAnimation2.SetNumber=function(value)
		    {
                self.mNewsTab.SetPosition(value, self.mNewsTab.GetY());
		    };

            cNumberAnimation3.SetNumber=function(value)
            {
                self.mNewsTabLabel.SetPosition(value, self.mNewsTabLabel.GetY());
            };

            cNumberAnimation4.SetNumber=function(value)
            {
                webViewFrame[0]=value;
                NGWindow.document.removeChild(webView);
                webView.setFrame(webViewFrame);
                NGWindow.document.addChild(webView);
            };
    	    
	        cNumberAnimation.OnStop=function()
	        {
	        	self.SetNewsWindowState(self.WindowState.CLOSED);
	        	self.mNewsWindow.destroy();
	        	delete self.mNewsWindow;
	        	self.mNewsWindow=null;
	        };

	        cNumberAnimation.SetNumber=function(value)
	        {
                self.mNewsWindow.setPosition(value, gRawHeight*0.5);
	        };

	        this.SetNewsWindowState(this.WindowState.CLOSING);
	        this.mNewsWindowClose=false;

	        self.mNewsWindow.OnExit(function()
	    	{
	        	if(cNumberAnimation)
	        	{
	        		cNumberAnimation.StopNoCallBack();
	        	}
	        	self.mNewsWindowState=self.WindowState.CLOSED;
	    	});	
    	}
    },
    
    SetNewsWindowState: function(state)
    {
    	this.mNewsWindowState=state;
    },
    
    ShowRealmsNavigation : function()
    {
    	if(this.mRealmsNavigationState==this.WindowState.CLOSED)
    	{	
    		
	    	var itemDef = WeUiMgr.GetItemDef("realms_navigation");
	        var gameWidget = WeUiMgr.CreateGameWidget(itemDef, null);

	        var nWidth=itemDef.args.size_x;
	        this.mRealmsNavigationWidth=nWidth;
	        var self=this;
	        	

	        var cNumberAnimation2= new NumberAnimation(0.5, self.mRealmsNavigationTab.mX, self.mRealmsNavigationTab.mX+nWidth);
	        
	    	cNumberAnimation2.SetNumber=function(value)
		    {
		       self.mRealmsNavigationTab.SetPosition(value, self.mRealmsNavigationTab.GetY());
		    };
		    
		    if(self.mRealmsNavigationTab.mNumberAnimation)
		    {
		    	self.mRealmsNavigationTab.mNumberAnimation.StopNoCallBack();
		    }
		    self.mRealmsNavigationTab.mNumberAnimation=cNumberAnimation2;
		    
		    if(!self.mRealmsNavigationTab.mOnExitAdded)
		    {
			    self.mRealmsNavigationTab.mOnExitAdded=true;
		        self.mRealmsNavigationTab.OnExit(function()
		    	{
		        	self.mRealmsNavigationTab.mOnExitAdded=false;
		        	if(self.mRealmsNavigationTab.mNumberAnimation)
		        	{
		        		self.mRealmsNavigationTab.mNumberAnimation.StopNoCallBack();
		        		self.mRealmsNavigationTab.mNumberAnimation=null;
		        	}
		        	self.mRealmsNavigationState=self.WindowState.CLOSED;
		    	});
    		}
		    
	        var cNumberAnimation= new NumberAnimation(0.5, 0-nWidth*0.5, 0+nWidth*0.5);
	        cNumberAnimation.OnStop=function()
	        {
	        	self.mRealmsNavigationState=self.WindowState.OPENED;
	        	
	        	if(self.mRealmsNavigationClose)
	        	{
	        		self.HideRealmsNavigation();
	        	}
	        };
	        cNumberAnimation.SetNumber=function(value)
	        {
	        	if(self.mRealmsNavigation && self.mRealmsNavigation!=undefined )
	        	{
	        		self.mRealmsNavigation.setPosition(value, gRawHeight*0.5); 
	        	}
	        };
	       	
	        self.mRealmsNavigation=gameWidget;
	        self.mRealmsNavigationState=this.WindowState.OPENING;
	        
	        self.mRealmsNavigation.OnExit(function()
	    	{
	        	if(cNumberAnimation)
	        	{
	        		cNumberAnimation.StopNoCallBack();
	        	}
	        	self.mRealmsNavigationState=self.WindowState.CLOSED;
	    	});	
	        
	        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
    	}
    },
    
    IsRealmsNavigationClosed : function()
    {
    	return this.mRealmsNavigationState==this.WindowState.CLOSED;
    },
    
    ForceHideRealmsNavigation: function()
    {
    	if(this.mRealmsNavigationState!=this.WindowState.CLOSED)
    	{
    		if(this.mRealmsNavigation)
    		{
    			// force set realmsNavigationTab position to original
    			this.mRealmsNavigationTab.SetPosition(this.mRealmsNavigationTab.mX, this.mRealmsNavigationTab.mY);
    			
    			this.mRealmsNavigationState=this.WindowState.CLOSED;
    			//WeGameStateMgr.SetGlobalGameWidget(null);
    			WeGameStateMgr.mGlobalGameWidget=null;
    			this.mRealmsNavigation.destroy();
    			delete this.mRealmsNavigation;
    			this.mRealmsNavigation=null;
    		}
    	}
    },
    
    HideRealmsNavigation : function()
    {
    	
    	if(this.mRealmsNavigationState==this.WindowState.OPENING)
    	{
    		this.mRealmsNavigationClose=true;
    	}
    	if(this.mRealmsNavigationState==this.WindowState.OPENED)
    	{
    		 var nWidth=this.mRealmsNavigationWidth;
    		var self=this;
    	    var cNumberAnimation2= new NumberAnimation(0.5,  self.mRealmsNavigationTab.mX+nWidth, self.mRealmsNavigationTab.mX);
	       
    	    if( self.mRealmsNavigationTab.mNumberAnimation)
    	    {
    	    	self.mRealmsNavigationTab.mNumberAnimation.StopNoCallBack();
    	    }
    	    
    	    self.mRealmsNavigationTab.mNumberAnimation=cNumberAnimation2;
    	    
	    	cNumberAnimation2.SetNumber=function(value)
		    {
		       self.mRealmsNavigationTab.SetPosition(value, self.mRealmsNavigationTab.GetY());
		    };
		    
		    if(!self.mRealmsNavigationTab.mOnExitAdded)
		    {
			    self.mRealmsNavigationTab.mOnExitAdded=true;
		        self.mRealmsNavigationTab.OnExit(function()
		    	{
		        	self.mRealmsNavigationTab.mOnExitAdded=false;
		        	if(self.mRealmsNavigationTab.mNumberAnimation)
		        	{
		        		self.mRealmsNavigationTab.mNumberAnimation.StopNoCallBack();
		        		self.mRealmsNavigationTab.mNumberAnimation=null;
		        	}
		        	self.mRealmsNavigationState=self.WindowState.CLOSED;
		    	});
    		} 
		    
		    var cNumberAnimation= new NumberAnimation(0.5,  0+nWidth*0.5, 0-nWidth*0.5);
	        cNumberAnimation.OnStop=function()
	        {
	        	self.mRealmsNavigationState=self.WindowState.CLOSED;
	        	self.mRealmsNavigation.destroy();
	        	delete self.mRealmsNavigation;
	        	self.mRealmsNavigation=null;
	        };

	        cNumberAnimation.SetNumber=function(value)
	        {
	        	if(self.mRealmsNavigation && self.mRealmsNavigation != undefined )
	        	{
	        		self.mRealmsNavigation.setPosition(value, gRawHeight*0.5);
	        	}
	        };
	        this.mRealmsNavigationState=this.WindowState.CLOSING;
	        this.mRealmsNavigationClose=false;
	        
	        self.mRealmsNavigation.OnExit(function()
	    	{
	        	if (cNumberAnimation)
	    	    {
	        		cNumberAnimation.StopNoCallBack();
	        		cNumberAnimation=null;
	    	    }
	    	    self.mRealmsNavigationState=self.WindowState.CLOSED; 	 
	        });       
    	}
    },

    CreateFullScreenWebView : function(url)
    {
        var itemDef = WeUiMgr.GetItemDef("fullScreenWebView");
        gameWidget = WeUiMgr.CreateGameWidget(itemDef, {fullScreenWebUrl:url});
        gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
        return gameWidget;
    },
    
    ShowOKDialog : function(cb, label, text)
    {
        var args            = {};
        args.OnOk           = cb
        args.popup_label    = label;
        args.popup_text     = text;
        var itemDef         = WeUiMgr.GetItemDef("popup_box");
        if (itemDef === null)
        {
            var alertDialog = new NGUI.AlertDialog();
    		alertDialog.setTitle(label);
    		alertDialog.setText(text);
    		alertDialog.setChoices(["OK"]);
    		alertDialog.onchoice  = function(event)
    		{
    				Device.LifecycleEmitter.exitProcess();
    		};
    		alertDialog.show();
            return;
        }
        var gameWidget      = WeUiMgr.CreateGameWidget(itemDef, args);
        gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    

        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
    },

    
    ShowNetworkErrorPopUp : function()
    {
        NgLogD("Showing network error popup...");

        var cb = function()
        {
            WeGameStateMgr.SetGlobalGameWidget(null);
			NgLogD("ShowNetworkErrorPopUp ok pressed: active screen is" + this.mActiveScreen);
            if(!WeGameStateMgr.GetGameLotInfo() || this.mActiveScreen == "IntroScreen")
            {
            	ExitGame();
            }
        };

        this.ShowOKDialog(cb, "Error!", "Connection Lost.\n\nUnable to connect to the server at this time, please try again in a little while.");
        
        
    },
    
    ShowAlertPopUp : function(title, message, cb)
    {
        var args = {};
        args.OnOk = function(args)
        {
        	if (Exists(cb))
            {
            	cb();
            }
        	
            WeGameStateMgr.SetGlobalGameWidget(null);
        };

        args.popup_label = title;
        args.popup_text = message;
        var itemDef = WeUiMgr.GetItemDef("popup_box");
        itemDef.z = 100;
        var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
        gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5, 100);    

        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
    },
    
    
    
    ShowTaskToast : function(goalName, taskName)
    {
    	var args = {};
    	args.goalName=goalName;
    	args.taskName=taskName;
		var itemDef = this.GetItemDef("task_toast");
		var gameWidget = this.CreateGameWidget(itemDef, args, this.mScreen.GetNode());
        
		this.mCompositeFactory.ManageComposite(gameWidget);
		return gameWidget;
		//gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
		//WeGameStateMgr.SetGlobalGameWidget(gameWidget);
    },
    
    ShowItemToBuild: function(proto_entity_id)
    {
    	var db = weProtoDb.getInstance();
    	
    	var type = null;
    	
    	var cProtoEntity = db.getProtoEntityById(proto_entity_id);
    	NgLogD("ShowItemToBuild "+cProtoEntity);
    	if(cProtoEntity)
    	{
    		var in_stash = db.getStoreItemStashCount(cProtoEntity);
            if(in_stash || cProtoEntity.gold_cost !== 0 || cProtoEntity.mana_cost !== 0
               || WeGameStateMgr.IsEventParticipationID(cProtoEntity.id))
            {
            	type=cProtoEntity.store_category;
            }
            
    	}
    	NgLogD("ShowItemToBuild type"+type);
    	
    	this.ShowItemToBuildType(proto_entity_id, type);
    },
    
    ShowItemToBuildNoMoneyManaTest: function(proto_entity_id)
    {
    	var db = weProtoDb.getInstance();
    	
    	var type = null;
    	
    	var cProtoEntity = db.getProtoEntityById(proto_entity_id);
    	NgLogD("ShowItemToBuild "+cProtoEntity);
    	if(cProtoEntity)
    	{
            type=cProtoEntity.store_category;  
    	}
    	NgLogD("ShowItemToBuild type "+type);
    	
		if (proto_entity_id)
		{
			// dismiss any full screen webview first
	    	WeGameStateMgr.SetPopupWidget(null);
	        WeGameStateMgr.SetGlobalGameWidget(null);

    		this.ShowItemToBuildType(proto_entity_id, type);
		}
    },
    
    ShowItemToBuildType: function(proto_entity_id, type)
    {
        if(type==null) return;
    	
    	this.TransitionScreenTo("BuildBuyScreen");
    	var tab_Names = 
    		{
    			"Featured" : "tab_featured",
    			"Building" : "tab_building",
    			"Decoration" : "tab_decoration",
    			"Tree" : "tab_tree",
    			"Upgrades" : "tab_upgrades",
    			"MojoStore" : "tab_mojo_store"
    		};
    	var image = this.GetImageFactory().FindImageOfName(tab_Names[type]);
    	image.OnTapEvent(null);
    	
    	var composite = WeUiMgr.GetCompositeFactory().FindCompositeOfName("featured_display");
    	var tempArray=composite.xController.mWidgetList;
    	for(var i=0; i<tempArray.length; i++)
    	{
    		var widget=tempArray[i];
    		if(widget.xItem.proto_id==proto_entity_id)
    		{
    			var area = composite.xController;
				var position = area.mScrollArea.getScrollPosition();
    			area.setPosition(new Core.Point(-widget.mX+widget.xWidth*0.5, 
    											position.getY()/*-widget.mY+widget.xHeight*0.5*/));
    			area.onUpdate();
    		}
    	}
    },
    
    m_cCaptureScreen : null,
	
    MoveOutImage: function(image)
    {
		if(image.animation)
		{
			image.animation.Stop();
			image.animation=null;
		}
		
		var cNumberAnimation= new NumberAnimation(1.5,  image.GetY(), image.GetY()+image.imageDef.args.offsetOutY);
		cNumberAnimation.SetNumber=function(value)
	    {
			image.SetPosition(image.GetX(), value);
	    };
	    cNumberAnimation.OnStop=function()
	    {
	    	image.SetVisible(false);
	    };
	    
	    image.OnExit(function()
	    {
	    	cNumberAnimation.Stop();
	    });
	    image.animation=cNumberAnimation;
	},
	
	ShowCaptureSelectionScreen: function(proto, params)
	{
	    // We interpret the data of the screen events_touch.
        itemDef = WeUiMgr.GetItemDef("events_touch");

        // We describe the screen.
    	itemDef.images[3].asset = proto.touch_free_tool_png;
    	itemDef.images[5].asset = proto.touch_mojo_tool_png;
    	itemDef.images[5].args["mojo_cost"] = proto.touch_mojo_cost;
        itemDef.images[9].asset = "capture/" + proto.large_image_png;

        // We describe rarity.
        for(var n = 0; n < 3; ++n) {
            itemDef.images[10 + n] = {
                "name" : n,
                "pos_x" : itemDef.labels[10].pos_x + 48 + 24 * n,
                "pos_y" : itemDef.labels[10].pos_y + 3,
                "pos_z" : 0.3,
                "size_x" : 24,
                "size_y" : 24,
                "asset" : getAssets("capture_rarity_star"),
                "tag" : "empty_touch"
            };
        }
        
        // We make the stars that are not given to the dragon dark.
        for (var n = 0; n < (3 - proto.rarity); ++n) {
            itemDef.images[12 - n].args = {
                "decoration" : "darken"
            }; 
        }
        
        // We describe the item.
        itemDef.labels[0].text = proto.touch_popup_title;
        itemDef.labels[1].text = proto.touch_free_tool_name;
        itemDef.labels[2].text = proto.touch_free_tool_description;
        itemDef.labels[4].text = proto.touch_mojo_tool_name;
        itemDef.labels[5].text = proto.touch_mojo_tool_description;
        itemDef.labels[7].text = proto.touch_mojo_cost;
        itemDef.labels[8].text = proto.proto_name;
        itemDef.labels[11].text = proto.reward_gold;
        itemDef.labels[12].text = proto.reward_xp;
        
        // We create a widget.
        gameWidget = WeUiMgr.CreateGameWidget(itemDef, params);
        gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
        
        // We activate the widget.
        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
	},
	
	ShowCaptureScreenConnectionError: function()
	{
		if(this.m_cCaptureScreen.canThrowError)
		{
			WeUiMgr.m_cCaptureScreen.capturing_error.SetVisible(true);
		}
	},
	
	m_CaptureScreenAnimationLeft : 5,
    
    ShowCaptureScreen: function(dragon)
    {
    	WeUiMgr.m_CaptureScreenAnimationLeft=5;
    	this.m_cCaptureScreen={};
    	//this.m_cCaptureScreen.users=["dev05","hundredabbz","wemob42","tadukynas","awmob2","wrqart","nerijus1","jeb1","vmctestrule","vmccotab"];
    	this.m_cCaptureScreen.dragon=dragon;

		WePests.setAnimationRunning( true );
    	this.TransitionScreenTo("CaptureScreen");
    	this.m_cCaptureScreen.canThrowError=true;
		if ( Exists(this.m_cCaptureScreen.close_capture_screen_btn) )
	    	this.m_cCaptureScreen.close_capture_screen_btn.SetVisible(false);
    },
    
    ShowCaptureFailScreen: function( pest )
    {
    	//{"proto_name":"Toad Dragon", "large_image_png":"dragoncommon4_large.png"}
    	
		var	db = weProtoDb.getInstance();
		var proto = db.mapIdToPest[pest.proto_id];
		if ( proto )
		{
    		this.m_cCaptureScreen.capturing_fail1.GetGL2().setText(proto.touch_failed_title);
	    	this.m_cCaptureScreen.capturing_fail2.GetGL2().setText(proto.touch_failed_description);
		}
		else
		{
			NgLogD("ERROR ShowCaptureFailScreen: proto is not found ");
		}
		
    	this.m_cCaptureScreen.capturing_fail1.SetVisible(true);  	
    	this.m_cCaptureScreen.capturing_fail2.SetVisible(true);

    	this.m_cCaptureScreen.canThrowError=false;
    	//Sign image moves out
    	this.MoveOutImage(WeUiMgr.m_cCaptureScreen.capturing_sign);
    	this.MoveOutImage(WeUiMgr.m_cCaptureScreen.dragon_image);

	    //fail image in
	    var image=WeUiMgr.m_cCaptureScreen.fail_image;
	   
	    var cNumberAnimation= new NumberAnimation(1.5,  image.GetY()+image.imageDef.args.offsetY, image.GetY());
	    image.SetPosition(image.GetX(), image.GetY()+image.imageDef.args.offsetY);
	    image.SetVisible(true);
		cNumberAnimation.SetNumber=function(value)
	    {
			image.SetPosition(image.GetX(), value);
	    };
	    
        cNumberAnimation.OnStop=function()
        {
			if( Exists( WeUiMgr.m_cCaptureScreen.close_capture_screen_btn ) )
			{
	  	    	WeUiMgr.m_cCaptureScreen.close_capture_screen_btn.SetVisible(true);
			}
        };
        
	    image.OnExit(function()
	    {
	    	cNumberAnimation.Stop();
	    });
    },
    
    ShowCaptureShareScreen: function(users, pest)
    {
    	//users=["dev05","hundredabbz","wemob42","tadukynas","awmob2","wrqart","nerijus1","jeb1","vmctestrule","vmccotab"];
    	
		var	db = weProtoDb.getInstance();
		var proto = db.mapIdToPest[pest.proto_id];
		if ( proto )
		{
    		this.m_cCaptureScreen.capturing_fail1.GetGL2().setText(proto.touch_succeeded_title);
    		this.m_cCaptureScreen.capturing_fail2.GetGL2().setText(proto.touch_succeeded_description);
	    	this.m_cCaptureScreen.capturing_fail1.SetVisible(true);
	    	this.m_cCaptureScreen.capturing_fail2.SetVisible(true);
		}
		else
		{
			NgLogD("ERROR ShowCaptureShareScreen: proto is not found ");
		}
		

    	this.m_cCaptureScreen.users=users;
    	
    	var animationLength = 1.5;
		if(Exists(gConfigs.PestCapturingSuccessAnimationSecond))
			animationLength = parseFloat(gConfigs.PestCapturingSuccessAnimationSecond);
		
		WeUiMgr.m_CaptureScreenAnimationLeft=animationLength+1;
    	
    	
    	
    	WeUiMgr.GetCompositeFactory().RebuildComposite("CaptureScreenList_h", "CaptureScreenList");
    	
    	this.m_cCaptureScreen.canThrowError=false;
    	
    	this.MoveOutImage(WeUiMgr.m_cCaptureScreen.capturing_sign);
    	
    	var bCreate=true;

	    var image=WeUiMgr.m_cCaptureScreen.capturing_success;
	    image.SetVisible(true);
		
	    var cNumberAnimation= new NumberAnimation(animationLength,  0, animationLength * 5);
		cNumberAnimation.SetNumber=function(value)
	    {
			if( Math.floor(value) % 2 == 0 )
			{
				WeUiMgr.m_cCaptureScreen.capturing_success.SetVisible( true );
				WeUiMgr.m_cCaptureScreen.capturing_success2.SetVisible( false );
			}
			else
			{
				WeUiMgr.m_cCaptureScreen.capturing_success.SetVisible( false );
				WeUiMgr.m_cCaptureScreen.capturing_success2.SetVisible( true );
			}
	    };
	    
        cNumberAnimation.OnStop=function()
        {
        	if(bCreate)
        	{
        		WeUiMgr._FadeDragon();
        		WeUiMgr.m_cCaptureScreen.capturing_success.SetVisible(false);
        		WeUiMgr.m_cCaptureScreen.capturing_success2.SetVisible(false);
        		WeUiMgr.m_cCaptureScreen.capturing_share_back.SetVisible(true);
				if (WeUiMgr.m_cCaptureScreen.capturing_composite && WeUiMgr.m_cCaptureScreen.capturing_composite.GetGL2())
				{
        			WeUiMgr.m_cCaptureScreen.capturing_composite.GetGL2().setVisible(true);
				}
		    	WeUiMgr.m_cCaptureScreen.capturing_fail1.SetVisible(false);  	
		    	WeUiMgr.m_cCaptureScreen.capturing_fail2.SetVisible(false);
        		//this._MoveIn(WeUiMgr.m_cCaptureScreen.capturing_share_back);
				if( Exists( WeUiMgr.m_cCaptureScreen.close_capture_screen_btn ) )
		  	    	WeUiMgr.m_cCaptureScreen.close_capture_screen_btn.SetVisible(true);
        	}
        };
        
	    image.OnExit(function()
	    {
	    	bCreate=false;
	    	cNumberAnimation.Stop();
	    });
    	
    	
    	/*
        //fail image in
	 
	    */
    },
    
    _FadeDragon: function()
    {
	    var image=WeUiMgr.m_cCaptureScreen.dragon_image;
	    image.SetVisible(true);
	    var cNumberAnimation= new NumberAnimation(1,  1.0, 0.0);
		cNumberAnimation.SetNumber=function(value)
	    {
			WeUiMgr.m_CaptureScreenAnimationLeft=value;
			image.SetAlpha(value);
	    };
	    
	    cNumberAnimation.OnStop=function()
	    {
	    	WeUiMgr.m_CaptureScreenAnimationLeft=-1;
	    	image.SetVisible(false);
	    };
	    
	    image.OnExit(function()
	    {
	    	cNumberAnimation.Stop();
	    });
    },
    
    _MoveIn: function(image, cb)
    {
    	var create=true;
	    //fail image in
	    image.SetVisible(true);
	    var cNumberAnimation= new NumberAnimation(1.5,  image.GetY()+image.imageDef.args.offsetY, image.GetY());
		cNumberAnimation.SetNumber=function(value)
	    {
			image.SetPosition(image.GetX(), value);
	    };
	    
	    cNumberAnimation.OnStop=function()
	    {
	    	if(cb && create)
	    	{
	    		cb();
	    	}
	    };
	    
	    image.OnExit(function()
	    {
	    	create=false;
	    	cNumberAnimation.Stop();
	    });
    },

	FindScreenImageOfName : function(name)
	{
    	var json = WeUiMgr.GetJSONDef();
        var activescreen = WeUiMgr.GetActiveScreen();
        var currentscreen = json[activescreen];

		for (var i in currentscreen.images)
		{
			if (currentscreen.images[i].name == name)
				return currentscreen.images[i];
		} 

		return undefined;
	},
	
	CreateImageWithDefAndAsset : function(oldDef, newAsset)
	{
		var newDef = ObjectUtils.GetCloneOfObject(oldDef);						
		newDef.asset = newAsset;
        if (this.mImageFactory)
		{
			var image = this.mImageFactory.CreateImage(newDef, WeUiMgr.GetScreen().GetNode());
			return image;
		}
		return null;
	},

	ShowFirstEarnEventPoints : function()
	{
		NgLogD("ShowFirstEarnEventPoints!");
		var newArgs = {};
		newArgs.popup_label = "Earned some points!";
		newArgs.popup_text = (Exists(gConfigs.firstTimeEarnEventPointText) && gConfigs.firstTimeEarnEventPointText) ? gConfigs.firstTimeEarnEventPointText : "You have earned some points! You can use them to buy the items in the store.";

		newArgs.OnOk = function(theNewArgs)
		{
		};

		var itemDef = this.GetItemDef("popup_box");
		var newGameWidget = this.CreateGameWidget(itemDef, newArgs);
		newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

		WeGameStateMgr.SetGlobalGameWidget(newGameWidget);		
	},

	ShowNotEnoughEventItem : function()
	{
		var newArgs = {};
		newArgs.popup_label = "You can not spin!";
		newArgs.popup_text = WeEventGame.getGameEventNoEventItemPopupText();

		newArgs.OnOk = function(theNewArgs)
		{
		};

		var itemDef = this.GetItemDef("popup_box");
		var newGameWidget = this.CreateGameWidget(itemDef, newArgs);
		newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

		WeGameStateMgr.SetGlobalGameWidget(newGameWidget);		
	},

	ShowNotEnoughMojoPopup : function()
	{
		var newArgs = {};
		newArgs.OnYes = function(theNewArgs)
		{
			WeUiMgr.TransitionScreenTo("BuyMojoScreen");
		};

		newArgs.OnNo = function(theNewArgs)
		{
		};
		newArgs.popup_label = "Oops!";
		newArgs.popup_text = "You don't have enough " + GameSpecificVariables.Texts.mojoTextU + ". Get more?";

		var itemDef = this.GetItemDef("popup_box");
		var newGameWidget = this.CreateGameWidget(itemDef, newArgs);
		newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

		WeGameStateMgr.SetGlobalGameWidget(newGameWidget);	
   },

	/* if we are in the current user's kingdom screen */
	isInOwnGameScreen : function()
	{
		return (this.mActiveScreen == "InGameScreen");
	}
});

exports.WeUiMgr = new WeUiMgrDef();

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Bank'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Bank'] || {}; $MODULE_REGISTRY['NGCore/Client/Bank'] = exports; 

exports.Bank = require('NGCore/Client/Social/US/Service/Bank').Bank;; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2'] = exports; /**
 * <p>Classes and objects contained by the GL2 module.</p>
 * @name GL2
 * @namespace
 * @description <p>The GL2 module is a collection of classes that support manipulation of visual effects and frameworks in an application.
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 * <ul>
 * <li><code>{@link GL2.Animation}</code>: Control animations in applications.</li>
 * <li><code>{@link GL2.Node}</code>: Control positionable screen elements.</li>
 * <li><code>{@link GL2.Primitive}</code>: Control the drawing of arbitrary vertex-based geometry.</li>
 * <li><code>{@link GL2.Root}</code>: A singleton that acts as a proxy object for the GLView node hierarchy 
 * (<code>Root</code> is the root element of the node hierarchy for GL2View).</li>
 * <li><code>{@link GL2.Sprite}</code>: Control resources for and use of application sprites.</li>
 * <li><code>{@link GL2.Text}</code>: Control resources for and use of application text.</li>
 * <li><code>{@link GL2.Touch}</code>: Control objects that track touch events for a device.</li>
 * <li><code>{@link GL2.TouchTarget}</code>: Control objects that support physical touch events on a device.</li>
 * <li><code>{@link GL2.RenderTarget}</code>: Render GL2 Nodes into a texture, which can then be attached to a GL.Animation</li>
 * </ul>
 * Games must instantiate a {@link UI.GLView} object, set the active state to <code>true</code> and wait for the callback before instantiating any objects in the GL2 class.
 */
exports.GL2 = {};

exports.GL2.__defineGetter__("Animation", function() {
	delete this.Animation;
	return this.Animation = require('NGCore/Client/GL2/Animation').Animation;
});
exports.GL2.__defineGetter__("Node", function() {
	delete this.Node;
	return this.Node = require('NGCore/Client/GL2/Node').Node;
});
exports.GL2.__defineGetter__("Primitive", function() {
	delete this.Primitive;
	return this.Primitive = require('NGCore/Client/GL2/Primitive').Primitive;
});
exports.GL2.__defineGetter__("Touch", function() {
	delete this.Touch;
	return this.Touch = require('NGCore/Client/GL2/Touch').Touch;
});
exports.GL2.__defineGetter__("TouchTarget", function() {
	delete this.TouchTarget;
	return this.TouchTarget = require('NGCore/Client/GL2/TouchTarget').TouchTarget;
});
exports.GL2.__defineGetter__("Root", function() {
	delete this.Root;
	return this.Root = require('NGCore/Client/GL2/Root').Root;
});
exports.GL2.__defineGetter__("Sprite", function() {
	delete this.Sprite;
	return this.Sprite = require('NGCore/Client/GL2/Sprite').Sprite;
});
exports.GL2.__defineGetter__("Text", function() {
	delete this.Text;
	return this.Text = require('NGCore/Client/GL2/Text').Text;
});
exports.GL2.__defineGetter__("RenderTarget", function() {
	delete this.RenderTarget;
	return this.RenderTarget = require('NGCore/Client/GL2/RenderTarget').RenderTarget;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeScreen2D'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeScreen2D'] || {}; $MODULE_REGISTRY['weEngine/WeScreen2D'] = exports; //////////////////////////////////////////////////////////////////////////////
/**
 * @file:      WeScreen2D.js
 * @author:    cjimison@gmail.com
 * @copyright: 2010 NGMOCO:) All rights reserved
 * 
 * @brief:     Defines the base screen type
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;

//////////////////////////////////////////////////////////////////////////////
/**
 * Class WeScreen2D
 * @brief:
 */
exports.WeScreen = Core.Class.subclass(
{
	classname: 'WeScreen',
	
    initialize: function()
    {
    },

    Setup : function(parent)
    {
        this.mNode = new GL2.Node();
        this.parent = parent || GL2.Root;
        parent.addChild(this.mNode);
    },

    destroy: function()
    {
        this.parent.removeChild(this.mNode);
        this.mNode.destroy();
    },

    GetNode : function() {	return this.mNode; }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeRenderDevice'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeRenderDevice'] || {}; $MODULE_REGISTRY['weEngine/WeRenderDevice'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeRenderDevice
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     The main Render device for the system.  This is also a 
///             singleton and should only ever have one instance per run.
//////////////////////////////////////////////////////////////////////////////

var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;

//////////////////////////////////////////////////////////////////////////////
// States
var States = {UNKNOWN:0, COMPLETE:1, PROCESS:2};

////////////////////////////////////////////////////////////////////////////////
// Class: WeGameRoot
// @param int width of the screen
// @param int height of the screen
// @param float, scale you are zoomed out at

var WeScaleRoot = Core.MessageListener.subclass(
{
	classname: 'WeScaleRoot',
	
    initialize: function(scale)
    {
        this.mNode = new GL2.Node();
        this.mNode.setPosition(0, 0);
        this.mNode.setScale(scale, scale);
        this.mXScale = scale;
    },
   
    GetNode: function()
    {
        return this.mNode;
    },
    
    GetScale: function()
    {
        return this.mNode.getScale();
    },
    
    SetScale: function(scaleX, scaleY)
    {
        scaleY = scaleY || scaleX;
        return this.mNode.setScale(scaleX, scaleY);
    }
});

//////////////////////////////////////////////////////////////////////////////
// Class: WeRenderDevice
exports.WeRenderDevice = Core.Class.singleton(
{
    initialize: function()
    {
		// screen space UI elements
        this.mUiRoot = new GL2.Node();
        this.mUiRoot.setDepth(2);
        GL2.Root.addChild(this.mUiRoot);
        
		// setup the main gamespace drawing node and sub-nodes
        this.mScaleRoot = new WeScaleRoot(gScale);
        this.mScaleRoot.mNode.setDepth(1);
        this.mTranslationRoot = new GL2.Node();
        
		// a node for gamespace UI elements
        this.mUiGameRoot = new GL2.Node();
        this.mUiGameRoot.setDepth(2);
		// a node for gamespace objects
        this.mGameRoot = new GL2.Node();
        this.mGameRoot.setDepth(1);
        
        this.mScaleRoot.mNode.addChild(this.mTranslationRoot);        
        this.mTranslationRoot.addChild(this.mGameRoot);
        this.mTranslationRoot.addChild(this.mUiGameRoot);

        GL2.Root.addChild(this.mScaleRoot.GetNode());

        this.mDisplayInfo = {};    
    },
    
    Setup: function(width, height)
    {
        this.mDisplayInfo.mHeight = height;
        this.mDisplayInfo.mWidth = width;  
    },

    EnableGame: function(bEnable)
    {
    	this.GetGameRoot().setVisible(bEnable);
    	this.GetGameUiRoot().setVisible(bEnable);
    },
    
    //////////////////////////////////////////////////////////////////////
    // Method: GetScreenInfo
    // @return Object{ mHeight, mWidth } container for the screen width and height
    GetScreenInfo : function(){ return this.mDisplayInfo; },

    //////////////////////////////////////////////////////////////////////
    // Method: GetRoot
    // @return NgGroup2D, root object for the UI system
    GetRoot : function(){ return GL2.Root; },
    
    //////////////////////////////////////////////////////////////////////
    // Method: GetGameRoot
    // @return NgGroup2D, the Game root.  Use this to attach game objects
    //                      to the scene
    GetGameRoot : function(){ return this.mGameRoot; },
    
    GetGameUiRoot : function(){ return this.mUiGameRoot; },
    
    //////////////////////////////////////////////////////////////////////
    // Method: GetUiRoot
    // @return NgGroup2D, the Game root.  Use this to attach game objects
    //                      to the scene
    GetGroundRoot : function(){ return this.mGameRoot; },
   
    GetScaleRoot : function(){ return this.mScaleRoot; },
    GetTranslationRoot : function(){ return this.mTranslationRoot; },

    //////////////////////////////////////////////////////////////////////
    // Method: GetUiRoot
    // @return NgGroup2D, the Game root.  Use this to attach game objects
    //                      to the scene
    GetUiRoot : function(){ return this.mUiRoot; },

    //////////////////////////////////////////////////////////////////////
    // Method: DebugGameRootLog
    // @return NgGroup2D, the Game root.  Print out debug info for each
    //         child
    DebugGameRootLog : function()
    {
        NgLogD("***************XXXXXXXXXXXXXXX*****************");
        PrintChildrenInfo(mGameRoot);
        NgLogD("***************XXXXXXXXXXXXXXX*****************");
    },

    //////////////////////////////////////////////////////////////////////
    // Method: ResetGameCamera
    ResetGameCamera : function()
    {
        this.mScaleRoot.mNode.setPosition(0, 0);
        this.mScaleRoot.SetScale(gScale);
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeImageFactory'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeImageFactory'] || {}; $MODULE_REGISTRY['weEngine/WeImageFactory'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeImageFactory.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     This Module knows how to construct a Image sprite
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var UI = require('NGCore/Client/UI').UI;

var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Content = require('weEngine/WeContent').Content;
var WeScreen = require('weEngine/WeScreen2D').WeScreen;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;
var WeFramedSprite2D = require('weEngine/WeSprite2D').WeFramedSprite2D;
var WeSocialMapMgr = require('weEngine/WeSocialMapMgr').WeSocialMapMgr;
var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;
var WeBoundary = require('weEngine/WeBoundary').WeBoundary;
var ViewGeometry = require('NGCore/Client/UI/ViewGeometry').ViewGeometry;
var WeRuleHome = require('weEngine/RulePlusHome').RuleHome;
var Social = require('NGCore/Client/Social').Social;
var WeCloudManager = require('weEngine/WeCloudMgr').WeCloudManager;
var WeRealms = require('weEngine/WeRealms').WeRealms;
var WeCoinsCrowns = require('weEngine/WeCoinsCrowns').WeCoinsCrowns;
var WeEventGame = require('weEngine/WeEventGame').WeEventGame;
var WeEventSpinner = require('weEngine/WeEventSpinner').WeEventSpinner;

exports.WeImageFactory = Core.Class.subclass(
{
	classname: 'WeImageFactory',
	
    initialize : function()
    {
        this.mFactoryImages = [];
        this.mDownloadingAvatars = [];
    },

    preloadNewsWebView: function()
    {
        // External conf
        var conf = WeUiMgr.mJSONDef.items.news_window.images[1];
        // Preload the news web view
        this.mNewsWebView = new UI.WebView({'frame': [conf.pos_x, conf.pos_y, conf.size_x, conf.size_y]});
        this.mNewsWebView.loadUrl(gConfigs.NewsUrl);
        this.mNewsWebView.setOnShouldload(function(event) 
        {
            if (event.url.indexOf("web://") >= 0)
            {
                NGWindow.document.mNewsWebView_full = new UI.WebView({'frame': [0, 0, gRawWidth, gRawHeight]});
                NGWindow.document.mNewsWebView_full.loadUrl(event.url.replace("web://", ""));
                NGWindow.document.addChild(NGWindow.document.mNewsWebView_full);
                return false;
            }
            else
            {
                return true;
            }
        });
        WeUiMgr.SetNewsWebView(this.mNewsWebView);
    },

    ReleaseImages : function()
    {
        var len = this.mFactoryImages.length;
        for(var idx = 0; idx < len; ++idx)
        {
            if (Exists(this.mFactoryImages[idx]))
            {
                this.mFactoryImages[idx].destroy();
                this.mFactoryImages[idx] = null;
            }
        }
        this.mFactoryImages = [];

        // Release the news web view
        if(Exists(this.mNewsWebView))
        {
            if(Exists(this.mNewsWebView.Olddestroy))
            {
                this.mNewsWebView.Olddestroy();
            }
            else
            {
                this.mNewsWebView.destroy();
            }
            this.mNewsWebView=null;
        }
    },

    ManageImage : function(image)
    {
        if(image)
        {
            this.mFactoryImages.push(image);
        }
    },

	ReleaseImage : function(image)
	{
		var len = this.mFactoryImages.length;
		for (var i = 0; i < len; i++)
		{
			if (this.mFactoryImages[i] === image)
			{
				this.mFactoryImages.splice(i,1);
				return;
			}
		}
	},

	FindImageOfName : function(name)
	{
		var len = this.mFactoryImages.length;
		for (var i = 0; i < len; i++)
		{
			if (this.mFactoryImages[i].xName == name)
			{
				return this.mFactoryImages[i];
			}
		}
		return undefined;
	},

    ProcessImageTag : function(imageDef, parent, args)
    {
        var handle = 'OnHandleTag_' + imageDef.tag;
        var image = null;
        if(Exists(this[handle]))
        {
            image = this[handle](imageDef, parent, args); 
        }
        return image;
    },
            
    CreateImage : function(imageDef, parent, args, wasTagProcessed)
    {
		WeUiMgr.setPositionByPercent(imageDef);

        if (imageDef.asset)
        {
          //NgLogD("WeCoinsCrowns image 1:" + imageDef.asset);
          if(WeCoinsCrowns.isCoinImage(imageDef.asset))
          {
        	  imageDef.asset = WeCoinsCrowns.getCoinsOrCrowns(imageDef.asset);
        	  //NgLogD("WeCoinsCrowns image 2:" + imageDef.asset);
        	  
    	  	  if (imageDef.anim)
    		  {
    	  		  	imageDef.anim = WeCoinsCrowns.getCoinsOrCrowns(imageDef.anim);
    		  }
          }
        	imageDef.asset = Content.getImagePath(imageDef.asset);
        }
        
        var image = null;
        if(!Exists(wasTagProcessed))
        {
            wasTagProcessed = false;
        }

		// Check to see if this image has been turned off
		if (Exists(imageDef.disabled) && imageDef.disabled)
		{
			return null;
		}
		
    	if(imageDef.OnSetSize)
    	{
    		var handle = 'OnSetSize_' + imageDef.OnSetSize;
	        if(Exists(this[handle]))
	        {
	            this[handle](imageDef, parent, args); 
	        }
    	}

        if(!wasTagProcessed && Exists(imageDef.tag) && "" !== imageDef.tag)
        {
            image = this.ProcessImageTag(imageDef, parent, args);
            
            if(image!=null && imageDef.args && imageDef.args.decoration )
            {
            	var handle = 'Decorate_' + imageDef.args.decoration;
            	this[handle](image, imageDef, parent, args);
            }
        }
        else
        {
			if (Exists(imageDef.anim))
			{
				image = new WeAnimatedSprite2D(parent, imageDef.anim, 0, false, 3);
				image.SetPosition(imageDef.pos_x,imageDef.pos_y,imageDef.pos_z);
				if(Exists(imageDef.scale_x))
					image.SetScale(imageDef.scale_x, imageDef.scale_y);
			}
			else
			{
		        var anchor = [0,0];
		        var pos= [imageDef.pos_x,imageDef.pos_y,  imageDef.pos_z];
		        
		        if(Exists(imageDef.anchor_x) && Exists(imageDef.anchor_y))
		        {
		            anchor[0] = imageDef.anchor_x;
		            anchor[1] = imageDef.anchor_y;
		        }
		        else
		        {
		        	pos[0]-=imageDef.size_x*0.5;
		        	pos[1]-=imageDef.size_y*0.5;
                }
		        
		        if(Exists(imageDef.uv))
		        {
		        	image = new WeFramedSprite2D(imageDef.asset,
		        	[imageDef.size_x, imageDef.size_y],
                    pos, 
                    imageDef.uv,
                    parent, anchor);
		        }
		        else
		        {
		        	image = new WeSprite2D( imageDef.asset, [imageDef.size_x, imageDef.size_y], pos, parent, anchor);
		        	
		        	if(Exists(imageDef.scale_x))
    					image.SetScale(imageDef.scale_x, imageDef.scale_y);
		        }
			}
            image.SetDepth(imageDef.pos_z || 0);

            // Optional tags
            if(Exists(imageDef.color_r) && Exists(imageDef.color_g) && Exists(imageDef.color_b))
            {
                image.SetColor(imageDef.color_r, imageDef.color_g, imageDef.color_b);
            }
            if(Exists(imageDef.color_a))
            {
                image.SetAlpha(imageDef.color_a);
            }
            if(Exists(imageDef.rotation))
            {
               // image.mRotation = imageDef.rotation;
               image.SetRotation(imageDef.rotation);
            }
            
            // Cache off an additional info
            if(Exists(imageDef.tag))
            {
                image.xTag =  imageDef.tag;
            }
            
			if(Exists(imageDef.name))
			{
				image.xName = imageDef.name;
			}

            if(Exists(imageDef.args))
            {
                image.xArgs =  imageDef.args;
            }
            
            image.mScaleTouchX = imageDef.scale_touch_x;
            image.mScaleTouchY = imageDef.scale_touch_y;

			image.xPosX = imageDef.pos_x;
			image.xPosY = imageDef.pos_y;
			image.xPosZ = imageDef.pos_z;
            
            if (Exists(imageDef.hide_idle))
            {
                image.hide_idle = imageDef.hide_idle;
            }
            else
            {
                image.hide_idle = false;
            }

            if(Exists(imageDef.args) && Exists(imageDef.args.sound))
            {
                image.mSound = imageDef.args.sound;
            }
        }
        
        if(Exists(imageDef.args) && Exists(imageDef.args.OnTapEvent))
        {
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true; };
            image.OnTapEvent = function (touch)
            {
                eval(imageDef.args.OnTapEvent);
                return true;
            };
        }
		
    	if(imageDef.asset_touch_down)
    	{
	        image.Enable("Touch");
	        image.OnTouchDown = function(touch)
			{
				NgLogD("Touch down:" + imageDef.asset_touch_down);
				image.SetImage(imageDef.asset_touch_down);
				return true;
			};
		    image.OnTouchEnd = function(touch) 
			{
				NgLogD("Touch end:" + imageDef.asset);
				image.SetImage(imageDef.asset);
				return true;
			};
    	}
        
        return image;
    },
    
    Decorate_darken: function(image, imageDef, parent, args)
    {
        image.SetColor(0, 0, 0, 0);
        return image;
    },
    
    Decorate_highlight_on_touch: function(image, imageDef, parent, args)
    {
    	if(imageDef.highlight_color_on && imageDef.highlight_color_off)
    	{
    		return this.Decorate_highlight_on_touch_color(image, imageDef, parent, args);
    	}
        image.MonkeyOnTouchDown=image.OnTouchDown;
        image.MonkeyOnTouchEnd=image.OnTouchEnd;
        image.MonkeyOnTapEvent=image.OnTapEvent;
		image.MonkeyOnTouchMove=image.OnTouchMove;
		image.mRerouteEvents = true;
        
        image.OnTouchDown = function(touch) 
		{
			DebugTouch(touch, "highlight OnTouchDown()");
			
			image.mRerouteEvents = true;
			if(image.mSpriteGL2!=null) 
			{ 
				image.SetColor(0.8, 0.8, 0.8, 1.0);
			} 
			return image.MonkeyOnTouchDown(touch); 
		};

	    image.OnTouchEnd = function(touch) 
		{
			DebugTouch(touch, "highlight OnTouchEnd()");
			
			if(image.mSpriteGL2!=null)
			{ 
				image.SetColor(255, 255, 255, 1); 
			} 
			return image.MonkeyOnTouchEnd(touch); 
		};

	    image.OnTapEvent = function(touch)
		{
			DebugTouch(touch, "highlight OnTapEvent()");
			
			if(image.mRerouteEvents && image.mSpriteGL2!=null) 
			{ 
				image.SetColor(255, 255, 255, 1); 
			} 
			return image.MonkeyOnTapEvent(touch); 
		};

		image.OnTouchMove = function(touch, delta)
		{
			if(image.mRerouteEvents && image.mSpriteGL2 && image.mTouchTarget) 
			{
				if(!touch.getIsInside(image.mTouchTarget))
				{
					image.mRerouteEvents = false;
					image.SetColor(255, 255, 255, 1);
                	return image.MonkeyOnTouchEnd(touch);
				}
			}
			return image.MonkeyOnTouchMove(touch, delta);
		};
	    return image;
    },
    
    Decorate_highlight_on_touch_color: function(image, imageDef, parent, args)
    {
    	var color_on=imageDef.highlight_color_on;
    	var color_off=imageDef.highlight_color_off;
        image.MonkeyOnTouchDown=image.OnTouchDown;
        image.MonkeyOnTouchEnd=image.OnTouchEnd;
        image.MonkeyOnTapEvent=image.OnTapEvent;
		image.MonkeyOnTouchMove=image.OnTouchMove;
		image.mRerouteEvents = true;
        
        image.OnTouchDown = function(touch) 
		{
			DebugTouch(touch, "highlight OnTouchDown()");
			
			image.mRerouteEvents = true;
			if(image.mSpriteGL2!=null) 
			{ 
				image.SetColor(color_on[0],color_on[1], color_on[2], color_on[3]);
			} 
			return image.MonkeyOnTouchDown(touch); 
		};

	    image.OnTouchEnd = function(touch) 
		{
			DebugTouch(touch, "highlight OnTouchEnd()");
			
			if(image.mSpriteGL2!=null)
			{ 
				image.SetColor(color_off[0],color_off[1], color_off[2], color_off[3]); 
			} 
			return image.MonkeyOnTouchEnd(touch); 
		};

	    image.OnTapEvent = function(touch)
		{
			DebugTouch(touch, "highlight OnTapEvent()");
			
			if(image.mRerouteEvents && image.mSpriteGL2!=null) 
			{ 
				image.SetColor(color_off[0],color_off[1], color_off[2], color_off[3]);  
			} 
			return image.MonkeyOnTapEvent(touch); 
		};

		image.OnTouchMove = function(touch, delta)
		{
			if(image.mRerouteEvents && image.mSpriteGL2 && image.mTouchTarget) 
			{
				if(!touch.getIsInside(image.mTouchTarget))
				{
					image.mRerouteEvents = false;
					image.SetColor(color_off[0],color_off[1], color_off[2], color_off[3]);
                	return image.MonkeyOnTouchEnd(touch);
				}
			}
			return image.MonkeyOnTouchMove(touch, delta);
		};
	    return image;
    },

    Decorate_highlight_on_touch_Xoom: function(image, imageDef, parent, args)
    {
        image.MonkeyOnTouchDown=image.OnTouchDown;
        image.MonkeyOnTouchEnd=image.OnTouchEnd;
        image.MonkeyOnTapEvent=image.OnTapEvent;
		image.mRerouteEvents = true;
        image.OnTouchDown = function(touch) 
		{ 
			image.mRerouteEvents = true;
			if(image.mSpriteGL2!=null) 
			{ 
				image.SetColor(0.8, 0.8, 0.8, 1.0);
			} 
			return image.MonkeyOnTouchDown(touch); 
		};
	    image.OnTouchEnd = function(touch) 
		{ 
			if( image.mSpriteGL2!=null)
			{ 
				image.SetColor(255, 255, 255, 1); 
			} 
			return image.MonkeyOnTouchEnd(touch); 
		};
	    image.OnTapEvent = function(touch)
		{ 
			if(image.mRerouteEvents && image.mSpriteGL2!=null) 
			{ 
				image.SetColor(255, 255, 255, 1); 
			} 
			return image.MonkeyOnTapEvent(touch); 
		};
	    return image;
    },
    Decorate_highlight_on_touch_alpha: function(image, imageDef, parent, args)
    	{
        image.MonkeyOnTouchDown=image.OnTouchDown;
        image.MonkeyOnTouchEnd=image.OnTouchEnd;
        image.MonkeyOnTapEvent=image.OnTapEvent;
        image.MonkeyOnTouchMove=image.OnTouchMove;
		image.mRerouteEvents = true;
        image.OnTouchDown = function(touch) 
		{ 
			DebugTouch(touch, "highlight_on_touch_alpha OnTouchDown()");
			image.mRerouteEvents = true;
			if(image.mSpriteGL2!=null) 
			{ 
				image.SetAlpha(0.3);
			} 
			return image.MonkeyOnTouchDown(touch); 
		};
	    image.OnTouchEnd = function(touch) 
		{ 
	    	DebugTouch(touch, "highlight_on_touch_alpha OnTouchEnd()");
			if( image.mSpriteGL2!=null)
			{ 
				image.SetAlpha(0); 
			} 
			return image.MonkeyOnTouchEnd(touch); 
		};
	    image.OnTapEvent = function(touch)
		{ 
	    	DebugTouch(touch, "highlight_on_touch_alpha OnTapEvent()");
			if(image.mRerouteEvents && image.mSpriteGL2!=null) 
			{ 
				image.SetAlpha(0); 
			} 
			return image.MonkeyOnTapEvent(touch); 
		};
		image.OnTouchMove = function(touch, delta)
		{
			if(image.mRerouteEvents && image.mSpriteGL2 && image.mTouchTarget) 
			{
///*
				image.mRerouteEvents = false;
				image.SetAlpha(0); 
            	return image.MonkeyOnTouchEnd(touch);
//*/
/*
				if(!touch.getIsInside(image.mTouchTarget))
				{
					image.mRerouteEvents = false;
					image.SetAlpha(0); 
                	return image.MonkeyOnTouchEnd(touch);
				}
//*/
			}
			return image.MonkeyOnTouchMove(touch, delta);
		};
	    return image;
    	},
    OnSetSize_FullScreen: function(imageDef, parent, args)
    {
    	imageDef.pos_x=0;
    	imageDef.pos_y=0;
    	imageDef.size_x=gRawWidth;
        imageDef.size_y=gRawHeight;
    },
    
    OnSetSize_CenterWidget: function(imageDef, parent, args)
    {
    	imageDef.pos_x=gRawWidth*0.5;
    	imageDef.pos_y=gRawHeight*0.5;    	
    },
    
    OnSetSize_FullScreenWidget: function(imageDef, parent, args)
    {
    	imageDef.pos_x=gRawWidth*0.5;
    	imageDef.pos_y=gRawHeight*0.5;
    	imageDef.size_x=gRawWidth;
        imageDef.size_y=gRawHeight;
    },
    
    OnSetSize_FullScreenObstruction: function(imageDef, parent, args)
    {
    	imageDef.pos_x=0;
    	imageDef.pos_y=0;
    	imageDef.size_x=gRawWidth*3;
        imageDef.size_y=gRawHeight*3;
    },
    
    OnSetSize_FullScreenWidgetObstruction: function(imageDef, parent, args)
    {
    	imageDef.pos_x=gRawWidth*0.5;
    	imageDef.pos_y=gRawHeight*0.5;
    	imageDef.size_x=gRawWidth*3;
        imageDef.size_y=gRawHeight*3;
    },
    
    OnSetSize_Relative: function(imageDef, parent, args)
    {
    
    	imageDef.pos_x*=gRawWidth;
    	imageDef.pos_y*=gRawHeight;
		imageDef.size_x*=gRawWidth;
	    imageDef.size_y*=gRawHeight;
    	
    },

    OnHandleTag_magic_net : function(imageDef, parent, args)
    {
    	//FIX
    	return this.OnHandleTag_events_touch_bought(imageDef, parent, args);
    },

    OnHandleTag_events_touch_bought : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        var targetArgs = args;
        var self = this;
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
			if ( imageDef.args["mojo_cost"] && WeGameStateMgr.GetGameLotInfo().mana < imageDef.args["mojo_cost"] )
			{ // not enough mana
				WeUiMgr.ShowNotEnoughMojoPopup();
			}
			else
			{
                self.confirmSpendMojoWithTarget(targetArgs);
			}
			return true;
        };
        image.Name = function() { return "OnHandleTag_magic_net"; };
        return image;
    },
    
    OnHandleTag_events_touch_free : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
			WeUiMgr.ShowCaptureScreen(args);	
            WeProtocol.touchPest(args.pest_id, false);
            WeGameStateMgr.SetGlobalGameWidget(null);
            return true;
        };
        image.Name = function() { return "OnHandleTag_events_touch_free"; };
        return image;
    },

	OnHandleTag_event_goal_pest_img : function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		newDef.asset = args.image;

		var image = this.CreateImage(newDef, parent, args, true);
		return image;
	},

    OnHandleTag_user_avatar : function(imageDef, parent, args)
    {
        var image;

        var self = this;
        var myparent = parent;
        var def = imageDef;
        if (Exists(WeGameStateMgr.mAvatarCache[Social.US.Session.getCurrentSession().user().gamertag]))
        {
            var ext = ParseAvatarExtension(WeGameStateMgr.mAvatarCache[Social.US.Session.getCurrentSession().user().gamertag]);
            imageDef.asset = Content.getAvatarPath(Social.US.Session.getCurrentSession().user().gamertag + "" + ext);
            imageDef.hide_idle = true;
            image = this.CreateImage(imageDef, parent, args, true);
        }
        else
        {
            imageDef.asset = getAssets( "crown" );
            var image = this.CreateImage(imageDef, parent, args, true);
            var myimage = image;
            Social.US.User.getUserWithGamertag(Social.US.Session.getCurrentSession().user().gamertag, function(err, usr)
            {
                if(usr && !err)
                {

                    WeGameStateMgr.mCurrentPhotoId = usr.photoId;
                    self.DownloadAvatar(usr, def, myparent, true, image);     
                
                }
                else
                {
                    NgLogD("*** AVATAR ERROR");
                }
            });
        }
        image.Enable("Touch");
        image.OnTouchDown = function(touch) {return true;}
        image.OnTapEvent = function(touch)
        {
            Social.Common.People.getCurrentUser(null, function(error, usr) {
                if(error)
                {
                    NgLogD(error.description);
                }
                else
                {
                    Social.Common.Service.openUserProfile(usr.id, function(err)
                    {
                        NgLogD(err.description);
                    });
                }
            });
            return true;
        };
        image.Name = function() { return "OnHandleTag_user_avatar"; }
        return image;
    },

    OnHandleTag_friend_avatar : function(imageDef, parent, args)
    {
        var image;
        var self = this;
        var myparent = parent;
        var def = imageDef;
        if (Exists(WeGameStateMgr.mAvatarCache[WeGameStateMgr.GetCurrentKingdomUser()]))
        {
            var ext = ParseAvatarExtension(WeGameStateMgr.mAvatarCache[WeGameStateMgr.GetCurrentKingdomUser()]);
            imageDef.asset = Content.getAvatarPath(WeGameStateMgr.GetCurrentKingdomUser() + "" + ext);
            image = this.CreateImage(imageDef, parent, args, true);   
        }
        else
        {
            imageDef.asset = getAssets( "crown" );
            var image = this.CreateImage(imageDef, parent, args, true);
            var myimage = image;
            Social.US.User.getUserWithGamertag(WeGameStateMgr.GetCurrentKingdomUser(), function(err, usr)
            {
                if(usr && !err)
                {
                    self.DownloadAvatar(usr, def, myparent, true, image);     
                }
                else
                {
                    NgLogD("*** AVATAR ERROR");
                }
            });
        }
        image.Name = function() { return "OnHandleTag_friend_avatar"; }
        return image;
    },

    OnHandleTag_social_avatar : function(imageDef, parent, args)
    {       
        var image;		
        var self = this;
        var myparent = parent;
        var def = imageDef;
        
        if (Exists(WeGameStateMgr.mAvatarCache[imageDef.args.gamertag]))
        {
            var ext = ParseAvatarExtension(WeGameStateMgr.mAvatarCache[imageDef.args.gamertag]);
            imageDef.asset = Content.getAvatarPath(imageDef.args.gamertag + "" + ext);
            image = this.CreateImage(imageDef, parent, args, true);
        }
        else
        {
            imageDef.asset = getAssets( "crown" );
            var image = this.CreateImage(imageDef, parent, args, true);
            var myimage = image;
            Social.US.User.getUserWithGamertag(imageDef.args.gamertag, function(err, usr)
            {
                if(usr && !err)
                {
                    self.DownloadAvatar(usr, def, myparent, true, image); 
                }
                else
                {
                    NgLogD("*** AVATAR ERROR");
                }
            });
        }
        image.Name = function() { return "OnHandleTag_social_avatar"; }
        return image;
    },
    
    OnHandleTag_change_state_notification : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
			NgLogD(">>> OnHandleTag_change_state_notification >>> push notify was " + (args.source.mEntity.push_notify ? "on" : "off"));		
            WeProtocol.updatePushNotificationsForEntity(args.source.mEntity.id, !args.source.mEntity.push_notify, function (proto, obj)
            {
				args.source.mEntity.push_notify = obj.entity.push_notify;
				NgLogD(">>> OnHandleTag_change_state_notification >>> push notify is now " + (args.source.mEntity.push_notify ? "on" : "off"));
            });
            return true;
        };
        image.Name = function() { return "OnHandleTag_change_state_notification"; };
        return image;
    },

    OnHandleTag_debug_reload : function(imageDef, parent, args)
    {
        //var newDef = ObjectUtils.GetCloneOfObject(imageDef);
        //newDef.asset = "SomeAsset.png";
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        { 
            gDownloadScreenDefs = true;
            WeUiMgr.RequestScreenInfo();
            return true;
        };
        image.Name = function(){ return "OnHandleTag_debug_reload"; };
        return image;
    },

    OnHandleTag_slow_goto_screen : function(imageDef, parent, args)
    {
        // Tests against a given function to see whether or not
        // to show the image.
        if (imageDef.args.enabledTest !== undefined)
        {
            var handle = "OnHandleArg_" + imageDef.args.enabledTest;
            if (Exists(this[handle]))
            {
                enabled = this[handle]();
                if (enabled === false)
                {
                    // don't even create the image - just bail...
                    return null;
                }
            }
        }
       
        var image = this.CreateImage(imageDef, parent, args, true); 
        var screen = imageDef.args.screen;
        image.Name = function(){ return "OnHandleTag_goto_screen"; };
        
        image.Enable("UpdateEmitter", function()
        {
            if (Exists(this.startTime))
            {
              if (Core.Time.getFrameTime()-this.startTime > 500)
              {
			      delete this.startTime; // ensures that this will never be called repeatedly
                  WeUiMgr.TransitionScreenTo(screen);
              }
            }
        });
        
        var levelRestriction = "";
        var levelMsg = "";
        if (imageDef.args.levelRestrictionType !== undefined)
        {
            levelRestriction = imageDef.args.levelRestrictionType;
        }
        
        if (imageDef.args.levelMsg !== undefined)
        {
            levelMsg = imageDef.args.levelMsg;
        }
        
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTouchMove = function(touch, delta) { return true;  };
        image.OnTapEvent = function(touch)
        {
            var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
            var level = 0;
            if (gameEvent && levelRestriction == "game_event")
            {
                level = gameEvent.unlock_level;
                levelMsg = levelMsg.replace("{level}", level);
            }
            
            if (WeGameStateMgr.GetGameLotInfo().mLevel < level)
            {
                var args = {};
    		    args.OnOk = function(args)
    		    {
    			    WeGameStateMgr.SetGlobalGameWidget(null);
    		    };
    		    
    		    args.popup_label = "Sorry!";
                args.popup_text = levelMsg;
    		    var itemDef = WeUiMgr.GetItemDef("popup_box");
    		    var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
    		    newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
    		    WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
                return true;
            }
            
            
            if (!Exists(this.startTime))
            {
                WeUiMgr.ShowLoading(true);
                this.startTime = Core.Time.getFrameTime();
            }
            return true;
        };
        
        return image;
    },
    
    OnHandleTag_goto_screen : function(imageDef, parent, args)
    {
        // Tests against a given function to see whether or not
        // to show the image.
        if (imageDef.args.enabledTest !== undefined)
        {
            var handle = "OnHandleArg_" + imageDef.args.enabledTest;
            if (Exists(this[handle]))
            {
                enabled = this[handle]();
                if (enabled === false)
                {
                	handle = "OnHandleArg_" + imageDef.args.enabledTest + "_Image";
                	if (Exists(this[handle]))
            		{
            			var image = this[handle](imageDef, parent, args);
            			if (image !== undefined)
            				return image;
            		}
                    // don't even create the image - just bail...
                    return null;
                }
            }
        }
       
        var image = this.CreateImage(imageDef, parent, args, true); 
        var screen = imageDef.args.screen;
        image.Name = function(){ return "OnHandleTag_goto_screen"; };
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
            WeUiMgr.TransitionScreenTo(screen);
            return true;
        };
        
        return image;
    },
    OnHandleTag_goto_screen_social_map : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_goto_screen_social_map"; };
        
        image.Enable("UpdateEmitter", function()
        {
            if (Exists(this.startTime))
            {
              if (Core.Time.getFrameTime()-this.startTime > 500)
              {
			      delete this.startTime; // ensures that this will never be called repeatedly
			      //NgLogD("Social map on button");
			      //WeSocialMapMgr.isCommunityMap = true;
                  WeSocialMapMgr.launchSocialMap(1);
              }
            }
        });
        
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
            //NgLogD("Heading to social screen");
            
            if (!Exists(this.startTime))
            {
                WeUiMgr.ShowLoading(true);
                this.startTime = Core.Time.getFrameTime();
            }
            return true;
        };
        
        return image;
    },
	OnHandleTag_goto_friend_kingdom : function(imageDef, parent, args)
	{
        var image = this.CreateImage(imageDef, parent, args, true);
		var kingdom_index = args;
        image.Name = function(){ return "OnHandleTag_goto_friend_kingdom"; };
        image.Enable("Touch");
        image.OnTouchDown = function(touch) {  return true;  };
        // have to override onTouchDown return true to get the other touch events
        image.OnTapEvent = function(touch)
        {
            NgLogD(">>>>>>>> Going to " + kingdom_index + ".");
			WeSocialMapMgr.gotoKingdomFromMap(kingdom_index);
            return true;
        };
        return image;
    },
    
    OnHandleTag_add_friend : function(imageDef, parent, args)
    {
        //NgLogD("*** ADD FRIEND CREATED")
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_goto_friend_kingdom"; };
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
			WeSocialMapMgr.addFriend();
			return true;
        };
        return image;
	},

    OnHandleTag_save_and_exit_redesign : function(imageDef, parent, args)
    {
        // Tests against a given function to see whether or not
        // to show the image.
        if (imageDef.args.enabledTest !== undefined)
        {
            var handle = "OnHandleArg_" + imageDef.args.enabledTest;
            if (Exists(this[handle]))
            {
                enabled = this[handle]();
                if (enabled === false)
                {
                    // don't even create the image - just bail...
                    return null;
                }
            }
        }
       
        var image = this.CreateImage(imageDef, parent, args, true); 
        var screen = imageDef.args.screen;
        image.Name = function(){ return "OnHandleTag_goto_screen"; };
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTouchUp = function(touch)
            {
                if(WeGameStateMgr.GetActiveObject())
                {
                    WeGameStateMgr.mLot.Unhighlight(WeGameStateMgr.GetActiveObject());
                    WeGameStateMgr.GetActiveObject().LostFocus();
                    WeGameStateMgr.SetActiveObject(null);
                }
                return true;
            };
        image.OnTapEvent = function(touch)
        {
            if(WeGameStateMgr.GetActiveObject())
            {
                WeGameStateMgr.mLot.Unhighlight(WeGameStateMgr.GetActiveObject());
                WeGameStateMgr.GetActiveObject().LostFocus();
                WeGameStateMgr.SetActiveObject(null);
            }
        	WeGameStateMgr.SendAllRelocatedBuildingToServer();
            WeUiMgr.TransitionScreenTo(screen);
            return true;
        };
        
        return image;
    },
    
    OnHandleTag_task_toast_flag: function(imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
		if(!image)
		{
			objDump(imageDef);
			return null;
		}
		
    	var cNumberAnimation= new NumberAnimation(0.5,  0.0, 1.0);

		cNumberAnimation.SetNumber=function(value)
	    {
			image.mSpriteGL2.setImage(imageDef.asset, [ imageDef.size_x*value, imageDef.size_y], [0,0], [0.0, 0.0, 1.0*value , 1.0 ]);
			var x=imageDef.pos_x-imageDef.size_x*0.5;
            var y=imageDef.pos_y-imageDef.size_y*0.5;
			image.SetPosition(x+imageDef.size_x-(value)*imageDef.size_x,y,imageDef.pos_z);
			
	    };
	    
	    cNumberAnimation.OnStop=function()
	    {
			children=image.xParent.xChildren;
	    	for(var i=0; i <children.length; i++  )
	    	{
	    		if( Exists( children[i].mTextGL2) )
	    		{
	    			if(children[i].xName=="task_toast_goal")
	    			{
	    				children[i].SetAlpha(1.0);
	    			}
	    			else if (children[i].xName=="task_toast_task")
	    			{
	    				children[i].SetAlpha(1.0);
	    			}
	    		}
	    	}
	    }
	    

	    
	   // cNumberAnimation.onUpdate();
	    
	    image.OnExit(function()
	    {
	    	cNumberAnimation.Stop();
	    });
	    
		var cTimer= new Timer(4, function()
	    {
			children=image.xParent.xChildren;
	    	for(var i=0; i <children.length; i++  )
	    	{
	    		if( Exists( children[i].mTextGL2) )
	    		{
	    			if(children[i].xName=="task_toast_goal")
	    			{
	    				children[i].SetAlpha(0.0);
	    			}
	    			else if (children[i].xName=="task_toast_task")
	    			{
	    				children[i].SetAlpha(0.0);
	    			}
	    		}
	    	}
			
	    	var cNumberAnimation2= new NumberAnimation(0.5,  0.0, 1.0);

	    	cNumberAnimation2.SetNumber=function(value)
		    {
				value=1.0-value;
				image.mSpriteGL2.setImage(imageDef.asset, [ imageDef.size_x*value, imageDef.size_y], [0,0], [0.0, 0.0, 1.0*value , 1.0 ]);
				var x=imageDef.pos_x-imageDef.size_x*0.5;
	            var y=imageDef.pos_y-imageDef.size_y*0.5;
				image.SetPosition(x+imageDef.size_x-(value)*imageDef.size_x,y,imageDef.pos_z);
		    };
		    
		    image.OnExit(function()
		    {
		    	cNumberAnimation2.Stop();
		    	//image.xParent.destroy();
		    });
	    }
		);
		
	    image.OnExit(function()
	    {
	    	cTimer.StopNoCallBack();
	    });
		
		return image;
    },
    
    OnHandleTag_newsWebView: function(imageDef, parent, args)
    {
		var image = this.CreateImage(imageDef, parent, args, true);
        var self = this;
        this.mNewsWebView_visible = true;
		parent.webViewHack=this.mNewsWebView;
		NGWindow.document.addChild(this.mNewsWebView);
		image.OnExit(function()
		{
	    	if(self.mNewsWebView_visible)
			{
				NGWindow.document.removeChild(self.mNewsWebView);
                self.mNewsWebView_visible = false;
			}
		});
    	return image;
    },
    
    OnHandleTag_close_new_tab: function(imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	image.Enable("Touch");
    	  image.OnTouchUp = function(touch) { return true; };
          image.OnTapEvent = function(touch){ return true; };
    	 image.OnTouchDown = function(touch)
         {
    		args.OnTouch(touch);
         	return true;
         }
    	 return image;
    },

    OnHandleTag_display_news_window: function(imageDef, parent, args)
    {
        if(WeUiMgr.mActiveScreen == "SocialMapScreen")
        {
            imageDef.hide_idle = false;
        }
    	var image = this.CreateImage(imageDef, parent, args, true);
    	WeUiMgr.SetNewsTab(image);
    	
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
        	if(WeUiMgr.IsNewsWindowClosed())
        	{
                WeUiMgr.ShowNewsWindow();
        	}
        	else
        	{
        		WeGameStateMgr.SetGlobalGameWidget(null);
        	}
            return true;
        };

        // Preload the news web view
        this.preloadNewsWebView();

    	return image;
    },
  
    OnHandleTag_display_realms_navigation: function(imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	
    	//WeUiMgr.SetRealmsNavigationTab(image);

    	
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
        	if(WeUiMgr.IsRealmsNavigationClosed())
        	{
        		WeRealms.CreateRealmsData();
                WeUiMgr.ShowRealmsNavigation();
        	}
        	else
        	{
        		WeGameStateMgr.SetGlobalGameWidget(null);
        	}
            return true;
        };
    	return image;
    },
    
    mMojoItems_semaphore : true,

    OnHandleTag_mojo_item_bought : function(imageDef, parent, args)
    {    	
        var image = this.CreateImage(imageDef, parent, args, true); 
        var localImageDef = args;
        //var isOfLevel = (args.required_level <= WeGameStateMgr.GetGameLotInfo().mLevel);
        //var self=this;

        image.Name = function(){ return "OnHandleTag_mojo_item_bought"; };
        var tempID = args.product_identifier;
        var tempMojo = args.mojo;
        var self=this;
        
            // Create the on touch event for this item in the store
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        
        /*
	    image.OnTouchDown = function(touch) 
		{
			image.mTouchDownPos = touch.getPosition();
			image.SetColor(255, 255, 255, .6); 
			return true;  
		};
	    image.OnTouchEnd = function(touch) { image.SetColor(255, 255, 255, 1); return true; };
		image.OnTouchMove = function(touch, delta) 
		{
			var pos = touch.getPosition();
			if (Exists(image.mTouchDownPos))
			{
			    var dx = pos.getX() - image.mTouchDownPos.getX();
    			var dy = pos.getY() - image.mTouchDownPos.getY();
    			if(dx*dx + dy*dy > WeUiMgr.GetTouchLeeway())
    				return image.OnTouchEnd(touch); 
			}
			return true;
		};              
        */        
        
        image.OnTapEvent = function( touch )
        {   // we CAN buy this
        	//NgLogD("OnHandleTag_mojo_item_bought OnTapEvent");
        	if(!self.mMojoItems_semaphore) return true;
        	self.mMojoItems_semaphore=false;
    		WeTransaction.buyMojoWithItemId(tempID, function(error) 
    		{ 
    			//NgLogD(" canTouch callback "+self.mMojoItems_semaphore); 
    			self.mMojoItems_semaphore=true; 
    		} );
        	return true;
		};
        return image;
    },
    
    OnHandleTag_popup_purchase_button : function(imageDef, parent, args)
    {
        var cb = args.OnPurchase;
        if(Exists(cb))
        {
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Name = function(){ return "OnHandleTag_popup_purchase_button"; };
            var root = parent;
            var theArgs = args;
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs);
                // if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                //                 {
                //                  if (Exists(root.owner))
                //                  {
                //                      root.owner.destroy();
                //                  }
                //                 }
                return true;
            };
            return image;
        }
        return null;
    },
    
    OnHandleTag_popup_place_button : function(imageDef, parent, args)
    {
        var cb = args.OnUseStash;
        if(Exists(cb))
        {
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Name = function(){ return "OnHandleTag_popup_place_button"; };
            var root = parent;
            var theArgs = args;
            
            if(args.InStashCount>0)
            {
	            image.Enable("Touch");
	            image.OnTouchDown = function(touch) { return true;  };
	            image.OnTapEvent = function(touch)
	            {
	                cb(theArgs);
	                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
	                {
						if (Exists(root.owner))
						{
							root.owner.destroy();
						}
	                }
	                return true;
	            };
            }
            else
            {
            	image.SetAlpha(0.6);
            }
            return image;
        }
        return null;
    },

    OnHandleTag_store_item_bought : function(imageDef, parent, args)
    {
		
		var db = weProtoDb.getInstance();
        var image = this.CreateImage(imageDef, parent, args, true); 
        var localImageDef = args;
        var isOfLevel = (args.required_level <= WeGameStateMgr.GetGameLotInfo().mLevel);
        var canAfford = true; // Let the user build the items free of charge.
        var hasEnoughPopulationRoom = (WeGameStateMgr.GetGameLotInfo().getAvailablePopulation() >= localImageDef.population_cost);
		var isBuildLimitReached = db.isBuildLimitReached(args);
		var hasViolatedKingdomRestriction = db.hasViolatedKingdomRestriction(args);

        image.mRequiresTap = true;
        image.Name = function(){ return "OnHandleTag_store_item_bought"; };
        // store items have prerequisite objectives too
        var curr_obj_id = WeGameStateMgr.GetCurrentObjectiveId();
        args.xMeetsObjectivePrereq = true;
        if (!gConfigs.DisableTutorial && args.prerequisite_objective_id !== null)
        {
            args.xMeetsObjectivePrereq = weProtoDb.getInstance().hasCompletedObjective(curr_obj_id, args.prerequisite_objective_id);
        }
 
        if (Exists(args.points_cost) && args.points_cost != 0)
        {
            canAfford = (args.points_cost <= WeEventGame.getEventPoints());
        }
        else if(Exists(args.gold_cost) && args.gold_cost !== 0)
        {
            canAfford = (args.gold_cost <= WeGameStateMgr.GetGameLotInfo().gold);
        }
        else if(Exists(args.mana_cost) && args.mana_cost !== 0)
        {
            canAfford = (args.mana_cost <= WeGameStateMgr.GetGameLotInfo().mana);
        }

		var isInStash = weProtoDb.getInstance().getStoreItemStashCount(args) > 0;

		var exception = WeGameStateMgr.lockAllItemsExcept();
        var screen = imageDef.args.screen;
        var mtx = WeUiMgr.GetMTXForProtoId(args.id);
		var inStashOrCanBuy = (isInStash || (isOfLevel && (canAfford || mtx )));
        if(inStashOrCanBuy && args.xMeetsObjectivePrereq && hasEnoughPopulationRoom && !isBuildLimitReached && !hasViolatedKingdomRestriction
           && (!exception || args.id == exception) /*&& weProtoDb.getInstance().isStoreItemUnlocked(args)*/)
        {
            // Create the on touch event for this item in the store
            image.Enable("Touch");
            image.OnTouchDown = function(touch) 
            {
                return true;  
            };
            
            image.OnTapEvent = function( touch )
            {
                // This is good so lets create the item in the game map
                if (mtx)
                {
                    var gameWidget;
            		var theArgs = {};
            		var itemDef;
                    var count = weProtoDb.getInstance().getStoreItemStashCount(localImageDef);
            		theArgs.OnPurchase = function(objArgs)
            		{
            			WeTransaction.buyIAPBuildingItemId(mtx.product_identifier, function(error) {  } );
            		};
            		
            		theArgs.OnUseStash = function(objArgs)
            		{
            		    if (count > 0)
            		    {
            			    WeGameStateMgr.SetPendingObject(localImageDef);
                            WeUiMgr.TransitionScreenTo(screen);
                            WeGameStateMgr.PlacePendingObjects();
                        }
            		};
            		
            		theArgs.OnCancel = function(objArgs)
            		{
            	        WeGameStateMgr.SetGlobalGameWidget(null);
            		};
                    theArgs.game_label_3 = "MobaCoin: " + mtx.cost;
                    theArgs.game_label_4 = "Owned: " + count;
                    theArgs.InStashCount = count;
            		itemDef = WeUiMgr.GetItemDef("iap_box");
                itemDef.images[3].asset = mtx.asset;
                itemDef.labels[1].text = mtx.description;
                    var gameWidget;
            		gameWidget = WeUiMgr.CreateGameWidget(itemDef, theArgs);
            		gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
            		WeGameStateMgr.SetGlobalGameWidget(gameWidget);
                }
                else
                {
                    WeGameStateMgr.SetPendingObject(localImageDef);
                    WeUiMgr.TransitionScreenTo(screen);
                    WeGameStateMgr.PlacePendingObjects();
                }
                return true;
            };
            
            // image.OnNativeTouch = function( touch )
            //             {
            //                 // This is good so lets create the item in the game map
            //                 WeGameStateMgr.SetPendingObject(localImageDef);
            //                 WeUiMgr.TransitionScreenTo(screen);
            //                 WeGameStateMgr.PlacePendingObjects();
            //                 return true;
            //             };
        }
        else
        {
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function( touch )
            {
                var text = "";
				var buyMojoButton = false;
                if(args.required_level > WeGameStateMgr.GetGameLotInfo().mLevel)
                {
                    text = "You need to be level " + args.required_level + " to build this!";
                }
                else if (args.xMeetsObjectivePrereq === false)
                {
                    text = "You must complete additional objectives to build this item.";
                }
                else if(args.gold_cost > WeGameStateMgr.GetGameLotInfo().gold)
                {
                    text = GameSpecificVariables.Texts.YouDoNotHaveEnoughCashBuyThis;
					buyMojoButton = true;
                }
                else if(args.mana_cost > WeGameStateMgr.GetGameLotInfo().mana)
                {
                    text = "You don't have enough "+GameSpecificVariables.Texts.mojoTextU+".";
					buyMojoButton = true;
                }
                else if(args.points_cost > WeGameStateMgr.GetGameLotInfo().pointsTextU)
                {
                    text = "You don't have enough "+GameSpecificVariables.Texts.pointsTextU+".";
					buyMojoButton = false;
                }
                else if (hasEnoughPopulationRoom === false)
                {
                    text = "Not enough available population space. Level up for more room.";
                }
                else if (isBuildLimitReached)
                {
                    text = "You have already built this item. You cannot build this anymore.";
                }
                else if (hasViolatedKingdomRestriction)
                {
                    text = "You can not build this item in this realm.";
                }
                else
                {
                    //failsafe
                    text = "You may need to reload your kingdom to see this.";
                }

                // setup the popup
                var popup_args = {};
                popup_args.popup_label = "Sorry!";
                popup_args.popup_text = text;

				if (buyMojoButton)
				{
					popup_args.OnNo = function(popup_args)
	                {
	                };
					popup_args.OnNoText = "OK";
					
					popup_args.OnYes = function(popup_args)
	                {
						WeUiMgr.TransitionScreenTo("BuyMojoScreen");
	                };
					popup_args.OnYesText = "Buy "+GameSpecificVariables.Texts.mojoTextU;
				}
				else
				{
					popup_args.OnOk = function(popup_args)
	                {
	                };
				}


                var itemDef = WeUiMgr.GetItemDef("popup_box");
                itemDef.images[0].tag = "empty_touch";
                var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popup_args);
                gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
                WeGameStateMgr.SetGlobalGameWidget(gameWidget);	
                return true;
            };
        }
        return image;
    },

    OnHandleTag_store_item_con : function(imageDef, parent, args)
    {
        var image = null;
		if (!weProtoDb.getInstance().isStoreItemUnlocked(args))
		{
		    var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		    newDef.asset = GameSpecificVariables.WeLabelFactory.storeLockIcon;
		    image = this.CreateImage(newDef, parent, args, true); 
		}
		
        if(image)
        {
            image.Name = function(){ return "OnHandleTag_store_item_con"; };
            image.mRequiresTap = true;
        }
        
        return image;
    },
    
    
    OnHandleTag_event_item_bought : function(imageDef, parent, args)
    {
		
		var db = weProtoDb.getInstance();
        var image = this.CreateImage(imageDef, parent, args, true); 
        var localImageDef = args;
        var isOfLevel = (args.required_level <= WeGameStateMgr.GetGameLotInfo().mLevel);
        var canAfford = true; // Let the user build the items free of charge.
        var hasEnoughPopulationRoom = (WeGameStateMgr.GetGameLotInfo().getAvailablePopulation() >= localImageDef.population_cost);
		var isBuildLimitReached = db.isBuildLimitReached(args);
		var hasViolatedKingdomRestriction = db.hasViolatedKingdomRestriction(args);

        image.mRequiresTap = true;
        image.Name = function(){ return "OnHandleTag_store_item_bought"; };
        // store items have prerequisite objectives too
        var curr_obj_id = WeGameStateMgr.GetCurrentObjectiveId();
        args.xMeetsObjectivePrereq = true;
        if (!gConfigs.DisableTutorial && args.prerequisite_objective_id !== null)
        {
            args.xMeetsObjectivePrereq = weProtoDb.getInstance().hasCompletedObjective(curr_obj_id, args.prerequisite_objective_id);
        }

        if(args.points_cost !== 0)
        {
            canAfford = (args.points_cost <= WeEventGame.getEventPoints());
        }
        else if(args.gold_cost !== 0)
        {
            canAfford = (args.gold_cost <= WeGameStateMgr.GetGameLotInfo().gold);
        }
        else if(args.mana_cost !== 0)
        {
            canAfford = (args.mana_cost <= WeGameStateMgr.GetGameLotInfo().mana);
        }

		var isInStash = weProtoDb.getInstance().getStoreItemStashCount(args) > 0;

		var exception = WeGameStateMgr.lockAllItemsExcept();
        var screen = imageDef.args.screen;
        var isLocked = WeEventGame.isStoreItemLocked(args);
		var inStashOrCanBuy = (isInStash || (isOfLevel && (canAfford )));
        if(!isLocked && inStashOrCanBuy && args.xMeetsObjectivePrereq && hasEnoughPopulationRoom && !isBuildLimitReached && !hasViolatedKingdomRestriction
           && (!exception || args.id == exception) /*&& weProtoDb.getInstance().isStoreItemUnlocked(args)*/)
        {
            // Create the on touch event for this item in the store
            image.Enable("Touch");
            image.OnTouchDown = function(touch) 
            {
                return true;  
            };
            
            image.OnTapEvent = function( touch )
            {
                // This is good so lets create the item in the game map
                WeGameStateMgr.SetPendingObject(localImageDef);
                WeUiMgr.TransitionScreenTo(screen);
                WeGameStateMgr.PlacePendingObjects(true);
                
                return true;
            };
            
            // image.OnNativeTouch = function( touch )
            //             {
            //                 // This is good so lets create the item in the game map
            //                 WeGameStateMgr.SetPendingObject(localImageDef);
            //                 WeUiMgr.TransitionScreenTo(screen);
            //                 WeGameStateMgr.PlacePendingObjects();
            //                 return true;
            //             };
        }
        else
        {
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function( touch )
            {
                var text = "";
				var buyMojoButton = false;
                if(WeEventGame.isStoreItemLocked(args))
                {
                    text = "This item is locked!";
                }
                else if (args.xMeetsObjectivePrereq === false)
                {
                    text = "You must complete additional objectives to build this item.";
                }
                else if(args.points_cost > WeEventGame.getEventPoints())
                {
                	text = "You don't have enough "+GameSpecificVariables.Texts.pointsTextU+".";
					buyMojoButton = false;
                }
                else if (hasEnoughPopulationRoom === false)
                {
                    text = "Not enough available population space. Level up for more room.";
                }
                else if (isBuildLimitReached)
                {
                    text = "You have already built this item. You cannot build this anymore.";
                }
                else if (hasViolatedKingdomRestriction)
                {
                    text = "You can not build this item in this realm.";
                }
                else
                {
                    //failsafe
                    text = "You may need to reload your kingdom to see this.";
                }

                // setup the popup
                var popup_args = {};
                popup_args.popup_label = "Sorry!";
                popup_args.popup_text = text;

				if (buyMojoButton)
				{
					popup_args.OnNo = function(popup_args)
	                {
	                };
					popup_args.OnNoText = "OK";
					
					popup_args.OnYes = function(popup_args)
	                {
						WeUiMgr.TransitionScreenTo("BuyMojoScreen");
	                };
					popup_args.OnYesText = "Buy "+GameSpecificVariables.Texts.mojoTextU;
				}
				else
				{
					popup_args.OnOk = function(popup_args)
	                {
	                };
				}


                var itemDef = WeUiMgr.GetItemDef("popup_box");
                itemDef.images[0].tag = "empty_touch";
                var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popup_args);
                gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
                WeGameStateMgr.SetGlobalGameWidget(gameWidget);	
                return true;
            };
        }
        return image;
    },
    
    OnHandleTag_event_item_con : function(imageDef, parent, args)
    {
        var image = null;
		if (WeEventGame.isStoreItemLocked(args))
		{
		    var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		    newDef.asset = GameSpecificVariables.WeLabelFactory.storeLockIcon;
		    image = this.CreateImage(newDef, parent, args, true); 
		}
		
        if(image)
        {
            image.Name = function(){ return "OnHandleTag_store_item_con"; };
            image.mRequiresTap = true;
        }
        
        return image;
    },

	OnHandleTag_store_item_badge : function(imageDef, parent, args)
	{
		var image = null;
		image = this.CreateImage(imageDef, parent, args, true);
		image.Name = function(){ return "OnHandleTag_store_item_badge"; };
        image.SetAlpha(0);
        image.Enable("UpdateEmitter", function()
        {
		    if(weProtoDb.getInstance().getStoreItemStashCount(args) > 0)
    		{
			    image.SetAlpha(1);
    		}
    	});

		return image;
	},

    confirmSpendMojoWithTarget : function (targetArgs)
    {
        var args = {};
        args.targetArgs = targetArgs;
		var opts = args;
/*        if(Exists(gConfigs.MojoConfirmationTitle))
        {
            args.popup_label = gConfigs.MojoConfirmationTitle;
        }
        else
        {
            args.popup_label = "Using Mojo";
        }
        if(Exists(gConfigs.MojoConfirmationMessage))
        {
            args.popup_text = gConfigs.MojoConfirmationMessage;
        }
        else
        {
            args.popup_text = "Are you sure you would like to use mojo?";
        }
        args.OnYesText = "Cancel";
        args.OnNoText = "Confirm";
        args.OnNo = function (opts)
        {*/
            WeGameStateMgr.SetGlobalGameWidget(null);
            if(Exists(opts.targetArgs.proto_task_id))
            {
                WeProtocol.taskWithMojo(opts.targetArgs.proto_task_id);
            }
            else if(Exists(opts.targetArgs.gifts))
            {
			    WeProtocol.boostGifts(opts.targetArgs.gifts, function(){
				    // rebuild gift list
				    WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");
			    });
            }
            else if(Exists(opts.targetArgs.pest_id))
            {
				WeUiMgr.ShowCaptureScreen(opts.targetArgs);
            	WeProtocol.touchPest(opts.targetArgs.pest_id, true);
            }
            else
            {
                opts.targetArgs.source.OnUseMojo(opts.targetArgs.product);
            }
/*        };
        args.OnYes = function (opts)
        {
            WeGameStateMgr.SetGlobalGameWidget(null);
        };
        var itemDef = WeUiMgr.GetItemDef("popup_box");
        var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
        gameWidget.setPosition(gRawWidth / 2, gRawHeight / 2);
        WeGameStateMgr.SetGlobalGameWidget(gameWidget);*/
    },

    OnHandleTag_use_mojo : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        var targetArgs = args;
        var self = this;
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function( touch )
        {
            self.confirmSpendMojoWithTarget(targetArgs);

            return true;
        };
        image.Name = function(){ return "OnHandleTag_use_mojo"; };
        return image;
    },
    
    OnHandleTag_use_happy_mojo : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        var source = args.source;
        var prod = args.product;
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function( touch )
        {
            // Tell the source object to use the mojo to increase happyness
            source.OnUseHappyMojo(prod);
            return true;
        };

        image.Name = function(){ return "OnHandleTag_use_happy_mojo"; };
        return image;
    },

    OnHandleTag_harvest_item_selected : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
//        NgLogD("####### OnHandleTag_harvest_item_selected ##########");
//        objDump(args);
//        //NgLogD("####### OnHandleTag_harvest_item_selected END ##########");
        var theArgs = args;
        //image.mRequiresTap = true;
        image.Callback = function()
        {
            if (theArgs.enabled)
            {
                this.SetAlpha(0.0);
            }
            return false;
        };
        image.Enable("Touch");
        image.OnTouchDown = function(touch)
        {
            if (theArgs.enabled)
            {
                this.SetAlpha(0.3);
            }
            return true;
        };

        image.OnTouchUp = function(touch)
        {
            if (theArgs.enabled)
            {
                this.SetAlpha(0);
            }
            return true;
        };

        image.OnTapEvent = function( touch )
        {
             var time = Core.Time.getFrameTime();
             var delta = time - this.mLastTime;
             if (theArgs.enabled && delta < 500)
             {
                 this.SetAlpha(0.3);
                 // can they afford the crop?
                 var kingdom = WeGameStateMgr.GetGameLotInfo();
                 if (theArgs.gold_cost > kingdom.gold)
                 {
                     var args = {};
                     args.OnOk = function(args)
                     {
                     };    
                     args.popup_label = "Oops";
                     args.popup_text = GameSpecificVariables.Texts.YouDoNotHaveCashToProduce;
                     var itemDef = WeUiMgr.GetItemDef("popup_box");
                     var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
                     gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
                     WeGameStateMgr.SetGlobalGameWidget(gameWidget);
                 }
                 else
                 {
                     kingdom.gold -= theArgs.gold_cost;
                     theArgs.source.OnItemSelected(theArgs);
                     WeGameStateMgr.SetGlobalGameWidget(null);
                 }

                 return true;
             }
        };

        image.Name = function(){ return "OnHandleTag_harvest_item_selected"; };
        // make this image invisible
        image.SetAlpha(0);
        return image;
    },
    
    OnHandleTag_user_item_add : function(imageDef, parent, args)
    {
    	 var image = this.CreateImage(imageDef, parent, args, true);
    	 
    	 image.Enable("Touch");
    	 
    	 var canTap=true;
         
         image.OnTapEvent = function( touch )
         {
        	 if(canTap)
        	 {
        		 canTap=false;
			      this.SetAlpha(0.3);
			      
			      objDumpMembers(args, 4);
			      
			      WeProtocol.addNeighbor(args.name, function(response)
				  {
			    	  canTap=true;
			    	  objDumpMembers(response);
				  }
			      );
        	 }
              
              return true;
         };

    	 return image;
    },
    
    OnHandleTag_user_item_selected : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true); 
        var theArgs = args;

        image.Callback = function()
        {
            if (theArgs.enabled)
            {
                this.SetAlpha(0.0);
            }
            return false;
        };
        image.Enable("Touch");
        image.OnTouchDown = function(touch)
        {
            if (theArgs.enabled)
            {
                this.SetAlpha(0.3);
            }
            return true;
        };

        image.OnTouchUp = function(touch)
        {
            if (theArgs.enabled)
            {
                this.SetAlpha(0);
            }
            return true;
        };

        image.OnTapEvent = function( touch )
        {
             if (theArgs.enabled)
             {
                 this.SetAlpha(0.3);
                 // can they afford the crop?
                 return true;
             }
        };

        image.Name = function(){ return "OnHandleTag_user_item_selected"; };
        // make this image invisible
        image.SetAlpha(0);
        return image;
    },
    
    CreateAvatar: function(cacheName, imagedef, parent, needManage, proxyImage)
    {
    	
    	if(proxyImage)
    	{
    		proxyImage.destroy();
    		proxyImage=null;
    	}
        var image2;
        if (cacheName === null)
        {
            image2 = new WeSprite2D( Content.getImagePath( getAssets( "crown" )), 
            [imagedef.size_x, imagedef.size_y],
            [
            imagedef.pos_x-imagedef.size_x*0.5,
            imagedef.pos_y-imagedef.size_y*0.5,
            imagedef.pos_z
            ],
            parent, [0,0]);
        }
        else
        {
            var ext = ParseAvatarExtension(WeGameStateMgr.mAvatarCache[cacheName]);
            image2 = new WeSprite2D( Content.getAvatarPath(cacheName + ext), 
            [imagedef.size_x, imagedef.size_y],
            [
            imagedef.pos_x-imagedef.size_x*0.5,
            imagedef.pos_y-imagedef.size_y*0.5,
            imagedef.pos_z
            ],
            parent, [0,0]);
        }

        if (Exists(imagedef.hide_idle))
        {
            image2.hide_idle = imagedef.hide_idle;
            
            if (WeGameStateMgr.IsGameUIHidden())
            {
                image2.SetVisible(false);
            }
        }
        
        if (needManage)
        {
            this.ManageImage(image2);
        }
    },
    
    DownloadAvatar: function(usr, imagedef, parent, needManage, proxyImage)
    {
        var self = this;
        var usr = usr;
        var imagedef = imagedef;
        var parent = parent;
        var cacheName = usr.gamertag;
        var imageId = usr.photoId;
        if (!Exists(usr.photoId))
        {
            imageId = usr.avatarId;
        }
        
        var manage = true;
        if (Exists(needManage))
        {
            manage = needManage;
        }
        
        // if (Exists(WeGameStateMgr.mAvatarCache[cacheName]) && WeGameStateMgr.mAvatarCache[cacheName] == imageId)
        //         {
        //             this.CreateAvatar(cacheName, imagedef, parent);
        //             return;
        //         }
        if (imageId.indexOf(".jpg") >= 0)
        {   // disable jpgs till ngCore supports jpgs better
            return;
        }
        
        var ext = ParseAvatarExtension(imageId);
        //NgLogD("*** DOWNLOAD AVATAR GET " + imageId + " for " + cacheName);
        //NgLogD("*** DOWNLOAD SAVED AS " + Content.getAvatarPath(cacheName + ext));
        
        
        var key = Content.getAvatarPath(cacheName + ext);
        
        if (Exists(this.mDownloadingAvatars[key]) && this.mDownloadingAvatars[key] === true)
        {
            cacheName = cacheName + "_1";
            key = Content.getAvatarPath(cacheName + ext);
          //  return;
        }
        
        this.mDownloadingAvatars[key] = true;        
        (new Network.DownloadFile()).start(key, "GET", imageId, [], function(status, md5){
            // update image
             self.mDownloadingAvatars[key] = false;
            //NgLogD("*** DOWNLOAD AVATAR STATUS " + status + " for " + cacheName);
            if (status == 200)
            {
                //NgLogD("*** DOWNLOAD AVATAR USE CACHE " + cacheName + " on: " + imageId);
                WeGameStateMgr.mAvatarCache[cacheName] = imageId;
                self.CreateAvatar(cacheName, imagedef, parent, manage, proxyImage); 
            }
            else
            {   // try again?
                if (!Exists(imagedef.retryCount))
                {
                    imagedef.retryCount  = 0;
                }
                else
                {
                    imagedef.retryCount = imagedef.retryCount + 1;
                }
                
                //NgLogD("*** DOWNLOAD AVATAR RETRY " + imagedef.retryCount + " on: " + cacheName);
                if (imagedef.retryCount >= 3)
                {
                     //NgLogD("*** DOWNLOAD AVATAR FAIL " + imagedef.retryCount + " on: " + cacheName);
                     self.CreateAvatar(null, imagedef, parent, manage, proxyImage); 
                }
                else
                {
                    self.DownloadAvatar(usr, imagedef, parent, manage, proxyImage);
                }
            }
           
        });
    },

	/* the icon shown on the pest bubble */
    OnHandleTag_pest_icon : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if ( Exists(args.GetPestBubbleImage) )
		{
			newDef.asset = args.GetPestBubbleImage();
		}
        image = this.CreateImage(newDef, parent, args, true);
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
			if ( args.mPest )
			{
				WePests.onTouch(args.mPest);
			}
            return true;
        };

        return image;	
	},

    OnHandleTag_obj_state_defined : function(imageDef, parent, args)
    {
        var image = null;
        if(Exists(args.OnObjStateAssetRequested))
        {
            var newDef = ObjectUtils.GetCloneOfObject(imageDef);
            newDef.asset = args.OnObjStateAssetRequested();
            if (!Exists(newDef.asset) || newDef.asset === "")
            {
                return null;
            }
            
            if (newDef.asset.indexOf(".User_") >= 0)
            {
            	if(newDef.scale_avatar_x)
            	{
            		newDef.size_x=newDef.size_x*newDef.scale_avatar_x;
            	}
            	
            	if(newDef.scale_avatar_y)
            	{
            		newDef.size_y=newDef.size_y*newDef.scale_avatar_y;
            	}
				
                var gamertag = newDef.asset.replace(".User_", "");
                if (Exists(WeGameStateMgr.mAvatarCache[gamertag]))
                {
                    var ext = ParseAvatarExtension(WeGameStateMgr.mAvatarCache[gamertag]);
                    newDef.asset = Content.getAvatarPath(gamertag + "" + ext);
                    image = this.CreateImage(newDef, parent, args, true);
                }
                else
                {
                    newDef.asset = getAssets( "crown" )
                    image = this.CreateImage(newDef, parent, args, true);
                    var self = this;
                    var myimage = image;
                    var myparent = parent;
                    var def = newDef;
                    if (Exists(gamertag) && gamertag.length > 0)
                    {
                        Social.US.User.getUserWithGamertag(gamertag, function(err, usr)
                        {
                            if(usr && !err)
                            {
                                self.DownloadAvatar(usr, def, myparent, false);
                        
                            }
                            else
                            {
                                NgLogD("*** AVATAR ERROR");
                            }
                        });
                    }
                }
            }
            else
            {
				// if(Exists(newDef.asset))
				//              {
				//                  newDef.anim = 'SPR_' + newDef.asset.replace('.png', '');
				//                  if(Exists(gTunables.icon_scale))
				//                      newDef.scale_x = newDef.scale_y = gTunables.icon_scale;
				//                      
				//                  NgLogD("**** ASSET " + newDef.asset);
				//                  NgLogD("**** ANIM " + newDef.anim);
				//              }
                image = this.CreateImage(newDef, parent, args, true);
            }

            image.Name = function(){ return "OnHandleTag_obj_state_defined"; };
        }
        return image;
    },

    OnHandleTag_request_job : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        
        var source = args.source;
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
            source.OnSocialJobRequest(args);
            return true;
        };
        
        image.Name = function(){ return "OnHandleTag_request_job"; };
        return image;
    },

    OnHandleTag_display_xp_progress : function(labelDef, parent, args)
    {
        var image = this.CreateImage(labelDef, parent, args, true);
        image.Name = function(){ return "OnHandleTag_display_xp_progress"; };

        var origx = image.GetX();
        var barMaxWidth = image.xArgs.container_size_x;
        var barHeight = image.GetHeight();
        image.Enable("UpdateEmitter", function()
        {
            var info = WeGameStateMgr.GetGameLotInfo();
            if(info)
            {
                var level = info.mLevel;
                var currProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(level);
                var nextProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(level+1);
                var required_xp = info.xp;
                if (nextProtoLevel !== null)
                {
                    required_xp = nextProtoLevel.required_xp;
                }
                var percent = (info.xp - currProtoLevel.required_xp) / (required_xp - currProtoLevel.required_xp);
                image.GetGL2().setScale(percent, 1);
            }
        });
    
        return image;
    },

	OnHandleTag_is_crop_out_of_level : function(imageDef, parent, args)
	{
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if (Exists(args.out_of_level) && args.out_of_level)
		{
			return null;
		}
        var image = this.CreateImage(newDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_is_crop_out_of_level"; };
        return image;
	},
    
    OnHandleTag_proto_image : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if (Exists(args[imageDef.args.proto_tag]) && args[imageDef.args.proto_tag])
		{
        	newDef.asset = Content.getIconImagePath(args[imageDef.args.proto_tag]);
		}
		else
		{
			NgLogD("Proto image is not defined in " + imageDef.args.proto_tag + ", the args is " + JSON.stringify(args));			
		}
        var image = this.CreateImage(newDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_proto_image"; };
        return image;
    },
    
    OnHandleTag_proto_collection_image : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);        
        var count = args.progress.toString().split('/');
        
        

        
        if (parseInt(count[0]) < parseInt(count[1]))
        {
        	newDef.asset = Content.getIconImagePath(WeEventGame.getGameEventAssetsFolder() + args.image_silhouette);
        	NgLogD("<<<<<---- LOOK " + JSON.stringify(count));
        }
       	else
        	newDef.asset = Content.getIconImagePath(WeEventGame.getGameEventAssetsFolder() + args.image_progress);        	
        var image = this.CreateImage(newDef, parent, args, true); 

        image.Name = function(){ return "OnHandleTag_proto_collection_image"; };
        return image;
    },
    
    OnHandleTag_se_collection_progress_item1 : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);        
        newDef.asset = WeEventGame.getCollectionPanelItemAsset(0);  
        
        if (!newDef.asset)
            return null;
        var image = this.CreateImage(newDef, parent, args, true); 

        WeEventGame.mCollectionPanelItemImage1 = image;
        return image;
    },
    
    OnHandleTag_se_collection_progress_item2 : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);        
        newDef.asset = WeEventGame.getCollectionPanelItemAsset(1);  
        if (!newDef.asset)
            return null;
        var image = this.CreateImage(newDef, parent, args, true); 

        WeEventGame.mCollectionPanelItemImage2 = image;
        return image;
    },
    
    OnHandleTag_se_collection_progress_item3 : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);        
        newDef.asset = WeEventGame.getCollectionPanelItemAsset(2);  
        if (!newDef.asset)
            return null;
        var image = this.CreateImage(newDef, parent, args, true);

        WeEventGame.mCollectionPanelItemImage3 = image;
        return image;
    },
    
    OnHandleTag_game_asset_1 : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
        newDef.asset = args.game_asset_1;
        var image = this.CreateImage(newDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_game_asset_1"; };
        return image;
    },
    
    m_bBuildTabSemaphoreStartTime : 0,
    
	OnHandleTag_load_proto_tab : function(imageDef, parent, args)
	{
	    var image = this.CreateImage(imageDef, parent, args, true); 
	    image.Name = function(){ return "OnHandleTag_load_proto_tab"; };

		var deltaX = imageDef.args.enabled_delta_x;
		var deltaY = imageDef.args.enabled_delta_y;
		var scale = imageDef.args.enabled_scale;
		
		if (!deltaX)
		{
			deltaX = 0;
		}
		if (!deltaY)
		{
			deltaY = 0;
		}
		if (!scale)
		{
			scale = 1;
		}
		
        if(Exists(imageDef.args.enabled) && imageDef.args.enabled == 1)
		{
			var composite = WeUiMgr.GetCompositeFactory().FindCompositeOfName(imageDef.args.composite);
	        composite.xCurrentTab = image;
	        image.SetPosition(image.GetX() + deltaX, image.GetY() + deltaY);
	        image.SetScale(scale);
		}
		
	    image.Enable("Touch");
	
	    image.OnTouchDown = function(touch) 
		{
			DebugTouch(touch, "image OnTouchDown()");
			
			image.mTouchDownPos = touch.getPosition();
			image.SetColor(255, 255, 255, .6); 
			return true;  
		};
		
	    image.OnTouchEnd = function(touch)
		{
			DebugTouch(touch, "image OnTouchEnd()");
			
			image.SetColor(255, 255, 255, 1); 
			return true; 
		};
		
		image.OnTouchMove = function(touch, delta) 
		{
			DebugTouch(touch, "image OnTouchMove()");
			
			var pos = touch.getPosition();
			if (Exists(image.mTouchDownPos))
			{
			    var dx = pos.getX() - image.mTouchDownPos.getX();
    			var dy = pos.getY() - image.mTouchDownPos.getY();
    			if(dx*dx + dy*dy > WeUiMgr.GetTouchLeeway())
    				return image.OnTouchEnd(touch); 
			}
			return true;
		};
		
		var self=this;
		self.m_bBuildTabSemaphoreStartTime=0;

	    image.OnTapEvent = function(touch)
	    {
	    	if(Math.abs( Core.Time.getFrameTime()-self.m_bBuildTabSemaphoreStartTime) < 500)
	    	{
		    	NgLogD("OnTapEvent BuilTab stoped");
	    		return true;
	    	}
	    	self.m_bBuildTabSemaphoreStartTime=Core.Time.getFrameTime();
	    	
	        var composite = WeUiMgr.GetCompositeFactory().FindCompositeOfName(imageDef.args.composite);

			// resize the tab graphics
			composite.xCurrentTab.SetPosition(composite.xCurrentTab.GetX() - deltaX, composite.xCurrentTab.GetY() - deltaY);
			this.SetPosition(this.GetX() + deltaX, this.GetY() + deltaY);
			composite.xCurrentTab.SetScale(1);		
			this.SetScale(scale);
			//NgLogD ("##### ProtoTab: setting color to 0");
			this.SetColor(0, 0, 0, 1);
			
			// clean up the prior scroller
			WeUiMgr.GetCompositeFactory().ReleaseComposite(composite);
			composite.destroy();

			// get the definition for the original scroll_area
	        var json = WeUiMgr.GetJSONDef();
	        var activescreen = WeUiMgr.GetActiveScreen();
	        var itemDef = ObjectUtils.GetCloneOfObject(json[activescreen].composite[0]);

	        // modify the definition with parameters from this tab
			if (Exists(imageDef.args.proto_tab))
			{
				itemDef.controller_args.data_source_args.type = imageDef.args.proto_tab;
			}

			// Check for a while set of new item info (Upgrade items are quite different)
			if (Exists(imageDef.args.item_size_x) && Exists(imageDef.args.item_size_y) &&
				Exists(imageDef.args.elements_per_group) && Exists(imageDef.args.item_type) &&
				Exists(imageDef.args.data_source_tag)) 
			{
				itemDef.controller_args.data_source_tag = imageDef.args.data_source_tag;
				itemDef.controller_args.item_type = imageDef.args.item_type;
				itemDef.controller_args.elements_per_group = imageDef.args.elements_per_group;
				itemDef.controller_args.item_size_x = imageDef.args.item_size_x;
				itemDef.controller_args.item_size_y = imageDef.args.item_size_y;
			}

			// create and add the new scroller
			composite = WeUiMgr.GetCompositeFactory().CreateComposite(itemDef, WeUiMgr.GetScreen().GetNode());
			WeUiMgr.GetCompositeFactory().ManageComposite(composite);
			composite.xCurrentTab = this;
			
			// re-create the background
			if (Exists(imageDef.args.background))
			{
		        var bg_image = WeUiMgr.GetImageFactory().FindImageOfName("scroller_background");
				if (Exists(bg_image))
				{
					WeUiMgr.GetImageFactory().ReleaseImage(bg_image);
					bg_image.destroy();

					// hunt for the background in the json image list
					for (var i = 0; i < json[activescreen].images.length; i++)
					{
						if (json[activescreen].images[i].name == "scroller_background")
						{
							// recreate the background with this def.
					        var backgroundDef = ObjectUtils.GetCloneOfObject(json[activescreen].images[i]);
							backgroundDef.asset = imageDef.args.background;
							bg_image = WeUiMgr.GetImageFactory().CreateImage(backgroundDef, WeUiMgr.GetScreen().GetNode());
							WeUiMgr.GetImageFactory().ManageImage(bg_image);
							break;
						}
					}
				}
			}
			
			//NgLogD ("##### ProtoTab: setting color to 255");
			this.SetColor(255, 255, 255, 1);
		};
		
		if(WeUiMgr)
		
		return image;
	},

    OnHandleTag_proto_image_select : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);

		// ugly special case - don't draw this if they've already got the upgrade
		if (labelDef.name == "upgrade_item_cost")
		{
			var avail = weProtoDb.getInstance().canPurchaseUpgrade(args);
			if (avail == UpgradeStatus.kAlreadyPurchased)
			{
				return null;
			}
		}

        var len = labelDef.args.select_len;
        var results = [];
        for(var idx = 0; idx < len; ++idx)
        {
            var name = "proto_tag_" + (idx + 1);
            var assetName = "asset_select_" + (idx + 1);
            var obj = {};
            
            if (labelDef.args[name] === "price_cost")
			{
			    var mtx = WeUiMgr.GetMTXForProtoId(args["id"]);
			    if (mtx)
			    {
			        results = [];
    			    obj.xCost = mtx.cost;
                    obj.xAsset = labelDef.args[assetName];
    			    results.push(obj);
    			    break;
			    }
		    }
		    else
		    {
                obj.xCost = args[labelDef.args[name]];
                obj.xAsset = labelDef.args[assetName];
                results.push(obj);
            }
        }
        if(labelDef.args.select_type == "largest")
        {
            results.sort(function(a, b){ return b.xCost - a.xCost; });
        }
        else if(labelDef.args.select_type == "smallest")
        {
            results.sort(function(a, b){ return a.xCost - b.xCost; });
        }
        newDef.asset = results[0].xAsset;
        NgLogD("<<<<!!! " + JSON.stringify(results[0]));
        var image = this.CreateImage(newDef, parent, args, true); 

        image.Name = function(){ return "OnHandleTag_proto_image_select"; };
        return image;
    },

    OnHandleTag_mojo_store_image : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
        newDef.asset = args.asset;
        image = this.CreateImage(newDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_mojo_store_image"; };
        return image;   
    },

    OnHandleTag_obj_state_image : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
        newDef.asset = Content.getIconImagePath(args.obj_state_image);
        image = this.CreateImage(newDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_obj_state_image"; };
        return image;   
    },

    OnHandleTag_objective_image : function(imageDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
        var objId = WeGameStateMgr.GetCurrentObjectiveId();
        var obj = weProtoDb.getInstance().getCurrentObjective(objId);
        var key = WeGameStateMgr.IsCompletedObjective() ? imageDef.args.completed_key : imageDef.args.key;
        newDef.asset = obj[key];
        image = this.CreateImage(newDef, parent, args, true);
        image.Name = function(){ return "OnHandleTag_objective_image"; };
        return image;
    },

    OnHandleTag_objective_image_okbutton : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Name = function(){ return "OnHandleTag_objective_image_okbutton"; };
        image.Enable("Touch");
        image.OnTouchDown = function(touch) {
			WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.ButtonPress);
			return true;
		};
        image.OnTapEvent = function(touch)
        {
            //Was this a completed objective screen?
            if (WeGameStateMgr.IsCompletedObjective())
            {
                // set the completed objective to false...
                WeGameStateMgr.SetCompletedObjective(false);
                // preemptively setup the next objective...
                var objId = WeGameStateMgr.GetCurrentObjectiveId();
                var obj = weProtoDb.getInstance().getNextObjective(objId);

                var cb = function(request)
                {
                    try
                    {
                        NgLogD ( "Got a response from the complete objective hit...");
                        if (Exists(request.responseText) && 0 !== request.responseText.length )
                        {
                            var obj = JSON.parse(request.responseText);
                            WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.completed_objective.kingdom.kingdom);
                        }
                    }
                    catch(ex)
                    {
                        NgLogD("Error: image.onTapEvent");
                        WeUiMgr.ShowNetworkErrorPopUp();
                    }
                };          
                
                // Push a notification to the server that we completed an objective
                WeProtocol.completeObjective( objId, cb );
        
                if ( obj !== undefined )
                {
                    WeGameStateMgr.SetCurrentObjectiveId(obj.id);
                    //drop into the next objective screen...
                    WeUiMgr.TransitionScreenTo("ObjectiveScreen");
                }
                else
                {
                    //drop into the regular game screen
					WeSocialMapMgr.transitionScreenToKingdom();
                }
            }
            else
            {
                var objId = WeGameStateMgr.GetCurrentObjectiveId();
                var obj = weProtoDb.getInstance().getCurrentObjective(objId);
                if (obj.requires_show_social_map)
                {
                    // clear cache id so it will reload
                    WeGameStateMgr.SetCurrentKingdomId(-1);
                    WeGameStateMgr.SetIsFirstLoad(true);
                    WeUiMgr.ShowLoading(true);
                    WeSocialMapMgr.launchSocialMap(1);
                }
                else
                {
                    //drop into the regular game screen
					WeSocialMapMgr.transitionScreenToKingdom();
                }
            }
            return true;
        };
        
        return image;
    },

	// TODO: Too much hassle for one special case (redesign level lock), might want to cleanup
    OnHandleArg_MeetsLevelReq : function()
    {
        return WeGameStateMgr.mLotInfo.mLevel >= cRedesignModeLevelUnlock;
    },
    OnHandleArg_MeetsLevelReq_Image : function(imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true); 
    	var screen = imageDef.args.screen;
    	image.Name = function(){ return "OnHandleArg_MeetsLevelReq_Image"; };
    	image.Enable("Touch");
    	// have to override onTouchDown return true to get the other touch events
    	image.OnTouchDown = function(touch) { return true;  };
    	image.OnTapEvent = function(touch)
    	{
    		if (WeGameStateMgr.mLotInfo.mLevel >= cRedesignModeLevelUnlock)
    		{
    			WeUiMgr.TransitionScreenTo("RedesignScreen");
            	return true;
    		}
    		else
    		{
		    var args = {};
		    args.OnOk = function(args)
		    {
			    WeGameStateMgr.SetGlobalGameWidget(null);
		    };
		    args.popup_label = "Sorry!";
            args.popup_text = "You need to reach level " + cRedesignModeLevelUnlock + " to unlock Re-Design Mode (to move, flip, sell and store items). You're almost there. Complete goals to level up faster!";
		    var itemDef = WeUiMgr.GetItemDef("popup_box");
		    var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
		    newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
		    WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
    		}
    	};
    	return image;
    },
    
    OnHandleArg_HasGameEventData : function()
    {
    	if (weProtoDb.getInstance().getProtoGameEvent())
    	{
    	    return true;
    	}
    	
    	return false;
    },
    
    
    OnHandleArg_HasObjectives : function()
    {
    	if (gConfigs.DisableTutorial) return false;
		return WeGameStateMgr.HasRemainingObjectives();
    },

    gifting_tab_semaphore : true,
	/* Gifting screen items */
	OnHandleTag_gifting_tab: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var self = this;
    	
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {        	
        	if (WeGameStateMgr.IsGiftsLoading())
        	{
        	    return true;
        	}
        	if(self.gifting_tab_semaphore===false) return false;
        	self.gifting_tab_semaphore=false;
        	
        	var json = WeUiMgr.GetJSONDef();
            var activescreen = WeUiMgr.GetActiveScreen();
            var currentscreen = json[activescreen];
            // Find image of active tab
            var activetabname = "gifting_active_tab";
    		var img = self.FindImageOfName(activetabname);
    		if (Exists(img))
    		{	// Remove image and associated view
    			if (Exists(img.view))
    			{
    				WeUiMgr.DestroyView(img.view);
    			}
    			self.ReleaseImage(img);
                img.destroy();
  				// Recreate active tab image - it will load its view
	    		for (var i in currentscreen.images)
	    		{
	    			if (currentscreen.images[i].name == activetabname)
	    			{
	    				var imgDef = ObjectUtils.GetCloneOfObject(currentscreen.images[i]);
	    				imgDef.pos_x = imageDef.pos_x;
	    				imgDef.pos_y = imageDef.pos_y;
	    				imgDef.size_x = imageDef.size_x;
	    				imgDef.size_y = imageDef.size_y;
	    				imgDef.asset = imageDef.args.active;
	    				imgDef.args.handle = imageDef.args.handle;
	    				imgDef.args.view = imageDef.args.view;
	    				
	    				img = self.CreateImage(imgDef, WeUiMgr.GetScreen().GetNode());
	                    self.ManageImage(img); 
	    				break;
	    			}
	    		} 
    		}  		   		
    	};
    	
    	return image;
    }, 
    
    OnHandleTag_gifting_active_tab: function (imageDef, parent, args)
    {   	
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	image.Enable("Touch");
    	image.OnTouchDown = function(touch) { return true; };
    	// Load view
    	WeUiMgr.CreateView(newDef.args.view, WeUiMgr.GetScreen());
    	if (Exists(newDef.args.handle) && Exists(this[newDef.args.handle]))
    		this[newDef.args.handle]();
    	image.view = newDef.args.view;
    	
    	return image;	
    },
	
	OnHandleTag_gift_boost_reminder : function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		newDef.pos_y -= imageDef.size_y;		
		var image = this.CreateImage(newDef, parent, args, true);

		image.mAnim = null;
		image.mAnimState = WeUiMgr.WindowState.CLOSED;
								
		return image;
	},
	
	OnHandleTag_gift_sent_popup : function (imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		newDef.pos_y += imageDef.size_y;		
		var image = this.CreateImage(newDef, parent, args, true);
		
		image.closed_pos = 	[image.GetX(), image.GetY()];
		image.open_pos = 	[image.GetX(), image.GetY()-image.GetHeight()];	
		image.mAnim = null;
		image.mAnimState = WeUiMgr.WindowState.CLOSED;
		
		image.OnExit(function()
		{
			if (Exists(image.mAnim))
				image.mAnim.Stop();
		});
		
		return image;		
	},
	
	OnHandleTag_gift_progress_bar : function (imageDef, parent, args)
	{
		// TODO: find this item in action
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		newDef.pos_y -= imageDef.size_y;		
		var image = this.CreateImage(newDef, parent, args, true);
		
		return image;				
	},
	
	OnHandleTag_send_gift_button : function(imageDef, parent, args)
	{	// TODO: implement same behaviour for loading popup/ boost sign
		var image = this.CreateImage(imageDef, parent, args, true);
		image.mRequiresTap = true;
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			// show relevant popup
			var popup = WeUiMgr.GetImageFactory().FindImageOfName("gift_sent_popup");
			
			if (Exists(popup))
			{
				if(popup.mAnimState !== WeUiMgr.WindowState.OPENED) 
				{
					var self = popup;
					if (popup.mAnimState == WeUiMgr.WindowState.OPENING)
					{	// if it's opening, ignore
						NgLogD ("Gift Sent popup already opening!");
						return;
					}
					// params for closed popup
					var time = 1.0;
					var cpy = popup.closed_pos[1];
					var opy = popup.open_pos[1];
					if (popup.mAnimState == WeUiMgr.WindowState.CLOSING)
					{
						// params for partially closed popup
						time = time * Math.abs(popup.GetY() - opy) / Math.abs(cpy - opy);
						cpy = popup.GetY();
						if (Exists(popup.mAnim))
							popup.mAnim.Stop();
						popup.mAnim = null;
					}
					// do the animation
					var animation = new NumberAnimation (time, cpy, opy);
					animation.SetNumber = function(value)
					{
						self.SetPosition(self.GetX(), value);
					};
					animation.OnStop = function()
					{
						self.mAnimState = WeUiMgr.WindowState.OPENED;
						//NgLogD("Sent popup animation complete!");
						self.mAnim = null;
						if (Exists(self.queue))
						{	// this is how we deal with delayed closing for now
							var execNext = self.queue;
							self.queue = null;
							execNext();
						}
					};
					
					popup.mAnim = animation;
					popup.mAnimState = WeUiMgr.WindowState.OPENING;				
				}
				else	// if it's open, ignore
				{
					NgLogD("Gift Sent popup opened, ignoring open!");
				}
			}			
			
			// notify server
			var users = [];
			users.push(args);
			WeProtocol.sendGifts(users, function(){
				// close popup
				var popup = WeUiMgr.GetImageFactory().FindImageOfName("gift_sent_popup");
				if (Exists(popup))
				{					
					var self = popup;
					if (popup.mAnimState !== WeUiMgr.WindowState.CLOSED)
					{
						var closeAnim = function ()
						{
							var animation = new NumberAnimation (1.0, popup.open_pos[1], popup.closed_pos[1]);
							animation.SetNumber = function(value)
							{
								self.SetPosition(self.GetX(), value);
							};
							animation.OnStop = function()
							{
								self.mAnimState = WeUiMgr.WindowState.CLOSED;
								//NgLogD("Sent popup animation complete!");
								self.mAnim = null;
								if (Exists(self.queue))
								{	// not used now, only for consistency
									var execNext = self.queue;
									self.queue = null;
									execNext();
								}							
							};
							
							popup.mAnim = animation;
							popup.mAnimState = WeUiMgr.WindowState.CLOSING;																					
						};
						
						if (popup.mAnimState == WeUiMgr.WindowState.OPENING)
							popup.queue = closeAnim;	// delay closing
						else if (popup.mAnimState == WeUiMgr.WindowState.OPENED)
							closeAnim();				// close at once
						else // already closing
							NgLogD ("Gift Sent popup already closing, ignoring!");						
					}								
				}							
			});						
			// remove user from list
			var list = WeGameStateMgr.mGiftUsers;
			for (var i=0; i<list.length; i++)
			{
				if (list[i] == args)
				{
					WeGameStateMgr.mGiftUsers.splice(i,1);
					break;
				}
			}		
			// rebuild user list
			WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "GiftSendView");

			//NgLogD("Gift sent!");
			return true;
		};

		image.Name = function(){ return "OnHandleTag_send_gift_button"; };
        return image;			
	},
	
	OnHandleTag_send_share_button : function(imageDef, parent, args)
	{	// TODO: implement same behaviour for loading popup/ boost sign
		var image = this.CreateImage(imageDef, parent, args, true);
		image.mRequiresTap = true;
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			// show relevant popup
			var popup = WeUiMgr.GetImageFactory().FindImageOfName("gift_sent_popup");
			
			if (Exists(popup))
			{
				if(popup.mAnimState !== WeUiMgr.WindowState.OPENED) 
				{
					var self = popup;
					if (popup.mAnimState == WeUiMgr.WindowState.OPENING)
					{	// if it's opening, ignore
						NgLogD ("Gift Sent popup already opening!");
						return;
					}
					// params for closed popup
					var time = 1.0;
					var cpy = popup.closed_pos[1];
					var opy = popup.open_pos[1];
					if (popup.mAnimState == WeUiMgr.WindowState.CLOSING)
					{
						// params for partially closed popup
						time = time * Math.abs(popup.GetY() - opy) / Math.abs(cpy - opy);
						cpy = popup.GetY();
						if (Exists(popup.mAnim))
							popup.mAnim.Stop();
						popup.mAnim = null;
					}
					// do the animation
					var animation = new NumberAnimation (time, cpy, opy);
					animation.SetNumber = function(value)
					{
						self.SetPosition(self.GetX(), value);
					};
					animation.OnStop = function()
					{
						self.mAnimState = WeUiMgr.WindowState.OPENED;
						//NgLogD("Sent popup animation complete!");
						self.mAnim = null;
						if (Exists(self.queue))
						{	// this is how we deal with delayed closing for now
							var execNext = self.queue;
							self.queue = null;
							execNext();
						}
					};
					
					popup.mAnim = animation;
					popup.mAnimState = WeUiMgr.WindowState.OPENING;				
				}
				else	// if it's open, ignore
				{
					NgLogD("Gift Sent popup opened, ignoring open!");
				}
			}			
			
			// notify server
			var users = [];
			users.push(args);
			var item_id = weProtoDb.getInstance().proto_game_events.proto_id;
			NgLogD("<<<!!>>> Item ID " + item_id);
			WeProtocol.sendSEGifts(users, item_id, function(request){
				var item_id = weProtoDb.getInstance().proto_game_events.proto_id;
				var obj = JSON.parse(request.responseText);
 				if(obj && obj.available_share_count)
 				{
 					for(key in obj.available_share_count)
 					{
 						if(key == item_id)
 						{
 							WeEventGame.mShareCount = obj.available_share_count[key];
 						}
 					}
 				}
				// close popup
				var popup = WeUiMgr.GetImageFactory().FindImageOfName("gift_sent_popup");
				if (Exists(popup))
				{					
					var self = popup;
					if (popup.mAnimState !== WeUiMgr.WindowState.CLOSED)
					{
						var closeAnim = function ()
						{
							var animation = new NumberAnimation (1.0, popup.open_pos[1], popup.closed_pos[1]);
							animation.SetNumber = function(value)
							{
								self.SetPosition(self.GetX(), value);
							};
							animation.OnStop = function()
							{
								self.mAnimState = WeUiMgr.WindowState.CLOSED;
								//NgLogD("Sent popup animation complete!");
								self.mAnim = null;
								if (Exists(self.queue))
								{	// not used now, only for consistency
									var execNext = self.queue;
									self.queue = null;
									execNext();
								}							
							};
							
							popup.mAnim = animation;
							popup.mAnimState = WeUiMgr.WindowState.CLOSING;																					
						};
						
						if (popup.mAnimState == WeUiMgr.WindowState.OPENING)
							popup.queue = closeAnim;	// delay closing
						else if (popup.mAnimState == WeUiMgr.WindowState.OPENED)
							closeAnim();				// close at once
						else // already closing
							NgLogD ("Gift Sent popup already closing, ignoring!");						
					}								
				}							
			});						
			// remove user from list
			var list = WeGameStateMgr.mSEGiftUsers;
			for (var i=0; i<list.length; i++)
			{
				if (list[i] == args)
				{
					WeGameStateMgr.mSEGiftUsers.splice(i,1);
					break;
				}
			}		
			// rebuild user list
			WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "SpecialEventGiftSendView");

			//NgLogD("Gift sent!");
			return true;
		};
		
		image.Name = function(){ return "OnHandleTag_send_gift_button"; };
        return image;			
	},
	
	OnHandleTag_capture_user_icon : function(imageDef, parent, args)
	{
		imageDef.args.gamertag=args.user;
		if(WeUiMgr.m_CaptureScreenAnimationLeft>0)
		{
			args.delayDownload =WeUiMgr.m_CaptureScreenAnimationLeft;
		}
		return this.OnHandleTag_gift_user_icon(imageDef, parent, args);
	},
	
	OnHandleTag_capture_share : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.mRequiresTap = true;
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			// show relevant popup
			var popup = WeUiMgr.GetImageFactory().FindImageOfName("gift_sent_popup");
			
			if (Exists(popup))
			{
				if(popup.mAnimState !== WeUiMgr.WindowState.OPENED) 
				{
					var self = popup;
					if (popup.mAnimState == WeUiMgr.WindowState.OPENING)
					{	// if it's opening, ignore
						NgLogD ("Gift Sent popup already opening!");
						return;
					}
					// params for closed popup
					var time = 1.0;
					var cpy = popup.closed_pos[1];
					var opy = popup.open_pos[1];
					if (popup.mAnimState == WeUiMgr.WindowState.CLOSING)
					{
						// params for partially closed popup
						time = time * Math.abs(popup.GetY() - opy) / Math.abs(cpy - opy);
						cpy = popup.GetY();
						if (Exists(popup.mAnim))
							popup.mAnim.Stop();
						popup.mAnim = null;
					}
					// do the animation
					var animation = new NumberAnimation (time, cpy, opy);
					animation.SetNumber = function(value)
					{
						self.SetPosition(self.GetX(), value);
					};
					animation.OnStop = function()
					{
						self.mAnimState = WeUiMgr.WindowState.OPENED;
						//NgLogD("Sent popup animation complete!");
						self.mAnim = null;
						if (Exists(self.queue))
						{	// this is how we deal with delayed closing for now
							var execNext = self.queue;
							self.queue = null;
							execNext();
						}
					};
					
					popup.mAnim = animation;
					popup.mAnimState = WeUiMgr.WindowState.OPENING;				
				}
				else	// if it's open, ignore
				{
					NgLogD("Gift Sent popup opened, ignoring open!");
				}
			}			
			
			// notify server
			var users = [];
			users.push(args);
			var item_id = weProtoDb.getInstance().proto_game_events.proto_id;
			NgLogD("<<<!!>>> Item ID " + item_id);
			WeProtocol.sendSEGifts(users, item_id, function(request){
				var item_id = weProtoDb.getInstance().proto_game_events.proto_id;
				var obj = JSON.parse(request.responseText);
 				if(obj && obj.available_share_count)
 				{
 					for(key in obj.available_share_count)
 					{
 						if(key == item_id)
 						{
 							WeEventGame.mShareCount = obj.available_share_count[key];
 						}
 					}
 				}
				// close popup
				var popup = WeUiMgr.GetImageFactory().FindImageOfName("gift_sent_popup");
				if (Exists(popup))
				{					
					var self = popup;
					if (popup.mAnimState !== WeUiMgr.WindowState.CLOSED)
					{
						var closeAnim = function ()
						{
							var animation = new NumberAnimation (1.0, popup.open_pos[1], popup.closed_pos[1]);
							animation.SetNumber = function(value)
							{
								self.SetPosition(self.GetX(), value);
							};
							animation.OnStop = function()
							{
								self.mAnimState = WeUiMgr.WindowState.CLOSED;
								//NgLogD("Sent popup animation complete!");
								self.mAnim = null;
								if (Exists(self.queue))
								{	// not used now, only for consistency
									var execNext = self.queue;
									self.queue = null;
									execNext();
								}							
							};
							
							popup.mAnim = animation;
							popup.mAnimState = WeUiMgr.WindowState.CLOSING;																					
						};
						
						if (popup.mAnimState == WeUiMgr.WindowState.OPENING)
							popup.queue = closeAnim;	// delay closing
						else if (popup.mAnimState == WeUiMgr.WindowState.OPENED)
							closeAnim();				// close at once
						else // already closing
							NgLogD ("Gift Sent popup already closing, ignoring!");						
					}								
				}							
			});						
			// remove user from list
			var list = WeGameStateMgr.mSEGiftUsers;
			for (var i=0; i<list.length; i++)
			{
				if (list[i] == args)
				{
					WeGameStateMgr.mSEGiftUsers.splice(i,1);
					break;
				}
			}		
			// rebuild user list
			WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "SpecialEventGiftSendView");

			//NgLogD("Gift sent!");
			return true;
		};
		
		image.Name = function(){ return "OnHandleTag_send_gift_button"; };
        return image;			
	},
	
	OnHandleTag_capture_user_icon : function(imageDef, parent, args)
	{
		imageDef.args.gamertag=args.user;
		if(WeUiMgr.m_CaptureScreenAnimationLeft>0)
		{
			args.delayDownload =WeUiMgr.m_CaptureScreenAnimationLeft;
		}
		return this.OnHandleTag_gift_user_icon(imageDef, parent, args);
	},
	
	OnHandleTag_capture_share : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			WeProtocol.releasePest(WeUiMgr.m_cCaptureScreen.dragon.pest_id, args.user);
			WeSocialMapMgr.transitionScreenToKingdom();
		};
		return image;
	},
	
	OnHandleTag_capture_user_back : function(imageDef, parent, args)
	{
		var image=this.CreateImage(imageDef, parent, args, true);
		if(args.index % 2 == 0)
		{
			image.SetAlpha(0.0);
		}
		else
		{
			image.SetAlpha(0.3);
		}
		return image;
	},

	OnHandleTag_gift_user_icon : function(imageDef, parent, args)
	{
	    var image;
        var self = this;
        var myparent = parent;
        var def = imageDef;
        
        NgLogD("*** SHARE USER TEST " + imageDef.args.gamertag);
        if (Exists(imageDef.args.gamertag) && imageDef.args.gamertag.length > 0)
        {
            if (Exists(WeGameStateMgr.mAvatarCache[imageDef.args.gamertag]))
            {
                var ext = ParseAvatarExtension(WeGameStateMgr.mAvatarCache[imageDef.args.gamertag]);
                imageDef.asset = Content.getAvatarPath(imageDef.args.gamertag + "" + ext);
                image = this.CreateImage(imageDef, parent, args, true);
            }
            else
            {
                imageDef.asset = getAssets( "crown" );
                image = this.CreateImage(imageDef, parent, args, true);
                
				var shouldPestLoadReleaseUserIcon = true;
				// AW: We don't need this in android since loading is async.
			//	if(Exists(gConfigs.PestLoadReleaseUserIcon))
			//		shouldPestLoadReleaseUserIcon = gConfigs.PestLoadReleaseUserIcon;
				
				if ( shouldPestLoadReleaseUserIcon )
				{
	                if(args.delayDownload)
	                {
	                    NgLogD("*** SHARE DELAY " + imageDef.args.gamertag);
	                	var cTimer=new Timer(args.delayDownload, function()
	                	{
	    	                Social.US.User.getUserWithGamertag(imageDef.args.gamertag, function(err, usr)
	    	                {
	    	                    if(usr && !err)
	    	                    {
	    	                        self.DownloadAvatar(usr, def, myparent, true, image);             
	    	                    }
	    	                    else
	    	                    {
	    	                        NgLogD("*** AVATAR ERROR");
	    	                    }
	    	                });                		
	                	}
	                	);
	                	/*
	                	image.OnExit(function()
	              	    {
	              	    	cTimer.StopNoCallBack();
	              	    });
	              	    */
	                }
	                else
	                {
	                    NgLogD("*** SHARE USER " + imageDef.args.gamertag);
		                Social.US.User.getUserWithGamertag(imageDef.args.gamertag, function(err, usr)
		                {
		                    if(usr && !err)
		                    {
	                    	
		                        self.DownloadAvatar(usr, def, myparent, true, image);               
		                    }
		                    else
		                    {
		                        NgLogD("*** AVATAR ERROR");
		                    }
		                });
	                }
				} // end of if (PestLoadReleaseUserIcon)
            }
            
            image.Name = function() { return "OnHandleTag_gift_user_icon"; }
        }
        
        return image;			
	},
	
	OnHandleTag_gift_send_all : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			// notify server
			var users = WeGameStateMgr.mGiftUsers;
			if (users.length == 0)
			{
				// relevant popup
				var popupArgs = {};		
				popupArgs.popup_label = "No Gifts to Send"; 
				popupArgs.popup_text = "You have already sent all your gifts!";
				
				popupArgs.OnOk = function(args)
				{
				    WeGameStateMgr.SetGlobalGameWidget(null);
				};
		
				// push the popup box onto the screen
				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
				gameWidget.setPosition(gRawWidth*0.3, gRawHeight*0.5);    
				WeGameStateMgr.SetGlobalGameWidget(gameWidget);				
				NgLogD("Nowhere to send!");
				return true;
			}
			WeProtocol.sendGifts(users, function(){
				// relevant popup
				var popupArgs = {};		
				popupArgs.popup_label = "Gifts Sent"; 
				popupArgs.popup_text = "All gifts will be received.";
				
				popupArgs.OnOk = function(args)
				{
				    WeGameStateMgr.SetGlobalGameWidget(null);
				};
		
				// push the popup box onto the screen
				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
				gameWidget.setPosition(gRawWidth*0.3, gRawHeight*0.5);    
				WeGameStateMgr.SetGlobalGameWidget(gameWidget);				
				
			});
			// remove users			
			WeGameStateMgr.mGiftUsers = [];
			// rebuild user list
			WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "GiftSendView");
			
			NgLogD("All gifts sent!");
			return true;
		};
		image.Name = function(){ return "OnHandleTag_gift_send_all"; };
        return image;			
	},
	
	OnHandleTag_gift_waiting : function(imageDef, parent, args)
	{	
		var image = this.CreateImage(imageDef, parent, args, true);
		if (Exists(WeGameStateMgr.mGiftUsers) && WeGameStateMgr.mGiftUsers.length > 0)
		{
			image.SetAlpha(0.0);
		}		

		image.Name = function(){ return "OnHandleTag_gift_waiting"; };
        return image;				
	},
	
	OnHandleTag_gift_se_waiting : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		if (Exists(WeGameStateMgr.mSEGiftUsers) && WeGameStateMgr.mSEGiftUsers.length > 0)
		{
			NgLogD("<<<! OnHandleTag_gift_se_waiting");
			image.SetAlpha(0.0);
		}		

		image.Name = function(){ return "OnHandleTag_gift_se_waiting"; };
        return image;				
	},
	
	OnHandleTag_gift_se_no_items : function(imageDef, parent, args)
	{	
		var image = this.CreateImage(imageDef, parent, args, true);
		if (Exists(WeEventGame.mShareCount) && WeEventGame.mShareCount > 0)
		{
			NgLogD("<<<! OnHandleTag_gift_se_no_items");
			image.SetAlpha(0.0);
		}		

		image.Name = function(){ return "OnHandleTag_gift_se_no_items"; };
        return image;				
	},
	
	OnHandleTag_gift_empty_list : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		if (Exists(WeGameStateMgr.mGifts) && WeGameStateMgr.mGifts.length > 0)
		{
			image.SetAlpha(0.0);
		}		

		image.Name = function(){ return "OnHandleTag_gift_empty_list"; };
        return image;				
	},
	
	getGiftBoxImage : function (tag, side)
	{
		var key;
		if 		(tag == "gifting_gift_wizard") 	key = "wizard_box";
		else if (tag == "gifting_gift_boosted")	key = "boosted_box";
		else if (tag == "gifting_gift")			key = "orange_box";
		else return "alpha2.png";
		
		return "gifting/gifting_"+key+side+".png";
	},
	
	OnHandleTag_gift_box : function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if (args.proto_gift_id != -1 || args.image == "alpha2")
		{
			newDef.asset = "alpha2.png";
			//newDef.color_a = 0.0;
		}
		else
		{						
			//NgLogD ("ATTENTION: image tag from server for this gift box asset is "+args.image);
			newDef.asset = this.getGiftBoxImage(args.image, imageDef.name == "gift_box_top"?"_top":"_bottom");
			newDef.color_a = 1.0;
		}
		
		var image = this.CreateImage(newDef, parent, args, true);
		image.Name = function(){ return "OnHandleTag_gift_box"; };
        return image;			
	},
	
	OnHandleTag_gift_box_lock : function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);

		if (!args.free_open && !WeGameStateMgr.mFreeOpen && args.proto_gift_id == -1)
		{
			newDef.color_a = 1.0;
		}
		else
		{
			newDef.color_a = 0.0;
		}
		
		var image = this.CreateImage(newDef, parent, args, true);
		image.Name = function(){ return "OnHandleTag_gift_box_lock"; };
        return image;			
	},	

	OnHandleTag_gift_box_item : function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if (args.proto_gift_id != -1)
		{
			if (args.image == "gifting_bldg_gift.png" ||
				args.image == "gifting_deco_gift.png" ||
				args.image == "gifting_mojo_gift.png" ||
				args.image == "gifting_xp_gift.png")
			{	
				newDef.asset = 'gifting/'+args.image;
			}
			// Special case, meh
			else if (GameInfo.appName == "WeRule" && args.image == "gifting_coin_gift.png")
			{
				newDef.asset = GameSpecificVariables.Textures.Crowns;
			}
			else
			{
				newDef.asset = args.image;
			}
			newDef.color_a = 1.0;
		}
		else
		{
			newDef.asset = "black.png";
			newDef.color_a = 0.0;
		}
				
		var image = this.CreateImage(newDef, parent, args, true);
		image.Name = function(){ return "OnHandleTag_gift_box_item"; };
        return image;			
	},		
	
	OnHandleTag_GiftShowScreen_alpha: function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);

		newDef.asset = Content.getIconImagePath(imageDef.asset);
		var image = this.CreateImage(newDef, parent, args, true);
		if(!image)
		{
			objDump(newDef);
			return null;
		}
		image.SetAlpha(0);
		
		var nWait=0;
		if(newDef.args && newDef.args.wait)
		{
			nWait=newDef.args.wait;
		}
		var cTimer= new Timer(nWait, function()
	    {
	    	var cNumberAnimation= new NumberAnimation(1,  0.0, 1.0);

			cNumberAnimation.SetNumber=function(value)
		    {
				image.SetAlpha(value);
		    };
		    
			image.OnExit(function()
		    {
				cNumberAnimation.Stop();
		    });
	    }
		);
	    return image;
	},
	
	OnHandleTag_GiftShowScreen_scale: function(imageDef, parent, args)
	{
		var image = this.OnHandleTag_GiftShowScreen_alpha(imageDef, parent, args);
		if(!image)
		{
			objDump(imageDef);
			return null;
		}
		
		var nWait=0;
		if(imageDef.args && imageDef.args.wait)
		{
			nWait=imageDef.args.wait;
		}
		var cTimer= new Timer(nWait, function()
	    {
	    	var cNumberAnimation= new NumberAnimation(2,  0.0, 1.0);

			cNumberAnimation.SetNumber=function(value)
		    {
				image.SetScale(value, value);
		    };
		    
			image.OnExit(function()
		    {
				cNumberAnimation.Stop();
		    });
	    }
		);
	    return image;
	},
	
	OnHandleTag_GiftShowScreen_image: function(imageDef, parent, args)
	{
		if(args && args.image)
		{
			if (args.image == "gifting_xp_gift.png" || args.image == "gifting_mojo_gift.png")
		     {    
					args.image = 'gifting/'+args.image;
	         }
			
			imageDef.asset = Content.getImagePath(args.image);
            // Special case, meh
            if (GameInfo.appName == "WeRule" && imageDef.asset.indexOf("gifting_coin_gift") != -1)
                imageDef.asset = GameSpecificVariables.Textures.Crowns;
			var image= this.CreateImage(imageDef, parent, args, true);
			NgLogD("imageDef.asset = " + imageDef.asset)
			return image;
		}
		else if(args.gift)
		{
			if (args.gift.image == "gifting_xp_gift.png" || args.gift.image == "gifting_mojo_gift.png")
		     {    
					args.gift.image = 'gifting/'+args.gift.image;
	         }
			
			imageDef.asset=args.gift.image;
			// Special case, meh
			if (GameInfo.appName == "WeRule" && imageDef.asset.indexOf("gifting_coin_gift") != -1)
				imageDef.asset = GameSpecificVariables.Textures.Crowns;
		}
		return this.OnHandleTag_GiftShowScreen_scale(imageDef, parent, args);
	},
	
	OnHandleTag_GiftShowScreen_accept: function(imageDef, parent, args)
	{
		var image = this.OnHandleTag_GiftShowScreen_alpha(imageDef, parent, args);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		
		var self=this;
		
		image.OnTapEvent = function (touch)
		{
			if(args.gift && args.gift.can_gift_back)
			{
				// rebuild gift list
				WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");
				
	            var newArgs = {};
	            newArgs.OnYes = function(theNewArgs)
	            {
	            	WeGameStateMgr.SetGlobalGameWidget(null);
	            	// send gift
	            	var users = [];
	            	users.push(args.gift.sender);
	            	WeProtocol.sendGifts(users, function(){return;});
	            };
	            
	            newArgs.OnNo = function(theNewArgs)
	            {
	            	 WeGameStateMgr.SetGlobalGameWidget(null);
	            };
	            newArgs.popup_label = "Send a Thank You Gift"; 
	            newArgs.popup_text = "Would you like to return the favor and send a gift to " + args.gift.sender + "?";
	            
	            var itemDef = WeUiMgr.GetItemDef("popup_box");
	            var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
	            newArgs.xGameWidget = newGameWidget;
	            newGameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
			}
			else
			{
				// rebuild gift list
				WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");	
				WeGameStateMgr.SetGlobalGameWidget(null);
			}
			return true;
		};
		return image;
	},
	
	OnHandleTag_gift_show_item_selected: function(imageDef, parent, args)
	{
		
		if(args.index%2==0)
		{
			imageDef.asset=imageDef.args.image1;
		}
		else
		{
			imageDef.asset=imageDef.args.image2;
		}
		imageDef.asset = Content.getIconImagePath(imageDef.asset);
		var image = this.CreateImage(imageDef, parent, args, true);
		
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		
		var self=this;
		
		image.OnTapEvent = function (touch)
		{
			if(args && args.can_gift_back)
			{
				var newGameWidget=null;
				// rebuild gift list
				WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");	
			
	            var newArgs = {};
	            newArgs.OnYes = function(theNewArgs)
	            {
	            	WeGameStateMgr.SetGlobalGameWidget(null);
	            	// send gift
	            	var users = [];
	            	users.push(args.sender);
	            	WeProtocol.sendGifts(users, function(){return;});
	            };
	
	            newArgs.OnNo = function(theNewArgs)
	            {
	            	newGameWidget.destroy();
	            	delete newGameWidget;
	            };
	            newArgs.popup_label = "Send a Thank You Gift"; 
	            newArgs.popup_text = "Would you like to return the favor and send a gift to " + args.sender + "?";
	
	            var itemDef = WeUiMgr.GetItemDef("popup_box");
	            newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
	            newArgs.xGameWidget = newGameWidget;
	            newGameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
			}
		};
		
		return image;
	},
	
	OnHandleTag_GiftShowScreen_dust_show: function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		if(!image)
		{
			objDump(imageDef);
			return null;
		}
		var cTimer= new Timer(1.5, function()
	    {
	    	var cNumberAnimation= new SinAnimation(Math.random()*Math.PI);

			cNumberAnimation.SetNumber=function(value)
		    {
				image.SetAlpha(value);
		    };
			image.OnExit(function()
		    {
				cNumberAnimation.Stop();
		    });
	    }
		);
		return image;
	},
	
	OnHandleTag_gift_box_open : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.mRequiresTap = true;
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		
		var self=this;
		
		image.OnTapEvent = function (touch)
		{
		    if (WeGameStateMgr.IsGiftsLoading())
		    {
		        return true;
		    }
		    
			if (args.id == -1)
			{
				NgLogD("Dummy gift!");
				return true;
			}
			if (WeGameStateMgr.mShowingGiftOpenAnimation)
			{
				NgLogD("OnTapEvent: Still showing gift opening animation!");
				return true;				
			}
			else if (args.proto_gift_id != -1)
			{
				NgLogD("Already opened!");
				return true;
			}
			else if (!args.free_open && !WeGameStateMgr.mFreeOpen)
			{
				if (args.boost_cost > WeGameStateMgr.GetGameLotInfo().mana)
				{
					NgLogD("You are too poor for that!");
					return true;
				}
				// relevant popup
				var popupArgs = {};		
				popupArgs.popup_label = "Out of Free Gifts"; 
				popupArgs.popup_text = "You can't open any more regular gifts today, but if you boost this gift then you can open it!";
				
				popupArgs.OnYesText = "Boost";
				popupArgs.OnYes = function(args)
				{
					WeGameStateMgr.SetGlobalGameWidget(null);
					var giftIds = [];
					giftIds.push (WeGameStateMgr.mGifts[WeGameStateMgr.mCurrentGift].id);					
					WeProtocol.boostGifts(giftIds, function(){
						// rebuild gift list
						WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");
					});			
					
					NgLogD("Gift boosted from Open!");				    
				};
				popupArgs.OnNoText = "Cancel";
				popupArgs.OnNo = function(args)
				{
				    WeGameStateMgr.SetGlobalGameWidget(null);
				};
		
				// push the popup box onto the screen
				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
				gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
				WeGameStateMgr.SetGlobalGameWidget(gameWidget);					
				
				NgLogD ("Not free to open!");
				return true;
			}
			
			if(image.xParent && !WeGameStateMgr.mShowingGiftOpenAnimation)
			{			
				NgLogD("Gift is opening!");
				
				var itemDef = WeUiMgr.GetItemDef("EmptyScreen");
                var cCatchTouchWidget = WeUiMgr.CreateGameWidget(itemDef, {});
                cCatchTouchWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
                WeGameStateMgr.SetGlobalGameWidget(cCatchTouchWidget);
				
				var gift_box_top=null;
				var len = image.xParent.xChildren.length;
		        for (var i = 0; i < len; i++)
		        {
		            if (image.xParent.xChildren[i].xName == "gift_box_top")
		            {
		            	gift_box_top= image.xParent.xChildren[i];
		            	break;
		            }
		        }			
		        if(gift_box_top)
		        {
		        	WeGameStateMgr.mShowingGiftOpenAnimation = true;
		        	var cNumberAnimation= new NumberAnimation(1,  gift_box_top.GetY(), gift_box_top.GetY()-200);
					var cNumberAAnimation= new NumberAnimation(1,  1.0, 0.0);
					cNumberAAnimation.SetNumber=function(value)
				    {
						gift_box_top.SetAlpha(value);
				    };
					cNumberAnimation.SetNumber=function(value)
				    {
						gift_box_top.SetPosition(gift_box_top.GetX(), value);
				    };
				    
			        cNumberAnimation.OnStop=function()
			        {
			        	if(args)
			        	{   	
							var giftIds = [];
							giftIds.push(args.id);
							WeGameStateMgr.SetIsGiftsLoading(true);
							WeProtocol.openGifts(giftIds, function(request){
							    WeGameStateMgr.SetIsGiftsLoading(false);
								var gift=null;
								// real gift
								var obj = JSON.parse(request.responseText);
								var gifts = obj.gifts;
								for (var j in gifts)
								{
									for (var i=0; i<WeGameStateMgr.mGifts.length; i++)
									{
										if (gifts[j].gift.id == WeGameStateMgr.mGifts[i].id)
										{
											gift = WeGameStateMgr.mGifts[i];
											break;
										}
									}
								}
								if(gift)
								{
									//NgLogD ("@@@@@ We opened a gift!");
									WeGameStateMgr.SetGlobalGameWidget(null);
									
									var newArgs = {};
									newArgs.gift=gift;
			                        var itemDef = WeUiMgr.GetItemDef("GiftShowScreen");
			                        gameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
			                        gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
			
			                        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
			                        //NgLogD ("@@@@@ We are about to play the sound!");
			                        WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GiftOpening);
			                        //NgLogD ("@@@@@ We just played a sound!");
								}
								WeGameStateMgr.mShowingGiftOpenAnimation = false;
							});
			        	}
			        	else
							WeGameStateMgr.mShowingGiftOpenAnimation = false;
			        };
		        }
			}		
			return true;
		};
		image.Name = function(){ return "OnHandleTag_gift_box_open"; };
        return image;			
	},
	
	OnHandleTag_capturing_sign: function(imageDef, parent, args)
	{	
		var image=this.CreateImage(imageDef, parent, args, true);
		image.imageDef=imageDef;
		var yStart=image.GetY();
		var cNumberAnimation= new NumberAnimation(4,  0, 8*Math.PI);
		cNumberAnimation.setLoop(false);
		cNumberAnimation.SetNumber=function(value)
	    {
			value=Math.sin(value);
			image.SetPosition(image.GetX(), yStart+imageDef.args.offsetY*value);
	    };
        	    
        cNumberAnimation.OnStop=function()
        {
			//NgLogD("################### capturing sign animation done");
			WePests.setAnimationRunning( false );
			WePests.handleCatchSuccessOrFail();
        };

	    image.OnExit(function()
	    {
	    	cNumberAnimation.Stop();
	    });
	    image.animation=cNumberAnimation;
	    WeUiMgr.m_cCaptureScreen.capturing_sign=image;	    
		return image;
	},

	OnHandleTag_close_capture_screen_btn: function(imageDef, parent, args)
    {

       var image = this.CreateImage(imageDef, parent, args, true); 
       image.Enable("Touch");
       // have to override onTouchDown return true to get the other touch events
       image.OnTouchDown = function(touch) { return true;  };
       image.OnTapEvent = function(touch)
       {
           if (this.GetVisible() === true)
           {
				WeSocialMapMgr.transitionScreenToKingdom();
	       }
           return true;
       };

	   image.SetVisible(false);
	   WeUiMgr.m_cCaptureScreen.close_capture_screen_btn = image;
       return image;
	},

	OnHandleTag_capture_capturing_dragon_image: function(imageDef, parent, args)
	{
		imageDef.asset= "capture/" + WeUiMgr.m_cCaptureScreen.dragon.large_image_png;
		var image=this.CreateImage(imageDef, parent, args, true);
		image.imageDef=imageDef;
		var cNumberAnimation= new NumberAnimation(2,  image.GetY()+imageDef.args.offsetY, image.GetY());
		image.SetVisible(true);
		cNumberAnimation.SetNumber=function(value)
	    {
			image.SetPosition(image.GetX(), value);
	    };
        
	    image.OnExit(function()
	    {
	    	cNumberAnimation.Stop();
	    });
	    image.animation=cNumberAnimation;
	    WeUiMgr.m_cCaptureScreen.dragon_image=image;
		return image;
	},
	
	OnHandleTag_capturing_success: function(imageDef, parent, args)
	{
		var image=this.CreateImage(imageDef, parent, args, true);
		image.imageDef=imageDef;
	    WeUiMgr.m_cCaptureScreen.capturing_success=image;
	    image.SetVisible(false);
		return image;
	},
	
	OnHandleTag_capturing_success2: function(imageDef, parent, args)
	{
		var image=this.CreateImage(imageDef, parent, args, true);
		image.imageDef=imageDef;
	    WeUiMgr.m_cCaptureScreen.capturing_success2=image;
	    image.SetVisible(false);
		return image;
	},

	OnHandleTag_capturing_share_back: function(imageDef, parent, args)
	{
		var image=this.CreateImage(imageDef, parent, args, true);
		image.imageDef=imageDef;
	    WeUiMgr.m_cCaptureScreen.capturing_share_back=image;
	    image.SetVisible(false);
		return image;
	},
	
	OnHandleTag_capture_fail_image: function(imageDef, parent, args)
	{
		var image=this.CreateImage(imageDef, parent, args, true);
		image.imageDef=imageDef;
	    WeUiMgr.m_cCaptureScreen.fail_image=image;
	    image.SetVisible(false);
		return image;
	},
	
	OnHandleTag_EventStatus_back: function(imageDef, parent, args)
	{
		NgLogD("OnHandleTag_EventStatus_back");
		var webView = new UI.WebView({'frame': [imageDef.pos_x - imageDef.size_x/2, imageDef.pos_y - imageDef.size_y/2,
									 			imageDef.size_x, imageDef.size_y]});
		
		NgLogD("gConfigs.EventParticipationEntityIds "+gConfigs.EventParticipationEntityIds);
		
		var url = null;
		if (WeGameStateMgr.mInterstitialURL)
		{
            url=WeGameStateMgr.mInterstitialURL;
		    webView.loadUrl(url);
		    WeGameStateMgr.mInterstitialURL = null;
    		NGWindow.document.EventScreen = webView;
    		NGWindow.document.addChild(webView);
    		var cb = WebViewCommands;
		
            webView.setOnShouldload(cb);
		}
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.OnExit(function()
		{
			NgLogD("Removing ShowItemToBuild");
	    	if(NGWindow.document.EventScreen)
			{
				NGWindow.document.removeChild(NGWindow.document.EventScreen);
				NGWindow.document.EventScreen.destroy();
				NGWindow.document.EventScreen = null;
			}			
		});
		
		return image;
	},
	
	OnHandleTag_EventScreen_back: function(imageDef, parent, args)
	{
		NgLogD("OnHandleTag_EventScreen_back");
		var webView = new UI.WebView({'frame': [imageDef.pos_x - imageDef.size_x/2, imageDef.pos_y - imageDef.size_y/2,
									 			imageDef.size_x, imageDef.size_y]});
		
		NgLogD("gConfigs.EventParticipationEntityIds "+gConfigs.EventParticipationEntityIds);
		
		var url="http://wewerule.s3.amazonaws.com/webviews/events/not_participating_has_no_pests.html";
        if(WePests.hasPests())
        {
            url=gConfigs.EventNotParticipatingHasPests;
        }
        else
        {
            url=gConfigs.EventNotParticipatingHasNoPestsURL;
        }

		//gConfigs.EventNotParticipatingHasNoPestsURL
		//gConfigs.EventNotParticipatingHasPests
		//gConfigs.EventMainGoalsCompletedURL
		
		//WeUiMgr.TransitionScreenTo("EventScreen");
		
	//	webView.loadUrl(url);
		
		//D/droid/jni/v8helper.h(11887): (69)js: EventNotParticipatingHasNoPestsURL -> http://wewerule.s3.amazonaws.com/webviews/events/not_participating_has_no_pests.html
		//	D/droid/jni/v8helper.h(11887): (69)js: EventNotParticipatingHasPests -> http://wewerule.s3.amazonaws.com/webviews/events/not_participating_has_pests.html
		//	D/droid/jni/v8helper.h(11887): (69)js: EventMainGoalsCompletedURL -> http://wewerule.s3.amazonaws.com/webviews/events/main_goals_complete.html
		
		NGWindow.document.EventScreen = webView;
		NGWindow.document.addChild(webView);
		var cb = WebViewCommands;
		
        webView.setOnShouldload(cb);
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.OnExit(function()
		{
			NgLogD("Removing ShowItemToBuild");
	    	if(NGWindow.document.EventScreen)
			{
				NGWindow.document.removeChild(NGWindow.document.EventScreen);
				NGWindow.document.EventScreen.destroy();
				NGWindow.document.EventScreen = null;
			}			
		});
		
		return image;
	},
	
	OnHandleTag_EventScreen_start: function(imageDef, parent, args)
	{
		return null;
		var webView = new UI.WebView({'frame': [imageDef.pos_x - imageDef.size_x/2, imageDef.pos_y - imageDef.size_y/2,
									 			imageDef.size_x, imageDef.size_y]});
		
		webView.loadUrl("");
		NGWindow.document.giftWebView = webView;
		NGWindow.document.addChild(webView);
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.OnExit(function()
		{
	    	if(NGWindow.document.giftWebView)
			{
				NGWindow.document.removeChild(NGWindow.document.giftWebView);
				NGWindow.document.giftWebView.destroy();
            	NGWindow.document.giftWebView = null;
			}			
		});
		
		return image;
	},
	
	OnHandleTag_EventScreen_exit: function(imageDef, parent, args)
	{
		
		var bubble = new UI.Button();
		var asset = Content.getImagePath(imageDef.asset);
		bubble.setImage(asset);
		bubble.setImageFit(UI.FitMode.Stretch);
		bubble.setFrame([imageDef.pos_x-imageDef.size_x/2, imageDef.pos_y-imageDef.size_y/2/*-70*/, imageDef.size_x, imageDef.size_y]);
		
		bubble.setOnClick(function()
		{
			WeSocialMapMgr.transitionScreenToKingdom();
		}
		);
		
		NGWindow.document.addChild(bubble);
		
		NGWindow.document.EventScreenExit=bubble;
		
	
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.OnExit(function()
		{
			NgLogD("Removing OnHandleTag_EventScreen_exit");
	    	if(NGWindow.document.EventScreenExit)
			{
				NGWindow.document.removeChild(NGWindow.document.EventScreenExit);
				NGWindow.document.EventScreenExit = null;
			}			
		});
		
		return image;		
	},
	
	OnHandleTag_CaptureScreen_Share: function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{			 
			WeUiMgr.ShowCaptureShareScreen();
		};
		return image;
	},
	
	OnHandleTag_CaptureScreen_Fail: function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{			 
			WeUiMgr.ShowCaptureFailScreen();
		};
		return image;
	},	
	
	OnHandleTag_CaptureScreen: function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{			 
			WeUiMgr.ShowCaptureScreen({proto_name:"Asilo berete", large_image_png:"elemental_combo_large.png"});
		};
		return image;
	},		
	
	OnHandleTag_gifting_accept_now: function(imageDef, parent, args)
	{
		return this.CreateImage(imageDef, parent, args, true);
	},

	OnHandleTag_gift_open_all : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{			 
		    if (WeGameStateMgr.IsGiftsLoading())
		    {
		        return true;
		    }
			if (WeGameStateMgr.mShowingGiftOpenAnimation)
			{
				NgLogD("OnTapEvent: Still showing gift opening animation!");
				return true;				
			}
		
			var giftIds = [];
			var freeOpen = false;
			// collect gift ids
			var gifts = WeGameStateMgr.mGifts;
			for (var i=0; i<gifts.length; i++)
			{
				if (gifts[i].proto_gift_id == -1)
				{
					giftIds.push(gifts[i].id);
					if (gifts[i].free_open) freeOpen = true;
				}
			}

			if (giftIds.length == 0)							// no gifts left
			{
				NgLogD("No gifts to open!");
				return true;
			}
			else if (!freeOpen && !WeGameStateMgr.mFreeOpen)	// all gifts locked
			{
				// cost calculation
				var cost = -1;
				for (var i=0; i<gifts.length; i++)
				{
					if (gifts[i].boost_cost >= 0)
					{
						cost = cost < 0 ? gifts[i].boost_cost : cost + gifts[i].boost_cost;
					}
				}				
				if (cost <= 0)
				{
					NgLogD(">>>>> Curious encounter <<<<<<");
				}
				else if (cost > WeGameStateMgr.GetGameLotInfo().mana)
				{
					NgLogD ("You are both lonely and poor!");
					return true;
				}
				
				// relevant popup
				var popupArgs = {};	
				popupArgs.popup_label = "Out of Free Gifts"; 
				popupArgs.popup_text = "You can't open any more regular gifts today, but if you boost your gifts for "
										+ cost + " "+GameSpecificVariables.Texts.mojoTextU+" then you can open them all!";
				
				popupArgs.OnYes = function(args)
				{
					WeGameStateMgr.SetGlobalGameWidget(null);
					var giftIds = [];
					var gifts = WeGameStateMgr.mGifts;
					// collect gift ids			
					for (var i=0; i<gifts.length; i++)
					{
						giftIds.push(gifts[i].id);
					}			
					// notify server
					WeProtocol.boostGifts(giftIds, function(){
						// rebuild gift list
						WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");					
					});	
					NgLogD("All gifts boosted by allOpen!");				    
				};
				popupArgs.OnNo = function(args)
				{
				    WeGameStateMgr.SetGlobalGameWidget(null);
				};
		
				// push the popup box onto the screen
				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
				gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
				WeGameStateMgr.SetGlobalGameWidget(gameWidget);					
				
				NgLogD("No free gifts!");
				return true;
			}
			
			WeGameStateMgr.SetIsGiftsLoading(true);
			// notify server
			WeProtocol.openGifts(giftIds, function(request){
				WeGameStateMgr.SetIsGiftsLoading(false);	        	
				// real gift
				var obj = JSON.parse(request.responseText);
				var gifts = obj.gifts;
				var giftList = [];
				for (var j in gifts)
				{
					for (var i=0; i<WeGameStateMgr.mGifts.length; i++)
					{
						if (gifts[j].gift.id == WeGameStateMgr.mGifts[i].id)
						{
							giftList.push(WeGameStateMgr.mGifts[i]);
							break;
						}
					}
				}
				
				WeGameStateMgr.mOpenedGifts=giftList;
								
				var newArgs = {};
				newArgs.giftList=giftList;
	            var itemDef = WeUiMgr.GetItemDef("GiftShowScreenAll");
	            gameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
	            gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    

	            WeGameStateMgr.SetGlobalGameWidget(gameWidget);
	            WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GiftOpening);				
			});			

			NgLogD("All (possible) gifts opened!");
			return true;
		};
		image.Name = function(){ return "OnHandleTag_gift_open_all"; };
        return image;			
	},

	notEnoughMojoPopup : function ()
	{
		var popupArgs = {};

		popupArgs.popup_label = "Not Enough "+GameSpecificVariables.Texts.mojoTextU; 
		popupArgs.popup_text = "You don't have enough "+GameSpecificVariables.Texts.mojoTextU+" to perform that boost. Would you like to visit the "+GameSpecificVariables.Texts.mojoTextU+" Store?";
		
		popupArgs.OnYes = function(args)
		{
		    WeUiMgr.TransitionScreenTo("BuyMojoScreen");
		};
		popupArgs.OnNo = function(args)
		{
		    WeGameStateMgr.SetGlobalGameWidget(null);
		};

		// push the popup box onto the screen
		var itemDef = WeUiMgr.GetItemDef("popup_box");
		var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
		gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
		WeGameStateMgr.SetGlobalGameWidget(gameWidget);	
	},
	
	boostConfirmationPopup : function ()
	{		
		
	},

	OnHandleTag_gift_boost : function(imageDef, parent, args)
	{
		var self = this;
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
		    if (WeGameStateMgr.IsGiftsLoading())
		    {
		        return true;
		    }
		    
			var n = WeGameStateMgr.mCurrentGift;
			var giftIds = [];
			var gifts = WeGameStateMgr.mGifts;
			if (!Exists(gifts[n]) || gifts[n].boost_cost == -1 || gifts[n].proto_gift_id != -1)
			{
				NgLogD("Can't boost this one!");
				return true;
			}		
			if (gifts[n].boost_cost > WeGameStateMgr.GetGameLotInfo().mana)
			{
				// show the error popup
				self.notEnoughMojoPopup();					
				return true;
			}
			
			giftIds.push (gifts[n].id);
            self.confirmSpendMojoWithTarget({gifts: giftIds});
			return true;
		};
		image.Name = function(){ return "OnHandleTag_gift_boost"; };
        return image;			
	},

	OnHandleTag_gift_boost_all : function(imageDef, parent, args)
	{
		var self = this;
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
		    if (WeGameStateMgr.IsGiftsLoading())
		    {
		        return true;
		    }
			if (WeGameStateMgr.mShowingGiftOpenAnimation)
			{
				NgLogD("OnTapEvent: Still showing gift opening animation!");
				return true;				
			}
			var cost = -1;
			// collect gift ids
			var gifts = WeGameStateMgr.mGifts;
			for (var i=0; i<gifts.length; i++)
			{
				if (gifts[i].boost_cost >= 0)
				{
					cost = cost < 0 ? gifts[i].boost_cost : cost + gifts[i].boost_cost;
				}
			}
			if (cost < 0)
			{
				NgLogD("No boostable gifts!");
				return true;
			}
			if (cost > WeGameStateMgr.GetGameLotInfo().mana)
			{
				// show the error popup
				self.notEnoughMojoPopup();					
				return true;
			}			
						
			//show the confirmation popup
			var popupArgs = {};

			popupArgs.popup_label = "Boost All Gifts?"; 
			popupArgs.popup_text = "Do you want to spend "+cost+" "+GameSpecificVariables.Texts.mojoTextU+" to increase the value of all gifts?";
			
			popupArgs.OnYes = function(args)
			{
				var giftIds = [];
				var gifts = WeGameStateMgr.mGifts;
				// collect gift ids			
				for (var i=0; i<gifts.length; i++)
				{
					giftIds.push(gifts[i].id);
				}			
				// notify server
				WeProtocol.boostGifts(giftIds, function(){
					// rebuild gift list
					WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");					
				});	
				NgLogD("All gifts boosted!");
			};
			popupArgs.OnNo = function(args)
			{
			    WeGameStateMgr.SetGlobalGameWidget(null);
			};

			// push the popup box onto the screen
			var itemDef = WeUiMgr.GetItemDef("popup_box");
			var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
			gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
			WeGameStateMgr.SetGlobalGameWidget(gameWidget);					
			
			return true;
		};
		image.Name = function(){ return "OnHandleTag_gift_boost_all"; };
        return image;			
	},

	OnHandleTag_gifting_close_button : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			WeGameStateMgr.mGiftingOpen = false;
			// adding XP received from gifts
			if (WeGameStateMgr.mDelayedXp !== null)
			{
				WeGameStateMgr.GetGameLotInfo().xp = WeGameStateMgr.mDelayedXp;
			}

			var info = WeGameStateMgr.GetGameLotInfo();
			if(info)
				info.checkLevelUp();

			WeSocialMapMgr.transitionScreenToKingdom();
			return true;
		};
		image.Name = function(){ return "OnHandleTag_gifting_close_button"; };
        return image;
	},

	OnHandleTag_gift_loading_sign : function(imageDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		newDef.pos_y -= imageDef.size_y;		
		var image = this.CreateImage(newDef, parent, args, true);
		
		image.mAnim = null;
		image.mAnimState = WeUiMgr.WindowState.CLOSED;
		
		return image;			
	},

	show_boost_reminder : function ()
	{
		var image = WeUiMgr.GetImageFactory().FindImageOfName("gift_boost_reminder");
		if (!Exists(image) || image.mAnimState != WeUiMgr.WindowState.CLOSED)
		{
			NgLogD("Boost reminder does not exist!");
			return;
		}
			
		var self = image;
		var animation = new NumberAnimation (0.5, image.GetY(), image.GetY()+image.GetHeight());
		animation.SetNumber = function(value)
		{
			self.SetPosition(self.GetX(), value);
		};
		animation.OnStop = function()
		{
			self.mAnimState = WeUiMgr.WindowState.CLOSED;
			//NgLogD("Gift loading popup animation complete!");
		};
		// clean-up on deleting image
		if (!Exists(image.Olddestroy))
		{
    		image.Olddestroy=image.destroy;
    		image.destroy=function()
    		{
    			this.mAnim.Stop();
    			this.Olddestroy();
    		};
    	}		
		
		image.mAnim = animation;
		image.mAnimState = WeUiMgr.WindowState.CLOSING;		
	},

	show_gift_loading_sign : function ()
	{
		var image = WeUiMgr.GetImageFactory().FindImageOfName("gift_loading_sign");
		if (!Exists(image) || image.mAnimState != WeUiMgr.WindowState.CLOSED)
		{
			NgLogD("Gift loading popup does not exist!");
			return;
		}
			
		var self = image;
		var animation = new NumberAnimation (0.4, image.GetY(), image.GetY()+image.GetHeight());
		animation.SetNumber = function(value)
		{
			self.SetPosition(self.GetX(), value);
		};
		animation.OnStop = function()
		{
			self.mAnimState = WeUiMgr.WindowState.CLOSED;
			//NgLogD("Gift loading popup animation complete!");
		};
		// clean-up on deleting image
		if (!Exists(image.Olddestroy))
		{
    		image.Olddestroy=image.destroy;
    		image.destroy=function()
    		{
    			this.mAnim.Stop();
    			this.Olddestroy();
    		};
    	}		
		
		image.mAnim = animation;
		image.mAnimState = WeUiMgr.WindowState.CLOSING;		
	},

	hide_gift_loading_sign : function ()
	{
		var image = WeUiMgr.GetImageFactory().FindImageOfName("gift_loading_sign");
		if (!Exists(image))
		{
			NgLogD("Gift loading popup does not exist!");
			return;
		}
		if (image.mAnimState != WeUiMgr.WindowState.CLOSED)
		{
			//NgLogD("Gift loading pop up called to hide too soon!");
			//TODO: 'correct' animating
			WeGameStateMgr.SetIsGiftsLoading(false);
			image.mAnim.Stop();
		}
			
		var self = image;
		var animation = new NumberAnimation (0.4, image.GetY(), image.GetY()-image.GetHeight());
		animation.SetNumber = function(value)
		{
			self.SetPosition(self.GetX(), value);
		};
		animation.OnStop = function()
		{
			self.mAnimState = WeUiMgr.WindowState.CLOSED;
			//NgLogD("Gift loading popup animation complete!");
			WeGameStateMgr.SetIsGiftsLoading(false);
		};
		// clean-up on deleting image
		if (!Exists(image.Olddestroy))
		{
    		image.Olddestroy=image.destroy;
    		image.destroy=function()
    		{
    			this.mAnim.Stop();
    			this.Olddestroy();
    		};
    	}		
		
		image.mAnim = animation;
		image.mAnimState = WeUiMgr.WindowState.CLOSING;		
	},

	gift_receive_loaded : function()
	{
		NgLogD("gift_receive_loaded");
	    // load data from server                   
        WeUiMgr.GetImageFactory().show_gift_loading_sign();
        WeGameStateMgr.SetIsGiftsLoading(true);
        var self=this;
		WeProtocol.getGifts(function(){
			WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_h", "GiftReceiveView");
			WeUiMgr.GetImageFactory().hide_gift_loading_sign();
			
			NgLogD("gift_receive_loaded "+self.gifting_tab_semaphore);
			self.gifting_tab_semaphore=true;
		});
	},
	
	gift_send_loaded : function()
	{
		NgLogD("gift_send_loaded");
		// load data from server
		var self=this;
        WeProtocol.getGiftUsers(function(){
    		WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "GiftSendView");
    		NgLogD("gift_send_loaded "+self.gifting_tab_semaphore);
    		self.gifting_tab_semaphore=true;
    	});
	},
	
	OnHandleTag_gift_showcase : function (imageDef, parent, args)
	{
		// Add random winner webview
		var webView = new UI.WebView({'frame': [imageDef.pos_x - imageDef.size_x/2, imageDef.pos_y - imageDef.size_y/2,
									 			imageDef.size_x, imageDef.size_y]});
		
		webView.loadUrl(imageDef.url);
		NGWindow.document.giftWebView = webView;
		NGWindow.document.addChild(webView);
		
		var image = this.CreateImage(imageDef, parent, args, true);
		image.OnExit(function()
		{
	    	if(NGWindow.document.giftWebView)
			{
				NGWindow.document.removeChild(NGWindow.document.giftWebView);
				NGWindow.document.giftWebView.destroy();
            	NGWindow.document.giftWebView = null;
			}			
		});
		
		return image;
	},
	/* End of gifting code */

    
	OnHandleTag_popup_yes_button : function(imageDef, parent, args)
    {
        var cb = args.OnYes;
        if(Exists(cb))
        {
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Name = function(){ return "OnHandleTag_popup_yes_button"; };
            var root = parent;
            var theArgs = args;
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(args); 
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
					if (Exists(root.owner))
					{
						root.owner.destroy();
					}
                }
                
                if (WeUiMgr.GetActiveScreen() == "SocialMapScreen")
                {
                    Social.Common.Service.showCommunityButton([1.0,0.0], "dark", function(error)
            		{
            			NgLogD("ERROR showCommunityButton: "+error);
            		}		
            		);
        		}
                return true;
            };
            return image;
        }
        return null;
    },

    OnHandleTag_popup_no_button : function(imageDef, parent, args)
    {
        var cb = args.OnNo;
        if(Exists(cb))
        {
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Name = function(){ return "OnHandleTag_popup_no_button"; };
            var root = parent;
            var theArgs = args;
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs);
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
					if (Exists(root.owner))
					{
						root.owner.destroy();
					}
                }
                return true;
            };
            return image;
        }
        return null;
    },

    OnHandleTag_popup_ok_button : function(imageDef, parent, args)
    {
        var cb = args.OnOk;
        if(Exists(cb))
        {
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Name = function(){ return "OnHandleTag_popup_ok_button"; };
            var root = parent;
            var theArgs = args;
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs);
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
					if (Exists(root.owner))
					{
						root.owner.destroy();
					}
                }
                return true;
            };
            return image;
        }
        return null;
    },

    OnHandleTag_action_sell : function(imageDef, parent, args)
    {
        var image = null;
        var cb = args.OnSell;
        if(Exists(cb))
        {
            var root = parent;
            var theArgs = args;
            image = this.CreateImage(imageDef, parent, args, true);
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs); 
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
					if (Exists(root.owner))
					{
						root.owner.destroy();
					}
                }
                return true;
            };
            image.Name = function(){ return "OnHandleTag_action_sell"; };
        } 
        return image;
    },

	// Currently this is mostly the same as action_sell
    OnHandleTag_action_stash : function(imageDef, parent, args)
    {
        var image = null;
        var cb = args.OnStash;
        if(Exists(cb))
        {
            var root = parent;
            var theArgs = args;
            image = this.CreateImage(imageDef, parent, args, true);
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs); 
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
                    if (Exists(root.owner))
                    {
                        root.owner.destroy();
                    }
                }
                return true;
            };
            image.Name = function(){ return "OnHandleTag_action_stash"; };
        } 
        return image;
    },

    OnHandleTag_action_cancel : function(imageDef, parent, args)
    {
        var image = null;
        var cb = args.OnCancel;
        if(Exists(cb))
        {
            var root = parent;
            var theArgs = args;
            image = this.CreateImage(imageDef, parent, args, true);
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs); 
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
					if (Exists(root.owner))
					{
						root.owner.destroy();
					}
                }
                return true;
            };
            image.Name = function(){ return "OnHandleTag_action_cancel"; };
        } 
        return image;
    },

    OnHandleTag_action_buy : function(imageDef, parent, args)
    {
        var image = null;
        var cb = args.OnBuy;
        if(Exists(cb))
        {
            var root = parent;
            var theArgs = args;
            image = this.CreateImage(imageDef, parent, args, true);
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs); 
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
					if (Exists(root.owner))
					{
						root.owner.destroy();
					}
                }
                return true;
            } ;
            image.Name = function(){ return "OnHandleTag_action_buy"; };
        } 
        return image;
    },

    OnHandleTag_action_flip : function(imageDef, parent, args)
    {
    	//printStack("Flip button is being created from: ");
    	//NgLogD("Creating flip button -- ");
        var image = null;
        var cb = args.OnFlip;
        if(Exists(cb))
        {
        	//NgLogD("Found OnFlip method!");
            var root = parent;
            var theArgs = args;
            image = this.CreateImage(imageDef, parent, args, true);
            
            if(args.OnFlipAlpha)
            {
            	image.SetAlpha(args.OnFlipAlpha);
        	}
            else
            {
            	 image.Enable("Touch");
            }

            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
                cb(theArgs); 
                if(!Exists(imageDef.args.exit_on_tap) || imageDef.args.exit_on_tap)
                {
                	//NgLogD("Let's find root owner!");
					if (Exists(root.owner))
					{
						//NgLogD("Root owner: "+root.owner);
						root.owner.destroy();
					}
                }
                return true;
            };

            image.Name = function(){ return "OnHandleTag_action_flip"; };
        } 
        return image;
    },

    OnHandleTag_empty_touch : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        image.Enable("Touch");
        image.OnNativeTouch = function(touch){ 
            return true; 
        };
        if(imageDef.asset=="alpha2.png")
        {
        	image.SetVisible(false);
        }
        image.Name = function(){ return "OnHandleTag_empty_touch"; };
        return image;
    },

    OnHandleTag_auto_rotate : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true);
        image.rotation = 0;
        image.Name = function(){ return "OnHandleTag_auto_rotate"; };
        image.Enable("UpdateEmitter", function()
        {
            this.SetRotation(this.rotation);
            this.rotation += imageDef.args.rotation_speed;
        });
        
        return image;
    },
    
    OnHandleTag_upgrade_item_button : function(imageDef, parent, args)
    {
        var enabled = false;
        
        var status = weProtoDb.getInstance().canPurchaseUpgrade(args);
        var image;
        if (status == UpgradeStatus.kCanPurchase )
        {
            imageDef.asset = imageDef.args.enabled_asset;
            image = this.CreateImage(imageDef, parent, args, true);
            
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            // run purchase code...
            image.OnTapEvent = function(touch)
            {
            	Social.Common.Service.hideBalanceButton( function(error)
        		{
        			NgLogD("ERROR hideBalanceButton: "+error);
        		}		
        		);
				// Show confirmation screen
				var popupArgs = {};
				popupArgs.id = args.id;
				popupArgs.OnYes = function(args) 
				{
					Social.Common.Service.showBalanceButton(WeGameStateMgr.mBalanceRect, function(error)
					{
						NgLogD("ERROR showBalanceButton: "+error);
					});
					WeProtocol.purchaseUpgrade(args.id);
				};
				popupArgs.OnNo = function(args) 
				{
					Social.Common.Service.showBalanceButton(WeGameStateMgr.mBalanceRect, function(error)
					{
						NgLogD("ERROR showBalanceButton: "+error);
					});	
				};
				var itemDef = WeUiMgr.GetItemDef("UpgradeConfirmUI");
				var widget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
				widget.setPosition(gRawWidth*0.5, gRawHeight*0.5, 1000000000);
				WeGameStateMgr.SetGlobalGameWidget(widget);
                return true;
            };
            image.Name = function(){ return "OnHandleTag_upgrade_item_button"; };
            return image;
        }
        else
        {
            imageDef.asset = imageDef.args.disabled_asset;
            image = this.CreateImage(imageDef, parent, args, true); 
            // run purchase code...
            image.Name = function(){ return "OnHandleTag_upgrade_item_button 2"; };
            return image;
        }
    },

    OnHandleTag_AdjustScale : function(imageDef, parent, args)
    {
        var scale_adj = imageDef.args.adjustment;
        var platform = Core.Capabilities.getPlatformOS();
        if(  platform != "Android" && platform != "iPhone OS")
        {
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            // run purchase code...
            image.OnTapEvent = function(touch)
            {
                scale = WeCamera.scaleRoot.mXScale;
                scale += scale_adj;
                WeCamera.scaleRoot.setScale(scale, scale);
                return true;
            };

            image.Name = function(){ return "OnHandleTag_AdjustScale"; };
            return image;
        }
    },
    
    OnHandleTag_realm_select_button_open: function(imageDef, parent, args)
    {
		var page=0;
    	if(args )
    	{	
    		if( args.page>=0 )
    		{
    			page=args.page;
    		}
    		WeRealms.SetPage(page);
    	}
    	if (!WeGameStateMgr.IsCurrentUser())
    	{
    		if(WeGameStateMgr.HasOpenJobsIn( WeRealms.GetRealmName(imageDef.name)) )
    		{
    			return this.CreateImage(imageDef, parent, args, true);
    		}
    	}
    	return null;
    },
    
    OnHandleTag_realm_go_home: function(imageDef, parent, args)
    {
    	if (!WeGameStateMgr.IsCurrentUser() || WeCloudManager.mRealmIndex != Realms.MainRealm.index)
    	{
            var image = this.CreateImage(imageDef, parent, args, true);
            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true;  };
            image.OnTapEvent = function(touch)
            {
            	//TODO: Start Close realm menu
            	if (WeLoadNamedLot(gCurKingdomUser))
				{
	            	WeGameStateMgr.SetCurrentKingdomUser(gCurKingdomUser);					
				}
            	return true;
            };
            return image;
    	}
    	return null;
    },
    
    OnHandleTag_realms_view_back: function (imageDef, parent, args)
    {
    	if(WeRealms.GetPageCount()<=1)
    	{
    		return null;
    	}
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var self = this;
    	
    	this.realms_view_back=image;
    	
    	if( WeRealms.GetPage()==0 )
    	{
    		image.SetVisible(false);
    	}
    	
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
        	if(WeRealms.PageBack())
        	{
        		//NgLogD("realms_view_back switched"+ WeRealms.GetPage());
        		WeUiMgr.GetCompositeFactory().RebuildComposite("build_realms_view_h", "build_realms_view");
        	}
        	
           	if( !(WeRealms.GetPage()<WeRealms.GetPageCount()-1) )
        	{
           		self.realms_view_forward.SetVisible(false);
        	}
           	else	
           	{
           		self.realms_view_forward.SetVisible(true);
           	}
           	
           	if( WeRealms.GetPage()==0 )
        	{
           		self.realms_view_back.SetVisible(false);
        	}
           	else	
           	{
           		self.realms_view_back.SetVisible(true);
           	}
    	};
    	
    	return image;
    },
    
    OnHandleTag_realms_view_forward: function (imageDef, parent, args)
    {
    	if(WeRealms.GetPageCount()<=1)
    	{
    		return null;
    	}
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var self = this;
    	
    	this.realms_view_forward=image;
    	
    	if( !(WeRealms.GetPage()<WeRealms.GetPageCount()-1) )
    	{
    		image.SetVisible(false);
    	}
    	
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
        	//REMOVE
        	//NgLogD("realms_view_forward current "+WeRealms.GetPage());
        	if(WeRealms.PageForward())
        	{
        		//NgLogD("realms_view_forward switched"+ WeRealms.GetPage())
        		WeUiMgr.GetCompositeFactory().RebuildComposite("build_realms_view_h", "build_realms_view");
        	}
        	
           	if( !(WeRealms.GetPage()<WeRealms.GetPageCount()-1) )
        	{
           		self.realms_view_forward.SetVisible(false);
        	}
           	else	
           	{
           		self.realms_view_forward.SetVisible(true);
           	}
           	
           	if( WeRealms.GetPage()==0 )
        	{
           		self.realms_view_back.SetVisible(false);
        	}
           	else	
           	{
           		self.realms_view_back.SetVisible(true);
           	}
    	};
    	
    	return image;
    },
    
    OnHandleTag_realm_select_button : function(imageDef, parent, args)
    {
		var page=0;
    	if(args )
    	{	
    		if( args.page>=0 )
    		{
    			page=args.page;
    		}
    		WeRealms.SetPage(page);
    	}
    	var kingdom = WeGameStateMgr.GetGameLotInfo();
	    var current_kingdom_type = kingdom.kingdom_type;
	    var all_kingdoms = kingdom.all_kingdoms;
	    var len = all_kingdoms.length;
	    
	    var sRealmName=imageDef.name;

	    var unlockUpgrade=WeRealms.GetUpgrade(sRealmName); // WeGameStateMgr.UnlockUpgrade(sRealmName);
	    if(!unlockUpgrade)
	    {
	    	return null;
	    }
	    var realm=WeRealms.GetRealm(sRealmName);
	    var state=WeRealms.GetState(sRealmName);
	    
	    if(WeBoundary.RealmState.None==state)
	    {
	    	//REMOVE
	    	//return null;
	    }
	    
	    imageDef.asset=WeRealms.GetAsset(sRealmName, state);
	    
        var image = this.CreateImage(imageDef, parent, args, true); 
        
        image.mState= state;
        image.mUnlockUpgrade=unlockUpgrade;
        image.mRealmName=sRealmName;
        image.page=page;
        
    	imageDef.highlight_color_off=[1.0, 1.0, 1.0, 1.0];
    	imageDef.highlight_color_on=[0.8, 0.8, 0.8, 1.0];
        
        var dest_realm2 = image.mRealmName;
	        // Flush all game state objects for now
	    var realm2=WeRealms.GetRealm(dest_realm2);
    	if(realm2)
		{
		 	if( WeGameStateMgr.GetCurrentKingdomId()==realm2.kingdom_id )
		 	{
		 		imageDef.highlight_color_off=[0.8, 0.8, 0.8, 1.0];
		 		image.SetColor(0.8, 0.8, 0.8, 1.0);
		 	}
		}

        var self=this;
        
        image.Enable("Touch");
        image.OnTouchDown = function(touch) 
        { 
        	if( Exists(parent))
        	{
        		var parent2= parent.getParent();
        		if( Exists(parent2) )
        		{
	        		if(Exists(parent2.getAlpha));
	        		{
	              		if(parent2.getAlpha()<0.2)
	            		{
	            			return false;
	            		}
	        		}
        		}
        	}
        	return true;  
        };
        image.OnTapEvent = function(touch)
        {
        	if( Exists(parent))
        	{
        		var parent2= parent.getParent();
        		if( Exists(parent2) )
        		{
	        		if(Exists(parent2.getAlpha));
	        		{
	              		if(parent2.getAlpha()<0.2)
	            		{
	            			return false;
	            		}
	        		}
        		}
        	}

        	if(Exists(this.page))
        	{
        		//REMOVE
        		NgLogD("Setting to page "+this.page);
        		WeRealms.SetPage(this.page);
        	}
        	
            switch(image.mState)
            {
            	case WeBoundary.RealmState.PurchasedLot:
            	{
            		if (Exists(WeGameStateMgr.GetGameLotInfo().mConstructing) && WeGameStateMgr.GetGameLotInfo().mConstructing)
         	        {
         	            return false;
         	        }
         	        
         	        var dest_realm = image.mRealmName;
         	        // Flush all game state objects for now
         	        var realm=WeRealms.GetRealm(dest_realm);
     	       		if(realm)
     	            {
     	            	if( WeGameStateMgr.GetCurrentKingdomId()!=realm.kingdom_id )
     	            	{
     	            		WeUiMgr.ForceHideRealmsNavigation();
     	            	    WeGameStateMgr.SetActiveObject(null);
     	         	        WeGameStateMgr.SetLastActiveObject(null);
     	         	        if(WeGameStateMgr.GetGameLotInfo())
     	         	        {
     	         	        	WeGameStateMgr.GetGameLotInfo().ReleaseShellObject();
     	         	        }
     	            	
         	                WeLotLoad(realm.kingdom_id);    
         	                WeGameStateMgr.SetCurrentKingdomId(realm.kingdom_id);
     	            	}
     	                return true;
     	            }
         	        NgLogD("ERROR: Couldn't find the destination kingdom!");
            		break;
            	}
	            case WeBoundary.RealmState.LockedLot:
	        	{
	    	        if (WeGameStateMgr.IsCurrentUser())
	    	        {
	    	        	WeGameStateMgr.onShowRealmPurchaseStatic(image.mUnlockUpgrade.id, image.mState);
	    	        }
	            	break;
	        	}
	            case WeBoundary.RealmState.UnpurchasedLot:
	        	{
	    	        if (WeGameStateMgr.IsCurrentUser())
	    	        {
	    	        	WeGameStateMgr.onShowRealmPurchaseStatic(image.mUnlockUpgrade.id, image.mState);
	    	        }
	            	break;
	        	}
	        	default:
	        		return false;
	        }
            return true;
        };
        return image;
    },

    OnHandleTag_close_global_widget : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Enable("Touch");
        //image.OnTouchDown = function(touch) { return true;  };
        image.OnTouchDown = function(touch)
        {
            WeGameStateMgr.SetGlobalGameWidget(null);
            return true;
        };
        if(imageDef.asset=="alpha2.png")
        {
        	image.SetVisible(false);
        }
        image.Name = function(){ return "OnHandleTag_close_global_widget"; };
        return image;
    },
    
    OnHandleTag_close_buil_widget : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Enable("Touch");
        //image.OnTouchDown = function(touch) { return true;  };
        image.OnTouchDown = function(touch)
        {
            //WeGameStateMgr.SetGlobalGameWidget(null);
            return false;
        };
        if(imageDef.asset=="alpha2.png")
        {
        	image.SetVisible(false);
        }
        image.Name = function(){ return "OnHandleTag_close_buil_widget"; };
        return image;
    },

    OnHandleTag_print_fps : function(imageDef, parent, args)
    {
        var image = this.CreateImage(imageDef, parent, args, true); 
        image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
            NgLogD("High FPS = " + gHighFPS + ", Low FPS = " + gLowFPS);
            gHighFPS = 0;
            gLowFPS = 100000;
            return true;
        };
    },
	OnHandleTag_goto_social_navigator_forward: function(imageDef, parent, args)
	{
		var currentPage = WeSocialMapMgr.getMapCurrentPage();
		var maxPage     = WeSocialMapMgr.getMapMaxPages();
		
		if (maxPage === currentPage || maxPage === 1)
		{
			return null;
		}
		
		var nextPage = currentPage + 1;
		
		var image = this.CreateImage(imageDef, parent, args, true);
		
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
        	if(WeSocialMapMgr.changeingPage )
        	{
        		return false;
        	}  
        	//NgLogD("Social map on navig >");  	
			WeSocialMapMgr.launchSocialMap(nextPage);
			WeUiMgr.ShowLoading(true);
            return true;
        };
        return image;
	},
	OnHandleTag_goto_social_navigator_back: function(imageDef, parent, args)
	{
		var currentPage = WeSocialMapMgr.getMapCurrentPage();
		var maxPage     = WeSocialMapMgr.getMapMaxPages();
		
		if (currentPage === 1 || maxPage === 1)
		{
			return null;
		}
		
		var prevPage = currentPage - 1;
		var image = this.CreateImage(imageDef, parent, args, true);
		
        image.Enable("Touch");
        // have to override onTouchDown return true to get the other touch events
        image.OnTouchDown = function(touch) { return true;  };
        image.OnTapEvent = function(touch)
        {
        	if(WeSocialMapMgr.changeingPage )
        	{
        		return false;
        	}
        	//NgLogD("Social map on navig <");
			WeSocialMapMgr.launchSocialMap(prevPage);
			WeUiMgr.ShowLoading(true);
			this.LaunchingSocialMap=false;
            return true;
        };
        return image;
    },
    OnHandleTag_social_navigator_center: function(imageDef, parent, args)
    {
        var maxPage = WeSocialMapMgr.getMapMaxPages();
        if (maxPage === 1)
            return null;
        
        var image = this.CreateImage(imageDef, parent, args, true);
        return image;
    },
    
    OnHandleTag_communityMapButton: function (imageDef, parent, args)
    {	
    	
    	 var configs = weProtoConfigs.getInstance().configs;
    	 var bCommunityMapEnabled=true;
    	 if( configs["CommunityMapEnabled"]!= undefined )
    	 {
    		 
    		 bCommunityMapEnabled=configs["CommunityMapEnabled"].value;
    		 NglogD("CommunityMapEnabled "+bCommunityMapEnabled);
    	 }
    	 if(!bCommunityMapEnabled)
    	{
    		 return null;
    	}
    	
    	if (WeSocialMapMgr.isCommunityMap)
    	{
    		imageDef.asset= imageDef.args.toSocial;
    	}
    	else
    	{
    		imageDef.asset= imageDef.args.toCommunity;
    	}
    	
		var image = this.CreateImage(imageDef, parent, args, true);
		
		image.Enable("Touch");
		// have to override onTouchDown return true to get the other touch events
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function(touch)
		{
			WeSocialMapMgr.changeMode();
		    return true;
		};
		return image;
    },
    
    OnHandleTag_communityRefreshButton: function (imageDef, parent, args)
    {	
    	if(!WeSocialMapMgr.isCommunityMap) return null;
    	
    	NgLogD("OnHandleTag_communityRefreshButton "+WeSocialMapMgr.isCommunityMap);

		var image = this.CreateImage(imageDef, parent, args, true);
		
		image.Enable("Touch");
		// have to override onTouchDown return true to get the other touch events
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function(touch)
		{
			WeSocialMapMgr.Refresh();
		    return true;
		};
		return image;
    },
    
    OnHandleTag_addMeButton: function (imageDef, parent, args)
    {
    	//	fullRecurseDump(WeGameStateMgr.GetGameLot(),  4, 4);
		NgLogD("@@@@@ Creating addMe button, invisible so far");
		var image = this.CreateImage(imageDef, parent, args, true);
		
		image.SetAlpha(0.0);
		
		var name=WeGameStateMgr.GetCurrentKingdomUser();
		
		var kingdom = WeGameStateMgr.GetGameLotInfo();
		objDumpMembers(kingdom, 4);
		NgLogD("is friend "+kingdom.is_friend);

		if( !WeGameStateMgr.IsFriend() )
		//WeProtocol.isNeighbor(name , function(response )  
		{
			//NgLogD("@@@@@ Got response from isNeighbor, response is as following:");
			//objDumpMembers(response, 4);

			//var obj;
			try
	        {
	       	   // obj = JSON.parse(response.responseText);
	       	   // var neighbor=false;
	       	   // neighbor=obj.status;
	       	    
	       	    
	       		//if(!neighbor)
				{
					var canTap=true;
					//NgLogD("@@@@@ Making addMe visible");
					image.SetAlpha(1.0);
					
					image.Enable("Touch");
					image.OnTouchDown = function(touch) { return true; };
					image.OnTapEvent = function(touch)
					{
						//NgLogD("@@@@@ addMe tapped");
						canTap=false;
						
						WeProtocol.addNeighbor(name, function(response)
						{
		       	    		image.SetAlpha(1.0);
							canTap=true;
							//NgLogD("@@@@@ Got response from addNeighbor, response is as following:");
							//objDumpMembers(response, 4);
							// if "result" == "SUCCESS", make invisible again
							var obj;
							try
					        {
					       	    obj = JSON.parse(response.responseText);
					       	    if(obj.result == "SUCCESS")
					       	    {
										kingdom.is_friend = true;
										WeGameStateMgr.SetIsFriend(true);
				       	    			image.SetAlpha(0.0);
				       	    			canTap=false;

                                        var itemDef = WeUiMgr.GetItemDef("popup_box");
                                        var gameWidget = WeUiMgr.CreateGameWidget(itemDef, {popup_label: 'Add a friend', popup_text: 'Hooray! ' + name  + ' is now your friend and can be visited through your Social Map.', OnOk: function (opts) {WeGameStateMgr.SetGlobalGameWidget(null);}});
                                        gameWidget.setPosition(gRawWidth / 2, gRawHeight / 2);
                                        WeGameStateMgr.SetGlobalGameWidget(gameWidget);
					       	    }
					       	   
					        }
					        catch(ex)
					        {
					        	NgLogD("Exception: "+ex);	
					        }
							

						}
						);
					    return true;
					};
				}
			}
	        catch(ex)
	        {
	        	NgLogD("Exception: "+ex);	
	        }
		
		}		
		//);
		return image;
    },
    
    OnHandleTag_goto_userprofile: function (imageDef, parent, args)
    {
    	//	fullRecurseDump(WeGameStateMgr.GetGameLot(),  4, 4);
		NgLogD("@@@@@ Creating addMe button, invisible so far");
		var image = this.CreateImage(imageDef, parent, args, true);
		
		image.SetAlpha(0.0);
		
		var name=WeGameStateMgr.GetCurrentKingdomUser();
		
		var kingdom = WeGameStateMgr.GetGameLotInfo();
	//	objDumpMembers(kingdom, 4);
	//	NgLogD("is friend "+kingdom.is_friend);

	//	if( !WeGameStateMgr.IsFriend() )
		//WeProtocol.isNeighbor(name , function(response )  
		{
			//NgLogD("@@@@@ Got response from isNeighbor, response is as following:");
			//objDumpMembers(response, 4);

			//var obj;
			try
	        {
	       	   // obj = JSON.parse(response.responseText);
	       	   // var neighbor=false;
	       	   // neighbor=obj.status;
	       	    
	       	    
	       		//if(!neighbor)
				{
					var canTap=true;
					//NgLogD("@@@@@ Making addMe visible");
					image.SetAlpha(1.0);
					
					image.Enable("Touch");
					image.OnTouchDown = function(touch) { return true; };
					image.OnTapEvent = function(touch)
					{
						NgLogD("@@@@@ profile tapped " + name);
						canTap=false;
						Social.US.Service.Profile.showUserProfile(name, null)
						
					    return true;
					};
				}
			}
	        catch(ex)
	        {
	        	NgLogD("Exception: "+ex);	
	        }
		
		}		
		//);
		return image;
    },
/*
		NgLogD("Ad castle configs: ");		
		NgLogD(gConfigs.AdCastleBonusType+", "+gConfigs.AdCastleRefreshTime+"s, ["+
			   gConfigs.AdCastleOffsetX+" "+gConfigs.AdCastleOffsetY+"], "+
			   gConfigs.AdCastleTitle+", "+gConfigs.AdCastleText); 
 */    
    OnHandleTag_ad_castle_tap: function (imageDef, parent, args)
    {
    	//	fullRecurseDump(WeGameStateMgr.GetGameLot(),  4, 4);
		NgLogD("@@@@@ Creating addMe button, invisible so far");
		var image = this.CreateImage(imageDef, parent, args, true);
		
		image.SetAlpha(0.0);
		
		var name=WeGameStateMgr.GetCurrentKingdomUser();
		
		var kingdom = WeGameStateMgr.GetGameLotInfo();
	//	objDumpMembers(kingdom, 4);
	//	NgLogD("is friend "+kingdom.is_friend);

	//	if( !WeGameStateMgr.IsFriend() )
		//WeProtocol.isNeighbor(name , function(response )  
		{
			//NgLogD("@@@@@ Got response from isNeighbor, response is as following:");
			//objDumpMembers(response, 4);

			//var obj;
			try
	        {
	       	   // obj = JSON.parse(response.responseText);
	       	   // var neighbor=false;
	       	   // neighbor=obj.status;
	       	    
	       	    
	       		//if(!neighbor)
				{
					var canTap=true;
					//NgLogD("@@@@@ Making addMe visible");
					image.SetAlpha(1.0);
					
					image.Enable("Touch");
					image.OnTouchDown = function(touch) { return true; };
					image.OnTapEvent = function(touch)
					{
						NgLogD("@@@@@ profile tapped " + name);
						canTap=false;
						Social.US.Service.Profile.showUserProfile(name, null)
						
					    return true;
					};
				}
			}
	        catch(ex)
	        {
	        	NgLogD("Exception: "+ex);	
	        }
		
		}		
		//);
		return image;
    },
    
    OnHandleTag_goto_userprofile: function (imageDef, parent, args)
    {
        //	fullRecurseDump(WeGameStateMgr.GetGameLot(),  4, 4);
        NgLogD("@@@@@ Creating addMe button, invisible so far");
        var image = this.CreateImage(imageDef, parent, args, true);
        image.SetAlpha(0.0);
        var name=WeGameStateMgr.GetCurrentKingdomUser();
        try
        {

            var canTap=true;
            //NgLogD("@@@@@ Making addMe visible");
            image.SetAlpha(1.0);

            image.Enable("Touch");
            image.OnTouchDown = function(touch) { return true; };
            image.OnTapEvent = function(touch)
            {
                WeUiMgr.ShowLoading(true);
                Social.US.User.getUserWithGamertag(name, function(err, usr)
                {   
                    if(usr && !err)
                    {

                        Social.US.Service.Profile.showUserProfile(usr, null)  ;

                    }
                    else
                    {
                        NgLogD("*** PROFILE ERROR");
                        var cb = function(args)
                        {
                            WeGameStateMgr.SetGlobalGameWidget(null);

                        };
                        WeUiMgr.ShowOKDialog(cb, "Error", "Sorry, we can't find anyone with that name.");
                        WeUiMgr.ShowLoading(false);
                    }
                });
                return true;
            };

        }
        catch(ex)
        {
            NgLogD("Exception: "+ex);	
        }


        return image;
    },
/*
		NgLogD("Ad castle configs: ");		
		NgLogD(gConfigs.AdCastleBonusType+", "+gConfigs.AdCastleRefreshTime+"s, ["+
			   gConfigs.AdCastleOffsetX+" "+gConfigs.AdCastleOffsetY+"], "+
			   gConfigs.AdCastleTitle+", "+gConfigs.AdCastleText); 
 */    
    OnHandleTag_ad_castle_tap: function (imageDef, parent, args)
    {
		var image = this.CreateImage(imageDef, parent, args, true);
		image.mRequiresTap = true;
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true; };
		image.OnTapEvent = function(touch)
		{
		  NgLogD ("Ad castle tapped!");
		  
		  var args = {};
		  args.OnYes = function (){NgLogD("Yes!")};
		  
          itemDef = WeUiMgr.GetItemDef("AdViewUI");
          gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
          gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
          WeGameStateMgr.SetGlobalGameWidget(gameWidget);
          
          Social.Common.Service.hideCommunityButton(function(error)
  				{
  					NgLogD("ERROR hideCommunityButton: "+error);
  				});
  				
		};
		return image;    	
    },
    
    OnHandleTag_ad_view_web : function (imageDef, parent, args)
    {
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true; };
		image.OnTapEvent = function(touch)
		{
			return true;					
		};
		image.OnExit(function(){WeRuleHome.removeAd()});
		WeRuleHome.removeAd();
		WeRuleHome.showAdWebWithArgs(imageDef.args.ad_loc_x, imageDef.args.ad_loc_y, imageDef.size_x, imageDef.size_y);
		return image;    	
    },
    
    CreateAdditionalLoadingWebView: function (url, size, cbError, cbOnLoad)
    {
        NgLogD("Got 2nd WebView");
	    var webView2 = new UI.WebView({'frame': [
			(gRawWidth - size.x) / 2, (gRawHeight - size.y) / 2, size.x, size.y]
		});
	
		webView2.setOnError(cbError.bind(webView2));
		webView2.initialVisible =  false;
		webView2.loaded = false;
    	webView2.setOnPageload(cbOnLoad.bind(this, webView2));
		webView2.setBackgroundColor("FF000000");
	    webView2.setAlpha(0);
	    webView2.setVisible(false);
	    
	    return webView2;
    },
    
    OnHandleTag_loading_adview: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	
		var size = {x : imageDef.size_x, y : imageDef.size_y};
		
		if (!Exists(size.x) || !Exists(size.y))
		{
		    size.x = gRawWidth;
		    size.y = gRawHeight;
		}
		var webView = new UI.WebView({'frame': [
			(gRawWidth - size.x) / 2, (gRawHeight - size.y) / 2, size.x, size.y]
		});
		
		var cbError = function()
		{
			//
			//	this is bound to webview
			//
			NgLogD("error loading webview");
			NGWindow.document.removeChild(this);
		};
		
		var cbPageload = function(webview)
		{
			imageDef.asset = "black.png";
						
			if(gFirstBoot)
			{
				if (Exists(webview.first) && webview.first)
				{
					NGWindow.document.loadingInfoView.infoTextExtended.setVisible(true);
				}
			}
				
			webview.setVisible(webview.initialVisible);
						
			webview.loaded = true;
			
			if (this.mUrlList.length > 0)
			{
				//
				//	load next webview
				//
				url = this.mUrlList.shift();
				NgLogD("loading next url: " + url);
				wv = this.mWebViewsToLoad.shift();
  				wv.loadUrl(url+ '?v=' + (new Date().getTime()));
			}
		};
		
		webView.initialVisible =  true;
		webView.first =  true;
		
		webView.setOnError(cbError.bind(webView));
		webView.setOnPageload(cbPageload.bind(this, webView)); 
			
		if (imageDef.args.firstUrl)
		{
			if(gFirstBoot) 
			{
				NgLogD("Showing first boot webview url");
				webView.loadUrl(imageDef.args.firstUrl + '?v=' + (new Date().getTime()));
			}			    
			else 
			{
				NgLogD("Showing regular webview url");
				webView.loadUrl(imageDef.args.url+ '?v=' + (new Date().getTime()));
			}
		}
		else
		{
			NgLogD("Showing regular webview url (firstUrl undefined)");
			webView.loadUrl(imageDef.args.url+ '?v=' + (new Date().getTime()));
		}
		
		var webList = [];
		var webView2;
		this.mUrlList = [];
		
		if (gFirstBoot)
		{
		    if (Exists(imageDef.args.url2))
    		{
		    	this.mUrlList.push(imageDef.args.url2);
		    	var webView2 = this.CreateAdditionalLoadingWebView(imageDef.args.url2, size, cbError, cbPageload);
		    	webList.push(webView2);
			}
		
    		if (Exists(imageDef.args.url3))
    		{
    			this.mUrlList.push(imageDef.args.url3);
    			var webView2 = this.CreateAdditionalLoadingWebView(imageDef.args.url2, size, cbError, cbPageload);
    			webList.push(webView2);
    		}
		
    		if (Exists(imageDef.args.url4))
    		{
    			this.mUrlList.push(imageDef.args.url4);
    			var webView2 = this.CreateAdditionalLoadingWebView(imageDef.args.url2, size, cbError, cbPageload);
    			webList.push(webView2);
    		}
		
    		if (Exists(imageDef.args.url5))
    		{
    			this.mUrlList.push(imageDef.args.url5);
    			var webView2 = this.CreateAdditionalLoadingWebView(imageDef.args.url5, size, cbError, cbPageload);
    			webList.push(webView2);
    		}
		
    		if (Exists(imageDef.args.url6))
    		{
    			this.mUrlList.push(imageDef.args.url6);
    			var webView2 = this.CreateAdditionalLoadingWebView(imageDef.args.url5, size, cbError, cbPageload);
    			webList.push(webView2);
    		}
		}
		
		this.mWebViewsToLoad = webList.slice(0); 

		webView.setBackgroundColor("FF000000");
		webView.setVisible(false);
		
		NGWindow.document.loadingWebView = webView;
		NGWindow.document.additionalWebList = webList;
		
		if (gLoadingAdView)
		{
			NGWindow.document.addChild(webView);
			
			for (i in webList)
    		{
    			wv = webList[i];
    			NGWindow.document.addChild(wv);
    		}
			
			image.SetVisible(true);
		}
		else
		{
			image.SetVisible(false);
		}
		
        image.OnExit(function()
        {
	    	if(NGWindow.document.loadingWebView)
			{
				if (gLoadingAdView)
				{
					NGWindow.document.removeChild(NGWindow.document.loadingWebView);
					NGWindow.document.loadingWebView.destroy();
				}
				NGWindow.document.loadingWebView = null;
			}        	
			
			if (NGWindow.document.additionalWebList)
			{
			    var count = NGWindow.document.additionalWebList.length;
    			for (var i=0; i < count; i++)
    			{
    			    NGWindow.document.removeChild(NGWindow.document.additionalWebList[i]);
    			    NGWindow.document.additionalWebList[i].destroy();
    			    NGWindow.document.additionalWebList[i] = null;
    			}
			}
			
			NGWindow.document.additionalWebList = null;
        });
       
        return image;    		
    },

	OnHandleTag_loading_backbutton: function (imageDef, parent, args)
	{
		var dummyImg = null;
		if(gFirstBoot)
		{
    		var view = new UI.View();
    		view.setFrame([0, 0, gRawWidth, gRawHeight]);
			NGWindow.document.loadingBackbutton = view;
			NGWindow.document.addChild(view);

			var image = new UI.Image();
			image.setImage(imageDef.asset);
			image.setImageFit(UI.FitMode.Stretch);
			image.setFrame([gRawWidth - imageDef.size_x, 0, imageDef.size_x, imageDef.size_y]);
			view.addChild(image);

			var newDef = ObjectUtils.GetCloneOfObject(imageDef);
			newDef.asset = "alpha2.png";
			dummyImg = this.CreateImage(newDef, parent, args, true);
			dummyImg.OnExit(function()
			{
				if(NGWindow.document.loadingBackbutton)
				{
					NGWindow.document.removeChild(NGWindow.document.loadingBackbutton);
					NGWindow.document.loadingBackbutton = null;
				}        	
			});

			image.setOnClick(function()
			{
				var alertDialog = new UI.AlertDialog();
				alertDialog.setTitle("Oi!");
				alertDialog.setText("Do you want to go back to Mobage?");
				alertDialog.setChoices(["Yes", "No"]);
				alertDialog.onchoice = function(event)
				{
					if(event.choice == 0)
						Device.LifecycleEmitter.exitProcess();
				};
				alertDialog.show();
			});
		}

		return dummyImg; 
	},

    OnHandleTag_loading_additional_webview : function (imageDef, parent, args)
    {
        var image=this.CreateImage(imageDef, parent, args, true);
        image.OnExit(function()
        {
            if(NGWindow.document.loadingScreenAdditionalWebView)
            {
                NGWindow.document.removeChild(NGWindow.document.loadingScreenAdditionalWebView);
                NGWindow.document.loadingScreenAdditionalWebView = null;
            }
        });
		image.SetVisible(false);	// the image is a registered point for the webview, so no need to be visible
        return image;
    },
    
    OnHandleTag_loading_info: function (imageDef, parent, args)
    {
    	// loading information view
    	var infoView = new UI.View();
    	infoView.setFrame([0, 0, gRawWidth, gRawHeight]);
		NGWindow.document.loadingInfoView = infoView;
		NGWindow.document.addChild(infoView);

		// info bubble
		var bubble = new UI.Image();

		var asset = Content.getImagePath(imageDef.asset);
		bubble.setImage(asset);
		bubble.setImageFit(UI.FitMode.Stretch);
		bubble.setFrame([imageDef.pos_x-imageDef.size_x/2, imageDef.pos_y-imageDef.size_y/2/*-70*/, imageDef.size_x, imageDef.size_y]);
		infoView.addChild(bubble);
		
		
		// status message -- update function is in the relevant label
		var text = new UI.Label();
		text.setFrame([imageDef.pos_x-imageDef.size_x/2, imageDef.pos_y-imageDef.size_y/2/*-8-70*/, imageDef.size_x, imageDef.size_y]);
		text.setText("Loading...");
		text.setTextSize(getSmallFontSize());
		text.setTextColor(GameSpecificVariables.Colors.LoadingInfoTextColor);
		infoView.infoText = text;
		infoView.addChild(text);
		
		//
		//	second text label
		//
		
				
		var textExtended = new UI.Label();
		textExtended.setFrame([imageDef.pos_x_extended-imageDef.size_x_extended/2,
		                       imageDef.pos_y_extended-imageDef.size_y_extended/2/*-8-70*/, imageDef.size_x_extended, imageDef.size_y_extended]);
		
		textExtended.setText("");
		textExtended.setTextSize(getLargeFontSize());
		textExtended.setTextColor(GameSpecificVariables.Colors.LoadingInfoTextColor);
		infoView.infoTextExtended = textExtended;
		infoView.addChild(textExtended);
		textExtended.setVisible(false);
		
		// spinner
		if (gLoadingAdView)
			WeUiMgr.ShowLoading(true);
    	   	
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	newDef.asset = "alpha2.png";
        var image = this.CreateImage(newDef, parent, args, true);
        image.OnExit(function()
        {
	    	if(NGWindow.document.loadingInfoView)
			{
				NGWindow.document.removeChild(NGWindow.document.loadingInfoView);
            	NGWindow.document.loadingInfoView = null;
			}        	
        });
/*
        // hacky hacky
    	image.Olddestroy=image.destroy;
	    image.destroy=function()
        {
	    	if(NGWindow.document.loadingInfoView)
			{
				NGWindow.document.removeChild(NGWindow.document.loadingInfoView);
            	NGWindow.document.loadingInfoView = null;
			}						
        	this.Olddestroy();
        };  
*/                     
        return image;    	
    },
    
    OnHandleTag_close_popup: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
          	WeGameStateMgr.SetPopupWidget(null);
        }; 	
    	
    	return image;    	
    },
    
    
    OnHandleTag_close_popup_levelup: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
           	WeGameStateMgr.SetPopupWidget(null);
        	
        	var info = WeGameStateMgr.GetGameLotInfo();
        	if(info)
        	{
        		info.checkRatingDialog();
				info.checkAddFriendsPrompt();
        	}
        }; 	
    	
    	return image;    	
    },
    
    
	OnHandleTag_empty_tag: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	return image;
    },
    
    OnHandleArg_GoalsEnabled: function ()
    {
    	return WeGoals.enabled;
    },
    
    OnHandleTag_event_glow: function (imageDef, parent, args)
    {   	
    	var image = this.CreateImage(imageDef, parent, args, true);
    	image.SetAlpha(0.0);
    	
    	return image;	
    },
    
    OnHandleTag_gl_glow: function (imageDef, parent, args)
    {   	
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var animation = new NumberAnimation (2.0, 1.0, 0.0);
    	animation.setLoop(true);
		animation.SetNumber = function(value)
		{			
			if(WeGoals.animateGoalbook)
			{
				if(image.GetVisible())
				{
					image.SetAlpha(  (Math.sin(2*Math.PI*value)+1)*0.8 );
				}
			}
			else
			{
				image.SetAlpha(0.0);
			}
		};
		animation.OnStop = function()
		{
			this.destroy();
		};
		
		image.OnExit(function()
	    {
			animation.Stop();
	    });
    	return image;	
    },
    
    OnHandleTag_goal_finger: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var yStart=image.GetY(); 
    	var xStart=image.GetX();   	
    	var animation = new NumberAnimation (imageDef.args.time, -imageDef.args.distance*0.5, imageDef.args.distance*0.5);
    	animation.setLoop(true);
    	var vertical = imageDef.args.bounceVertical;
        var myArgs = args;
    	var myDef = imageDef;
    	var name = "firstGoal_" +  myDef.name;
        image.SetAlpha(0);
        animation.SetNumber = function(value)
        {
            if(WeGoals.currentGoal && WeGoals.currentGoal.proto_goal_id == gFirstGoalID
                && WeGoals.currentGoal.active)
            {
                if(Exists(myArgs) && Exists(myArgs.store_image_url))
                {
                    var i = 0;
                    for(; i < WeGoals.currentGoal.tasks.length; ++i)
                    {
                        if(WeGoals.currentGoal.tasks[i].proto_task.task_type_id == myArgs.proto_id)
                        {
                            break;
                        }
                    }
                    if(i == WeGoals.currentGoal.tasks.length)
                    {
                        image.SetAlpha(0);
                    }
                    else
                    {
                        image.SetAlpha(1);
                    }
                }
                else
                {
                    image.SetAlpha(1);
                }
                if (vertical)
                image.SetPosition(image.GetX(), yStart + Math.abs( value) );
                else
                    image.SetPosition(xStart + Math.abs( value), image.GetY() );
            }
            else
            {
                image.SetAlpha(0);
            }
		};
		animation.OnStop = function()
		{
			
		};
		var self = this;
		Storage.KeyValueCache.local.getItem( name ,function ( err, data )
        {
            if (data)
            {   // we displayed this before. Hide it now
                var img = self.FindImageOfName(myDef.name);
                if (img)
                {
                    img.SetAlpha(0);
                }
                
                if (image)
                {
                    image.SetAlpha(0);
                }
            }
            else
            {
                Storage.KeyValueCache.local.setItem(name, "true");
            }
        });
        
		
		image.OnExit(function()
	    {
			animation.Stop();
	    }); 
    	
    	return image;	
    },
    
    OnHandleTag_goalcomplete_guide: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (Exists(args) && Exists(args.proto_goal))
    	{
    		if (Exists(args.proto_goal.quest_giver_png))
    			newDef.asset = Content.getIconImagePath(args.proto_goal.quest_giver_png);
    	}
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;
    },
    
    OnHandleTag_goalcomplete_icon: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (Exists(args) && Exists(args.proto_goal))
    	{
    		if (Exists(args.proto_goal.icon_png))  
    			newDef.asset = args.proto_goal.icon_png;
    		if (Exists(args.proto_goal.reward_entity_id))
    		{
    			//NgLogD("Found reward entity id!");
    			var rewardEntity = weProtoDb.getInstance().getProtoEntityById(args.proto_goal.reward_entity_id);
    			if (Exists(rewardEntity) && Exists(rewardEntity.store_image_url))
    			{
    				//NgLogD("Found reward building asset!");
    				newDef.asset = rewardEntity.store_image_url;
    			}
    		}
    	}
        else if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal))
        {
			var proto_goal = WeGoals.goalToShowDetail.proto_goal;
    		if (Exists(proto_goal.icon_png))             
    			newDef.asset = proto_goal.icon_png;
    		if (Exists(proto_goal.reward_entity_id))
    		{
    			//NgLogD("Found reward entity id!");
    			var rewardEntity = weProtoDb.getInstance().getProtoEntityById(proto_goal.reward_entity_id);
    			if (Exists(rewardEntity) && Exists(rewardEntity.store_image_url))
    			{
    				//NgLogD("Found reward building asset!");
    				newDef.asset = rewardEntity.store_image_url;
    			}
    		}
        }
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;
    },
    
    OnHandleTag_goalcomplete_xp: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (!Exists(args) || !Exists(args.proto_goal) || !args.proto_goal.reward_xp)
    		newDef.asset = "alpha2.png";
		else
		    newDef.asset = Content.getIconImagePath(newDef.asset);
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;    	
    },
    
    OnHandleTag_goalcomplete_coins: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (!Exists(args) || !Exists(args.proto_goal) || !args.proto_goal.reward_gold)
    		newDef.asset = "alpha2.png";
    	else
    	    newDef.asset = Content.getIconImagePath(newDef.asset);
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;    	
    },
    
    OnHandleTag_goalcomplete_mojo: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (!Exists(args) || !Exists(args.proto_goal) || !args.proto_goal.reward_mojo)
    		newDef.asset = "alpha2.png";
    	else
    	    newDef.asset = Content.getIconImagePath(newDef.asset);
    	    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;    	
    },        
    
    OnHandleTag_goalunlocked_icon: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (Exists(args) && Exists(args.proto_goal))
    	{
    		if (Exists(args.proto_goal.icon_png))
    			newDef.asset = args.proto_goal.icon_png;
    	}
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;
    },
    
    OnHandleTag_goals_tab: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var self = this;
    	
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {
            var gotoTabName = imageDef.name;
			var gotoTabView = imageDef.args.view;

			// some tab needs to be rendered by other views
			if (gotoTabName == "goals_event" || gotoTabName == "goals_detail")
			{
				// event goal tab shows the current event goal, and the detail tab shows the current other goal
				gotoTabView = self.setGoalToShowDetailAndGetGoalDetailView( gotoTabName );
			}
			if ( !gotoTabView)
			{
				NgLogD("Error: OnHandleTag_goals_tab: Can not get the view for " + gotoTabName);
				return;
			}
        	
			self.gotoGoalBookTab( self, gotoTabName, gotoTabView);	   		
    	};
    	
    	return image;
    }, 
    
    OnHandleTag_gift_user_gem_icon: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	NgLogD("<<<<<!!!>>>>>> " + JSON.stringify(args));
    	var image = this.CreateImage(newDef, parent, args, true);
    	if (!WeEventGame.isShareUserInReceivedFrom(args))
    		image.SetAlpha(0);    	
    	return image;
    },
    
    OnHandleTag_collection_prev_button: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	var image = this.CreateImage(newDef, parent, args, true);
    	image.Enable("Touch");
    	image.OnTouchDown = function(touch) { return true; };
    	image.OnTapEvent = function(touch)
        {
    		WeEventGame.getPreviousCollection(WeEventGame.currentViewingCollection);
    		NgLogD("THE PREVIOUS COLLECTION IS " + WeEventGame.currentViewingCollection);
			WeUiMgr.GetCompositeFactory().RebuildComposite('se_collection_display', 'SpecialEventCollectionView');   
			var label_name = WeUiMgr.GetLabelFactory().FindLabelOfName("event_collection_name");
			var label_reward = WeUiMgr.GetLabelFactory().FindLabelOfName("event_collection_reward_total");
			var viewing_collection = WeEventGame.currentViewingCollection;
			var db = WeEventGame.getGameEventCollectionWithProtoId(viewing_collection);
			var text = '';
			text = db.name;
			label_name.GetGL2().setText(text);
			text = db.point_value;
			label_reward.GetGL2().setText(text);
			WeEventGame.showCollectionStatus();
        };
    	return image;
   	
    },
    
    OnHandleTag_collection_next_button: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	var image = this.CreateImage(newDef, parent, args, true);
    	image.Enable("Touch");
    	image.OnTouchDown = function(touch) { return true; };
    	image.OnTapEvent = function(touch)
        {
    		WeEventGame.getNextCollection(WeEventGame.currentViewingCollection);
    		NgLogD("THE NEXT COLLECTION IS " + WeEventGame.currentViewingCollection);
			WeUiMgr.GetCompositeFactory().RebuildComposite('se_collection_display', 'SpecialEventCollectionView');
			var label_name = WeUiMgr.GetLabelFactory().FindLabelOfName("event_collection_name");
			var label_reward = WeUiMgr.GetLabelFactory().FindLabelOfName("event_collection_reward_total");
			var viewing_collection = WeEventGame.currentViewingCollection;
			var db = WeEventGame.getGameEventCollectionWithProtoId(viewing_collection);
			var text = '';
			text = db.name;
			label_name.GetGL2().setText(text);
			text = db.point_value;
			label_reward.GetGL2().setText(text);
			WeEventGame.showCollectionStatus();
        };
    	return image;
   	
    },
    
    OnHandleTag_goals_active_tab: function (imageDef, parent, args)
    {   	
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	// If we're entering through goalbook button, pick appropriate tab
    	if (imageDef.args.view.length == 0)
    	{	
    		var tab;
    		if (WeGoals.showEventGoal)
        	{
        		tab = "goals_event";
        		WeGoals.showEventGoal = false;
        	}
    		else if (WeGoals.animateGoalbook)
    		{
    			tab = "goals_detail";
    			WeGoals.animateGoalbook = false;
    		}
    		else tab = "goals_list";    		

			var gotoTabImg = WeUiMgr.FindScreenImageOfName(tab);
   			if (gotoTabImg != undefined)
    		{
    			newDef.pos_y = gotoTabImg.pos_y;
	    		newDef.asset = gotoTabImg.asset;
	
				if ( !newDef.args.view)
					newDef.args.view = gotoTabImg.args.view;
    		}            
    	}
    	
		if (tab == "goals_event" || tab == "goals_detail")
		{
    		newDef.args.view = this.setGoalToShowDetailAndGetGoalDetailView( tab );			
		}
    	var image = this.CreateImage(newDef, parent, args, true);
    	image.Enable("Touch");
    	image.OnTouchDown = function(touch) { return true; };
    	// Load view
		if (newDef.args.view)
		{
	    	WeUiMgr.CreateView(newDef.args.view, WeUiMgr.GetScreen());
	    	image.view = newDef.args.view;			
		}
		else
		{
    		NgLogD("OnHandleTag_goals_active_tab error: no newDef.args.view.");
		}
    	
     	WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalbookPage);
    	return image;	
    },

    OnHandleTag_goals_detail_guide: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal))
    	{
			var proto_goal = WeGoals.goalToShowDetail.proto_goal;
    		if (Exists(proto_goal.quest_giver_png))
    			newDef.asset = Content.getIconImagePath(proto_goal.quest_giver_png);
    	}   	
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	return image;
    },

    OnHandleTag_fullScreenWebView : function (imageDef, parent, args)
    {
        var webView = new UI.WebView({'frame': [imageDef.pos_x, imageDef.pos_y, imageDef.size_x, imageDef.size_y]});
        webView.loadUrl(args.fullScreenWebUrl);
        NGWindow.document.fullScreenWebView=webView;
        NGWindow.document.addChild(webView);

		var cb = WebViewCommands;
        webView.setOnShouldload(cb);

        var image=this.CreateImage(imageDef, parent, args, true);
        image.OnExit(function()
        {
            if(NGWindow.document.fullScreenWebView)
            {
				NgLogD("Remove fullScreenWebView");
                NGWindow.document.removeChild(NGWindow.document.fullScreenWebView);
                NGWindow.document.fullScreenWebView.destroy();
                NGWindow.document.fullScreenWebView=null;
            }
        });
        return image;
    },
    
    OnHandleTag_open_InGameScreen_new_tab: function (imageDef, parent, args)
    {    	
    	var image = this.CreateImage(imageDef, parent, args, true);
    	image.mWindowState=WeUiMgr.WindowState.CLOSED;
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
		{
        	NgLogD("Opa patepinau ");
        	switch(image.mWindowState)
        	{
        	case WeUiMgr.WindowState.CLOSED:
        		{
        			NgLogD("WeUiMgr.WindowState.CLOSED");
        			image.mStartY= parent.getPosition().getY();
        			image.mMoveY= imageDef.args.move_by;

        			NgLogD("image.mStartY "+image.mStartY);
        			image.mWindowState=WeUiMgr.WindowState.OPENING;
	        	  	var cNumberAnimation= new NumberAnimation(1,  image.mStartY, image.mStartY-image.mMoveY);
	        		cNumberAnimation.SetNumber=function(value)
	        	    {
	        			parent.setPosition(parent.getPosition().getX() , value);
	        	    };
	        	    cNumberAnimation.OnStop=function()
	        	    {
	        	    	image.mWindowState=WeUiMgr.WindowState.OPENED;
	        	    };
	        	    

	        	    image.mAnimation=cNumberAnimation;
        		}
        		break;
	        case WeUiMgr.WindowState.OPENED:
	    		{
	        		NgLogD("WeUiMgr.WindowState.CLOSING ");
	        		image.mWindowState=WeUiMgr.WindowState.CLOSING;
	        		NgLogD("image.mStartY "+image.mStartY);
	        		var cNumberAnimation= new NumberAnimation(1,  image.mStartY-image.mMoveY, image.mStartY);
	        		cNumberAnimation.SetNumber=function(value)
	        	    {
	        			parent.setPosition(parent.getPosition().getX() , value);
	        	    };
	        	    cNumberAnimation.OnStop=function()
	        	    {
	        	    	image.mWindowState=WeUiMgr.WindowState.CLOSED;
	        	    };
	    		
	        	    image.mAnimation=cNumberAnimation;
	    		}
	    		break;  
	    		default:
	    			NgLogD("negerai ");
        	}

		};
		
		
    	image.OnExit(function()
		{
    		if(this.mAnimation)
    		{
    			this.mAnimation.StopNoCallBack();
    			this.mAnimation=null;
    		}			
		});
        
    	return image;     	
    	
    },

	OnHandleTag_native_exit: function(imageDef, parent, args)
	{
		var bubble = new UI.Button();
		var asset = Content.getImagePath(imageDef.asset);
		bubble.setImage(asset);
		bubble.setImageFit(UI.FitMode.Stretch);
		bubble.setFrame([imageDef.pos_x, imageDef.pos_y, imageDef.size_x, imageDef.size_y]);
		bubble.setOnClick(function()
		{
        	WeGameStateMgr.SetPopupWidget(null);
            WeGameStateMgr.SetGlobalGameWidget(null);
		});
		NGWindow.document.addChild(bubble);
		NGWindow.document.nativeExit=bubble;
        var newDef = ObjectUtils.GetCloneOfObject(imageDef);
        newDef.asset="alpha2.png";
		var image = this.CreateImage(newDef, parent, args, true);
		image.OnExit(function()
		{
	    	if(NGWindow.document.nativeExit)
			{
				NGWindow.document.removeChild(NGWindow.document.nativeExit);
				NGWindow.document.nativeExit = null;
			}			
		});
		return image;		
	},
    
    OnHandleTag_goals_help_webview: function (imageDef, parent, args)
    {
		// Add help webview
		var webView = new UI.WebView({'frame': [imageDef.pos_x - imageDef.size_x/2, 
												imageDef.pos_y - imageDef.size_y/2,
									 			imageDef.size_x, imageDef.size_y]});
		webView.loadUrl('http://wewerule.s3.amazonaws.com/webviews/goals/helpmobage.html');
		NGWindow.document.helpWebView = webView;
		NGWindow.document.addChild(webView);

		var image = this.CreateImage(imageDef, parent, args, true);
		image.OnExit(function()
		{
	    	if(NGWindow.document.helpWebView)
			{
				NGWindow.document.removeChild(NGWindow.document.helpWebView);
				NGWindow.document.helpWebView.destroy();
            	NGWindow.document.helpWebView = null;
			}			
		});
	
    	return image; 
    },
    
    OnHandleTag_goals_close: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	image.OnExit(function()
    	{
    		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalbookClose);
    	});

		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true; };
		image.OnTapEvent = function(tuoch)
		{
			var info = WeGameStateMgr.GetGameLotInfo();
			if(info)
				info.checkLevelUp();

			WeSocialMapMgr.transitionScreenToKingdom();
			return true;
		};
  	
    	WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalbookOpen);
    	return image;
    },
    
    OnHandleTag_task_item_check: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
		if (Exists(args) && Exists(args.proto_task) && args.current_count >= args.proto_task.count)
		{
			image.SetVisible(true);
		}
		else image.SetVisible(false);
    	
    	return image;     	
    },
    
    OnHandleTag_task_item_mojo: function (imageDef, parent, args)
    {
		if(!WeGameStateMgr.IsCurrentUser())
			return null;

		if (Exists(args) && Exists(args.proto_task))
		{
			var image = this.CreateImage(imageDef, parent, args, true);
			
			if (Exists(args.proto_task.boost_mojo_cost) && args.proto_task.boost_mojo_cost > 0
			&&	args.current_count < args.proto_task.count)
				image.SetVisible(true);
			else image.SetVisible(false);
			return image;
		}
		return null; 	
    },    
       
    OnHandleTag_task_lookup: function (imageDef, parent, args)
    {
    	if (!Exists(args) || !Exists(args.proto_task) || args.current_count >= args.proto_task.count)
    		return null;

    	if(args.proto_task.task_type.indexOf('entity', 0) != -1)
    	{
			if(!WeGameStateMgr.IsCurrentUser())
				return null;

	    	var image = this.CreateImage(imageDef, parent, args, true);
	    	image.Enable("Touch");
	    	image.OnTouchDown = function(touch) { return true; };
	    	image.OnTapEvent = function (touch)
	    	{
	    		NgLogD("Trying to locate task item or something!");
	    		var itemId;
	    		var separatorIndex = args.proto_task.task_type_id.indexOf('|',0);
	    		if (separatorIndex != -1)
	    			itemId = args.proto_task.task_type_id.substring(0, separatorIndex);
	    		else itemId = args.proto_task.task_type_id;
	    		WeUiMgr.ShowItemToBuild(itemId);
	    	};
	    	
	    	return image;  
    	}
    	else if(args.proto_task.task_type.indexOf('harvest', 0) != -1 || args.proto_task.task_type.indexOf('receive', 0) != -1 )
    	{
    		//NgLogD("task");
    		//objDump(args.proto_task);
    		 
     		var itemId;
    		var separatorIndex = args.proto_task.task_type_id.indexOf('|',0);
    		if (separatorIndex != -1)
    			itemId = args.proto_task.task_type_id.substring(0, separatorIndex);
    		else itemId = args.proto_task.task_type_id;
    		
    		
    		//FIX move to map
    		var harvestItemProto=null;
		    for(var idx in weProtoDb.getInstance().proto_products)
		    {
		        if(weProtoDb.getInstance().proto_products[idx].proto_product.id == itemId)
		        {
		        	harvestItemProto=weProtoDb.getInstance().proto_products[idx];
		            break;
		        }
		    }
		    //NgLogD("harvestItemProto.proto_product");
		    //objDump(harvestItemProto.proto_product);
    		   
    		
    		
    		//itemId=parseInt(itemId)-1;
    	    //var harvestItemProto= weProtoDb.getInstance().proto_products[itemId];
    	    if(!Exists(harvestItemProto)) 
    	    {
    	    	NgLogD("task_type harvest but no id for item");
    	    	return;
    	    }
    	    objDump(harvestItemProto, 4);
    	    objDump(harvestItemProto.proto_product, 4);
    	    var image=harvestItemProto.proto_product.icon_png;
    	    
    	    if( !Exists(harvestItemProto.proto_product.icon_png)  || args.proto_task.task_type.indexOf('receive', 0) != -1 )
    	    {

    	    	var protoEntyti=weProtoDb.getInstance().getProtoEntityById(harvestItemProto.proto_product.producing_proto_entity_id);
    	    	if(protoEntyti)
    	    	{
    	    		//NgLogD("protoEntyti");
    	    		//objDump(protoEntyti);
    	    		image= protoEntyti.store_image_url;
    	    	}
    	    }

    		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
            newDef.asset = Content.getIconImagePath(image);
    		var image = this.CreateImage(newDef, parent, args, true);
	    	return image;  
    		
    	}
    }, 
    
    OnHandleTag_task_use_mojo: function (imageDef, parent, args)
    {
    	if (!Exists(args) || !Exists(args.proto_task)
    	||	!Exists(args.proto_task.boost_mojo_cost) || args.proto_task.boost_mojo_cost <= 0
    	||	args.current_count >= args.proto_task.count)
    		return null;

		if(!WeGameStateMgr.IsCurrentUser())
			return null;
    	
    	var self = this;
    	var image = this.CreateImage(imageDef, parent, args, true);
        var targetArgs = args;
    	image.Enable("Touch");
    	image.OnTouchDown = function(touch) { return true; };
    	image.OnTapEvent = function (touch)
    	{
    		NgLogD("Trying to use mojo to complete task!");
    		if (args.proto_task.boost_mojo_cost > WeGameStateMgr.GetGameLotInfo().mana)
    			self.notEnoughMojoPopup();
    		else
    			self.confirmSpendMojoWithTarget(targetArgs);
    	};
    	return image;     	
    },   
    
    OnHandleTag_main_event_reward: function (imageDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	var goal = WeGoals.goalToShowDetail;
		var hasImage = false;

    	if (Exists(goal) && Exists(goal.proto_goal))
    	{
    		if (Exists(goal.proto_goal.reward_entity_id))
    		{

    			var rewardEntity = weProtoDb.getInstance().getProtoEntityById(goal.proto_goal.reward_entity_id);
    			if (Exists(rewardEntity) && Exists(rewardEntity.store_image_url))
    			{
    			    NgLogD("EVENT REWARD3");
    				newDef.asset = rewardEntity.store_image_url;
					hasImage = true;
    			}
    		}
    	}
    	
    	var image = this.CreateImage(newDef, parent, args, true);

		if ( !hasImage )
		{
			image.SetVisible(false);
		}
    	return image;   	
    },
    
    OnHandleTag_BalanceButton: function (imageDef, parent, args)
    {
    	NgLogD("OnHandleTag_BalanceButton");
    	var rect = new UI.ViewGeometry.Rect(imageDef.pos_x-imageDef.size_x/2, imageDef.pos_y-imageDef.size_y/2, imageDef.size_x, imageDef.size_y);
		WeGameStateMgr.mBalanceRect = rect;
		Social.Common.Service.showBalanceButton(rect, function(error)
		{
			NgLogD("ERROR showBalanceButton: "+error);
		}		
		);
    	return null;
    },
    
    OnHandleTag_reel_spin: function(imageDef, parent, args)
	{	
		if (!imageDef.args || imageDef.args.index >= WeEventSpinner.getReelCount())
			return null;

		var image = this.CreateImage(imageDef, parent, args, true);

		var index = imageDef.args.index;
		WeEventSpinner.mSpinners[index] = {};
		WeEventSpinner.mSpinners[index].stop_image = imageDef.args.stop_image;
		WeEventSpinner.SetAnimationObject(WeEventSpinner.mSpinners[index], image, imageDef.args);

		return image;
	},

    OnHandleTag_reel_spin_result: function(imageDef, parent, args)
	{	
		if (!imageDef.args || imageDef.args.index < 0 || imageDef.args.index >= WeEventSpinner.getReelCount())
			return null;

		var image = this.CreateImage(imageDef, parent, args, true);
		var index = imageDef.args.index;
		WeEventSpinner.mSpinResults[index] = {};
		WeEventSpinner.mSpinResults[index].image = image;	// save for later use
		WeEventSpinner.mSpinResults[index].delay_seconds = ((imageDef.args.delay_second) ? imageDef.args.delay_second : 1.0);	// save for later use
		return image;
	},
	
	OnHandleTag_event_close_button : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
		image.OnTouchDown = function(touch) { return true;  };
		image.OnTapEvent = function (touch)
		{
			WeEventSpinner.deleteEarnedPointStrokeLabels();
			// adding XP received from gifts
			if (WeGameStateMgr.mDelayedXp !== null)
			{
				WeGameStateMgr.GetGameLotInfo().xp = WeGameStateMgr.mDelayedXp;
			}

			var info = WeGameStateMgr.GetGameLotInfo();
			if(info)
				info.checkLevelUp();

			WeSocialMapMgr.transitionScreenToKingdom();
			WeEventGame.mEventView = "";
			return true;
		};
		image.Name = function(){ return "OnHandleTag_event_close_button"; };
        return image;		
	},
	
	OnHandleTag_spinner_view_bg: function(imageDef, parent, args)
	{	
		var image=this.CreateImage(imageDef, parent, args, true);
		image.Enable("Touch");
        image.OnNativeTouch = function(touch){ 
            return true; 
        };
        if(imageDef.asset=="alpha2.png")
        {
        	image.SetVisible(false);
        }
        image.OnExit(function()
	    {
	    	WeEventSpinner.cleanSpinner();
	    });
	    
	    
	    if (WeEventGame.canShowSellEventItems())
	    {
	        var newArgs = {};
    		newArgs.OnOk = function(theNewArgs)
    		{
    			WeProtocol.purchaseWithItems(WeEventGame.getAcquiredEventItemProtoId(1), WeEventGame.getAcquiredEventItemsCount(), function(request)
                {
                    var obj = WeProtocol.getRequestResponse(request);
                    WeGameStateMgr.SetGlobalGameWidget(null);
                    WeEventGame.showEventPoints();
					WeEventGame.setEventPointProgress();
                });
    		};

    		newArgs.popup_label = "Event is Over";
    		newArgs.popup_text = "Time to sell your gems for points!";

    		var itemDef = WeUiMgr.GetItemDef("popup_box_force");
    		var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
    		newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

    		WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
		}
		
		return image;
	},
	
    OnHandleTag_event_spin : function(imageDef, parent, args)
	{
        var platform = Core.Capabilities.getPlatformOS();
        if(platform != "iPhone OS" && imageDef && imageDef.args && imageDef.args.tier == 2)	//boost button
        {
			imageDef.asset = imageDef.asset_android;
			imageDef.asset_touch_down = imageDef.asset_android_touch_down;
		}
		var image = this.CreateImage(imageDef, parent, args, true);
        image.OnTapEvent = function(touch)
        {
			var tier = imageDef.args ? imageDef.args.tier : 1;
			WeEventSpinner.onSpinButtonClicked(tier);
			NgLogD("<<<<!!!!---- SPINNER" + JSON.stringify(WeEventGame.getGameEventCollection()));
        };

		if (imageDef.args && imageDef.args.tier == 1)
		{
        	WeEventSpinner.mEventSpinBtn = image;
		}
		else	// tier2
		{
        	WeEventSpinner.mEventBoostBtn = image;
		}

		return image;
	},
	
	OnHandleTag_eventgame_result : function(imageDef, parent, args)
	{
		var image = this.CreateImage(imageDef, parent, args, true);
		image.SetVisible(false);
		WeEventSpinner.mResultImage = image;	// save for later use
		return image;
	},
	
	OnHandleTag_event_page_frame : function(imageDef, parent, args)
	{
		var goal = WeGoals.goalToShowDetail;
		var hasImage = false;
		if (WeGoals.isGoalCurrentEventGoal(WeGoals.goalToShowDetail))
		{
			hasImage = true;
		}
		var image = this.CreateImage(imageDef, parent, args, true);
		if ( !hasImage )
		{
			image.SetVisible(false);
		}
		return image;
	},

	OnHandleTag_event_main_goal_title : function(imageDef, parent, args)
	{
		var goal = WeGoals.goalToShowDetail;
		var hasImage = false;
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if (WeGoals.isGoalCurrentEventGoal(WeGoals.goalToShowDetail))
		{
			if ( goal && goal.proto_goal && goal.proto_goal.goal_name_png )
			{
				newDef.asset = goal.proto_goal.goal_name_png.replace(".png", "@2x.png");
				hasImage = true;
			}
		}
		var image = this.CreateImage(newDef, parent, args, true);
		if ( !hasImage )
		{
			image.SetVisible(false);
		}
		return image;
	},

	OnHandleTag_event_main_goal_description : function(imageDef, parent, args)
	{
		var goal = WeGoals.goalToShowDetail;
		var hasImage = false;
		var newDef = ObjectUtils.GetCloneOfObject(imageDef);
		if (WeGoals.isGoalCurrentEventGoal(WeGoals.goalToShowDetail))
		{
			if ( goal && goal.proto_goal && goal.proto_goal.description_png )
			{
				newDef.asset = goal.proto_goal.description_png.replace(".png", "@2x.png");
				hasImage = true;
			}
		}
		var image = this.CreateImage(newDef, parent, args, true);
		if ( !hasImage )
		{
			image.SetVisible(false);
		}
		return image;
	},

	/* the tab we go to and the view we use could be different */
	gotoGoalBookTab: function( self, gotoTabName, gotoTabView )
	{
		var img = self.FindImageOfName("goals_active_tab");
		if (Exists(img))
		{	// Remove image and associated view
			var activeTabScreenImage = WeUiMgr.FindScreenImageOfName("goals_active_tab");
			if (activeTabScreenImage == undefined)
			{
				return;
			}
			var imgDef = ObjectUtils.GetCloneOfObject(activeTabScreenImage);
			if (Exists(img.view))
			{
				WeUiMgr.DestroyView(img.view);
			}
			self.ReleaseImage(img);
            img.destroy();
			// Recreate active tab image - it will load its view
			
			var gotoTabScreenImage = WeUiMgr.FindScreenImageOfName(gotoTabName);
			if ( !Exists(gotoTabScreenImage))
			{
				NgLogD("######## gotoGoalBook - gotoTabImage not found: " + gotoTabName);
				return;	/* something wrong */
			}
			var tabDef = ObjectUtils.GetCloneOfObject(gotoTabScreenImage);

			imgDef.pos_y = tabDef.pos_y;
			imgDef.asset = tabDef.asset;
    		imgDef.args.view = gotoTabView;
    			
    		img = self.CreateImage(imgDef, WeUiMgr.GetScreen().GetNode());
            self.ManageImage(img); 
		}
	},

    OnHandleTag_goal_list_item: function (imageDef, parent, args)
    {
    	var image = this.CreateImage(imageDef, parent, args, true);
    	//var theArgs = args;
//    	NgLogD("### OnHandleTag_goal_list_item Parent Dump ###");
//    	//fullRecurseDump(parent);
//    	objDump(imageDef);
//    	NgLogD("##OnHandleTag_goal_list_item Parent Dump  END ####");
    	image.mRequiresTap = true;
    	image.Enable("Touch");
//    	image.OnTouchDown = function(touch)
//    	{ 
//    		//image.SetVisible(true);
//    		return true;
//    	};
    	var self = this;   	 	
		image.OnTapEvent = function(touch)
        {
        	if (Exists(args))
        	{
       			WeGoals.currentGoal = args;
       			WeGoals.currentGoal.still_new = false;
        	}

            var gotoTabName = "goals_detail";
			var gotoTabView = self.setGoalToShowDetailAndGetGoalDetailView( gotoTabName );
			
			if ( !gotoTabView)
			{
				NgLogD("Error: OnHandleTag_goal_list_item: Can not get the view for " + gotoTabName);
				return;
			}

			self.gotoGoalBookTab( self, gotoTabName, gotoTabView);	   		
    	};
    	
    	image.SetAlpha(0);
    	return image;
    },

	/* set the WeGoals.goalToShow to the current event goal or the current non-event goal (or the completed lookup goall) based on the tab to go,
	   and get the view name that we need to use for the goal detail, based on the tab we are on, and based on the goalToShowDetail that is currently set */
	setGoalToShowDetailAndGetGoalDetailView: function (gotoTabName)
	{

		if (gotoTabName == "goals_detail")
		{
			WeGoals.goalToShowDetail = WeGoals.currentGoal;
			if (!WeGoals.goalToShowDetail)	// no goal detail to show
			{
				if (WeGoals.activeGoals && WeGoals.activeGoals.length > 0)  // if there is still no current goal, always set to the 1st active goal
				{
					WeGoals.goalToShowDetail = WeGoals.activeGoals[0];
					if (!WeGoals.goalToShowDetail)
					{
						return null;
					}
				}
			}
			else
			{
				return WeGoals.goalToShowDetail.shouldUseEventGoalView() ? "GoalsEventView" : "GoalsDetailView";
			}
		}
		else if (gotoTabName == "goals_event")
		{
			WeGoals.goalToShowDetail = WeGoals.getCurrentEventGoal(); 
			if (!WeGoals.goalToShowDetail)	// no event goal to show
			{
				return "GoalsNoEventGoalView";
			}
			else
			{
				return WeGoals.goalToShowDetail.shouldUseEventGoalView() ? "GoalsEventView" : "GoalsDetailView";
			}
		}
		else
		{
			return null;	/* should not call this function for the other tabs */
		}
	},
	
	event_gift_send_loaded : function()
	{
		NgLogD("event_gift_send_loaded");
		// load data from server
		var self=this;
        WeProtocol.getSEGiftUsers(function(){
    		WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "SpecialEventGiftSendView");
    		NgLogD("event_gift_send_loaded "+self.gifting_tab_semaphore);
    		self.gifting_tab_semaphore=true;
    	});
        if (WeEventGame.mShareCount < 0) 
        	WeUiMgr.GetCompositeFactory().RebuildComposite("store_display_v", "SpecialEventGiftSendView");
	},
	
	OnHandleTag_se_spinner_tab: function (imageDef, parent, args)
    {
		return null;
    },
	
	OnHandleTag_se_point_store_tab: function (imageDef, parent, args)
    {
		return null;
    },
    
    OnHandleTag_special_event_tab: function (imageDef, parent, args)
    {
        
        
    	var image = this.CreateImage(imageDef, parent, args, true);
    	var self = this;
    	
    	if (WeEventGame.isSpinnerEnabled() == false && imageDef.name != "se_store_tab")
        {
           return image;
        }
        
    	image.Enable("Touch");
        image.OnTouchDown = function(touch) { return true; };
        image.OnTapEvent = function(touch)
        {        	
        	if (WeGameStateMgr.IsGiftsLoading())
        	{
        	    return true;
        	}
        	if(self.gifting_tab_semaphore===false) return false;
        	self.gifting_tab_semaphore=false;
        	
        	var json = WeUiMgr.GetJSONDef();
            var activescreen = WeUiMgr.GetActiveScreen();
            var currentscreen = json[activescreen];
            // Find image of active tab
            var activetabname = "se_active_tab";
    		var img = self.FindImageOfName(activetabname);
    		if (Exists(img))
    		{	// Remove image and associated view
				WeEventSpinner.deleteEarnedPointStrokeLabels();	// delete the label objects created on-fly.
    			if (Exists(img.view))
    			{
    				WeUiMgr.DestroyView(img.view);
    			}
    			self.ReleaseImage(img);
                img.destroy();
  				// Recreate active tab image - it will load its view
	    		for (var i in currentscreen.images)
	    		{
	    			if (currentscreen.images[i].name == activetabname)
	    			{
	    				var imgDef = ObjectUtils.GetCloneOfObject(currentscreen.images[i]);
	    				imgDef.pos_x = imageDef.pos_x;
	    				imgDef.pos_y = imageDef.pos_y;
	    				imgDef.size_x = imageDef.size_x;
	    				imgDef.size_y = imageDef.size_y;
	    				imgDef.asset = imageDef.args.active;
	    				imgDef.args.handle = imageDef.args.handle;
	    				imgDef.args.view = imageDef.args.view;
	    				
						WeEventGame.mEventView = imgDef.args.view;
						WeEventGame.setSpinHintLabel();
	    				img = self.CreateImage(imgDef, WeUiMgr.GetScreen().GetNode());
	                    self.ManageImage(img);
						if (WeEventGame.isShowingSpinnerView())
						{
							WeEventSpinner.setIsSpinning(false);
						}
						WeEventGame.showEventPoints();
						WeEventGame.setEventPointProgress();
	    				break;
	    			}
	    		}
    		}
    	};
    	
    	return image;
    },
    
    OnHandleTag_special_event_active_tab: function (imageDef, parent, args)
    {   	
    	var newDef = ObjectUtils.GetCloneOfObject(imageDef);
    	
    	var image = this.CreateImage(newDef, parent, args, true);
    	image.Enable("Touch");
    	image.OnTouchDown = function(touch) { return true; };
    	// Load view
    	WeUiMgr.CreateView(newDef.args.view, WeUiMgr.GetScreen());
		WeEventGame.mEventView = newDef.args.view;
		WeEventGame.setSpinHintLabel();

    	if (Exists(newDef.args.handle) && Exists(this[newDef.args.handle]))
    		this[newDef.args.handle]();
    	image.view = newDef.args.view;
		if (WeEventGame.isShowingSpinnerView())
		{
			WeEventSpinner.setIsSpinning(false);
		}
		WeEventGame.showEventPoints();
		WeEventGame.setEventPointProgress();
    	
    	return image;	
    },
   
    OnHandleTag_se_progress_left: function (imageDef, parent, args)
    {   	
    	var image = this.CreateImage(imageDef, parent, args, true);    	
    	return image;	
    },

    OnHandleTag_se_progress_fill: function (imageDef, parent, args)
    {   	
    	var image = this.CreateImage(imageDef, parent, args, true);
		WeEventGame.mEventPointProgressW = imageDef.size_x;
		WeEventGame.mEventPointProgressH = imageDef.size_y;
		// the left_top position of the event point's progress bar
		WeEventGame.mEventPointProgressX = imageDef.pos_x - imageDef.size_x / 2;
		WeEventGame.mEventPointProgressY = imageDef.pos_y - imageDef.size_y / 2;
		WeEventGame.mEventPointProgressFillImage = image;
    	return image;	
    },

    OnHandleTag_se_progress_right: function (imageDef, parent, args)
    {   	
    	var image = this.CreateImage(imageDef, parent, args, true);    	
		WeEventGame.mEventPointProgressGemW = imageDef.size_x;
		WeEventGame.mEventPointProgressGemY = imageDef.pos_y - imageDef.size_y / 2;
		WeEventGame.mEventPointProgressRightImage = image;
    	return image;
    },

	OnHandleTag_se_progress_next_item: function (imageDef, parent, args)
	{
    	var image = this.CreateImage(imageDef, parent, args, true);    	
		WeEventGame.mEventPointProgressNextItemIcon = image;
		WeEventGame.setEventPointProgress();
    	return image;		
	},

	OnHandleTag_spin_loot_reveal: function (imageDef, parent, args)
	{
		if (!imageDef.args || !WeEventGame.isSpinnerEnabled())
			return null;

    	var image = this.CreateImage(imageDef, parent, args, true);
		image.SetVisible(false);

		WeEventSpinner.mSpinLootReveal = {};
		WeEventSpinner.SetAnimationObject(WeEventSpinner.mSpinLootReveal, image, imageDef.args);
    	return image;		
	},

	OnHandleTag_spinner_fanfare: function (imageDef, parent, args)
	{
		if (!imageDef.args || !WeEventGame.isSpinnerEnabled())
			return null;

    	var image = this.CreateImage(imageDef, parent, args, true);
		image.SetVisible(false);

		WeEventSpinner.mSpinFanfare = {};
		WeEventSpinner.SetAnimationObject(WeEventSpinner.mSpinFanfare, image, imageDef.args);
		if (imageDef.args)
		{
			WeEventSpinner.mSpinFanfare.mAnimationsA = [imageDef.args.animation_frame_1, imageDef.args.animation_frame_2];
			WeEventSpinner.mSpinFanfare.mAnimationsB = [imageDef.args.animation_frameb_1, imageDef.args.animation_frameb_2];
			WeEventSpinner.mSpinFanfare.mAnimationsC = [imageDef.args.animation_framec_1, imageDef.args.animation_framec_2];
		}
    	return image;		
	},

	OnHandleTag_spin_machine: function (imageDef, parent, args)
	{
		if (!imageDef.args)
			return null;

    	var image = this.CreateImage(imageDef, parent, args, true);
		WeEventSpinner.mSpinMachine = {};
		WeEventSpinner.SetAnimationObject(WeEventSpinner.mSpinMachine, image, imageDef.args);
    	return image;		
	},

	OnHandleTag_spin_spout: function (imageDef, parent, args)
	{
		if (!imageDef.args || !WeEventGame.isSpinnerEnabled())
			return null;

    	var image = this.CreateImage(imageDef, parent, args, true);
		WeEventSpinner.mSpinSpout = {};
		WeEventSpinner.SetAnimationObject(WeEventSpinner.mSpinSpout, image, imageDef.args);
    	return image;		
	}

});

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeCompositeFactory'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeCompositeFactory'] || {}; $MODULE_REGISTRY['weEngine/WeCompositeFactory'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeCompositeFactory.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     This Module knows how to construct a Image sprite
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Content = require('weEngine/WeContent').Content;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;
var WeNode2D = require('weEngine/WeNode2D').WeNode2D;
var WeScreen = require('weEngine/WeScreen2D').WeScreen;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var WeScaleAnimController = require('weEngine/WeAnimController').WeScaleAnimController;
var WeScrollArea = require('weEngine/WeScrollArea').WeScrollArea;
var WeRealmScrollArea = require('weEngine/WeRealmScrollArea').WeRealmScrollArea;
var WeSocialMapMgr = require('weEngine/WeSocialMapMgr').WeSocialMapMgr;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var WeProgressBar = require('weEngine/WeProgressBar').WeProgressBar;
var WeRealms = require('weEngine/WeRealms').WeRealms;
var WeComposite  = require('weEngine/WeComposite').WeComposite;
var WeEventGame = require('weEngine/WeEventGame').WeEventGame;

		

exports.WeCompositeFactory = Core.Class.subclass( {

	classname: 'WeCompositeFactory',
    //////////////////////////////////////////////////////////////////////////////
    // Class WeCompositeFactory
    initialize : function()
    {
        this.mFactoryObjects = [];
    },

    ReleaseComposites : function()
    {
        for(var idx in this.mFactoryObjects)
        {
        	if(this.mFactoryObjects[idx])
        	{
        		this.mFactoryObjects[idx].mManager=null;
        		this.mFactoryObjects[idx].destroy();
        		this.mFactoryObjects[idx] = null;
        	}
        }
        this.mFactoryObjects = [];
    },

    ManageComposite : function(composite)
    {
    	if(composite!=null && !this.HasComposite(composite))
    	{
    		this.mFactoryObjects.push(composite);
    	}
    },

	ReleaseComposite : function(composite)
	{
		var len = this.mFactoryObjects.length;
		for (var i = 0; i < len; i++)
		{
			if (this.mFactoryObjects[i] === composite)
			{
				this.mFactoryObjects.splice(i,1);
				return;
			}
		}
	},
	
    HasComposite : function(composite)
    {
        var len = this.mFactoryObjects.length;
        for(var idx = 0; idx < len; ++idx)
        {
            if(this.mFactoryObjects[idx]=== composite)
            {
            	return true;
            }
        }
        return false;
    },

    FindCompositeOfName : function(name)
    {
        var composite = null;
        var len = this.mFactoryObjects.length;
        for(var idx = 0; idx < len; ++idx)
        {
            if(this.mFactoryObjects[idx].xName == name)
            {
                composite = this.mFactoryObjects[idx];
                break;
            }
        }
        return composite;
    },

    ProcessCompositeTag : function(compositeDef, parent, args)
    {
        var handle = 'OnHandleTag_' + compositeDef.tag;
        var composite = null;
        if(Exists(this[handle]))
        {
            composite = this[handle](compositeDef, parent, args); 
        }
        return composite;
    },
            
    CreateComposite : function(compositeDef, parent, args, wasTagProcessed)
    {
        var composite = null;
        if(!Exists(wasTagProcessed))
        {
            wasTagProcessed = false;
        }
        if(!wasTagProcessed && Exists(compositeDef.tag) && "" !== compositeDef.tag)
        {
            composite = this.ProcessCompositeTag(compositeDef, parent, args); 
        }
        else
        {
            composite = new WeComposite(parent);          
            composite.GetGL2().setDepth(compositeDef.pos_z || 0);
            composite.GetGL2().setPosition(new Core.Vector(compositeDef.pos_x, compositeDef.pos_y));

            // Set up the external vars
            composite.xName = compositeDef.name; 
            composite.xParent = parent;
            composite.xWidth = compositeDef.size_x;
            composite.xHeight = compositeDef.size_y;
            
            composite.xPosX = compositeDef.pos_x;
            composite.xPosY = compositeDef.pos_y;
            composite.xPosZ = compositeDef.pos_z;
            
            composite.xBackground = null;
            
           
            if (Exists(compositeDef.hide_idle))
            {
            	composite.hide_idle = compositeDef.hide_idle;
            }
            else
            {
            	composite.hide_idle = false;
            }

            
            composite.OnSetBackground = function(background)
            {
                if(undefined === background || null === background)
                {
                    return;
                }
                var touchFunc = null;
                var depth = composite.GetGL2().getDepth();
                if (Exists(compositeDef.args.pos_z))
                {
                    depth = compositeDef.args.pos_z;
                }
                // Check if we already have a background 
                if(null !== this.xBackground)
                {
                    touchFunc = this.xBackground.OnNativeTouch;
                   // depth = this.xBackground.GetDepth();
                    this.xBackground.destroy();
                    this.xBackground = null;
                }
                
                 this.xBackground = new WeSprite2D( Content.getImagePath(background),
                                                    [this.xWidth, this.xHeight],
                                                    [this.GetX()-this.xWidth*0.5, this.GetY()-this.xHeight*0.5, depth],
                                                    parent);    

                this.xBackground.SetDepth(depth);

                this.xBackground.xParent = parent;
                this.xBackground.Name = function(){ return "CompositeBackground"; };

                if(null !== touchFunc)
                {
                    this.xBackground.Enable("Touch");
                    this.xBackground.OnNativeTouch = touchFunc;
                }
                
            };
            if(undefined !== compositeDef.args)
            {
                composite.OnSetBackground(compositeDef.args.background);
            }
            
            if(undefined !== compositeDef.controller)
            {
                if (Exists(args))
                {
                    composite.GetGL2().source = args.source;
                }
                composite.xController = this.BuildController(composite, compositeDef.controller, compositeDef.controller_args, args);
                composite.EnableUpdate(function(delta)
                {
                    if (composite.GetGL2().getParent() === null)
                    {
                        composite.destroy();
                    }
                    else
                    {
                        this.updating = true;
                        if(Exists(this.xController) && Exists(this.xController.OnControllerUpdate))
                        {
                            this.xController.OnControllerUpdate(); 
                        }
                    }
                });
            } 
        }
        return composite;
    },
    
    BuildController_view : function(container, controllerType, args, parent_args)
    {
		var item_def = WeUiMgr.GetItemDef(args.item_type);
		var local_args=parent_args;
		if(!Exists(local_args))
		{
			local_args={};
		}
		widget = WeUiMgr.CreateGameWidget(item_def, local_args, container.GetGL2());
		return widget;
    },
    
    BuildController_scroll_area : function(container, controllerType, args)
    {
    	var controller=null;
    	// this is the function that will return us a list of components
		var handle = 'OnHandleTag_' + args.data_source_tag;
		if (Exists(this[handle]))
		{
			var dx = 0;
			var dy = 0;
			var node_width = 0;
			var node_height = 0;
			var components = this[handle](args.data_source_args);

			if(Exists(components))
				var item_count = components.length;
			else
				var item_count = 0;

			var elements_per_row = args.elements_per_group;
			var num_rows = Math.ceil(item_count / elements_per_row); // number of rows or columns that we'll need
			var item_width = args.item_size_x;
			var item_height = args.item_size_y;
			var item_def = WeUiMgr.GetItemDef(args.item_type);
			var items_per_screen = item_count;

			// grow list down
			if (args.orientation == "vertical")
			{
				dx = 0;
				dy = 1;
				node_width = item_width * elements_per_row;
				node_height = item_height * num_rows;
				items_per_screen = (container.xHeight / (item_height / elements_per_row)) + 1;
			}
			// grow list to the right
			else
			{
				dx = 1;
				dy = 0;
				node_width = item_width * num_rows;
				node_height = item_height * elements_per_row;
				items_per_screen = (container.xWidth / (item_width / elements_per_row)) + 1;
			}
			// setup the scroll area control
			
			if(args.controllerClass=="WeRealmScrollArea")
			{
				controller = new WeRealmScrollArea( container.GetGL2(), [0,0,container.xWidth, container.xHeight], [node_width, node_height], args.orientation, args);
			}
			else
			{
				controller = new WeScrollArea( container.GetGL2(), [0,0,container.xWidth, container.xHeight], [node_width, node_height], args.orientation);
			}

			var node = controller.getContentNode();
			
			if (args.scroll_indicator)
			{	
				controller.scroll_indicator  = WeUiMgr.GetCompositeFactory().CreateComposite(args.scroll_indicator, container.GetGL2());
			}
			
			if (args.scroll_back)
			{	
				parent=container.GetGL2();
				if(container.GetGL2().getParent())
				{
					parent=container.GetGL2().getParent();
				}
				
				NgLogD("creating scrool back ");
				controller.scroll_back  = WeUiMgr.mImageFactory.CreateImage(args.scroll_back, parent, args);
				NgLogD("creating scrool back  e");
			}

			// build out the large surface that will scroll back and forth
			var x = (item_width * 0.5);
			var y = (item_height * 0.5);
	        for(var i = 0; i < num_rows; i++)
	        {
				for (var j = 0; j < elements_per_row; j++)
				{
					var widget;
					// handle grouping of multiple elements on a row/col
					var index = (i * elements_per_row) + j;
					if (index < item_count)
					{
						if (index < items_per_screen)
						{
							// add a real widget - it'll get created as needed
							item_def.pos_x = x + (j * item_width * dy); //if dy is 1 (vertical) ... then add this component
							item_def.pos_y = y + (j * item_height * dx); //if dx is 1 (vertical) ... then add this component
						    // modify item
                			if (Exists(args.item_type) && args.item_type == "gift_send_item" && Exists(WeGameStateMgr.mGiftUsers))
                			{
                			    var node = controller.getContentNode();
                                controller.widget_item_type = "gift_send_item";
                            	item_def.images[2].args.gamertag = WeGameStateMgr.mGiftUsers[index];
                                widget = {};
       							widget.mX = x + (j * item_width * dy);
       							widget.mY = y + (j * item_height * dx);

                    	    }
                    	    else if (Exists(args.item_type) && args.item_type == "share_send_item" && Exists(WeGameStateMgr.mSEGiftUsers))
                			{
                			    var node = controller.getContentNode();
                                controller.widget_item_type = "share_send_item";
                            	item_def.images[2].args.gamertag = WeGameStateMgr.mSEGiftUsers[index];
                                widget = {};
       							widget.mX = x + (j * item_width * dy);
       							widget.mY = y + (j * item_height * dx);
                    	    }
                    	    else
                    	    {
                    	    	// widget = WeUiMgr.CreateGameWidget(item_def, components[index], node);
                    	    	widget = {};
                    	    	widget.mX = x + (j * item_width * dy);
                    	    	widget.mY = y + (j * item_height * dx);
					        }
						}
						else
						{	
							// add a placeholder - it'll get created as needed
						    widget = {};
							widget.mX = x + (j * item_width * dy);
							widget.mY = y + (j * item_height * dx);
						}
						widget.xItem = components[index];

						// I don't even know if this does anything anymore - but its too late to
						// pull it out. I believe it relates to the harvest menu list...anyway
						// armorproofing it
						if (Exists(container.GetGL2().source))
						{
							widget.xItem.source = container.GetGL2().source;
						}
						widget.xItemDef = item_def;
						widget.xWidth = item_width;
						widget.xHeight = item_height;
						
						//NgLogD("Adding to widget widget.xItemDef "+widget.xItemDef.name);
						controller.pushWidget(widget);
					}
				}
				// move to the next row/col
				x += dx * item_width;
				y += dy * item_height;
	        }
			
			// this allows for a "on movement" callback into the sub-objects
			if (Exists(args.notify_children) && args.notify_children == true)
			{
				controller.setNotifyChildren(true);
			}

			// This will keep a scroll position saved for a particular list
			if (Exists(args.save_last_position) && args.save_last_position == true)
			{
				controller.setSaveLastPositionId(container.xName);
				var last_pos = WeUiMgr.GetLastScrollPosition(container.xName);
				if (Exists(last_pos))
				{
					controller.setPosition(last_pos);
				}
			}
			
			if (Exists(args.custom_update) && Exists(this[args.custom_update]))
			{
				controller.OnControllerUpdate = function (){
					var factory = WeUiMgr.GetCompositeFactory();
					factory[args.custom_update]();
				};
			}
    	    
		}
		return controller;
    },
    
    BuildController_anim_scale_enlarge : function(container, controllerType, args)
    {
    	var controller=null;
        controller = new WeScaleAnimController(function( _ItemType, _ObjSource, _Container) 
		{
			return WeUiMgr.CreateGameWidget(   _ItemType, _ObjSource, _Container);
		}
		);
        var itemDef = WeUiMgr.GetJSONDef().items;
        container.GetGL2().owner.xController = controller;
        controller.Init(itemDef[args.item_type],container.GetGL2(),args.value_x,args.value_y,args.time); 
    	return controller;
    },
    
    OnControllerUpdate_XP : function()
    {
    	  var info = WeGameStateMgr.GetGameLotInfo();
          if(info)
          {
              var level = info.mLevel;
              var currProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(level);
              var nextProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(level+1);
              var required_xp = info.xp;
              if (nextProtoLevel !== null)
              {
                  required_xp = nextProtoLevel.required_xp;
              }
              var percent = (info.xp - currProtoLevel.required_xp) / (required_xp - currProtoLevel.required_xp);
              
              this.SetProgress(percent);
          }
    },
    
    BuildController_progress_bar : function(container, controllerType, args)
    {
        var controller = new WeProgressBar();
        controller.Init(container.GetGL2());
        container.xController = controller;
        if(args && args.OnControllerUpdate)
        {
        	controller.args=args;
        	controller.OnControllerUpdate=this["OnControllerUpdate_"+args.OnControllerUpdate];
        	controller.Display(true);
        }
    	return controller;
    },
    
    BuildController_social_scroll_area : function(container, controllerType, args)
    {
    	var itemDef = WeUiMgr.GetJSONDef().items;
		// first lets eval how many friends there will be
		var nodes_per_screen = WeSocialMapMgr.getNodesPerScreen();
		var friend_count = WeSocialMapMgr.getFriendCount();
		var invite_count = WeSocialMapMgr.getInviteSpacesCount();
		var display_info = WeRenderDevice.GetScreenInfo();
	
		// calc how wide our BG is going to need to be...
		var bg_mult = ((friend_count + invite_count) / nodes_per_screen) + 2; // add 2 for the left and right buffer screens
		if (WeSocialMapMgr.isCommunityMap) bg_mult = 2; 					  // Community map should not scroll
		var bg_length = bg_mult * display_info.mWidth;
		var bg_height = display_info.mHeight;
					
		// create the scroll area - adjusing for the fact that we have buffer space on either side
		var controller = new WeScrollArea( container.GetGL2(), [0,0,display_info.mWidth, display_info.mHeight], 
										   [bg_length - display_info.mWidth * 2, bg_height] );
		var node = controller.getContentNode();
	    var user_kingdom_def = WeUiMgr.GetItemDef(args.friend_item);
		var invite_friend_def = WeUiMgr.GetItemDef(args.invite_item);
	
		// add the background to the area
		var bground = (WeSocialMapMgr.isCommunityMap)?(args.bg_new_img):(args.bg_image);
		var anim = new GL2.Animation();
		anim.setWrapMode(GL2.Animation.WrapMode.WrapUV);
                var res = Core.Capabilities.getScreenHeight()+"x"+Core.Capabilities.getScreenWidth();
		anim.pushFrame(new GL2.Animation.Frame(Content.getImagePath(bground), 1, [bg_length,bg_height], [3 / (bg_mult * 2),0.5], [0, 0, bg_mult, 1]));
		var sprite = new GL2.Sprite();
		sprite.setPosition(display_info.mWidth * 0.5, display_info.mHeight * 0.5);
		sprite.setDepth(0);
		sprite.setAnimation(anim, 0);
		node.addChild(sprite);
		
		// this will ensure it gets cleaned up (as part of the scrollers cleanup)
		controller.pushGL2(sprite);
        controller.pushAnim(anim);
        
		// add the friend castles
		var json = WeUiMgr.GetJSONDef();
		var activescreen = WeUiMgr.GetActiveScreen();
						
		// invite_friend_def.pos_x = json[activescreen].node_positions[0 % nodes_per_screen][0];
		//              invite_friend_def.pos_y = json[activescreen].node_positions[0 % nodes_per_screen][1]; 
		//              invite_friend_def.pos_x += Math.floor(0 / nodes_per_screen) * display_info.mWidth;
		//              WeUiMgr.CreateGameWidget(invite_friend_def, args, node);
		
		var spaceIndex = 0;
		
		var jsonActivescreen=json[activescreen];
		
		if( WeSocialMapMgr.isCommunityMap )
		{
			for( var i = 1; i < friend_count; i++)
			{
				var spaceIndex = i-1;
				user_kingdom_def.pos_x = jsonActivescreen.node_positions[spaceIndex % nodes_per_screen][0];
				user_kingdom_def.pos_y = jsonActivescreen.node_positions[spaceIndex % nodes_per_screen][1]; 
				user_kingdom_def.pos_x += Math.floor(spaceIndex / nodes_per_screen) * display_info.mWidth;
				WeSocialMapMgr.modifySocialItem(user_kingdom_def, i);
			    WeUiMgr.GetCompositeFactory().ManageComposite(WeUiMgr.CreateGameWidget(user_kingdom_def, i, node));
			}					
			return controller;
		}
	
		for( var i = 0; i < friend_count; i++)
		{
		    if (i === 0)
		    {
		        spaceIndex = 0;
		    }
		    else if (i === 1)
		    {
		        spaceIndex = 1;
		    }
		    else
		    {
		        spaceIndex = i+1;
		    }
			user_kingdom_def.pos_x = jsonActivescreen.node_positions[spaceIndex % nodes_per_screen][0];
			user_kingdom_def.pos_y = jsonActivescreen.node_positions[spaceIndex % nodes_per_screen][1]; 
			user_kingdom_def.pos_x += Math.floor(spaceIndex / nodes_per_screen) * display_info.mWidth;
			WeSocialMapMgr.modifySocialItem(user_kingdom_def, i);
		    WeUiMgr.GetCompositeFactory().ManageComposite(WeUiMgr.CreateGameWidget(user_kingdom_def, i, node));
		}
	
	    invite_friend_def.pos_x = jsonActivescreen.node_positions[2 % nodes_per_screen][0];
	    invite_friend_def.pos_y = jsonActivescreen.node_positions[2 % nodes_per_screen][1]; 
	    invite_friend_def.pos_x += Math.floor(2 / nodes_per_screen) * display_info.mWidth;
	    WeUiMgr.GetCompositeFactory().ManageComposite(WeUiMgr.CreateGameWidget(invite_friend_def, args, node));
		
	
	    // add "add_friend" buttons to the remaining slots
	    for ( var i = friend_count == 1 ? friend_count : friend_count+1; i < invite_count + friend_count; i++)
	    {
	        invite_friend_def.pos_x = jsonActivescreen.node_positions[i % nodes_per_screen][0];
	        invite_friend_def.pos_y = jsonActivescreen.node_positions[i % nodes_per_screen][1]; 
	        invite_friend_def.pos_x += Math.floor(i / nodes_per_screen) * display_info.mWidth;
	        WeUiMgr.GetCompositeFactory().ManageComposite(WeUiMgr.CreateGameWidget(invite_friend_def, args, node));
	    }
			   
		// add adware castle - if it's available
		if (WeSocialMapMgr.showAdCastle /*&& !WeSocialMapMgr.isCommunityMap*/)
		{		
			var ad_castle_def = WeUiMgr.GetItemDef(args.ad_castle);
			if(ad_castle_def)
			{
				var item = gConfigs.AdCastleBonusType;	
				var repeat = Math.floor(bg_length / display_info.mWidth) - 2;
				for (var i=0; i<repeat; i++)
				{
					ad_castle_def.pos_x = 580;
					ad_castle_def.pos_y = 80;
					ad_castle_def.pos_x += i*display_info.mWidth;
			        WeUiMgr.GetCompositeFactory().ManageComposite(WeUiMgr.CreateGameWidget(ad_castle_def, args, node));
				}
			}
		}
	    
    	return controller;
	},    

    BuildController : function(container, controllerType, args, parent_args)
    {
    	var exitMethod= "BuildController_"+controllerType;
        if(Exists(this[exitMethod]))
        {
            return this[exitMethod](container, controllerType, args, parent_args);
        }
        NgLogD("Unknown controller type = " + controllerType + ".  Please notify engineer");
        return null;
    },

	RebuildComposite : function(name, activeview)
	{
		//REMOVE
		//NgLogD("RebuildComposite from "+name+" to "+activeview);
		var composite = WeUiMgr.GetCompositeFactory().FindCompositeOfName(name);			
		if (Exists(composite))
		{
			var parent=composite.parent;
        	WeUiMgr.GetCompositeFactory().ReleaseComposite(composite);
        	composite.destroy();
        
        	var json = WeUiMgr.GetJSONDef();
        	var composites= json[activeview].composite;
        	for (var i in composites)
        	{
            	if (composites[i].name == name)
            	{
                	var itemDef = ObjectUtils.GetCloneOfObject(composites[i]);
                	composite = WeUiMgr.GetCompositeFactory().CreateComposite(itemDef, parent);
                	WeUiMgr.GetCompositeFactory().ManageComposite(composite);
                	break;
            	}
        	}            		
		}
		else
		{
			NgLogD("RebuildComposite no composite "+name);
		}
	},
	
	OnHandleTag_realms_item_init : function(compositeDef, parent, args)
	{

		var item_def = WeUiMgr.GetItemDef(compositeDef.controller_args.item_type);

		item_def.images[0].name=compositeDef.name;
		item_def.images[1].name=compositeDef.name;
		item_def.labels[0].name=compositeDef.name;

		var cComposite= this.CreateComposite(compositeDef, parent, args, true);
		//printStack("Opa");
		return cComposite;
	},
	
	OnHandleTag_realms_navigation_open_tab_create : function(compositeDef, parent, args)
	{
		var cComposite= this.CreateComposite(compositeDef, parent, args, true);         
        if(Exists(compositeDef.pos_x))
        {
        	cComposite.mX = compositeDef.pos_x;
        } 
        if(Exists(compositeDef.pos_y))
        {
        	cComposite.mY = compositeDef.pos_y;
        }
		
		NgLogD("OnHandleTag_realms_navigation_open_tab_create");
    	WeUiMgr.SetRealmsNavigationTab(cComposite);
		return cComposite;
	},

	OnHandleTag_compositeAlpha : function(compositeDef, parent, args)
	{
		var cComposite= this.CreateComposite(compositeDef, parent, args, true);
		cComposite.SetAlpha(0);
		
		var cTimer= new Timer(2, function()
	    {
			
	    	var cNumberAnimation= new NumberAnimation(1,  0.0, 1.0);

			cNumberAnimation.SetNumber=function(value)
		    {
				cComposite.SetAlpha(value);
		    };
		    
		    cComposite.Olddestroy=cComposite.destroy;
		    cComposite.destroy=function()
	        {
	        	cNumberAnimation.Stop();
	        	this.Olddestroy();
	        };
	    }
		);
		return cComposite;
	},

	/* Goals code */
	OnHandleTag_build_goals_list : function ()
	{
		return WeGoals.activeGoals;
	},
	
	OnHandleTag_build_task_list : function ()
	{
		if (Exists(WeGoals.goalToShowDetail))
		{
			return WeGoals.goalToShowDetail.tasks;			
		}
		return [];
	},
	
	OnHandleTag_build_se_collection_list : function(args)
	{
		var collection_list = [];
		var viewing_active = false;
		var viewing_collection = WeEventGame.currentViewingCollection;
		
		if (viewing_collection == WeEventGame.mEventCollectionProtoId)
			{
			NgLogD("!!!!!!!!!!!!!!!!!!");
			viewing_active = true;
			}
		
		var db = WeEventGame.getGameEventCollectionWithProtoId(viewing_collection);
		NgLogD("<<<<<!!------ " + JSON.stringify(db));
		for (item in db['items'])
		{
			var collectionItem = WeEventGame.getCollectionItemWithProtoId(item);
			if (viewing_active)
			{
				var progress_data = WeEventGame.mEventCollectionProgress;
				progress_data = progress_data[item];
				collectionItem.progress = progress_data.count + "/" + progress_data.total;
			}
			else
			{
			    if (WeEventGame.isCollectionCompleted(viewing_collection))
			    {
				    var count = collectionItem.count;
    				collectionItem.progress = count + "/" + count;
    			}
    			else
    			{
    			    var count = collectionItem.count;
    				collectionItem.progress = 0 + "/" + count;
    			}
			}
			
			collection_list.push(collectionItem);
			//collection_list.push(collectionItem);
		}
		
		/*var db2 = WeEventGame.getInactiveGameEventCollection();
		for (collectionKey2 in db2)
			for (var item in db2["" + collectionKey2]['items'])
			{
				var collectionItem = WeEventGame.getCollectionItemWithProtoId(item);
				collectionItem.name = "???";
				collection_list.push(collectionItem);
			}
		*/
		return collection_list;
		
	},
	
	OnHandleTag_build_featured_list : function(args)
	{	
		var featured_list = [];
		if (Exists(args.type))
		{
	        // Add the object defs to the controller  
	        if(Exists(weProtoDb.getInstance().proto_featured_items))
	        {
				var db = weProtoDb.getInstance();
	            var fLen = weProtoDb.getInstance().proto_featured_items.length;
		        for(i = 0; i < fLen; i++)
		        {
					var featuredItem = db.proto_featured_items[i].proto_featured_item;
					var protoEntity  = db.getProtoEntityById ( featuredItem.proto_entity_id );
					if( protoEntity )
						featured_list.push(protoEntity);
				}
			}
		}
		return featured_list;
	},
	
	OnHandleTag_build_se_store_list2 : function(args)
	{
		var store_list = [];
		var points_store = WeEventGame.getPointsStore();
		if (points_store)
		{
			NgLogD("<<<!>>> ProtoEntity Success Length: " + points_store.length);
			for (key in points_store)
			{
				var store_item = points_store[key];
				
				var protoEntity  = weProtoDb.getInstance().getProtoEntityById ( store_item.entity_id );
				NgLogD("<<<!>>> ProtoEntity: " + store_item.entity_id);
				if(protoEntity)
				{
					NgLogD("<<<!>>> ProtoEntity Success");
					protoEntity.points_cost = store_item.points_cost;
					protoEntity.points_unlock = store_item.points_unlock; /* check if store_item is locked, use WeEventGame.isStoreItemLocked(store_item) */
					protoEntity.point_store_order = store_item.point_store_order;
					store_list.push(protoEntity);
				}
			}
		}
		
		// sort users by mSEReceivedFrom
		store_list.sort(function (a, b) 
        {
            if (parseInt(a.point_store_order) > parseInt(b.point_store_order))
            {
                return 1;
            }
            
            if (parseInt(a.point_store_order) < parseInt(b.point_store_order))
            {
                return -1;
            }
            
            return 0;
        });
        
		return store_list;
		
	},
	
	OnHandleTag_build_realms_list : function()
	{
		var realms=[];
		for(var i=0; i<WeRealms.GetPageCount(); i++)
		{
			realms[i]={ "rubbish":"test" , "page":i };
		}
		return realms;
	},
	
	OnHandleTag_capture_share_items: function(compositeDef, parent, args)
	{
		var composite=this.CreateComposite(compositeDef, parent, args, true);
		WeUiMgr.m_cCaptureScreen.capturing_composite=composite;
		composite.GetGL2().setVisible(false);
		return composite;
	},
	
	OnHandleTag_news_tab_composite : function(compositeDef, parent, args)
    {
		if(gConfigs.display_news)
		{
			return this.CreateComposite(compositeDef, parent, args, true);
		}
        //return null;
        return this.CreateComposite(compositeDef, parent, args, true);
    },
	
	OnHandleTag_build_done_list : function ()
	{
		return WeGoals.completedGoals;
	},	

	/* Gifting code */
	gift_receive_update : function ()
	{		
		var composite = WeUiMgr.GetCompositeFactory().FindCompositeOfName("store_display_h");
		var area = composite.xController;
		var position = area.mScrollArea.getScrollPosition();
		var count = area.mWidgetList.length;
		var itemWidth = area.mWidgetList[0].xWidth;
		// calculate item currently shown in the middle
		var currentItem = Math.ceil(-position.getX()/itemWidth);
		if (currentItem < 1) currentItem = 1;
		else if (currentItem > count-2) currentItem = count-2;
/* Snapping to item */
		// some parameters
		var frameWidth = area.mFrame.getSize().getWidth(); //800;
		var slideFactor = 0.3;
		var grace = 3;
		// lock point - center of widget in focus
		var lockPointX = -((currentItem+0.5)*itemWidth-frameWidth/2);
		if (lockPointX > 0)
			lockPointX = 0;
		else if (lockPointX < -(count*itemWidth-frameWidth))
			lockPointX = -(count*itemWidth-frameWidth);
		// if not touched and not in lock point, move towards it
		var hasTouch = area.mScrollArea._dragger.hasTouch();
		if (!hasTouch && (position.getX() != lockPointX))
		{
			// cancel momentum
			area.mScrollArea._momentum = { x: 0, y: 0 };
			// calculate position
			var posX = position.getX()+(lockPointX - position.getX())*slideFactor;
			if (Math.abs(posX - lockPointX) < grace) posX = lockPointX;
			var posY = position.getY();
			area.mScrollArea.getContentNode().setPosition(posX,posY);
		}
/* End snapping code */		
		currentItem -= 1;
		// if item changed...
		if (currentItem != WeGameStateMgr.mCurrentGift)
		{
			WeGameStateMgr.mCurrentGift = currentItem;
			var gift = WeGameStateMgr.mGifts[currentItem];

			// reload gift description
			var label = WeUiMgr.GetLabelFactory().FindLabelOfName("gift_description");
			var text = ' ';
			if (Exists(gift))
			{
				if (gift.proto_gift_id != -1)
				{
					text = gift.gift_description.replace("{{GIFTER}}", gift.sender);
				}
				else
				{
					text = "From " + gift.sender;
				}
			}
			label.GetGL2().setText(text);
			// reload boost cost for current gift
			label = WeUiMgr.GetLabelFactory().FindLabelOfName("gift_boost_cost");
			var cost = 0;
			if (Exists(gift))
			{
				cost = WeGameStateMgr.mGifts[currentItem].boost_cost;
				if (cost < 0) cost = 0;
			}
			label.GetGL2().setText(cost.toString());
			NgLogD(text + ", "+cost);
		}
		
		// update bottom row of buttons
		this.gift_receive_button_status();
	},
	
	gift_receive_button_status : function ()
	{
		var open_all = WeUiMgr.GetImageFactory().FindImageOfName("gift_open_all");
		var boost = WeUiMgr.GetImageFactory().FindImageOfName("gift_boost");
		var boost_all = WeUiMgr.GetImageFactory().FindImageOfName("gift_boost_all");
		var label = WeUiMgr.GetLabelFactory().FindLabelOfName("gift_boost_cost");
		
		if (!(Exists(open_all)&&Exists(boost)&&Exists(boost_all)&&Exists(label)))
		{
			NgLogD("Missing buttons!");
			return;
		}
		
		var gifts = WeGameStateMgr.mGifts;
		if (!(Exists(gifts) && gifts.length > 0))
		{
			open_all.SetAlpha(0.5);
			boost.SetAlpha(0.5);
			label.GetGL2().setAlpha(0);
			boost_all.SetAlpha(0.5);
			
			open_all.Disable("Touch");
			boost.Disable("Touch");
			boost_all.Disable("Touch");
			
			return;
		}
		
		var canOpen = false;
		var canBoost = false;
		var canBoostAll = false;
		for (var i in gifts)
		{
			if (gifts[i].proto_gift_id == -1)
			{				
				if (gifts[i].boost_cost >= 0)
				{
					canBoostAll = true;
					if (i == WeGameStateMgr.mCurrentGift)
					{
						canBoost = true;
					}
				}
				if (gifts[i].free_open || WeGameStateMgr.mFreeOpen > 0)
				{
					canOpen = true;
				}
				if (canBoost && canBoostAll && canOpen)
				{
					break;
				}
			}
		}		
		
		if (canOpen)
			{
				open_all.SetAlpha(1.0);
			if(open_all.enabledTouch === false)
				open_all.Enable("Touch");
			}	
		else 
			{
				open_all.SetAlpha(0.5);
				open_all.Disable("Touch");
				
			}
			
		if (canBoostAll)
			{
			if(boost_all.enabledTouch === false)
				boost_all.Enable("Touch");
				boost_all.SetAlpha(1.0);
			}
		else
			{
				boost_all.SetAlpha(0.5);
				boost_all.Disable("Touch");
			}

		if (canBoost)
		{
			if(boost.enabledTouch === false)
				boost.Enable("Touch");
			boost.SetAlpha(1.0);
			label.GetGL2().setAlpha(1.0);
		}
		else
		{
			boost.SetAlpha(0.5);
			label.GetGL2().setAlpha(0);
			
			boost.Disable("Touch");
		}
		
		return;
	},
	
	OnHandleTag_build_capture_share_list : function(args)
	{
		var newUsers=[];
		var users=WeUiMgr.m_cCaptureScreen.users;
		for (var i in users)
		{
			newUsers[i]= {};
			newUsers[i].user=users[i];
			newUsers[i].index=i;
		}
		if (newUsers.length == 0)
		{
			NgLogD("OnHandleTag_build_capture_share_list: no new users to send!");
		}
		return newUsers;
	},
	
	OnHandleTag_build_giftuser_list : function(args)
	{
		var empty_img = WeUiMgr.GetImageFactory().FindImageOfName("gift_waiting");
		if (Exists(empty_img))
		{
			if (Exists(WeGameStateMgr.mGiftUsers) && WeGameStateMgr.mGiftUsers.length > 0)
			{
				//NgLogD("##### Hiding empty");
				empty_img.SetAlpha(0.0);
			}
			else
			{
				//NgLogD("##### Showing empty");
				empty_img.SetAlpha(1.0);
			}
		}
		
		if (Exists(WeGameStateMgr.mGiftUsers))
		{
			return WeGameStateMgr.mGiftUsers;
		}
	},
	
	OnHandleTag_build_se_giftuser_list : function(args)
	{
	    var empty_img = WeUiMgr.GetImageFactory().FindImageOfName("gift_se_waiting");
    	if (Exists(empty_img))
    	{
    	    if (Exists(WeGameStateMgr.mSEGiftUsers) && WeGameStateMgr.mSEGiftUsers.length > 0)
			{
				//NgLogD("##### Hiding empty");
				empty_img.SetAlpha(0.0);
			}
			else
			{
				//NgLogD("##### Showing empty");
				empty_img.SetAlpha(1.0);
			}
	    }
	    
	    var empty_img = WeUiMgr.GetImageFactory().FindImageOfName("gift_se_no_items");
    	if (Exists(empty_img))
    	{
    	    if (Exists(WeGameStateMgr.mSEGiftUsers) && WeGameStateMgr.mSEGiftUsers.length > 0)
			{
				//NgLogD("##### Hiding empty");
				empty_img.SetAlpha(0.0);
			}
			else
			{
				//NgLogD("##### Showing empty");
				empty_img.SetAlpha(1.0);
			}
	    }
	    
		if (!(Exists(WeEventGame.mShareCount) && WeEventGame.mShareCount > 0))
			return;
	    
		if (Exists(WeGameStateMgr.mSEGiftUsers))
		{
			var eventGiftUsers = [];
			var length = WeGameStateMgr.mSEGiftUsers.length;
			for (var i = 0; i < length; i++)
			{

				eventGiftUsers.push(WeGameStateMgr.mSEGiftUsers[i]);
				
			}
			return eventGiftUsers;
		}
		
		NgLogD("<<<!>>> List Error");
	},

/*
D/.3fs)   (12454): (53)js: can_gift_back: false
D/.3fs)   (12454): image: gifting_gift_wizard
D/.3fs)   (12454): date_sent: 2011-04-01T08:20:46Z
D/.3fs)   (12454): boost_cost: 0
D/.3fs)   (12454): proto_gift_id: -1
D/.3fs)   (12454): sender: ngmoco:)
D/.3fs)   (12454): recipient: vmcqaericb
D/.3fs)   (12454): id: 30931077
D/.3fs)   (12454): campaign: wr_anniversary_wizard
D/.3fs)   (12454): gift_description: 
D/.3fs)   (12454): date_opened: null
D/.3fs)   (12454): free_open: false
D/.3fs)   (12454): gift_tier: 0
D/.3fs)   (12454): proto_gift: null 
 */
 
/*
D/.3fs)   (12610): (53)js: Gift is opening!
D/.3fs)   (12610): (53)js: Messages: 
D/.3fs)   (12610): (53)js: 
D/.3fs)   (12610): (53)js: openGifts: 
D/.3fs)   (12610): (53)js: date_sent: 2011-03-19T15:57:38Z
D/.3fs)   (12610): image: gifting_coin_gift.png
D/.3fs)   (12610): proto_gift_id: 14
D/.3fs)   (12610): sender: ngmoco:)
D/.3fs)   (12610): free_open: false
D/.3fs)   (12610): recipient: vmcqaericb
D/.3fs)   (12610): id: 5240188
D/.3fs)   (12610): campaign: wr_anniversary_wizard
D/.3fs)   (12610): date_opened: 2011-04-01T09:51:30Z
D/.3fs)   (12610): proto_gift: [object Object]
D/.3fs)   (12610): gift_description: {{GIFTER}} sent you 7,500 gold!
D/.3fs)   (12610): gift_tier: 0
D/.3fs)   (12610): can_gift_back: false
D/.3fs)   (12610): boost_cost: -1
 */ 

/*
D/.3fs)   (18436): (53)js: Gift boosted!
D/.3fs)   (18436): (53)js: Messages: 
D/.3fs)   (18436): (53)js: 
D/.3fs)   (18436): (53)js: Gifts data: 
D/.3fs)   (18436): (53)js: can_gift_back: true
D/.3fs)   (18436): image: gifting_gift_boosted
D/.3fs)   (18436): date_sent: 2011-04-04T07:23:37Z
D/.3fs)   (18436): boost_cost: -1
D/.3fs)   (18436): proto_gift_id: -1
D/.3fs)   (18436): sender: nytstalker
D/.3fs)   (18436): recipient: sfunderground
D/.3fs)   (18436): id: 36261306
D/.3fs)   (18436): campaign: wr_anniversary
D/.3fs)   (18436): gift_description: 
D/.3fs)   (18436): date_opened: null
D/.3fs)   (18436): free_open: true
D/.3fs)   (18436): gift_tier: 1
D/.3fs)   (18436): proto_gift: null
 */
	
	OnHandleTag_build_gift_list : function(args)
	{
		var desc_list = [];
		var gift = dummyGift();
		
		if (Exists(WeGameStateMgr.mGifts))
		{
			var gifts = WeGameStateMgr.mGifts;
// clear opened items
/*
			for (var i=0; i<gifts.length; )
			{
				if (gifts[i].proto_gift_id != -1)
				{
					gifts.splice(i, 1);
					WeGameStateMgr.mCurrentGift = -1;
				}
				else i++;
			}
*/
			// populate gift list
			if (gifts.length > 0)
			{
				// fetch the rest
				desc_list.push(gift);
				for (var i = 0; i<gifts.length; i++)
				{
					// HACK: excluding ngmoco:) from boostable gifts
					// if (gifts[i].sender == "ngmoco:)")
					//   	gifts[i].boost_cost = -1;
					
//					if (gifts[i].proto_gift_id == -1)
					// exclude gifts from yourself
					if (Exists (gCurKingdomUser) && gifts[i].sender != gCurKingdomUser)
						desc_list.push(gifts[i]);
				}
				desc_list.push(gift);
			}
			
			// reload current gift description
			var label = WeUiMgr.GetLabelFactory().FindLabelOfName("gift_description");
			if (Exists(label))
			{ 
				var text = ' ';
				if (Exists(gifts[WeGameStateMgr.mCurrentGift]))
				{
					var gift = gifts[WeGameStateMgr.mCurrentGift];
					if (gift.proto_gift_id != -1)
					{
						text = gift.gift_description.replace("{{GIFTER}}", gift.sender);
					}
					else
					{
						text = "From " + gift.sender;
					}
				}
				label.GetGL2().setText(text);
			}
			
			// show boosting reminder if needed
			var canBoost = false;
			for (var i=0; i< gifts.length; i++)
			{
				if (gifts[i].proto_gift_id == -1 && gifts[i].boost_cost >= 0)
				{
					//NgLogD("Can boost!");
					canBoost = true;
					break;
				}
			}
			var image = WeUiMgr.GetImageFactory().FindImageOfName("gift_boost_reminder");	
			if (canBoost)
			{					
				if (Exists(image) && image.mAnimState == WeUiMgr.WindowState.CLOSED)
				{
					var self = image;
					var animation = new NumberAnimation (0.5, image.GetY(), image.GetY()+image.GetHeight());
					animation.SetNumber = function(value)
					{
						self.SetPosition(self.GetX(), value);
					};
					animation.OnStop = function()
					{
						self.mAnimState = WeUiMgr.WindowState.OPENED;
						//NgLogD("Boost reminder animation complete!");
					};
					// clean-up on deleting image
					if (!Exists(image.Olddestroy))
					{
			    		image.Olddestroy=image.destroy;
			    		image.destroy=function()
			    		{
			    			this.mAnim.Stop();
			    			this.Olddestroy();
			    		};
			    	}					
					
					image.mAnim = animation;
					image.mAnimState = WeUiMgr.WindowState.OPENING;
				}
			}
			else
			{
				if (Exists(image) && image.mAnimState == WeUiMgr.WindowState.OPENED)
				{
					var self = image;
					var animation = new NumberAnimation (0.5, image.GetY(), image.GetY()-image.GetHeight());
					animation.SetNumber = function(value)
					{
						self.SetPosition(self.GetX(), value);
					};
					animation.OnStop = function()
					{
						self.mAnimState = WeUiMgr.WindowState.CLOSED;
						//NgLogD("Boost reminder animation complete!");
					};
					// clean-up on deleting image
					if (!Exists(image.Olddestroy))
					{
			    		image.Olddestroy=image.destroy;
			    		image.destroy=function()
			    		{
			    			this.mAnim.Stop();
			    			this.Olddestroy();
			    		};
			    	}					
							
					image.mAnim = animation;
					image.mAnimState = WeUiMgr.WindowState.CLOSING;
				}				
			}
			
		}

		var empty_img = WeUiMgr.GetImageFactory().FindImageOfName("gift_empty_list");		
		if (desc_list.length == 0)
		{
			NgLogD("No gifts to display!");
			desc_list.push(gift);
			desc_list.push(gift);
			desc_list.push(gift);
			
			if (Exists(empty_img))
			{
				//NgLogD("##### Showing empty");
				empty_img.SetAlpha(1.0);
			}	
		}
		else
		{
			if (Exists(empty_img))
			{
				//NgLogD("##### Hiding empty");
				empty_img.SetAlpha(0.0);
			}
		}
		
		this.gift_receive_button_status();
		return desc_list;
	},
	
	OnHandleTag_build_gift_show_list : function()
	{
		/*
		var giftList = [];
		// dummy gift
    	var gift = {
    			image: "gifting_coin_gift.png",
    			proto_gift_id: 14,
    			sender: "ngmoco",
    			recipient: "vmcqaericb",
    			gift_description: "{{GIFTER}} sent you 7,500 gold!",
    			can_gift_back: true
    	};
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	giftList.push( ObjectUtils.GetCloneOfObject( gift) );
    	
    	for (var i = 0; i < giftList.length; i++)
    	{
    		giftList[i].index=i;
    	}
		
		return giftList;
		*/
		return WeGameStateMgr.mOpenedGifts;
	},	
	/* End gifting code */

	OnHandleTag_build_mojo_store_list : function()
	{
		return this.OnHandleTag_build_mojo_store_list_in_build_menu();
	},

	OnHandleTag_build_mojo_store_list_in_build_menu : function()
	{
		if (!WeUiMgr.GetMojoButtonClicked())
		{
			Core.Analytics.reportNavigation("Builld Menu", "Mojo Store", "Mojo Store Tab");
		}
		
		WeUiMgr.GetImageFactory().mMojoItems_semaphore=true;
		
		var desc_list = [];
		var json = WeUiMgr.GetJSONGlobals();
	//	var listData = json["iap_list_data"];
	    var listData = WeUiMgr.mIAPData;
		var itemscount = listData.length;
		for( var i = 0; i < itemscount; i++)
		{
		    if (listData[i].entity === 0)
		    {
			    desc_list.push(listData[i]);
		    }
		}
		return desc_list;
	},
	
	OnHandleTag_build_users_list : function(args)
	{
		return WeUiMgr.user_list;
		/* remove
		var ret =
		[
		        {
		        	name : "Mantas",
		        	description : "turbo deasel"
		        },
		        {
		        	name : "Andrius",
		        	description : "turbo deasel"
		        },
		        {
		        	name : "Stepas",
		        	description : "turbo deasel"
		        }
		];
		return ret;
		*/
	},

	OnHandleTag_build_harvest_list : function()
	{
		var in_level = [];
		var out_level = [];
        var player_level = WeGameStateMgr.GetGameLotInfo().mLevel;
		var products = weProtoDb.getInstance().getProtoProducesForEntity(gCurrentProducingBuilding);

		// grab all the in-level items
		for (var i = 0; i < products.length; i++)
		{
			if (player_level >= products[i].level)
			{
				var desc = this.BuildHarvestInfo(products[i]);
				desc.enabled = true;
				in_level.push(desc);
			}
		}
		// sort it so the highest level stuff is at the top
		in_level.sort(LevelSortDescending);
		
		// grab all the out of level level items
		for (var i = 0; i < products.length; i++)
		{
			if (player_level < products[i].level)
			{
				var desc = this.BuildHarvestInfo(products[i]);
				desc.out_of_level = true;
				desc.enabled = false;
				out_level.push(desc);
			}
		}
		
		// sort it so that the lowest level stuff is at the top of the disabled portion
		out_level.sort(LevelSortAscending);
		
		return in_level.concat(out_level);
	},
	
	BuildHarvestInfo : function(product)
    {
		//gold_cost <- how much this cost to use
		//produce_cap <- how much you get for this
		//produce_duration <- how long this will take to make
		//proto_name <- the name of the item
		//xp_reward <- the xp you get from this thing
		var ent = {};
		ent.gold_cost = product.gold_cost + " ";
		ent.produce_cap = product.produce_cap;

		var delta = product.produce_duration * 1000;
		var time = '';
		var hours = Math.floor( delta / 3600000);
		delta -= hours * 3600000;
		var minutes = Math.floor( delta / 60000);
		delta -= minutes * 60000;
		var seconds = Math.floor( delta / 1000);
		var fig = 2; 
		if(hours !== 0)
		{
		    time += hours + "h "; 
		    --fig;
		}
		if(minutes !== 0)
		{
		    time += minutes + "m ";
		    --fig;
		}
		if(seconds !== 0 && fig !== 0)
		{
		    time += seconds + "s ";
		}

		ent.produce_duration = time;
		ent.proto_name = product.proto_name;
		ent.xp_reward = product.xp_reward;
		ent.icon_png = product.icon_png;
		ent.source = this;
		ent.product = product;
		ent.level = product.level;
		return ent;
    },

	OnHandleTag_build_store_list : function(args)
	{
		var db = weProtoDb.getInstance();
		var config = weProtoConfigs.getInstance().map;

		var desc_list = [];
		if (Exists(args.type))
		{
	        // Add the object defs to the controller  
	        if(Exists(db.proto_entities))
	        {
				// Build list of stash items, which should appear in this
				// store list
				var stashItems = [];
				var stash = WeGameStateMgr.GetStash();
				for(var i in stash)
				{
					var ent = db.mapIdToEntity[stash[i].type_id];
					if (!Exists(ent))
					{
					    continue;
					}
					
					var in_stash = db.getStoreItemStashCount(ent);
					
					if(!ent || in_stash <= 0)
						continue;

					if(ent.store_category == null)
					{
						// Force category-less items to be at the end of the
						// list
						ent.store_priority += 10000;
						ent.store_category = 'Building';
					}	

					if(ent.store_category == args.type)
					{
						// Do not show inventory item, if it's featured
						var isFeatured = false;
						if(Exists(db.proto_featured_items))
						{
							for(var j in db.proto_featured_items)
							{
								var featuredItem = db.proto_featured_items[j].proto_featured_item;
								var featuredId = featuredItem.proto_entity_id;
								if(ent.id == featuredId) 
								{
									isFeatured = true;
									break;
								}
							}
						}

						if(!isFeatured)
						{
							stashItems.push(ent);
						}
					}
				}

				NgLogD("all entities");
				var configs = weProtoConfigs.getInstance().map;
                if (configs.EventParticipationEntityIds != undefined)
                {
                    var eventIDstring = configs.EventParticipationEntityIds.toString();
                    var eventIDs = eventIDstring.split("|");
                    var numEventIDs = eventIDs.length;
                }
                
				var protoLen = db.proto_entities.length;
		        for(i = 0; i < protoLen; i++)
		        {
		            var ent = db.proto_entities[i].proto_entity;
					// Hack to put harvest all building into store
					if(ent.id == config['HarvestAllEntityId']) 
						ent.store_category = 'Building';
						
					   // if (ent.id === 350)
                 	   // {
                 	   //     ent.store_category = 'Building';
                 	   // }
		            if(ent.store_category == args.type)
		            {
                        ent.store_image_url = Content.getIconImagePath(ent.store_image_url);
                        var in_stash = db.getStoreItemStashCount(ent);
		                if(in_stash || ent.gold_cost !== 0 || ent.mana_cost !== 0 || WeUiMgr.GetMTXForProtoId(ent.id) !== null)
		                {
		                	desc_list.push(ent);
		                }
		                else
		                {
		                    try
		                    {

                                for (var j = 0; j < numEventIDs; ++j)
                                {
                                    if (ent.id == parseInt(eventIDs[j]))
                                    {
                                        desc_list.push(ent);
                                    }
                                }
                                
                            }
                             catch(ex)
                                {
                                    NgLogD("Exception .. " + ex);
                                }
		                }

						// Mark already inserted stash items
						if(in_stash)
						{
							for(var j in stashItems)
							{
								if(stashItems[j] == ent)
									stashItems[j] = null;
							}
						}
		            }
		        }
                NgLogD("all entities DONE");
				// Insert leftover stash items
				for(var i in stashItems)
				{
					if(stashItems[i])
					{
						desc_list.push(stashItems[i]);
						
		                if(stashItems[i].store_priority==6125)
		                {
		                	stashItems[i].store_priority=0;
		                }
					}
				}
	        }
		}

		desc_list.sort(function (a, b) 
		{
			if(a.store_priority !== b.store_priority)
				return a.store_priority - b.store_priority;
			return a.id - b.id;
		});

		return desc_list;
	},
	
	OnHandleTag_build_upgrade_list : function(args)
	{	
		var desc_list = [];
        // load the new tab up
        if(Exists(weProtoDb.getInstance().proto_upgrades))
        {
            var kingdom_type = WeGameStateMgr.GetGameLotInfo().kingdom_type;
            var protoLen = weProtoDb.getInstance().proto_upgrades.length;
            for(var i = 0; i < protoLen; i++)
            {
                // filter the list by realm type
                var upgrade = weProtoDb.getInstance().proto_upgrades[i].proto_upgrade;
                if (kingdom_type == upgrade.kingdom_type)
                {
					desc_list.push(upgrade);
                }
            }
        }
		return desc_list;
	},
	
	OnHandleTag_build_featured_list : function(args)
	{	
		var featured_list = [];
		if (Exists(args.type))
		{
	        // Add the object defs to the controller  
	        if(Exists(weProtoDb.getInstance().proto_featured_items))
	        {
				var db = weProtoDb.getInstance();
	            var fLen = weProtoDb.getInstance().proto_featured_items.length;
		        for(i = 0; i < fLen; i++)
		        {
					var featuredItem = db.proto_featured_items[i].proto_featured_item;
					var protoEntity  = db.getProtoEntityById ( featuredItem.proto_entity_id );
					if( protoEntity )
						featured_list.push(protoEntity);
				}
			}
		}
		return featured_list;
	},
	
	OnHandleTag_build_se_store_list : function(args)
	{	
		var store_list = [];
		if (Exists(args.type))
		{
	        // Add the object defs to the controller
			//TODO: Change for proto_special_event_items or something like that
	        if(Exists(weProtoDb.getInstance().proto_featured_items))
	        {
				var db = weProtoDb.getInstance();
	            var fLen = weProtoDb.getInstance().proto_featured_items.length;
		        for(i = 0; i < fLen; i++)
		        {
					var eventItem = db.proto_featured_items[i].proto_featured_item;
					var protoEntity  = db.getProtoEntityById ( eventItem.proto_entity_id );
					if( protoEntity )
						store_list.push(protoEntity);
				}
			}
		}
		return store_list;
	},

	OnHandleTag_build_event_goals_list : function ()
	{
		var goal = WeGoals.goalToShowDetail;

		var db = weProtoDb.getInstance();
		if(goal !== null)
		{
			// Found goal, look which tasks are completed
			var result = []; 
			for(var i in goal.tasks)
			{
				var proto_task = goal.tasks[i].proto_task;
				if(proto_task.task_type !== 'capture_pest')
					continue;

				var pest_id = parseInt(proto_task.task_type_id);
				if(pest_id != proto_task.task_type_id)
				{
					NgLogD("Unable to get pest_id for capture task!");
					continue;
				}

				// Find which pest corresponds to task
				var proto = db.mapIdToPest[pest_id];
				if(Exists(proto))
				{
					// Pest found! Push list item
					if(goal.tasks[i].current_count > 0)
						var img = proto.progress_png;
					else
						var img = proto.progress_none_png;

					img = "capture/" + img; // event goal tab's small images are stored in the capture sub folder 
					var task = goal.tasks[i];
					result.push({ 
						image: img, 
						count: task.current_count, 
						total: task.proto_task.count, 
						pest_name: proto.proto_name 
					});
				}
			}
			return result;
		}	
		else
		{
			// Goal not found, assume not started yet
			var result = [];
			var pests = weProtoDb.getInstance().proto_pests;
			for(var i in pests)
			{
				var proto = pests[i];
				if(proto.enabled)
				{
					result.push({
						image: proto.progress_none_png, 
						count: 0, 
						total: 0,
						pest_name: proto.proto_name 
					});
				}
			}
			return result;
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeLabelFactory'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeLabelFactory'] || {}; $MODULE_REGISTRY['weEngine/WeLabelFactory'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeLabelFactory.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     This Module knows how to construct a Text Label 
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var WeLabel2D = require('weEngine/WeLabel2D').WeLabel2D;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;
var WeSocialMapMgr = require('weEngine/WeSocialMapMgr').WeSocialMapMgr;
var WeBoundary = require('weEngine/WeBoundary').WeBoundary;
var WeContentDownloader = require('weEngine/WeContentDownloader').WeContentDownloader;
var WeCoinsCrowns = require('weEngine/WeCoinsCrowns').WeCoinsCrowns;
var WeEventGame = require('weEngine/WeEventGame').WeEventGame;
var WeEventSpinner = require('weEngine/WeEventSpinner').WeEventSpinner;
//////////////////////////////////////////////////////////////////////////////
/**
 * Class WeLabelFactory
 */
exports.WeLabelFactory = Core.Class.subclass(
{
	classname: 'WeLabelFactory',
	
	ColorMult: 1.0 / 255.0,
    initialize : function()
    {
        this.mFactoryLabels = [];
    },

    ReleaseLabels : function()
    {
        var len = this.mFactoryLabels.length;
        for(var idx = 0; idx < len; ++idx)
        {
            if (this.mFactoryLabels[idx] !== null)
            {
                this.mFactoryLabels[idx].destroy();
            }
        }
        this.mFactoryLabels = [];
    },
    
    ShowLabels : function()
    {
    	NgLogD("Labels");
        for(var label in  this.mFactoryLabels)
        {
            if (label !== null)
            {
            	NgLogD("label.xName: "+label.xName);
            }
        }
    },

    ManageLabel : function(label)
    {
        this.mFactoryLabels.push(label);
    },

    ReleaseLabel : function(label)
    {
        var len = this.mFactoryLabels.length;
        for (var i = 0; i < len; i++)
        {
            if (this.mFactoryLabels[i] === label)
            {
                this.mFactoryLabels.splice(i,1);
                return;
            }
        }
    },

	FindLabelOfName : function(name)
	{
		var len = this.mFactoryLabels.length;
		for (var i = 0; i < len; i++)
		{
			if (this.mFactoryLabels[i].xName == name)
			{
				return this.mFactoryLabels[i];
			}
		}
		return undefined;
	},

    //////////////////////////////////////////////////////////////////////////////
    // Function CreateImage
    ProcessLabelTag : function(labelDef, parent, args)
    {
        var handle = 'OnHandleTag_' + labelDef.tag;
        var label = null;
        if(Exists(this[handle]))
        {
            label = this[handle](labelDef, parent, args); 
        }

        return label;
    },
            
    //////////////////////////////////////////////////////////////////////////////
    // Function CreateImage
    CreateLabel : function(labelDef, parent, args, wasTagProcessed)
    {
		WeUiMgr.setPositionByPercent(labelDef);

        if(Exists(labelDef.text))
        {
        	if(WeCoinsCrowns.isCoinText(labelDef.text))
        	labelDef.text = WeCoinsCrowns.replaceCoinText(labelDef.text);
        }
        
        if(!Exists(wasTagProcessed))
        {
            wasTagProcessed = false;
        }

		// Check to see if this label has been turned off
		if (Exists(labelDef.disabled) && labelDef.disabled)
		{
			return null;
		}

        if(!wasTagProcessed && Exists(labelDef.tag) && "" !== labelDef.tag)
        {
            label = this.ProcessLabelTag(labelDef, parent, args); 
        }
        else
        {
            label = new WeLabel2D(parent);
            var labelGL2=label.GetGL2();
            labelGL2.setScale(new Core.Vector(labelDef.scale_x, labelDef.scale_y));
            labelGL2.setPosition(new Core.Vector(labelDef.pos_x, labelDef.pos_y));
            labelGL2.setFontSize(labelDef.font_size);
            labelGL2.setDepth(labelDef.pos_z || 0);
            labelGL2.setText(labelDef.text);
            labelGL2.setAnchor(0.5, 0.5);
            labelGL2.setFontLocation(GL2.Text.FontLocation.System);
            // Is a sizing box provided?
            if(Exists(labelDef.size_x) && Exists(labelDef.size_y))
            {
                // AW: This crashes the device
                //NgLogD("******** size = " + labelDef.size_x + ", " + labelDef.size_y);
                labelGL2.setSize(labelDef.size_x, labelDef.size_y);
            }

            if(Exists(labelDef.wrap))
            {
                if(labelDef.wrap == "shrink")
                {
                    labelGL2.setOverflowMode(GL2.Text.OverflowMode.ReduceFontSize);
                }
                if(labelDef.wrap == "newline")
                {
                    labelGL2.setOverflowMode(GL2.Text.OverflowMode.Multiline);
                }
            }
            else
            {
                labelGL2.setOverflowMode(GL2.Text.OverflowMode.ReduceFontSize);
            }

            if(Exists(labelDef.color_r) && Exists(labelDef.color_g) && Exists(labelDef.color_b))
            {
                var color = [];
                color[0] = labelDef.color_r * this.ColorMult;
                color[1] = labelDef.color_g * this.ColorMult;
                color[2] = labelDef.color_b * this.ColorMult;
                labelGL2.setColor(color[0], color[1], color[2]);
            }
            else
            {
                // default to black
                labelGL2.setColor(0,0,0);
            }

            if(Exists(labelDef.color_a))
            {
                labelGL2.setAlpha(labelDef.color_a);
            }

			if(Exists(labelDef.name))
			{
				label.xName = labelDef.name;
			}

            if(Exists(labelDef.weight))
            {
                if( Core.Capabilities.getPlatformOS() == "Android")
                {
                    switch(labelDef.weight)
                    {
                        case "bold" :
                            labelGL2.setFontFamily('DroidSans-Bold');
                            break;
                        case "italic" :
                            labelGL2.setFontFamily('DroidSerif-Italic');
                            break;
                        case "bold-italic" :
                            labelGL2.setFontFamily('DroidSerif-BoldItalic');
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    switch(labelDef.weight)
                    {
                        case "bold" :
                            labelGL2.setFontFamily('Helvetica-Bold');
                            break;
                        case "italic" :
                            labelGL2.setFontFamily('HelveticaNeue-Italic');
                            break;
                        case "bold-italic" :
                            labelGL2.setFontFamily('HelveticaNeue-BoldItalic');
                            break;
                        default:
                            labelGL2.setFontFamily('Helvetica');
                            break;
                    }
                }
            }
            
            if (Exists(labelDef.hide_idle))
            {
                label.hide_idle = labelDef.hide_idle;
            }
            else
            {
                label.hide_idle = false;
            }


            if(Exists(labelDef.justify))
            {
                switch(labelDef.justify)
                {
                    case "center":
                    labelGL2.setHorizontalAlign(GL2.Text.HorizontalAlign.Center);
                    break;
                    case "left":
                    labelGL2.setHorizontalAlign(GL2.Text.HorizontalAlign.Left);
                    break;
                    case "right":
                    labelGL2.setHorizontalAlign(GL2.Text.HorizontalAlign.Right);
                    break;
                    default:
                    break;
                }
            }

            if(Exists(labelDef.vjustify))
            {
                switch(labelDef.vjustify)
                {
                    case "middle":
                    	labelGL2.setVerticalAlign(GL2.Text.VerticalAlign.Middle);
                    break;
                }
            }


            label.xFactory = this;

            if(Exists(labelDef.rotation))
            {
                label.SetRotation(labelDef.rotation);
            }
        }
        return label;
    },

    OnHandleTag_communityButtonLabel : function(labelDef, parent, args)
    {
        	if (WeSocialMapMgr.isCommunityMap)
        	{
        		labelDef.text= labelDef.args.toSocial;
        	}
        	else
        	{
        		labelDef.text= labelDef.args.toCommunity;
        	}
        return this.CreateLabel(labelDef, parent, args, true);
    },

    OnHandleTag_display_user_xp : function(labelDef, parent, args)
    {
		var getXpText = function()
		{
			var info = WeGameStateMgr.GetGameLotInfo();
            if(info)
            {
				var nextProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(info.mLevel+1);
				var required_xp = 0;
				if (nextProtoLevel !== null)
					required_xp = nextProtoLevel.required_xp;
				
				var xpString = "XP: " + info.xp + "/";
				if (required_xp === 0)
					xpString += info.xp;
				else
					xpString += required_xp;

				return xpString;
			}
			return "XP: 0";
		}

        var label = this.CreateLabel(labelDef, parent, args, true);
        label.GetGL2().setText(getXpText());
        label.EnableUpdate(function(delta)
        {
			var xpString = getXpText();      
			if (label.GetGL2().getText() != xpString)
				label.GetGL2().setText(xpString);
        });
        return label;
    },

    OnHandleTag_user_level : function(labelDef, parent, args)
    {
		var getLevelText = function()
		{
		    var info = WeGameStateMgr.GetGameLotInfo();
		    var infoStr = ' ';
		    if(info)
		    {
				infoStr = "Level: " + info.mLevel;				
			}
			return infoStr;
		};

        var label = this.CreateLabel(labelDef, parent, args, true);
        label.GetGL2().setText(getLevelText());
        label.EnableUpdate( function(delta)
        {       
			var text = getLevelText();
			if (label.GetGL2().getText() != text)
		   		label.GetGL2().setText(text);        
        });
        return label;
    },

    OnHandleTag_display_user_level : function(labelDef, parent, args)
    {
		var getLevelText = function()
		{
		    var info = WeGameStateMgr.GetGameLotInfo();
		    var infoStr = ' ';
		    if(info)
		    {
				infoStr = "Level: " + info.mLevel;				
			}
			return infoStr;
		}

        var label = this.CreateLabel(labelDef, parent, args, true);
        label.GetGL2().setText(getLevelText());
        label.EnableUpdate( function(delta)
        {       
			var text = getLevelText();
			if (label.GetGL2().getText() != text)
		   		label.GetGL2().setText(text);        
        });
		label.GetGL2().setHorizontalAlign(GL2.Text.HorizontalAlign.Left);
        label.GetGL2().setColor(0,0,0);
        return label;
    },    
    
    OnHandleTag_current_kingdom : function(labelDef, parent, args)
    {
    	if(args && Exists(args.page))
    	{
    		labelDef.text="Kingdom "+(args.page+1);
    	}
    	else
    	{
            var info = WeGameStateMgr.GetGameLotInfo();
            labelDef.text=info.name;
    	}
        return this.CreateLabel(labelDef, parent, args, true);
    },

    OnHandleTag_display_user_name : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        gKingdomName = WeGameStateMgr.GetCurrentKingdomUser();
        label.GetGL2().setText(gKingdomName);
//        label.EnableUpdate( function(delta)
//        {
//			gKingdomName = WeGameStateMgr.GetCurrentKingdomUser();
//			if(label.GetGL2().getText() != gKingdomName)
//               	label.GetGL2().setText(gKingdomName);
//        });
		label.GetGL2().setHorizontalAlign(GL2.Text.HorizontalAlign.Left);
        return label;
    },

    OnHandleTag_display_user_gold : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        var updateFunc = function(delta)
        {
            var info = WeGameStateMgr.GetGameLotInfo();
            if(info)
            {
                var goldStr = '' + info.gold;
                if(label.GetGL2().getText() != goldStr)
                {
                    label.GetGL2().setText(goldStr);
                }
            }
        };
        label.EnableUpdate( updateFunc );
        updateFunc();
        return label;
    },

    OnHandleTag_display_user_mojo : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        var updateFunc = function(delta)
        {
            var info = WeGameStateMgr.GetGameLotInfo();
            if(info)
            {
                var manaStr = '' + info.mana;
                if(label.GetGL2().getText() != manaStr)
                {
                    label.GetGL2().setText(manaStr);
                }
            }
        };
        label.EnableUpdate( updateFunc );
        updateFunc();
        return label;
    },

    OnHandleTag_is_crop_out_of_level : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		// ugly, if the item is out of level AND its flagged for alt-text, stub in the "avail at level X" stuff
		if (Exists(args.out_of_level) && args.out_of_level && Exists(labelDef.args) && Exists(labelDef.args.alternate_text))
		{
			newDef.text = labelDef.args.alternate_text + args.level;
		}
		// otherwise if its out of level just bail
		else if (Exists(args.out_of_level) && args.out_of_level)
		{
			return null;
		}
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_goals_done_text : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        if (WeGoals.completedGoals.length > 0)
        {
            label.SetVisible(false);
        }
        return label;
    },

    OnHandleTag_proto_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
        var text = args[labelDef.args.proto_tag];
        if (labelDef.args.pre_text !== undefined)
        {
            text = labelDef.args.pre_text + text;
        }

		// more ugly - don't draw this if they've already got the upgrade
		if (labelDef.name == "upgrade_item_description_level")
		{
			var avail = weProtoDb.getInstance().canPurchaseUpgrade(args);
			if (avail == UpgradeStatus.kAlreadyPurchased)
			{
				return null;
			}
		}

		//ugly, force_draw is used for the product name in the harvest list...otherwise
		//we don't want to draw any proto text for out-of-level items
		if (Exists(args.out_of_level) && args.out_of_level && !Exists(labelDef.args.force_draw)) 
		{
			return null;
		}
        
        // Filter out any "Magic" text
        //if (typeof(text)=='string')
        //{
        //    var index = text.indexOf("Magic ");
        //    if (index != -1)
        //    {
        //        text = text.slice(index + "Magic ".length);
        //    }
        //}
      
        if (labelDef.line_len !== undefined)
        {
            newDef.text = ConvertStringToMultipleLines(text, labelDef.line_len);
        }
        else
        {
            newDef.text = text;
        }

        if(labelDef.args.proto_tag == 'produce_duration')
        {
            // Check if there is an "hour" tag
             
            var hourIdx =  newDef.text.indexOf('h');
            if(hourIdx == 2)
            {
                // We may have a hour case.  Otherwise ignore
                var theSub = newDef.text.substr(0, 2);
                var hours = parseInt(theSub, 10);
                if( hours > 24 )
                {
                    var days = Math.floor(hours/24);
                    hours -= (days * 24);
                    var data = "";
                    data = data + days + "d";
                    if(hours > 0)
                    {
                        data = data + " " + hours + "h";
                    }
                    
                    var rest = newDef.text.substr(3);
                    if(rest.indexOf('m') != -1 || rest.indexOf('s') != -1)
                    {
                        data = data + " " + rest;
                    }
                    
                    newDef.text = data;
                }
            }
        }
        
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    /*
    OnHandleTag_current_kingdom : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_1;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
*/

    OnHandleTag_featured_proto_text : function(labelDef, parent, args)
    {
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
		var text = weProtoDb.getInstance().getFeaturedItemById(args.id).description;
		
		if (labelDef.line_len !== undefined)
        {
            newDef.text = ConvertStringToMultipleLines(text, labelDef.line_len);
        }
        else
        {
            newDef.text = text;
        }
		
		var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
	},
	
	OnHandleTag_event_store_proto_text : function(labelDef, parent, args)
    {
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
		var text = WeEventGame.getEventStoreItemById(args.id).store_text;
		if (!Exists(text))
		{
		    text = "";
		}
		
		if (labelDef.line_len !== undefined)
        {
            newDef.text = ConvertStringToMultipleLines(text, labelDef.line_len);
        }
        else
        {
            newDef.text = text;
        }
		
		var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
	},
	
	OnHandleTag_featured_item_level: function(labelDef, parent, args)
    {
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
		var text = args.required_level;
		
        if (Exists(newDef.pre_text) && newDef.pre_text !== undefined)
        {
            text = newDef.pre_text + text;
        }
		
        newDef.text = text;
		
		var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
	},

    OnHandleTag_news_tab_label : function(labelDef, parent, args)
    {
        if(WeUiMgr.mActiveScreen == "SocialMapScreen")
        {
            labelDef.hide_idle = false;
        }
        var label = this.CreateLabel(labelDef, parent, args, true);
        WeUiMgr.SetNewsTabLabel(label);
        return label;
    },

    OnHandleTag_game_label_1 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_1;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_game_label_2 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_2;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_game_label_3 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_3;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_game_label_4 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_4;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_game_label_5 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_5;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_game_label_6 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_6;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
    
    OnHandleTag_game_label_7 : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.game_label_7;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
    
    OnHandleTag_proto_event_price : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        var cost = args["points_cost"];
        newDef.text = "" + cost;
        var label = this.CreateLabel(newDef, parent, args, true); 

		// set the label to the "insufficient_funds_color" where necesasry
		var info = WeGameStateMgr.GetGameLotInfo();
		if(info)
		{
			var isLocked = WeEventGame.isStoreItemLocked(args);
			if (isLocked)
			{
				label.GetGL2().setColor(parseColor(labelDef.args.locked_color));
			}
			else if (WeEventGame.getEventPoints() < cost)
			{
				label.GetGL2().setColor(parseColor(labelDef.args.insufficient_funds_color));
			}
			else
			{
				label.GetGL2().setColor(parseColor(labelDef.args.unlocked_color));
			}
		}
        return label;
    },
    

    OnHandleTag_proto_text_select : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        var len = labelDef.args.select_len;
        var results = [];
        for(var idx = 0; idx < len; ++idx)
        {
            var name = "proto_tag_" + (idx + 1);
			var obj = {};
			if (labelDef.args[name] === "price_cost")
			{
			    var mtx = WeUiMgr.GetMTXForProtoId(args["id"]);
			    if (mtx)
			    {
    			    obj.value = (mtx.cost > 0) ? mtx.cost : "";
    			    obj.name = "MobaCoin";
    			    results = [];
    			    results.push(obj);
    			    break;
			    }
			}
			else
			{
			    obj.value = args[labelDef.args[name]];
			    obj.name = labelDef.args[name];
			    results.push(obj);
		    }
        }
		
		// determine the value we'll be using for this label
        if(labelDef.args.select_type == "largest")
        {
            results.sort(function(a, b){ return b.value - a.value; });
        }
        else if(labelDef.args.select_type == "smallest")
        {
            results.sort(function(a, b){ return a.value - b.value; });
        }

		var obj = results[0];
        newDef.text = "" + obj.value;
        var label = this.CreateLabel(newDef, parent, args, true); 

		// set the label to the "insufficient_funds_color" where necesasry
		var info = WeGameStateMgr.GetGameLotInfo();
		if(info)
		{
			var isLocked = !weProtoDb.getInstance().isStoreItemUnlocked(args);
			if (isLocked)
			{
				label.GetGL2().setColor(parseColor(labelDef.args.locked_color));
			}
			else if (obj.name == "gold_cost" && info.gold < obj.value && Exists(labelDef.args.insufficient_funds_color))
			{
				label.GetGL2().setColor(parseColor(labelDef.args.insufficient_funds_color));
			}
			else if (obj.name == "mana_cost" && info.mana < obj.value)
			{
				label.GetGL2().setColor(parseColor(labelDef.args.insufficient_funds_color));
			}
			else if (obj.name == "points_cost" && WeEventGame.getEventPoints() < obj.value)
			{
				label.GetGL2().setColor(parseColor(labelDef.args.insufficient_funds_color));
			}
			else
			{
				label.GetGL2().setColor(parseColor(labelDef.args.unlocked_color));
			}
		}
        return label;
    },

	OnHandleTag_proto_upgrade_cost : function(labelDef, parent, args)
	{
		var avail = weProtoDb.getInstance().canPurchaseUpgrade(args);
		if (avail == UpgradeStatus.kAlreadyPurchased)
		{
			return null;
		}

        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = args.gold_cost;
		var label = this.CreateLabel(newDef, parent, args, true); 
		
		// setup the color
		if (avail == UpgradeStatus.kCannotPurchase)
		{
			label.GetGL2().setColor(parseColor(labelDef.args.locked_color));
		}
		else if (avail == UpgradeStatus.kCannotAfford)
		{
			label.GetGL2().setColor(parseColor(labelDef.args.insufficient_funds_color));
		}
		else
		{
			label.GetGL2().setColor(parseColor(labelDef.args.unlocked_color));
		}
	},

    OnHandleTag_mojo_store_label : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args[labelDef.args.type_tag];
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_obj_state_time_remaining_full : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        var source = args.source;
        var prod = args.product;
        newDef.text = source.GetTimeRemaining(prod) + " Remaining";
        var label = this.CreateLabel(newDef, parent, args, true);
        label.EnableUpdate( function(delta)
        {
            if (label.GetGL2().getParent() === null)
            {
                label.destroy();
            }
            else
            {
                var text = source.GetTimeRemaining(prod);
                label.GetGL2().setText(text + " Remaining");
            }
        });
        return label;
    },

    OnHandleTag_obj_state_notification : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = (args.source.mEntity.push_notify) ? 'ON' : 'OFF';
        var label = this.CreateLabel(newDef, parent, args, true);
        label.EnableUpdate( function(delta)
        {
            if (label.GetGL2().getParent() === null)
            {
                label.destroy();
            }
            else
            {
                var text = (args.source.mEntity.push_notify) ? 'ON' : 'OFF';
                if(text != label.GetGL2().getText())
                {
                    label.GetGL2().setText(text);
                }
            }
        });
        return label;
    },

    OnHandleTag_obj_state_time_remaining_percent : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        var source = args.source;
        var prod = args.product;
        newDef.text = source.GetPercentRemaining(prod) + "%";
        var label = this.CreateLabel(newDef, parent, args, true);
        label.xTimeText = "";
        label.EnableUpdate( function(delta)
        {
            if (label.GetGL2().getParent() === null)
            {
                label.destroy();
            }
            else
            {
                var text = source.GetPercentRemaining(prod);
                if(text != label.xTimeText)
                {
                    label.GetGL2().setText(text + "%");
                    label.xTimeText = text;
                }
            }
        });
        return label;
    },

    OnHandleTag_obj_state_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.obj_state_text;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_obj_state_boost : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = ""+args.obj_state_boost;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
    
    OnHandleTag_obj_state_happy_boost : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.obj_state_happy_boost;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
    
    OnHandleTag_obj_state_happy_perc : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = args.obj_state_happy_perc;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_popup_label : function(labelDef, parent, args)
    {
        var label = null;
        if(Exists(args.popup_label))
        {
            var newDef = ObjectUtils.GetCloneOfObject(labelDef);
            newDef.text = args.popup_label;
            label = this.CreateLabel(newDef, parent, args, true); 
        }
        return label;
    },
    
    OnHandleTag_loading_progress : function(labelDef, parent, args)
    {
        var label = null;
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        label = this.CreateLabel(newDef, parent, args, true); 
        label.EnableUpdate( function(delta)
        {
            label.GetGL2().setText(WeUiMgr.mLoadingProgress);
        });
        
        return label;
    },

    OnHandleTag_popup_text : function(labelDef, parent, args)
    {
        var label = null;
        if(Exists(args.popup_text))
        {
            var newDef = ObjectUtils.GetCloneOfObject(labelDef);
            if (labelDef.line_len !== undefined)
            {
                newDef.text = ConvertStringToMultipleLines(args.popup_text, labelDef.line_len);
            }
            else
            {
                newDef.text = args.popup_text;
            }
            label = this.CreateLabel(newDef, parent, args, true); 
        }
        return label;
    },

    OnHandleTag_popup_yes_button : function(labelDef, parent, args)
    {
        var label = null;
        if(Exists(args.OnYes))
        {
            var newDef = ObjectUtils.GetCloneOfObject(labelDef);
            newDef.text= "YES";
			if (Exists(args.OnYesText))
			{
				newDef.text = args.OnYesText;
			}
            label = this.CreateLabel(newDef, parent, args, true); 
        }
        return label;
    },

    OnHandleTag_popup_no_button : function(labelDef, parent, args)
    {
        var label = null;
        if(Exists(args.OnNo))
        {
            var newDef = ObjectUtils.GetCloneOfObject(labelDef);
			if (Exists(args.OnNoText))
			{
				newDef.text = args.OnNoText;
			}
            label = this.CreateLabel(newDef, parent, args, true); 
        }
        return label;
    },

    OnHandleTag_popup_ok_button : function(labelDef, parent, args)
    {
        var label = null;
        if(Exists(args.OnOk))
        {
            labelDef.text = "OK";
			if (Exists(args.OnOkText))
			{
				labelDef.text = args.OnOkText;
			}
            label = this.CreateLabel(labelDef, parent, args, true); 
        }
        return label;
    },

    OnHandleTag_ribbonwinner_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = labelDef.args.text;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
    
    OnHandleTag_event_key : function(labelDef, parent, args)
    {
    	var newDef = ObjectUtils.GetCloneOfObject(labelDef);
    	var theEvent = weProtoDb.getInstance().getProtoEventId(args.eventId);
    	newDef.text = obj[args.key] + "";
    	
    	var label = this.CreateLabel(newDef, parent, args, true);
    	return label;
    },
    
    OnHandleTag_objective_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = WeGameStateMgr.IsCompletedObjective() ? labelDef.args.completed_text : labelDef.args.text;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_objective_key : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        var objId = WeGameStateMgr.GetCurrentObjectiveId();
        var obj = weProtoDb.getInstance().getCurrentObjective(objId);
        var key = WeGameStateMgr.IsCompletedObjective() ? labelDef.args.completed_key : labelDef.args.key;
        if (labelDef.line_len !== undefined)
        {
            newDef.text = ConvertStringToMultipleLines(obj[key], labelDef.line_len) + "";
        }
        else
        {
            newDef.text = obj[key] + "";
        }
        
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },


    OnHandleTag_levelup_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        var level = WeGameStateMgr.mLotInfo.mLevel;
        var ProtoDB = weProtoDb.getInstance();

        var upgrade_text = "";
        var product_text = "";
        var object_text = "";	
        var full_text = "";

        var i = 0; 
        var line_len = labelDef.line_len;

        // Iterate products
        var upgrades = ProtoDB.getUpgradesForLevel( level );
        var upgrades_to_list = upgrades.length > 2 ? 2 : upgrades.length;
        if(level == 10 || upgrades.length > 0)
        {
            WeProtocol.getGifts(WeProtocol.getGiftsCallback);
		    WeProtocol.getGiftUsers(WeProtocol.getGiftUsersCallback);
            upgrade_text = "Upgrades:";
        }
        if(level == 10)
        {
            upgrade_text += "Gift Cart"
            if(upgrades_to_list > 0)
            {
                upgrade_text += ",";
            }
        }
        if (upgrades.length > 0)
        {
            for (i = 0; i < upgrades_to_list; i++ ) // hack - never allow more than 2 upgrades to show.
            {
                upgrade_text += " " + upgrades[i].proto_name;
                // skip adding a , for the last item in this list
                if ( i < upgrades_to_list - 1)
                {
                    upgrade_text += ",";
                }
            }
        }
        if(level == 10 || upgrades.length > 0)
        {
            upgrade_text += "\n";
        }
        var products = ProtoDB.getProductsForLevel( level );
        if (products.length > 0)
        {
            product_text = "Products:";
            for (i = 0; i < products.length; i++ )
            {
                product_text += " " + products[i].proto_name;
                // skip adding a , for the last item in this list
                if ( i < products.length - 1)
                {
                    product_text += ",";
                }
            }
            product_text += "\n";
        }

        // This is a little odd - none of these are setup properly in the DB - guessing this is just broken for now
        var all_objects = ProtoDB.getObjectsForLevel( level );
        var objects = PruneDuplicateProtoNames(all_objects);
        
        var objects_to_list_max = GameSpecificVariables.WeLabelFactory.objects_to_list_max;

        var objects_to_list = objects.length > objects_to_list_max ? objects_to_list_max : objects.length;
        if (objects.length > 0)
        {
            object_text = "Objects:";
            for (i = 0; i < objects_to_list; i++ )
            {
                object_text += " " + objects[i].proto_name;
                // skip adding a , for the last item in this list
                if ( i < objects_to_list - 1)
                {
                    object_text += ",";
                }
            }
			if (objects.length > objects_to_list_max)
			{
				object_text += " and more...\n";
			}
			else
			{
	            object_text += "\n";
			}
            object_text = ConvertStringToMultipleLines(object_text, line_len);
        }
        
        full_text = upgrade_text + product_text + object_text;
        full_text += "Rewards: " + ProtoDB.getMojoRewardForLevel( level ) + " "+GameSpecificVariables.Texts.mojoTextU;
        
        //TODO: update Mojo gui
        // redraw the lot
        // WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.entity.kingdom.kingdom);
        
        var farms = ProtoDB.getNewFarmsForLevel( level );
        if (farms > 0)
        {
			if (farms == 1) 
			{
            	full_text += " and " + farms + " " + GameSpecificVariables.WeLabelFactory.oneFactory;
			}
			else
			{
            	full_text += " and " + farms + " " + GameSpecificVariables.WeLabelFactory.moreFactories;
			}
        }
            
        newDef.text = full_text;
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_upgrade_item_button_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = "Locked";

        var status = weProtoDb.getInstance().canPurchaseUpgrade(args);
        if ( status == UpgradeStatus.kCanPurchase || status == UpgradeStatus.kCannotAfford )
        {
            newDef.text = "Buy";
        }
        else if ( status == UpgradeStatus.kAlreadyPurchased )
        {
            newDef.text = "Purchased";
        }
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },
    
    fpsCounter : 0 ,
    fpsAll : 0 ,
    fpsAvg : 0 ,

    OnHandleTag_profile_fps : function(labelDef, parent, args)
    {
        var label = null;
        self=this;

        label = this.CreateLabel(labelDef, parent, args, true);
        label.EnableUpdate( function(delta)
        {
            // cache off the last time
            var fps = 0; 
            if(delta !== 0)
            {
                fps = Math.floor(1000/delta);
            }
            
            self.fpsAll+=fps;
            self.fpsCounter+=1;
            if(self.fpsCounter>30)
            {
            	self.fpsAvg= self.fpsAll/self.fpsCounter;
            	self.fpsCounter=0;
            	self.fpsAll=0;
            }

            if(fps > gHighFPS)
            {
                gHighFPS = fps;
            }

            if(fps < gLowFPS)
            {
                gLowFPS = fps;
            }
            
            label.GetGL2().setText("current: "+fps+" avg "+ self.fpsAvg+" low: "+gLowFPS+" hi "+gHighFPS);
        });
        return label;
    },

    OnHandleTag_profile_build : function(labelDef, parent, args)
    {
        var label = null;
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = "S: " + gSDKBuild + "\nB: " + gServerBuild;

        label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },
/*
    OnHandleTag_status_message : function(labelDef, parent, args)
    {
        var label = null;
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = GetStatusMessage();

        label = this.CreateLabel(newDef, parent, args, true);
        label.EnableUpdate( function(delta)
        {
            var text = GetStatusMessage();
            if(text != label.GetGL2().getText())
            {
                label.GetGL2().setText(text);
            }
        });
        return label;
    },
*/
    OnHandleTag_status_message : function(labelDef, parent, args)
    {
        var label = null;
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = GetStatusMessage();
		// native text label
		if (NGWindow.document.loadingInfoView)
		{
			NGWindow.document.loadingInfoView.infoText.setText(newDef.text);
		}
		
		newDef.text = " ";
        label = this.CreateLabel(newDef, parent, args, true);
        // update status message
        label.EnableUpdate( function(delta)
        {
            var text = GetStatusMessage();
            if(NGWindow.document.loadingInfoView && text != NGWindow.document.loadingInfoView.infoText.getText())
            {
                NGWindow.document.loadingInfoView.infoText.setText(text);
            }
        
            //label.GetGL2().setText(text);
        });
        return label;
    },	 
    
    OnHandleTag_status_message_extended : function(labelDef, parent, args)
    {
    	
    	
    	var text = WeContentDownloader.GetLoadingText();
    	
    	var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = text;
		// native text label
		if (NGWindow.document.loadingInfoView)
		{
			NGWindow.document.loadingInfoView.infoTextExtended.setText(text);
		}
		
		if (!NGWindow.document.loadingWebView)
    	{
			NGWindow.document.loadingInfoView.infoTextExtended.setText("");
    	}
		
		newDef.text = " ";

		var label = null;
		
        label = this.CreateLabel(newDef, parent, args, true);
        // update status message
        label.EnableUpdate( function(delta)
        {
        	var text = WeContentDownloader.GetLoadingText();
        	
            if(NGWindow.document.loadingInfoView && text != NGWindow.document.loadingInfoView.infoTextExtended.getText())
           {
                NGWindow.document.loadingInfoView.infoTextExtended.setText(text);
            }
         
            if (!NGWindow.document.loadingWebView)
        	{
    			NGWindow.document.loadingInfoView.infoTextExtended.setText("");
        	}
        });
        return label;
    },
    
// ST: adding "animation" to status messages
	_addDots: function(text, dots)
	{
		for (var i=1; i<=dots; i++)
			text += '.';
		return text;
	},
	
    OnHandleTag_loading_dots : function(labelDef, parent, args)
    {
        var label = null;
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
        newDef.text = "";

        label = this.CreateLabel(newDef, parent, args, true);
        label.delta = 0;
        label.dots = 0;
        label._addDots = this._addDots;
        label.EnableUpdate( function(delta)
        {
        	//NgLogD ("$$$$$ Delta: "+delta);              	   
			label.delta += delta;
			if (label.delta > 1000)
			{
				label.delta %= 1000;
				label.dots = (label.dots+1)%4;
			}
			var text = ".";
			text = label._addDots(text, label.dots);
            if(text != label.GetGL2().getText())
            {
                label.GetGL2().setText(text);				
			}
        });
        return label;
    },
    
    OnHandleTag_social_page_nr : function(labelDef, parent, args)
    {
		var maxPage     = WeSocialMapMgr.getMapMaxPages();
		
		if (maxPage === 1)
			return null;
			
        var label = null;
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
        newDef.text = WeSocialMapMgr.getMapCurrentPage()+ " / " + WeSocialMapMgr.getMapMaxPages();

        label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },
    
    OnHandleTag_GiftShowScreen_info: function(imageDef, parent, args)
    {
    	if(args.gift)
    	{
    		var text= args.gift.gift_description.replace("{{GIFTER}}", args.gift.sender);
    		imageDef.text=text;
    		return this.OnHandleTag_GiftShowScreen_alpha(imageDef, parent, args);
    	}
    	return null;
    },
    
    OnHandleTag_levelup_info: function(imageDef, parent, args)
    {
    	return this.OnHandleTag_GiftShowScreen_alpha(imageDef, parent, args);
    },
    
    OnHandleTag_GiftShowScreenAll_sender: function(imageDef, parent, args)
    {
    	if(args.sender)
    	{
    		imageDef.text=args.sender;
    		return this.CreateLabel(imageDef, parent, args, true);
    	}
    	return null;
    },
    
    
    
    OnHandleTag_GiftShowScreenAll_info: function(imageDef, parent, args)
    {
    	if(args.gift_description)
    	{
    		var text= args.gift_description.substr(19);
    		imageDef.text=text;
    		return this.CreateLabel(imageDef, parent, args, true);
    	}
    	return null;
    	
    },
    
	OnHandleTag_GiftShowScreen_alpha: function(imageDef, parent, args)
	{
		var image = this.CreateLabel(imageDef, parent, args, true);
		
		var nWait=0;
		if(imageDef.args && imageDef.args.wait)
		{
			nWait=imageDef.args.wait;
		}
		var cTimer= new Timer(nWait, function()
	    {
	    	var cNumberAnimation= new NumberAnimation(1,  0.0, 1.0);

			cNumberAnimation.SetNumber=function(value)
		    {
				image.SetAlpha(value);
		    };
		    
		    image.Olddestroy=image.destroy;
		    image.destroy=function()
	        {
		    	cNumberAnimation.Stop();
	        	this.Olddestroy();
	        };
	    }
		);
	    return image;
	},
    
    OnHandleTag_error_title : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
        newDef.text = args.title;

        var label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },
    
    OnHandleTag_realm_level : function(labelDef, parent, args)
    {
    	if(args && args.page>=0)
    	{
    		WeRealms.SetPage(args.page);
    	}
    	
    	var sRealmName=labelDef.name;
    
    	var unlockUpgrade=WeRealms.GetUpgrade(sRealmName);
  	    if(!unlockUpgrade)
  	    {
  	    	return null;
  	    }
  	    var state=WeRealms.GetState(sRealmName);
  	    if(WeBoundary.RealmState.None==state)
  	    {
  	    	return null;
  	    }
		var kingdom = WeGameStateMgr.GetGameLotInfo();
		if( unlockUpgrade.requires_level > kingdom.mLevel )
		{
			labelDef.text = ""+unlockUpgrade.requires_level;
			return this.CreateLabel(labelDef, parent, args, true);
		}
    	
        return null;
    },

    OnHandleTag_error_message : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);

        newDef.text = args.message + "\nCode: " + args.code;

        var label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },

	OnHandleTag_store_stash_count : function(labelDef, parent, args)
	{
	    var localargs = args;
        var label = this.CreateLabel(labelDef, parent, args, true);
        label.GetGL2().setText(' ');
        var updateFunc = function(delta)
        {
            var count = weProtoDb.getInstance().getStoreItemStashCount(localargs);
    		if(count > 0)
    		{
    			label.GetGL2().setText('' + count);
    		}
        };
        label.EnableUpdate( updateFunc );
        updateFunc();
        
		return label;
	},
	
	OnHandleTag_copyright : function(labelDef, parent, args)
	{
		var text = new UI.Label();
		text.setFrame([labelDef.pos_x, labelDef.pos_y, labelDef.size_x, labelDef.size_y]);
		text.setText(labelDef.text);
		text.setTextSize(12);
		text.setTextColor(GameSpecificVariables.Colors.CopyrightTextColor);
		NGWindow.document.copyrightText = text;
		NGWindow.document.addChild(text);
		
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = ' ';
		label = this.CreateLabel(newDef, parent, args, true);

		// hacky hacky
    	label.Olddestroy=label.destroy;
	    label.destroy=function()
        {
	    	if(NGWindow.document.copyrightText)
			{
				NGWindow.document.removeChild(NGWindow.document.copyrightText);
            	NGWindow.document.copyrightText = null;
			}						
        	this.Olddestroy();
        }; 

		return label;				
	},

	OnHandleTag_goalunlocked_statement : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) && Exists(args.proto_goal.description))
		{
			newDef.text = args.proto_goal.description;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goalunlocked_teaser : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) && Exists(args.proto_goal.teaser_text))
		{
			newDef.text = args.proto_goal.teaser_text;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},	
	
	OnHandleTag_goalcomplete_title : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) && Exists(args.proto_goal.goal_name))
		{
			newDef.text = args.proto_goal.goal_name;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goalcomplete_text : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) && Exists(args.proto_goal.completion_text))
		{
			newDef.text = args.proto_goal.completion_text;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goalcomplete_xp : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) 
			&& Exists(args.proto_goal.reward_xp) && args.proto_goal.reward_xp != 0)
		{
			newDef.text = args.proto_goal.reward_xp.toString();
		}
        else if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal) 
			&& Exists(WeGoals.goalToShowDetail.proto_goal.reward_xp) && WeGoals.goalToShowDetail.proto_goal.reward_xp != 0)
        {
            newDef.text = WeGoals.goalToShowDetail.proto_goal.reward_xp.toString();
        }
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},	
	
	OnHandleTag_goalcomplete_coins : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) 
			&& Exists(args.proto_goal.reward_gold) && args.proto_goal.reward_gold != 0)
		{
			newDef.text = args.proto_goal.reward_gold.toString();
		}
        else if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal) 
			&& Exists(WeGoals.goalToShowDetail.proto_goal.reward_gold) && WeGoals.goalToShowDetail.proto_goal.reward_gold != 0)
        {
            newDef.text = WeGoals.goalToShowDetail.proto_goal.reward_gold.toString();
        }
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_news_label : function (labelDef, parent, args)
	{
		labelDef.text=gConfigs.NewsTabLabel;
		var label = this.CreateLabel(labelDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goalcomplete_mojo : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) 
			&& Exists(args.proto_goal.reward_mojo) && args.proto_goal.reward_mojo != 0)
		{
			newDef.text = args.proto_goal.reward_mojo.toString();
		}
        else if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal) 
			&& Exists(WeGoals.goalToShowDetail.proto_goal.reward_mojo) && WeGoals.goalToShowDetail.proto_goal.reward_mojo != 0)
        {
            newDef.text = WeGoals.goalToShowDetail.proto_goal.reward_mojo.toString();
        }
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},	
	
	OnHandleTag_task_item_title : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_task) && Exists(args.proto_task.description))
		{
			newDef.text = args.proto_task.description;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_task_item_progress : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_task))
		{
			newDef.text = args.current_count+' / '+args.proto_task.count;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_task_item_cost : function (labelDef, parent, args)
	{
		if(!WeGameStateMgr.IsCurrentUser())
			return null;

		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_task))
		{
			if (Exists(args.proto_task.boost_mojo_cost) && args.proto_task.boost_mojo_cost > 0
			&&	args.current_count < args.proto_task.count)
				newDef.text = args.proto_task.boost_mojo_cost;
			else newDef.text = ' ';
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goal_item_title : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.proto_goal) && Exists(args.proto_goal.goal_name))
		{
			newDef.text = args.proto_goal.goal_name;
		}
		
		// Make title in bold font if it is newly unlocked and not seen yet, or an event goal
		if ( (Exists(args) && (args.is_newly_unlocked && args.still_new)) || (args.proto_goal && args.proto_goal.goal_type == "event") )
		{
			newDef.weight = "bold";
		}

		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goal_item_date : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args) && Exists(args.active) && !args.active && Exists(args.time_completed))
		{
			//NgLogD ("Goal completed at: "+args.time_completed);
			var date = ConvertToDate(args.time_completed);
			newDef.text = (date.getUTCMonth()+1)+'/'+(date.getUTCDate())+'/'+date.getUTCFullYear();
		}
		else newDef.text = ' ';
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goals_detail_title : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal))
		{
			newDef.text = WeGoals.goalToShowDetail.proto_goal.goal_name;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_goals_detail_text : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(WeGoals.goalToShowDetail) && Exists(WeGoals.goalToShowDetail.proto_goal))
		{
			newDef.text = WeGoals.goalToShowDetail.proto_goal.description;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	/* Gifting code */
    OnHandleTag_gift_description : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists (WeGameStateMgr.mGifts) && Exists (WeGameStateMgr.mGifts[WeGameStateMgr.mCurrentGift]))
		{
			var gift = WeGameStateMgr.mGifts[WeGameStateMgr.mCurrentGift];
			if (gift.proto_gift_id != -1)
			{
				newDef.text = gift.gift_description.replace("{{GIFTER}}", gift.sender);
			}
			else
			{
        		newDef.text = "From "+ gift.sender;
        	}
        }
		else newDef.text = ' ';
        var label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },
    
    OnHandleTag_gift_boost_cost : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists (WeGameStateMgr.mGifts) && Exists (WeGameStateMgr.mGifts[WeGameStateMgr.mCurrentGift]))
		{
			var cost = WeGameStateMgr.mGifts[WeGameStateMgr.mCurrentGift].boost_cost;
        	newDef.text = cost > 0? cost.toString() : "0";
        }
        else newDef.text = ' ';

        var label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },
    
    OnHandleTag_no_event_goal_text : function(labelDef, parent, args)
	{
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);

		if (!WeGoals.isEventOn())  // no event is going on
		{
			if (Exists(gConfigs.EventDisabledGoalViewText))
        	{
				newDef.text = gConfigs.EventDisabledGoalViewText;
			}
		}
		else	// the event is going on but not available to the user yet because the the user does not reach the required level to unlock the first event goal
		{
			if (Exists( gConfigs.EventGoalNeedLevelUpToUnlockText))
			{
				newDef.text =  gConfigs.EventGoalNeedLevelUpToUnlockText;
			}
			else
			{
				newDef.text = "Play more and get to level %d to unlock the event!";	// default value from wiki
			}
			newDef.text = newDef.text.replace( "%d", WeGoals.getRequiredLevelToUnlockEventGoal() );
		}
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;		
	},

    OnHandleTag_event_main_goal_reward_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var goal = WeGoals.goalToShowDetail;
		if (goal && goal.proto_goal && !WeGoals.isGoalCurrentEventGoal(goal))	// the goal is for the previous event, should show text version
		{
       		newDef.text = "Reward:";
		}
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_event_main_goal_title_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var goal = WeGoals.goalToShowDetail;
		if (goal && goal.proto_goal && !WeGoals.isGoalCurrentEventGoal(goal))	// the goal is for the previous event, should show text version
		{
       		newDef.text = goal.proto_goal.goal_name;
		}
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_event_main_goal_description_text : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var goal = WeGoals.goalToShowDetail;
		if (goal && goal.proto_goal && !WeGoals.isGoalCurrentEventGoal(goal))	// the goal is for the previous event, should show text version
		{
       		newDef.text = goal.proto_goal.description;
		}
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_event_days_left : function(labelDef, parent, args)
    {
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (WeGoals.isGoalCurrentEventGoal(WeGoals.goalToShowDetail))
		{
       		newDef.text = WeGameStateMgr.mEventDaysLeft;
		}
        var label = this.CreateLabel(newDef, parent, args, true); 
        return label;
    },

    OnHandleTag_event_days_left_onwebview: function(labelDef, parent, args)
	{
		var text = new UI.Label();
		text.setFrame([labelDef.pos_x, labelDef.pos_y, labelDef.size_x, labelDef.size_y]);
		text.setText(WeGameStateMgr.mEventDaysLeft);
		text.setTextSize(12);
		text.setTextColor("FFFF0000");
		NGWindow.document.daysText = text;
		NGWindow.document.addChild(text);
		
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = ' ';
		label = this.CreateLabel(newDef, parent, args, true);

		// hacky hacky
    	label.Olddestroy=label.destroy;
	    label.destroy=function()
        {
	    	if(NGWindow.document.daysText)
			{
				NGWindow.document.removeChild(NGWindow.document.daysText);
            	NGWindow.document.daysText = null;
			}						
        	this.Olddestroy();
        };	
        
        return label;
	},
	
    OnHandleTag_capturing_error : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        label.SetVisible(false);
        WeUiMgr.m_cCaptureScreen.capturing_error=label;
        return label;
    },
    
    OnHandleTag_capturing_fail1 : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        label.SetVisible(false);
        WeUiMgr.m_cCaptureScreen.capturing_fail1=label;
        return label;
    },
    
    OnHandleTag_capturing_fail2 : function(labelDef, parent, args)
    {
        var label = this.CreateLabel(labelDef, parent, args, true);
        label.SetVisible(false);
        WeUiMgr.m_cCaptureScreen.capturing_fail2=label;
        return label;
    },
    
    OnHandleTag_capture_user_name : function(labelDef, parent, args)
    {
    	labelDef.text = args.user;
        return this.CreateLabel(labelDef, parent, args, true);
    },
    
    OnHandleTag_gift_user_name : function(labelDef, parent, args)
    {
    	NgLogD("<<<!>>> OnHandleTag_gift_user_name start");
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		
		if (Exists(args))
        	newDef.text = args;

        var label = this.CreateLabel(newDef, parent, args, true);
        return label;
    },
    /* End gifting code */
    
    OnHandleTag_task_toast_goal : function(labelDef, parent, args)
    {
        labelDef.text = args.goalName;
        var label = this.CreateLabel(labelDef, parent, args, true);
        return label;
    },
    
    OnHandleTag_user_item_name : function(labelDef, parent, args)
    {
        labelDef.text = args.name;
        var label = this.CreateLabel(labelDef, parent, args, true);
        return label;
    },

    OnHandleTag_task_toast_task : function(labelDef, parent, args)
    {
        labelDef.text = args.taskName;
        var label = this.CreateLabel(labelDef, parent, args, true);
        return label;
    },

	OnHandleTag_pest_name : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args))
		{
			newDef.text = args.pest_name;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},

	OnHandleTag_pest_badge : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (Exists(args))
		{
			newDef.text = args.count+' / '+args.total;
		}
		
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_collection_points_value_text : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = args.points_value;
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_collection_count_text : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = args.progress;
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_collection_name_text : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = args.name;
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_collection_subname_text : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		if (args.name == "???")
			newDef.text = "";
		else
			newDef.text = "Gnome";
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},

	OnHandleTag_event_collection_name : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var viewing_collection = WeEventGame.currentViewingCollection;
		var db = WeEventGame.getGameEventCollectionWithProtoId(viewing_collection);
		newDef.text = db.name;
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_event_collection_reward_total : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var viewing_collection = WeEventGame.currentViewingCollection;
		var db = WeEventGame.getGameEventCollectionWithProtoId(viewing_collection);
		newDef.text = db.point_value;
		var label = this.CreateLabel(newDef, parent, args, true);
        return label;
	},
	
	OnHandleTag_event_item_name : function (labelDef, parent, args)
	{
		var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = WeEventGame.getEventItemName();
		var label = this.CreateLabel(newDef, parent, args, true);
    	return label;
	},
	
	OnHandleTag_event_item_acquired_count : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
        var updateFunc = function(delta)
        {
            var acquired = '' + WeEventGame.getAcquiredEventItemsCount();
            if(label.GetGL2().getText() != acquired)
            {
                label.GetGL2().setText(acquired);
            }
        };
        label.EnableUpdate( updateFunc );
        updateFunc();
        return label;
	},
	
	OnHandleTag_spinner_left_collection_name : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		WeEventSpinner.mCollectionNameLabel = label;
		WeEventSpinner.showCurrentCollectionName();
        return label;
	},

	OnHandleTag_display_event_points : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		WeEventGame.mEventPointsLabel = label;
		WeEventGame.showEventPoints();
        return label;
	},

	OnHandleTag_point_loot : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		WeEventSpinner.mPointLootLabel = label;	// only used for showing a point loot's read (on the 2nd slot)
        label.SetVisible(false);
        return label;
	},
	
	OnHandleTag_loot_item_value : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		WeEventSpinner.mLootItemValue = label;	// only used for showing the count of points that a user spinned from the spinner
        label.SetVisible(false);
        return label;
	},
	
	OnHandleTag_loot_item_earned_points : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		WeEventSpinner.mLootItemEarnedPointsLabelDef = labelDef;
		WeEventSpinner.mLootItemEarnedPointsLabel = label;	// show the flyoff of the earned points from the loot item
		if (!WeEventSpinner.mLootItemEarnedPointsPos)	/* only init once */
		{
			WeEventSpinner.mLootItemEarnedPointsPos = ObjectUtils.GetCloneOfObject(label.GetGL2().getPosition());
		}
        label.SetVisible(false);
        return label;
	},
	
	OnHandleTag_loot_item_multiplier : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		WeEventSpinner.mLootItemMultiplier = label;
        return label;
	},
	
	OnHandleTag_boost_spin_mojo_cost : function (labelDef, parent, args)
	{
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		newDef.text = "" + WeEventSpinner.getBoostCost();
		var label = this.CreateLabel(newDef, parent, args, true);
		WeEventSpinner.mBoostSpinMojoCost = label;
        return label;
	},

	OnHandleTag_spin_hint_text : function (labelDef, parent, args)
	{
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var label = this.CreateLabel(newDef, parent, args, true);
		WeEventGame.mSpinHintLabel[labelDef.index] = label;
		WeEventGame.setSpinHintLabel();
        return label;
	},

	OnHandleTag_event_collection_status : function (labelDef, parent, args)
	{
        var newDef = ObjectUtils.GetCloneOfObject(labelDef);
		var label = this.CreateLabel(newDef, parent, args, true);
		if (!WeEventGame.mCollectionStatusLabel)
		{
			WeEventGame.mCollectionStatusLabel = [];
		}
		WeEventGame.mCollectionStatusLabel[labelDef.index] = label;
		WeEventGame.showCollectionStatus();
        return label;
	},

	OnHandleTag_event_share_count : function (labelDef, parent, args)
	{
		var label = this.CreateLabel(labelDef, parent, args, true);
		var updateFunc = function(delta)
        {
            var points = '' + WeEventGame.mShareCount;
            if(label.GetGL2().getText() != points)
            {
                label.GetGL2().setText(points);
            }
        };
        label.EnableUpdate( updateFunc );
        updateFunc();
        return label;
	}
	
});

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeNode2D'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeNode2D'] || {}; $MODULE_REGISTRY['weEngine/WeNode2D'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-23
 *  @file:      WeNode2D.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;

exports.WeNode2D = Core.MessageListener.subclass(
{
	classname: 'WeNode2D',
	
    initialize : function(parent)
    {
        this.mNodeGL2 = new GL2.Node();
        this.parent = parent || GL2.Root;
        this.parent.addChild(this.mNodeGL2);
        this.mNodeGL2.owner = this;
        this.updating = false;
        
        this.node2d_exit_routines = [];
        
        //REMOVE for debug porpuses
        this.node2d_exit_routinesCalled = [];
    },
    test : function(variable)
    {
    	NgLogD("*** In TEST *** "+ variable);
    	
    },
    destroy : function()
    {	    
    	//exit routines implementation
    	//NgLogD("########### WeNode2D.destroy " + this.toString());
    	
    	//objDump(this.node2d_exit_routines);
    	if (Exists(this.node2d_exit_routines))
    	{
	    	for (var i in this.node2d_exit_routines)
	    	{
	    		//REMOVE
	    		if(this.node2d_exit_routinesCalled[i])
	    		{
	    			NgLogD("recursive call to destroy");
	    			printStack();
	    		}
	    		this.node2d_exit_routinesCalled[i]=true;
	    		
	    		
	    		this.node2d_exit_routines[i]();
	    		//NgLogD("########### WeNode2D.destroy handle #### i:"+  this.node2d_exit_routines[i]);
	    	}
	    	this.node2d_exit_routines = null;
    	}
    	
        if (Exists(this.mNodeGL2))
        {    	
            this.mNodeGL2.destroy();
            delete this.mNodeGL2;
            this.mNodeGL2=null;
        }
        
        if (this.updating)
        {
            Core.UpdateEmitter.removeListener(this);
            this.updating = false;
        }
    },
  //exit routines implementation
    OnExit : function (handle)
    {
        if(Exists(this.node2d_exit_routines) && handle)
        {
    		this.node2d_exit_routines.push(handle);
    		
    		//REMOVE
    		this.node2d_exit_routinesCalled.push(false);
        }
    },
    EnableUpdate : function(cb)
    {
        if (this.updating)
        {
            Core.UpdateEmitter.removeListener(this);
        }
        this.updating = true;
        Core.UpdateEmitter.addListener(this, cb);
    },

    GetGL2 : function()
    {
        return this.mNodeGL2;
    },
    
    GetX: function()
    {
        return this.mNodeGL2.getPosition().getX();
    },
    
    GetY: function()
    {
        return this.mNodeGL2.getPosition().getY();
    },
    
    GetWidth: function()
    {
        return this.xWidth;
    },
    
    GetHeight: function()
    {
        return this.xHeight;
    },
    
    setScale: function(scale)
    {
       this.mNodeGL2.setScale(scale, scale);
    },
    
    getScale: function()
    {
       return this.mNodeGL2.getScale().getX();
    },
    
    SetVisible: function(value)
    {    	
    	this.mNodeGL2.setVisible(value);
    },
    
    GetVisible: function()
    {
    	return this.mNodeGL2.getVisible();
    },
    
    setAlpha: function(alpha)
    {
       this.mNodeGL2.setAlpha(alpha);
    },
    
    SetAlpha: function(alpha)
    {
       this.mNodeGL2.setAlpha(alpha);
    },
    
    SetPosition : function(x, y, z)
    {
        if(!Exists(this.mNodeGL2))
        {
            return;
        }
        this.mNodeGL2.setPosition(x, y);
        if (Exists(z))
        {
            this.mNodeGL2.setDepth(z || 0);
        }
    },
    
    setPosition : function(x, y, z)
    {
        if(!Exists(this.mNodeGL2))
        {
            return;
        }
        this.mNodeGL2.setPosition(x, y);
        if (Exists(z))
        {
            this.mNodeGL2.setDepth(z || 0);
        }
    }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeBoundaries'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeBoundaries'] || {}; $MODULE_REGISTRY['weEngine/WeBoundaries'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeBoundaries.js
/// @author:    mpatel@ngmococ.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     
//////////////////////////////////////////////////////////////////////////////

var WeBoundary = require('weEngine/WeBoundary').WeBoundary;

exports.WeBoundaries = Core.Class.subclass(
{
	classname: "WeBoundaries",
	
	initialize : function(parent, size)
    {
		var kingdom = WeGameStateMgr.GetGameLotInfo();
		if (kingdom != null)
		{
			this.mInit = true;
			this.mParent = parent;

			// The sibling realms
			this.NorthBoundary = new WeBoundary(parent, 'north', size, WeBoundary.RealmType.North, this.getRealmState(kingdom, WeBoundary.RealmType.North) );
			parent.addChild ( this.NorthBoundary.getNode() );

			this.SouthBoundary = new WeBoundary(parent, 'south', size, WeBoundary.RealmType.South, this.getRealmState(kingdom, WeBoundary.RealmType.South)  );
			parent.addChild ( this.SouthBoundary.getNode() );

			this.EastBoundary = new WeBoundary(parent, 'east', size, WeBoundary.RealmType.East, this.getRealmState(kingdom, WeBoundary.RealmType.East)  );
			parent.addChild ( this.EastBoundary.getNode() );

			this.WestBoundary = new WeBoundary(parent, 'west', size, WeBoundary.RealmType.West, this.getRealmState(kingdom, WeBoundary.RealmType.West)  );
			parent.addChild ( this.WestBoundary.getNode() );

			// closed corner lots
			this.NorthEastBoundary = new WeBoundary(parent, 'northeast', size, WeBoundary.RealmType.NorthEast, this.getRealmState(kingdom, WeBoundary.RealmType.NorthEast)  );
			parent.addChild ( this.NorthEastBoundary.getNode() );

			this.NorthWestBoundary = new WeBoundary(parent, 'northwest', size, WeBoundary.RealmType.NorthWest, this.getRealmState(kingdom, WeBoundary.RealmType.NorthWest)  );
			parent.addChild ( this.NorthWestBoundary.getNode() );

			this.SouthEastBoundary = new WeBoundary(parent, 'southeast', size, WeBoundary.RealmType.SouthEast, this.getRealmState(kingdom, WeBoundary.RealmType.SouthEast)  );
			parent.addChild ( this.SouthEastBoundary.getNode() );

			this.SouthWestBoundary = new WeBoundary(parent, 'southwest', size, WeBoundary.RealmType.SouthWest, this.getRealmState(kingdom, WeBoundary.RealmType.SouthWest)  );
			parent.addChild ( this.SouthWestBoundary.getNode() );
		}
	},
	
	destroy : function()
	{
		if (this.mInit && this.mParent)
		{
			this.mParent.removeChild ( this.SouthBoundary.getNode() );
			this.SouthBoundary.destroy();

			this.mParent.removeChild ( this.NorthBoundary.getNode() );
			this.NorthBoundary.destroy();

			this.mParent.removeChild ( this.EastBoundary.getNode() );
			this.EastBoundary.destroy();

			this.mParent.removeChild ( this.WestBoundary.getNode() );
			this.WestBoundary.destroy();

			this.mParent.removeChild ( this.NorthEastBoundary.getNode() );
			this.NorthEastBoundary.destroy();

			this.mParent.removeChild ( this.NorthWestBoundary.getNode() );
			this.NorthWestBoundary.destroy();

			this.mParent.removeChild ( this.SouthEastBoundary.getNode() );
			this.SouthEastBoundary.destroy();

			this.mParent.removeChild ( this.SouthWestBoundary.getNode() );
			this.SouthWestBoundary.destroy();

			this.mInit = false;
			this.mParent = null;
		}
	},
	
	getRealmState : function(kingdom, lot_type)
	{
	    var current_kingdom_type = kingdom.kingdom_type;
	    var all_kingdoms = kingdom.all_kingdoms;
	    var len = 0;
	    if (Exists(all_kingdoms))
	    {
	        len = all_kingdoms.length;
	    }

		switch (current_kingdom_type)
		{
		case "main":
			// check to see if this sub-lot been purchased
		    for(var idx = 0; idx < len; ++idx)
		    {
		        if( all_kingdoms[idx].kingdom_type == lot_type.name)
		        {   
		            return WeBoundary.RealmState.PurchasedLot;
		        }
		    }

			// check to see if this level CAN be purchased (due to level)
			if (kingdom.mLevel >= lot_type.req_level)
			{
				return WeBoundary.RealmState.UnpurchasedLot;
			}
			break;
		case "north":
			return lot_type == WeBoundary.RealmType.South ? WeBoundary.RealmState.MainLot : WeBoundary.RealmState.ClosedLot;
		case "south":
			return lot_type == WeBoundary.RealmType.North ? WeBoundary.RealmState.MainLot : WeBoundary.RealmState.ClosedLot;
		case "east":
			return lot_type == WeBoundary.RealmType.West ? WeBoundary.RealmState.MainLot : WeBoundary.RealmState.ClosedLot;
		case "west":
			return lot_type == WeBoundary.RealmType.East ? WeBoundary.RealmState.MainLot : WeBoundary.RealmState.ClosedLot;
		default:
			return WeBoundary.RealmState.ClosedLot;
		}
		return WeBoundary.RealmState.LockedLot;
	}
});

/*

// This is a bit of a work-around. On the Android phones at this point
// hooking up native touches to a group like this just doesn't work.
// Instead we have the 2d primitive send over its native touch event
WeBoundaries.prototype.onTouchFromPrimitive = function (touch)
{
	NgLogD("Got a touch:" + touch.mX + "," + touch.mY);
	if (WeUiMgr.Instance().GetActiveScreen() != "InGameScreen")
    {
        return false;
    }
    
	// manages hit tests for all the boundaries
	var NorthHitTest = this.NorthBoundary.hitTest(touch);
	var SouthHitTest = this.SouthBoundary.hitTest(touch);
	var EastHitTest = this.EastBoundary.hitTest(touch);
	var WestHitTest = this.WestBoundary.hitTest(touch);
	
	//NgLogD("North:" + NorthHitTest + " South:" + SouthHitTest + " East:" + EastHitTest + "West:" + WestHitTest);
	
	// If we've gotten an odd number of negative 1's - that indicates a valid hit
	if ((NorthHitTest * SouthHitTest * EastHitTest * WestHitTest) < 0)
	{
		if (NorthHitTest > 0)
		{
			this.NorthBoundary.onHit(touch);
		}
		else if (SouthHitTest > 0)
		{
			this.SouthBoundary.onHit(touch);
		}
		else if (EastHitTest > 0)
		{
			this.EastBoundary.onHit(touch);
		}
		else if (WestHitTest > 0)
		{
			this.WestBoundary.onHit(touch);
		}
	}
	return true;
};

*/
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeProtocol'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeProtocol'] || {}; $MODULE_REGISTRY['weEngine/WeProtocol'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-21
 *  @file:      WeProtocol.js
 *  @author:    Chris Jimison
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;
var Network = require('NGCore/Client/Network').Network;
var WeEventGame = require('weEngine/WeEventGame').WeEventGame;

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : WeProtocol
 * @brief: $DESCRIPTION
 */
exports.WeProtocol = Core.Class.singleton(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize : function()
    {
    },

    Setup : function(root, token, secret, variant, version)
    {
    	var name = Core.Capabilities.getPlatformOS();
        if( name == "Android")
        {
            this.proxyRoot = "";///proxy/";
        }
        else
        {
            this.proxyRoot = "";///proxy/";
        }
        
        this.root = root;
        this.token = token;     // Plus+ user
        this.secret = secret;       // Plus+ pass
        this.variant = variant;
        this.version = version;
        
        // currently internal members.
        this.userName = gCurKingdomUser; // Game user... can be different than Plus+ user.
    },

    kVerbGet : "GET",

    kVerbPost : "POST",

    kVerbPut : "PUT",

    doRequest : function ( verb, url, headers, payload, cb, skipXwwwHeader )
    {
        NgLogD("***************** Doing a test verb = " + verb + " url = " + url + " payload = " + payload);
        var request;
        request = new Network.XHR();
        
        request.onreadystatechange = function ()
        {
            try 
            {
                if ( this.readyState == 4 )
                {
					/*
					I took it from iOS version, then status is equal to 426 or 418 alert
					is presented that app/contetnt is updated. User must relaunch app to
					download new conten/app.
					*/
					//if (this.respHeaders.status == ResponseCode.RCCRequiredUpdate || this.respHeaders.status ==  ResponseCode.RCRequiredClientUpdate)
					if(this.status == ResponseCode.RCCRequiredUpdate || this.status == ResponseCode.RCCRequiredClientUpdate)
					{
						WeUiMgr.ShowAlertPopUp('New content available', 'Please re-launch the application', function(){RestartGame();});
					}
					else
					{
						//printFull (request.responseText, 120);
						//objDumpMembers(request);
						//NgLogD("### convert to json");
						var obj;
						try
				        {
				       	    obj = JSON.parse(request.responseText);
				       	    //fullRecurseDump(obj, 4);
						}
				        catch(ex)
				        {
				            NgLogD("Issue parsing server response into JSON");
				            NgLogD("Request status:" + request.statusText);
				            NgLogD("Request response:" + request.responseText);
				           // WeUiMgr.ShowNetworkErrorPopUp();
				        }
				        //NgLogD("### convert to finsih json");
						if (cb)
						{
					        cb ( this, obj );
							if (Exists(obj))
							{
								WeProtocol.findMessages(obj, this);
								WeProtocol.findAlert(obj, this);		
							}
						}
						else
						{
							NgLogD("No callback to process the object: " + JSON.stringify(obj));
						}
					}
                }
                else if(request.readyState === 0)
                {
                    //ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
                    WeUiMgr.ShowNetworkErrorPopUp();
                }
            }
            catch ( ex )
            {
                NgLogException ( ex );
                //ExitOnError(gErrors.SERVER_MESSAGE_REJECTED_CRITICAL);
                WeUiMgr.ShowNetworkErrorPopUp();
            }
        };

        request.open ( verb, url, true );
        if ( headers )
        {
            for(var h in headers)
            {
                if(headers.hasOwnProperity(h))
                {
                    request.setRequestHeader ( h, headers[ h ] );
                }
            }
        }
        
        //var userAgent = "Kingdoms-Android-Dev/1.50 PlusPlus/1.0";
    	//request.setRequestHeader("User-Agent", userAgent);
      
		request.setRequestHeader("User-Agent", "RaudonasDrambliukas/" + GameInfo.appVersion);
		
		request.setRequestHeader("x-kingdoms-version", "" + GameInfo.appVersion);

		if(gConfigs && gConfigs["ProtoDataVersion"])
			request.setRequestHeader("X-Proto-Data-Version", gConfigs["ProtoDataVersion"]);

        if ( verb == "POST" || verb == "PUT")
        {
            // We rule server chokes on this content-type.
           
			//if ((typeof skipXwwwHeader == 'undefined') || (skipXwwwHeader !== true)) {
				// This header confuses Kingdoms server for certain requests.
				// Therefore, it is skipped if requested by caller
            //	request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
			//}
        	if(skipXwwwHeader==undefined || skipXwwwHeader === true)
        	{
        		request.setRequestHeader ( "Accept", "application/json");
        		request.setRequestHeader ( "Content-Type", "application/json");
        		request.send ( payload );
        	}
        	else if(skipXwwwHeader === false)
        	{
        		request.setRequestHeader ( "Content-type", "application/x-www-form-urlencoded");
        		request.setRequestHeader("Content-length", payload.length);
        		request.send ( payload );       		
        	}
        }
        else
        {
            request.send ( null );
        }
    },
    
    findAlert : function (obj, request)
    {
        var title = "";
        var message = "";
        
        if 	(Exists(obj.interstitial_params) && Exists(obj.interstitial_params.alert))
		{
		    title = obj.interstitial_params.alert.alert_title;
		    message = obj.interstitial_params.alert.alert_message;
		}
		
		if 	(Exists(obj.messages) && Exists(obj.messages.alert))
		{
		    title = obj.messages.alert.alert_title;
		    message = obj.messages.alert.alert_message;
		}
		
		if 	(Exists(obj) && Exists(obj.alert))
		{
		    title = obj.alert.alert_title;
		    message = obj.alert.alert_message;
		}
		
		if 	(Exists(obj.kingdom) && Exists(obj.kingdom.messages) && Exists(obj.kingdom.messages.alert))
		{
		    title = obj.kingdom.messages.alert.alert_title;
		    message = obj.kingdom.messages.alert.alert_message;
		}
		
		if 	(Exists(obj.alert_message))
		{
		    message = obj.alert_message;
		}
		
		if 	(Exists(obj.alert_title))
		{
		    title = obj.alert_title;
		}
		
		if (Exists(title) && title.length > 0 || Exists(message) && message.length > 0)
		{
		    WeUiMgr.ShowAlertPopUp(title, message);
	    }
    },
    
	findMessages : function (obj, request)
	{
		//NgLogD("#### OBJECT: ####");
		//objDump(obj);
		//NgLogD("####  END    ####");		
		var messages = [];
		if 		(Exists(obj.messages)) 										messages.push(obj.messages);
		/*else*/ if (Exists(obj.kingdom) && Exists(obj.kingdom.messages)) 	messages.push(obj.kingdom.messages);
		/*else*/ if (Exists(obj.entity) && Exists(obj.entity.messages)) 	messages.push(obj.entity.messages);
		/*else*/ if (Exists(obj.upgrade) && Exists(obj.upgrade.messages)) 	messages.push(obj.upgrade.messages);
		/*else*/ if (Exists(obj.job) && Exists(obj.job.messages)) 			messages.push(obj.job.messages);
		/*else*/ if (Exists(obj.completed_objective) && Exists(obj.completed_objective.messages))
																			messages.push(obj.completed_objective.messages);
																			
																			
        if (Exists(obj.interstitial_params) && Exists(obj.interstitial_params.command))
        {
            var command = obj.interstitial_params.command;
            NgLogD("### INTERSTITIAL COMMAND " + command);
            WeGameStateMgr.mInterstitialCommand = command;
        }
        
        if (Exists(obj.messages) && Exists(obj.messages.command))
        {
            var command = obj.messages.command;
            NgLogD("### APP COMMAND " + command);
            WeGameStateMgr.mInterstitialCommand = command;
        }
                                                                      		 
		for (var i in messages)
		{
			this.handleMessages(messages[i], request);	
		}
	},

	handleMessages : function (obj, request)
	{
		//NgLogD("#### MESSAGES: ####");
		//objDump(obj);
		//NgLogD("####    END    ####");
		
		// actual handler
		// it may be delayed by collection bubble
		var handler = function (obj)
		{
			if (Exists(obj.goals))
			{
				WeGoals.handleGoals(obj.goals);
			}
			var goal_id = obj.main_event_goal_proto_id;
			if(goal_id)
				gConfigs.MainEventGoalProtoId = goal_id;
				
			if (Exists(obj.pests) && !WeGameStateMgr.IsCurrentUser())
			{
				WePests.handlePests(obj.pests);
			}
			
			if (Exists(obj.event_webview))
			{
				WeEventGame.showEventWebview(obj.event_webview);
			}

			if (Exists(obj.event))
			{
			    WeEventGame.handleEventData(obj.event);
			}
			
			if (Exists(obj.event_items))
			{
			    WeEventGame.handleEventItems(obj.event_items);
			}
		};
//*****//		
		// check and register handler with relevant collection bubble, if applicable
		var list = WeGameStateMgr.mCollectionBubbleList;
		for (var j in list)
		{
			if (Exists(list[j].xRequest) && request === list[j].xRequest)
			{
				list[j].notify = handler;
				list[j].notifyArgs = obj;
				return;
			}
		}
//******//
		// otherwise: handle messages now
		handler(obj);
	},

    makeDataUrl : function( verb, request )
    {
        return this.proxyRoot + this.root + "/" + this.variant + "Data" + this.version + "/" + request;
    },

    makeAppUrl : function( verb, request )
    {
        var ext = "";
        if( Core.Capabilities.getPlatformOS() == "Android" || 
            Core.Capabilities.getPlatformOS() == "iPhone OS")
        {
            ext = "";
        }
        else
        {
            ext = ".json";
        }
        
        return this.proxyRoot + this.root + request + "&app_name=" + this.variant + ext;
    },

    getPatcherToc : function(cb)
    {
        var url = this.makeDataUrl( this.kVerbGet, "patcher.toc" );
        this.doRequest( this.kVerbGet, url, null, null, cb );
    },

    getProtoConfigs : function(cb)
    {
        var url = this.makeAppUrl( "GET", "/proto_configs?" );
        
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },
    
	doHttpEncode: function(string)
	{
		var result = '';
		for (var i=0; i<string.length; i++)
		{
			result += '%' + parseInt(string.charCodeAt(i)).toString(16);
		}
		return result;
	},
	
	postWakeUp : function (cb)
	{
	    var platform = Core.Capabilities.getDeviceName();
        
        if (gEnableAndroidDualMana && Core.Capabilities.getPlatformOS() != "iPhone OS")
        {   
            // flash and android will set android platform for now.
            platform = "android";
        }   
		//HACK: ST: converting username to percent-encoded string to please XHR
		var userName = this.userName;
		var secret = this.secret;		
		
		NgLogD("fastappswitch user:"+userName );
		
		userName = this.doHttpEncode(userName);
		
	    var url;
        var payload;
        var ext = "";
        if( Core.Capabilities.getPlatformOS() == "Android" ||
            Core.Capabilities.getPlatformOS() == "iPhone OS")
        {
            var uid = Social.US.Session.getCurrentSession().user().recordID; 
            var session_id = Core.Analytics._getPipe().getMeta().sid;
            var unique_id = Core.Capabilities.getUniqueId();
            ext = "";
            url = this.proxyRoot + this.root + "/login/fast_app_switch_in?";

            payload =   "token=" + this.token + "&secret=" + secret + 
                        "&user_name=" + userName + "&user_login=" + 
                        userName + "&platform="+platform + "&app_name=" + this.variant + "&uid=" + uid + "&session_id=" + session_id + "&udid=" + unique_id;

        }
        else
        {
            ext = ".json";
            url = this.makeAppUrl(  "POST", "/login/fast_app_switch_in?token=" + this.token + 
                                    "&secret=" + secret + "&user_name=" + userName + 
                                    "&user_login=" + userName + "&platform="+platform+"&" );
            payload = null;
        }
        
        this.doRequest( this.kVerbPost, url, null, payload, cb);
	},

    postSessions : function( cb )
    {
    	/*
    	var url = this.makeAppUrl(this.kVerbGet, "/mobage/auth?platform=android&token="+this.token+"&secret="+this.secret+"&");
		this.doRequest(this.kVerbGet, url, null, null, function(request)
		{
			cb(request);
		}, true);
		
		return;
    	*/
    	
    	
        var platform = Core.Capabilities.getDeviceName();
        
        if (gEnableAndroidDualMana && Core.Capabilities.getPlatformOS() != "iPhone OS")
        {   
            // flash and android will set android platform for now.
            platform = "android";
        }   
		//HACK: ST: converting username to percent-encoded string to please XHR
		var userName = this.userName;
		var secret = this.secret;		
		
		NgLogD("postSessions user:"+userName );
		
		userName = this.doHttpEncode(userName);

        NgLogD("******* Posting the session");
        var url;
        var payload;
        var ext = "";
        if( Core.Capabilities.getPlatformOS() == "Android" ||
            Core.Capabilities.getPlatformOS() == "iPhone OS")
        {
            var uid = Social.US.Session.getCurrentSession().user().recordID; 
            var session_id = Core.Analytics._getPipe().getMeta().sid;
            var unique_id = Core.Capabilities.getUniqueId();
            //unique_id = "354494040441948";
            ext = "";
            url = this.proxyRoot + this.root + "/login/create_session?";

            payload =   "token=" + this.token + "&secret=" + secret + 
                        "&user_name=" + userName + "&user_login=" + 
                        userName + "&platform="+platform + "&app_name=" + this.variant + "&uid=" + uid + "&session_id=" + session_id + "&udid=" + unique_id;

        }
        else
        {
            ext = ".json";
            url = this.makeAppUrl(  "POST", "/login/create_session?token=" + this.token + 
                                    "&secret=" + secret + "&user_name=" + userName + 
                                    "&user_login=" + userName + "&platform="+platform+"&" );
            payload = null;
        }
        
        this.doRequest( this.kVerbPost, url, null, payload, cb);
    },

    getScreenDef : function(file, cb)
    {
        ext = "";
        NgLogD(this.proxyRoot+'---'+this.root+'---'+file);
        url = this.proxyRoot + this.root + file;
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },

    getProtoDb : function( cb )
    {
        var url = this.makeAppUrl( this.kVerbGet, "/login/proto_database?user_name=" + this.userName);
        this.doRequest( this.kVerbGet, url, null, null, cb, false);
    },
    
    getProtoDbList : function(cb)
    {
        var url = this.makeAppUrl( this.kVerbGet, "/proto_database?user_name=" + this.userName );
        this.doRequest( this.kVerbGet, url, null, null, cb, false);
    },
    
    getProtoDbTable : function( table, cb )
    {
        var url = this.makeAppUrl( this.kVerbGet, "/proto_database?user_name=" + this.userName + "&table=" + table );
        this.doRequest( this.kVerbGet, url, null, null, cb, false);
    },

    getSocialMaps : function( page,  cb )
    {
        var url = this.makeAppUrl( this.kVerbGet, "/social_maps?page="+page+"&skip_neighbor_refresh=0&" );
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },
    
    getCommunityMaps : function( page,  cb )
    {
        var url = this.makeAppUrl( "GET", "/social_maps/community_map?page="+page+"&skip_neighbor_refresh=0&" );
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },

    getMtxProducts : function( cb )
    {
        var url = this.makeAppUrl( this.kVerbGet, "/mtx_products?" );
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },

    getHeartbeat : function( cb )
    {
        var url = this.makeAppUrl( "GET", "/heartbeat?" );
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },

    getKingdom : function( id, cb )
    {
        var url = this.makeAppUrl( "GET", "/kingdom/" + id + "?include_entities=1&" );
        this.doRequest( this.kVerbGet, url, null, null, function(request)
        {
            cb(request);
			this.getStash();
        }.bind(this));
    },

    getKingdomByName : function( name, cb )
    {
        var url = this.makeAppUrl( "GET", "/kingdom?user=" + name + "&include_entities=1&" );
        this.doRequest( this.kVerbGet, url, null, null, function(request)
        {
        	//NgLogD("######## RESPONSE: ########");
        	//objDump(request);
        	//NgLogD("---------------------------");
        	//if (Exists(request.responseText))
        	//	objDump(request.responseText);
        	//NgLogD("########    END    ########");
            cb(request);
			this.getStash();
			
			//was commented
			//sz: commenting out as we do not need this
			//this.getGifts(function(){});
        	//this.getGiftUsers(function(){});
        }.bind(this));
    },

    getTestFile : function( cb )
    {
        this.doRequest( this.kVerbGet, "/index.html", null, null, cb);
    },

    updateBuildingPositions : function( id, changeList, cb)
    {
        var requestObject = JSON.stringify(changeList);
        var url = this.makeAppUrl( this.kVerbPost, "/entities/update_multiple?kingdom_id=" + id + "&");
        this.doRequest( this.kVerbPost, url, null, requestObject, cb);
    },

	// Build buildings for money/mana or from stash
    buildBuilding : function(id, item, stashed, cb)
    {
        var date = ConvertToWeDate(new Date());
        var requestObject = JSON.stringify(item);
		var params = stashed ? "/entities/use_stash?" : "/entities?";
        params = params + "worker_id=" + 0 + "&start_work_at=" + date + "&kingdom_id=" + id + "&";
        
        var url = this.makeAppUrl( this.kVerbPost, params);
        this.doRequest( this.kVerbPost, url, null, requestObject, function(request)
        {
            cb(request);
			this.getStash();
        }.bind(this));
    },
    
    // update state of push notifications for an object
    updatePushNotificationsForEntity : function (entityId, pushNotify, cb)
    {
        	var params = { entity : { push_notify : pushNotify } };
        	var requestObject = JSON.stringify (params);
        	var url = this.makeAppUrl(this.kVerbPut, "/entities/" + entityId + "?kingdom_id=" 
        							+ WeGameStateMgr.GetCurrentKingdomId() + "&");
        	this.doRequest(this.kVerbPut, url, null, requestObject, cb);
    },
    
	reportClickedEventStart : function ()
	{
        var url = this.makeAppUrl( this.kVerbGet, "/stats?type=report_clicked_event_start");
        this.doRequest( this.kVerbGet, url, null, null, null);		
	},

    purchaseWithPoints : function( id, cb)
    {
    	var request = "/game_events/purchase_with_points?proto_id="+id;
        var url = this.makeAppUrl( this.kVerbPut, request);
        this.doRequest( this.kVerbPut, url, null, null, cb);
        NgLogD("<<<<<<!!!! BUILD EVENT BUILDING " + url);
    },
    
    purchaseWithItems : function( id, count, cb)
    {
    	var request = "/game_events/purchase_with_items?item_id="+id+"&count="+count;
        var url = this.makeAppUrl( this.kVerbPut, request);
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },
    
    acquireItem : function( id, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/game_events/acquire_item?item_id="+ id);
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

	/*api has to be called for any items in the 'acquired state . this is the api for the 'slot machine' logic. Every slot machine either adds to point balance or changes progress in the active collection
	parameters: item_id - id of the game event item to use
	parameters: tier . set to 1 if the spin is free, set to 2 for the boosted slot machine spin
	*/
    generateEventLoot : function( id, tier, cb)
    {
        var url = this.makeAppUrl( this.kVerbGet, "/game_events/generate_loot?item_id=" + id + "&tier=" + tier);
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },

    refreshEventItems : function(cb)
    {
        var url = this.makeAppUrl( this.kVerbGet, "/game_events/refresh_items?test");
        this.doRequest( this.kVerbGet, url, null, null, cb);
    },

	/* show network error popup and return null if the response can not proceed the game;
	   preprocess the message and return the response object if the response is good */
	getRequestResponse : function( request )
	{
		if (!request)
		{
			return null;
		}
        if(request.readyState == 4)
        {
            try
            {
                if (Exists(request.responseText))
                {
                    var obj = JSON.parse(request.responseText);

					WeProtocol.handleMessages(obj, request);	// pre process all the necessary objects in the message
					return obj;
                }
                else
                {
                    WeUiMgr.ShowNetworkErrorPopUp();
					return null;
                }
            }
            catch(ex)
            {
                WeUiMgr.ShowNetworkErrorPopUp();
            }
        }
        else if(request.readyState === 0)
        {
            ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
            WeUiMgr.ShowNetworkErrorPopUp();
			return null;
        }

		return null;
	},

    harvest : function( id, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/entities/" + id + "?harvest=true&");
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

	harvestAll : function(buildings, cb)
	{
		var ids = [];
		for(i in buildings)
			ids.push(buildings[i].mEntity.id);

		var args = {
			entity_ids : ids,
			kingdom_id : WeGameStateMgr.GetCurrentKingdomId()
		};

		var url = this.makeAppUrl(this.kVerbPost, "/entities/harvest_multiple?");
		this.doRequest(this.kVerbPost, url, null, JSON.stringify(args), function(request)
		{
			cb(request);
		}.bind(this));
	},

    //////////////////////////////////////////////////////////////////////////////
	/**
	* Method : doPreTouch
	* @desc : Used to pet an animal or research a building
	* @param {Integer} id of the of the building entity to pet
	*/
    doPreTouch : function( id, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/entities/" + id + "?do_pre_touch=0&");
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },
    
    pettingWithMana : function( id, petting_mana, petting_amount, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/entities/" + id + "?petting_mana=" + petting_mana + "&petting=" + petting_amount);
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    produce : function( id, productId, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/entities/" + id + "?produce="+ productId + "&");
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    useMana : function( id, amount, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/entities/" + id + "?use_mana="+ amount + "&");
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    hireFriend : function( prod, friendId, entityId, existingJob, cb)
    {
        var data =  {'job' :  { 'request_name' : gCurKingdomUser, 
                                   'friend_kingdom_id'  : friendId,
                                   'entity_id'  : entityId,
                                   'product_id'  : prod.id}
                              }  ;
        var requestObject = JSON.stringify(data);
        var url = null;
        if (!existingJob)
        {
            url = this.makeAppUrl( this.kVerbPost, "/jobs?hire=true&");
        }
        else
        {
            url = this.makeAppUrl( this.kVerbPost, "/jobs/" + existingJob.id + "?hire=true&");
        }
        
        this.doRequest( this.kVerbPost, url, null, requestObject, cb);
    },

    completeObjective : function( objId, cb )
    {
        var data = {'completed_objective' : { 'proto_objective_id' : objId }};
        var requestObject = JSON.stringify(data);
        var url = this.makeAppUrl( this.kVerbPost, "/completed_objectives?" );
        this.doRequest( this.kVerbPost, url, null, requestObject, cb);
    },

    hireReply : function( job, accept, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/jobs/" + job.id + "?accept=" + accept + "&");
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    completeJob : function( job, cb)
    {
        var url = this.makeAppUrl( this.kVerbPut, "/jobs/" + job.id + "?complete=true&");
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    cancelJob : function( job, cb )
    {
        var url = this.makeAppUrl( this.kVerbPut, "/jobs/" + job.id + "?cancel=true&");

        job.pickupMessageSent = true;
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    pickupCompletedJob : function( job, cb )
    {
        var url = this.makeAppUrl( this.kVerbPut, "/jobs/" + job.id + "?pickup=true&");
        job.pickupMessageSent = true;
        this.doRequest( this.kVerbPut, url, null, null, cb);
    },

    purchaseUpgrade : function( objId )
    {
        var data = {'upgrade' : { 'proto_upgrade_id' : objId } };
        var requestObject = JSON.stringify(data);
        var kingdomId = WeGameStateMgr.GetCurrentKingdomId();
        var url = this.makeAppUrl( this.kVerbPost, "/upgrades?kingdom_id=" + kingdomId + "&" );
        this.doRequest( this.kVerbPost, url, null, requestObject, this.purchaseUpgradeCallback );
    },

    purchaseUpgradeCallback : function( request )
    {
        try
        {
            var obj = JSON.parse(request.responseText);
		}
        catch(ex)
        {
            NgLogD("Issue parsing Upgrade server response into JSON");
            NgLogD("Upgrade request status:" + request.statusText);
            NgLogD("Upgrade request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
		if (Exists(obj))
		{
			NgLogD("purchaseUpgradeCallback: obj exists - attempting to move forward");
			var new_upgrade = {};
			var LotInfo = WeGameStateMgr.GetGameLotInfo();
			//pull down any updates passed back in the request
			LotInfo.UpdateInfo(obj.upgrade.kingdom.kingdom);
			//add an upgrade tag to this kingdom...
			new_upgrade.created_at = obj.upgrade.created_at;
			new_upgrade.id = obj.upgrade.id;
			new_upgrade.kingdom_id = obj.upgrade.kingdom_id;
			new_upgrade.proto_upgrade_id = obj.upgrade.proto_upgrade_id;
			
			//HACK Check if new upgrade is in list and add only if it not

	        var info = WeGameStateMgr.GetGameLotInfo();
	        var upgrades=info.upgrades;
            var bIsValid=true;
            if(upgrades)
            {
	            for(var j=0; j < upgrades.length; j++)
	        	{
	            	var upgrade = upgrades[j];
	            	if(upgrade.id==new_upgrade.id && upgrade.kingdom_id==new_upgrade.kingdom_id && upgrade.proto_upgrade_id==new_upgrade.proto_upgrade_id)
	        		{
	            		NgLogD("Tried to create dublication off update");	
	            		bIsValid=false;
	            		break;
	        		}
	        	}
            }
            if(bIsValid)
            {
            	LotInfo.upgrades.push(new_upgrade);
            }
            //HACK END
			
			// rebuild the castle on the map
			var upgrade = weProtoDb.getInstance().getUpgrade(new_upgrade.proto_upgrade_id);
			if ( upgrade.from_proto_entity_id !== null && upgrade.to_proto_entity_id !== null )
			{
			    WeGameStateMgr.mLotInfo.UpgradeEntity(upgrade.from_proto_entity_id, upgrade.to_proto_entity_id);
			}

			// update zoom min
			WeGameStateMgr.GetGameLot().ReInitForNewMapSize();	

			// show the kingdom upgraded popup
			var popupArgs = {};
			popupArgs.OnOk = function(args)
			{
			    WeGameStateMgr.SetGlobalGameWidget(null);
			    WeGameStateMgr.SetCurrentKingdomUser(gCurKingdomUser);
				//WeLoadNamedLot(gCurKingdomUser);
				WeLotLoad(WeGameStateMgr.GetCurrentKingdomId());
			};

			popupArgs.popup_label = GameSpecificVariables.Texts.Congratulations; 
			popupArgs.popup_text = GameSpecificVariables.Texts.YourHasBeenUpgraded;
            
			// redraw the lot
			WeSocialMapMgr.transitionScreenToKingdom();

			// push the popup box onto the screen
			var itemDef = WeUiMgr.GetItemDef("popup_box");
			var gameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
			gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    
			WeGameStateMgr.SetGlobalGameWidget(gameWidget);
			NgLogD("purchaseUpgradeCallback: done setting up widget...");
		}
		else
		{
			NgLogD("Error in update response callback");
			// head back to the lot
			WeSocialMapMgr.transitionScreenToKingdom();
		}
    },
/* Gifting code */
	openGifts : function(ids, cb)
	{
		var data = {'ids': ids };
		var requestObject = JSON.stringify(data);
		var url = this.makeAppUrl(this.kVerbPost, "/gifts/open_gifts?");		
		this.doRequest(this.kVerbPost, url, null, requestObject, function(request)
        {
        	WeProtocol.openGiftsResponse(request);
        	WeProtocol.openGiftsCallback(request);
            cb(request);
        });			
	},
	
	boostGifts : function (ids, cb)
	{
		var data = {'ids': ids };
		var requestObject = JSON.stringify(data);
		var url = this.makeAppUrl(this.kVerbPost, "/gifts/boost_gifts?");		
		this.doRequest(this.kVerbPost, url, null, requestObject, function(request)
        {
        	WeProtocol.openGiftsResponse(request);
        	WeProtocol.openGiftsCallback(request);
            cb(request);
        });					
	},
	
	openGiftsResponse : function (request)
	{
        try
        {
            var obj = JSON.parse(request.responseText);
		}
        catch(ex)
        {
            NgLogD("Issue parsing Gift List server response into JSON");
            NgLogD("Request status:" + request.statusText);
            NgLogD("Request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
		if (Exists(obj))
		{
			//NgLogD("Messages: ");
			//objDump(obj.messages);
			NgLogD("@@@@@@ Gifts data: ");
			for (var i in obj.gifts)
			{
				objDump(obj.gifts[i].gift);
			}	
		}		
	},
	
	openGiftsCallback : function (request)
	{
		var obj = JSON.parse(request.responseText);
		if (Exists(obj))
		{
			//NgLogD("OpenGifts: ");
			//NgLogD("@@@@@@@@");
			//objDump(obj);
			//NgLogD("@@@@@@@@");
			
			// update game data with gift rewards OR subtract mana for boosting
			WeGameStateMgr.GetGameLotInfo().mana = obj.user_mana;
			WeGameStateMgr.GetGameLotInfo().gold = obj.user_gold;
			// WeGameStateMgr.GetGameLotInfo().xp = obj.user_xp;
			// Received XP is delayed until user closes gifting view
			// - to avoid LevelUp screen
			WeGameStateMgr.mDelayedXp = obj.user_xp;
			WeProtocol.getStash();
			
			WeGameStateMgr.mFreeOpen = obj.open_credit;
			
			var gifts = obj.gifts;
			var label = WeUiMgr.GetLabelFactory().FindLabelOfName("gift_description");
			if (obj.gifts.length < 1)
			{			

			} else
			for (var j in gifts)
			{
				for (var i=0; i<WeGameStateMgr.mGifts.length; i++)
				{
					if (gifts[j].gift.id == WeGameStateMgr.mGifts[i].id)
					{
						var newGift = ObjectUtils.GetCloneOfObject(gifts[j].gift);
						var coinText = GameSpecificVariables.Texts.cointText;
						newGift.gift_description = newGift.gift_description.replace(" gold", " " + coinText);
						WeGameStateMgr.mGifts[i] = newGift;
						break;
					}
				}
			}
		}		
	},
/*
	boostGiftsCallback : function (request)
	{
		var obj = JSON.parse(request.responseText);
		if (Exists(obj))
		{
			WeGameStateMgr.mFreeOpen = obj.open_credit;
			
			var gifts = obj.gifts;
			for (var j in gifts)
			{
				for (var i=0; i<WeGameStateMgr.mGifts.length; i++)
				{
					if (gifts[j].gift.date_sent == WeGameStateMgr.mGifts[i].date_sent)
					{
						var newGift = ObjectUtils.GetCloneOfObject(gifts[j].gift);
						WeGameStateMgr.mGifts[i] = newGift;
						break;
					}
				}
			}
		}		
	},
*/
	sendGifts : function(users, cb)
	{
		var data = {'gamernames': users };
		var requestObject = JSON.stringify(data);
		var url = this.makeAppUrl(this.kVerbPost, "/gifts/send_gifts?");		
		this.doRequest(this.kVerbPost, url, null, requestObject, function(request)
        {
        	WeProtocol.sendGiftsResponse(request);
            cb(request);
        });		
	},

	sendGiftsResponse : function (request)
	{
        try
        {
            var obj = JSON.parse(request.responseText);
		}
        catch(ex)
        {
            NgLogD("Issue parsing Gift List server response into JSON");
            NgLogD("Request status:" + request.statusText);
            NgLogD("Request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
		if (Exists(obj))
		{
			//NgLogD("Messages: ");
			//objDump(obj.messages);
		}		
	},

	getGifts : function(cb)
	{
        if (!gGiftingEnabled) return;
        var url = this.makeAppUrl(this.kVerbPost, "/gifts/list_gifts?");
        this.doRequest(this.kVerbPost, url, null, null, function(request)
        {
            WeProtocol.getGiftsCallback(request);
            cb(request);
        });
	},
	
	getGiftsCallback : function(request)
	{
        try
        {
            var obj = JSON.parse(request.responseText);
		}
        catch(ex)
        {
            NgLogD("Issue parsing Gift List server response into JSON");
            NgLogD("Request status:" + request.statusText);
            NgLogD("Request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
		if (Exists(obj))
		{
			//NgLogD("Gifts: ");
			//NgLogD("@@@@@@------");
			//objDump(obj);
			//NgLogD("------@@@@@@");
			if (!Exists(WeGameStateMgr.mGifts))
			{
				WeGameStateMgr.mGifts = [];
			}
			else
			{
				// clear opened items
				for (var i=0; i<WeGameStateMgr.mGifts.length; )
				{
					if (WeGameStateMgr.mGifts[i].proto_gift_id != -1)
					{
						WeGameStateMgr.mGifts.splice(i, 1);
						WeGameStateMgr.mCurrentGift = -1;
					}
					else i++;
				}
			}
			var gifts = obj.gifts;
			if (Exists(obj.open_credit))
			{
				WeGameStateMgr.mFreeOpen = obj.open_credit;
			}
			// add received gifts
			for(var i in gifts) 
			{
				//objDump(gifts[i].gift);				
				if (WeGameStateMgr.mGifts.length >= 20)
				{
					// max items in a list
					break;
				}
				// check whether received gift is already in a list
				var newGift = true;
				for (var j in WeGameStateMgr.mGifts)
				{
					if (WeGameStateMgr.mGifts[j].id == gifts[i].gift.id)
					{
						newGift = false;
						break;
					}
				}
				if (newGift  && gifts[i].gift.sender != WeProtocol.userName )
				{
					WeGameStateMgr.mGifts.push(gifts[i].gift);
				}
			}			
		}		
	},
	
	sendGiftToCurrentUser : function()
	{
		/* the server will check if the sending is successful; client just tries to send */
		var currentUser = WeGameStateMgr.currentKingdomUser;

		var args = {};
		args.OnYes = function(args)
		{
			WeProtocol.sendGifts([ currentUser ], function(request)
			{
				var obj = JSON.parse(request.responseText);
				
				if (obj.success)
				{
					// remove user from list
					var list = WeGameStateMgr.mGiftUsers;
					if ( list && list.length )
					{
						for (var i=0; i<list.length; i++)
						{
							if (list[i] == currentUser)
							{
								WeGameStateMgr.mGiftUsers.splice(i,1);
								break;
							}
						}
					}
				}

				// show popup
				var popupArgs = {};
				popupArgs.OnOk = function(args)
				{
					WeGameStateMgr.SetGlobalGameWidget(null);
				};

				if (obj.success)
				{
					popupArgs.popup_label = "Gift Sent";
					popupArgs.popup_text = "Your gift will be received by " + currentUser + ".";
				}
				else
				{
					popupArgs.popup_label = "Gift Limit";
					popupArgs.popup_text = "You have already sent a daily gift to " + currentUser + ".";					
				}

				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, popupArgs);
				newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

				WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
			});
		};

		args.OnNo = function(theNewArgs)
		{
			WeGameStateMgr.SetGlobalGameWidget(null);
		};

		args.popup_label = "Send gift";
		args.popup_text = "Do you want to send a gift to " + currentUser + "?";

		var itemDef = WeUiMgr.GetItemDef("popup_box");
		var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
		newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

		WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
	},

	getGiftUsers : function(cb)
	{
		if (!gGiftingEnabled) return;
		var url = this.makeAppUrl(this.kVerbPost, "/gifts/list_users?");
		this.doRequest(this.kVerbPost, url, null, null, function(request)
		{
			WeProtocol.getGiftUsersCallback(request);
		    cb(request);
		});
	},
	
	getGiftUsersCallback : function(request)
	{
        try
        {
            var obj = JSON.parse(request.responseText);
		}
        catch(ex)
        {
            NgLogD("Issue parsing Gift User List server response into JSON");
            NgLogD("Request status:" + request.statusText);
            NgLogD("Request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
		if (Exists(obj))
		{
			NgLogD("Users: ");
			NgLogD("@@@@@@------");
			objDump(obj);
			NgLogD("------@@@@@@");
			if (!Exists(WeGameStateMgr.mGiftUsers))
			{
				WeGameStateMgr.mGiftUsers = [];
			}
			var users = obj.users;
			for (i in users)
			{				
				if (WeGameStateMgr.mGiftUsers.length >= 20)
				{
					// max users in a list
					break;
				}
				// check whether a user is in a list
				var newUser = true;
				for (var j in WeGameStateMgr.mGiftUsers)
				{
					if (WeGameStateMgr.mGiftUsers[j] == users[i])
					{
						newUser = false;
						break;
					}
				}
				if (newUser)
				{
					WeGameStateMgr.mGiftUsers.push(users[i]);
				}
			}				
		}		
	},
	
	sendSEGifts : function(user, proto_id, cb)
	{
		var users = [];
		users.push(user);
		NgLogD("<<<!>>> sendSEGifts " + JSON.stringify(user));
		var url = this.makeAppUrl(this.kVerbPost, "/game_events/share?name=" + user + "&item_id=" + proto_id);		
		this.doRequest(this.kVerbPost, url, null, null, function(request)
        {
        	WeProtocol.sendGiftsResponse(request);
            cb(request);
        });
	},
	
	getSEGiftUsers : function(cb)
	{
		if (!gGiftingEnabled) return;
		//TODO: Change for "/se_gifts/list_users?" or something similar
		var url = this.makeAppUrl(this.kVerbPost, "/game_events/share_list?");
		this.doRequest(this.kVerbPost, url, null, null, function(request)
		{
			WeProtocol.getSEGiftUsersCallback(request);
		    cb(request);
		});
	},
	
	getSEGiftUsersCallback : function(request)
	{
        try
        {
            var obj = JSON.parse(request.responseText);
		}
        catch(ex)
        {
            NgLogD("Issue parsing Share User List server response into JSON");
            NgLogD("Request status:" + request.statusText);
            NgLogD("Request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
		if (Exists(obj))
		{
		    NgLogD("Request status:" + request.responseText);
			NgLogD("Users: ");
			NgLogD("@@@@@@------");
			objDump(obj);
			NgLogD("------@@@@@@");
			
			for (var proto_event_item_id in obj.available_share_count)
            {
                var count = obj.available_share_count[proto_event_item_id];
                WeEventGame.mShareCount = count;
                NgLogD("SHARE COUNT: " + WeEventGame.mShareCount);
            }

			if (!Exists(WeGameStateMgr.mSEGiftUsers))
			{
				WeGameStateMgr.mSEGiftUsers = [];
			}
			
			if (!Exists(obj.received_items_from))
			{
			    WeGameStateMgr.mSEReceivedFrom = [];
			}
			else
			{
			    WeGameStateMgr.mSEReceivedFrom = obj.received_items_from;
			}
			
			
			var users = obj.list;
			for (i in users)
			{				
				if (WeGameStateMgr.mSEGiftUsers.length >= 20)
				{
					// max users in a list
					break;
				}
				// check whether a user is in a list
				var newUser = true;
				for (var j in WeGameStateMgr.mSEGiftUsers)
				{
					if (WeGameStateMgr.mSEGiftUsers[j] == users[i])
					{
						newUser = false;
						break;
					}
				}
				if (newUser)
				{
					WeGameStateMgr.mSEGiftUsers.push(users[i]);
				}
			}		
			
			// sort users by mSEReceivedFrom
			WeGameStateMgr.mSEGiftUsers.sort(function (a, b) 
            {
                var inA = WeEventGame.isShareUserInReceivedFrom(a);
                var inB = WeEventGame.isShareUserInReceivedFrom(b);
                
                if (inA && !inB)
                {
                    return -1;
                }
                
                if (!inA && inB)
                {
                    return 1;
                }
                
                return 0;
            });		
		}		
	},
/* End gifting code */

	taskWithMojo : function(protoId)
	{
		var params= "proto_task_id=" + protoId;
		var line = "/goals/use_mojo?"+ params + "&";
		var url = this.makeAppUrl(this.kVerbPost, line);
		this.doRequest(this.kVerbPost, url, null, null, this.taskWithMojoCallback);
	
	},
	
	taskWithMojoCallback : function (request)
	{
		var obj = JSON.parse(request.responseText);
		if (Exists(obj) && Exists(obj.messages) && Exists(obj.messages.current_user))
		{
			WeGameStateMgr.GetGameLotInfo().xp = obj.messages.current_user.xp;
			WeGameStateMgr.GetGameLotInfo().gold = obj.messages.current_user.gold;
			WeGameStateMgr.GetGameLotInfo().mana = obj.messages.current_user.mana;
			//objDump (obj.messages.current_user);
		}
		
		//WeProtocol.findMessages(obj, this);	
	},
	
	getAdReward : function ()
	{
		var url = this.makeAppUrl(this.kVerbPost, "/social_maps/clicked_ad?");
		this.doRequest(this.kVerbPost, url, null, null, this.getAdRewardCallback);		
	},
	
	getAdRewardCallback : function (request)
	{
		var obj = JSON.parse(request.responseText);
        if (!Exists(obj)) return;
		var data = null;
		if (Exists(obj.kingdom)) data = obj.kingdom;
		if (Exists(data) && Exists(data.kingdom)) data = data.kingdom;

		NgLogD("@@@@@ Ad reward object: @@@@@");
		objDump(data);

		if (Exists(data))
		{
			WeGameStateMgr.GetGameLotInfo().xp = data.xp;
			WeGameStateMgr.GetGameLotInfo().gold = data.gold;
			WeGameStateMgr.GetGameLotInfo().mana = data.mana;		
		}
	},

	getStash : function()
	{
		if (!gStashEnabled) return;
		var url = this.makeAppUrl(this.kVerbPost, "/entities/my_stash?");
		this.doRequest(this.kVerbPost, url, null, null, this.getStashCallback);
	},

	updateStash : function(stash)
	{
		// Clear old stash
		WeGameStateMgr.mStash = [];

		// Fill it with new data
		if(stash) 
		{
			for(var i in stash) 
			{
				WeGameStateMgr.mStash.push(stash[i].stash);
			}
		}
	},

	getStashCallback : function (request)
	{
        try
        {
            var obj = JSON.parse(request.responseText);
			if (obj && obj.stash)
			{
				WeProtocol.updateStash(obj.stash);
			}
		}
        catch(ex)
        {
            NgLogD("Issue parsing Stash server response into JSON " + ex);
            NgLogD("Upgrade request status:" + request.statusText);
            NgLogD("Upgrade request response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
	},

    getPing : function( cb )
    {
        var url = this.makeAppUrl( this.kVerbGet, "/ping?" );
        this.doRequest( this.kVerbGet, url, null, null, cb );
    },

    createTransaction : function(id, transaction, cb)
    {
    	var params = "mtxid="+transaction.id;
        var url = this.makeAppUrl( this.kVerbPost, "/mtx_transactions/fulfill?");
        this.doRequest( this.kVerbPost, url, null, params, cb);
    },

    createMtxTransaction : function( id, transaction, cb)
    {
        var data =  {
                        'mtx_transaction' :
                        { 
                            'product_identifier' : transaction.product_identifier, 
                             'quantity'  : transaction.quantity,
                             'transaction_identifier'  : transaction.identifier,
                             'transaction_receipt'  : transaction.receipt,
                             'transaction_date'  : transaction.date,
							 'procver' : transaction.procver
                        }
                    } ;

        var requestObject = JSON.stringify(data);
        var url = this.makeAppUrl( this.kVerbPost, "/mtx_transactions?kingdom_id="+id+"&");

        this.doRequest( this.kVerbPost, url, null, requestObject, cb, true);
    },
	
	addNeighbor : function(name, cb)
	{
		var params= "friend="+name+"&";
		var url = this.makeAppUrl(this.kVerbGet, "/mobage/add_friend?"+params );
		this.doRequest(this.kVerbGet, url, null, params, cb);
	},
	
	isNeighbor : function(name, cb)
	{
		var params= "friend="+name;
		var url = this.makeAppUrl(this.kVerbPost, "/mobage/is_friend?");
		this.doRequest(this.kVerbPost, url, null, params, cb);
	},
	
	getRandomUsers : function(maxSize, cb)
	{
		var params= "size="+maxSize;
		var url = this.makeAppUrl(this.kVerbPost, "/mobage/get_random_users?");
		this.doRequest(this.kVerbPost, url, null, params, cb);
	},
	
	//http://kingdoms-demo.ngmoco.com/mobage/auth?platform=android&token={token}&secret={secret}

	// pests
	getPests : function(id)
	{
		if(gConfigs.EnablePests !== "TRUE") 
			return;

		if(!WeGameStateMgr.IsCurrentUser())
			return;

		var params = "kingdom_id=" + id;
		var url = this.makeAppUrl(this.kVerbGet, "/pests/list_kingdom_pests?"+params);
		this.doRequest(this.kVerbGet, url, null, null, function(req)
		{
			try
			{
				//NgLogD("*********** getPests funtion **********");
				//NgLogD("url :" + url);
				//NgLogD("kingdom_id :" + id);
				//NgLogD("req.responseText: " + req.responseText);
				var obj = JSON.parse(req.responseText);
				//if (WeGameStateMgr.IsCurrentUser())
				if (Exists(obj) && Exists(obj.messages))
				{
				    var goal_id = obj.messages.main_event_goal_proto_id;
				    if(goal_id)
					    gConfigs.MainEventGoalProtoId = goal_id; 
				    if(obj.messages.pests)
					    WePests.handlePests(obj.messages.pests);
                }
				// Should we display something?
				if(Exists(WeGameStateMgr.mInterstitialCommand))
				{
					HandleURLRequest(WeGameStateMgr.mInterstitialCommand);
				    WeGameStateMgr.mInterstitialCommand = null;
				}
			}
			catch(ex)
			{
				NgLogException(ex);
				NgLogD("Unable to parse list_kingdom_pests response!");
		//		WeUiMgr.ShowNetworkErrorPopUp();
			}
		});
	},

	touchPest : function(pest_id, mojo)
	{
		if(gConfigs.EnablePests !== "TRUE")
			return;

		var params = "user_pest_id=" + pest_id;
		var api = mojo ? "/pests/mojo_touch?" : "/pests/free_touch?";
		var url = this.makeAppUrl(this.kVerbGet, api + params);
		this.doRequest(this.kVerbGet, url, null, null, function(req)
		{
			try
			{
				var obj = JSON.parse(req.responseText);
				WePests.handleCatch(obj.messages.pests, pest_id, obj.messages.pests_shared_users);
				WeProtocol.getKingdomByName(Social.US.Session.getCurrentSession().user().gamertag, function(cb) {
				    var inst = JSON.parse(cb.responseText);
				    WeGameStateMgr.GetGameLotInfo().UpdateInfo(inst.kingdom);
				});
			}
			catch(ex)
			{
				NgLogD("Unable to parse pest touch response!");
				WeUiMgr.ShowCaptureScreenConnectionError();
			}
		});
	},

	releasePest : function(pest_id, friend_name)
	{
		var params = "user_pest_id=" + pest_id + "&friend_login=" + friend_name;
		var url = this.makeAppUrl(this.kVerbGet, "/pests/release_in_friend_main_kingdom?"+params);
		this.doRequest(this.kVerbGet, url, null, null, function(req)
		{
			// We don't really care about response
//			try
//			{
//				var obj = JSON.parse(req.responseText);
//				NgLogD("*********** releasePest funtion **********");
//				NgLogD("params:" + params);
//				NgLogD(req.responseText);
//				objDump(obj);
//				WePests.handlePests(obj.messages.pests);
//			}
//			catch(ex)
//			{
//				NgLogD("Unable to parse list_kingdom_pests response!");
//				WeUiMgr.ShowNetworkErrorPopUp();
//			}
		});
	}
});

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/RulePlusHome'] = function(){var exports = $MODULE_REGISTRY['weEngine/RulePlusHome'] || {}; $MODULE_REGISTRY['weEngine/RulePlusHome'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-11-22
 *  @file:      RulePlusHome.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by ngmoco:)
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

var Core = require('NGCore/Client/Core').Core;

var ThePlusRequest = require('NGCore/Client/Plus/PlusRequest').PlusRequest;
var NGUI = require('NGCore/Client/UI').UI;

//////////////////////////////////////////////////////////////////////////////////////////////////
// 'Global' Variables
/*
var homeScreen = {
	initialize: function() {
		var mainRect = new NGUI.ViewGeometry.Rect(0, 0, NGWindow.outerWidth, NGWindow.outerHeight);

		this.baseView = new NGUI.View();
		this.baseView.setFrame(mainRect.array());
		this.baseView.setGradient(Styles.background);

		// this.setupAdTimer();

		// Title Bar
		this.titleBar = new NGUI.View();
		this.titleBar.setFrame([0, 0, NGWindow.outerWidth, 41]);
//		this.titleBar.setGradient(Styles.transparent);
		this.titleBar.setImage(ContentRoot + '/Headerbar_Empty.png');
		this.titleBar.setImageFit(NGUI.ViewGeometry.FitModes.Fill);

		this.baseView.addChild(this.titleBar);

		mainRect.inset(25);
		var buttonArea = mainRect.sliceVertical(Math.floor(mainRect.h / 2));
		this.buttonPositions = buttonArea.getGrid(2, 3, true);	// Six elements in a flat array; 2 rows, 3 columns.

		this.buttonFrames = [
			'scanContactsFrame',
			'regFrame',
			'loginFrame',
			'navTestFrame',
			'emptyFrame1',
			'animateFrame'
		];

		for (i in this.buttonFrames)
        {
			var currentFrame = this[this.buttonFrames[i]] = new NGUI.View();
			currentFrame.setFrame(this.buttonPositions[i].inset(2,5).array());
			currentFrame.setBackgroundColor('000000FF');
			this.baseView.addChild(currentFrame);
		}

		this.buttons = [
			'scanContactsButton',
			'regButton',
			'loginButton',
			'navTestButton',
			'emptyButton1',
			'animateButton'
		];
		
		for (i in this.buttons)
        {
			var currentButton = this[this.buttons[i]] = new NGUI.Button();
			currentButton.setFrame([0, 0, 72, 72]);
			currentButton.setBackgroundColor('000000FF');
			currentButton.setNormalGradient(Styles.basicBox);
			currentButton.setHighlightedGradient(Styles.basicBoxDown);
			this[this.buttonFrames[i]].addChild(currentButton);
		}

		this.scanContactsButton.setNormalImage(ContentRoot + '/Friends_Up.png');
		this.scanContactsButton.setHighlightedImage(ContentRoot + '/Friends_Down.png');
		this.regButton.setNormalImage(ContentRoot + '/Profile_Up.png');
		this.regButton.setHighlightedImage(ContentRoot + '/Profile_Up_Copy.png');
		this.loginButton.setNormalImage(ContentRoot + '/Games_Up.png');
		this.loginButton.setHighlightedImage(ContentRoot + '/Games_Down.png');
		this.navTestButton.setNormalImage(ContentRoot + '/Honors_Up.png');
		this.navTestButton.setHighlightedImage(ContentRoot + '/Honors_Down.png');
		this.emptyButton1.setNormalImage(ContentRoot + '/Inbox_Up.png');
		this.emptyButton1.setHighlightedImage(ContentRoot + '/Inbox_Up_Copy.png');
		this.animateButton.setNormalImage(ContentRoot + '/CheckIn_Up.png');
		this.animateButton.setHighlightedImage(ContentRoot + '/CheckIn_Down.png');

		this.buttonLabels = [
			'scanContactsLabel',
			'regLabel',
			'loginLabel',
			'navTestLabel',
			'emptyLabel1',
			'animateLabel'
		];

		this.buttonLabelText = [
			'scan contacts',
			'reg flow',
			'login',
			'nav test',
			'[empty]',
			'animate'
		];

		for (i in this.buttonLabels)
        {
			var currentLabel = this[this.buttonLabels[i]] = new NGUI.Label();
			currentLabel.setFrame([0, 72, 72, 22]);
			currentLabel.setBackgroundColor('000000FF');
			currentLabel.setGradient(Styles.label);
			currentLabel.setTextGravity([0.5,0.5]);
		//	currentLabel.setFont({'font-face':['Marker Felt', 'Comic Sans'], 'font-size':15.0, 'bold':false});
			currentLabel.setTextColor('FF00');
			currentLabel.setText(this.buttonLabelText[i]);
			this[this.buttonFrames[i]].addChild(currentLabel);
		}

		var vc = this;
		this.scanContactsButton.analyticsName = "cntctbtn";
		this.scanContactsButton.onclick = function() {
			PlusUI.launchScanContacts(vc.scanContactsButton);
		};

		this.regButton.analyticsName = "sgnpbtn";
		this.regButton.onclick = function() {
			PlusUI.launchRegistrationProcess(function(user) {
				//NgLogD("Register Callback Success!!\n");
				NGUI.NavController.getInstance().backToView(vc.getMainContainer());
				
				OnPlusLogin(user);
			},vc.regButton);		
		};
		this.loginButton.analyticsName = "lgnbtn";
		this.loginButton.onclick = function() {
			PlusUI.launchLoginProcess(function(user) {
				//NgLogD("Login Callback Success!!\n");
				NGUI.NavController.getInstance().backToView(vc.getMainContainer());
				
				OnPlusLogin(user);
			},vc.loginButton);	
		};

		this.navTestButton.onclick = function(){
			secondScreen.initialize();
			NGUI.NavController.getInstance().forwardToView(secondScreen.getMainContainer());
		};

		// generate an array of the frame objects
		var buttonFrameObjects = [];
		
		for (i in this.buttonFrames)
        {
			buttonFrameObjects.push(this[this.buttonFrames[i]]);
		}
		
		this.animateButton.onclick = function(){
			var animateFrame = buttonFrameObjects[5];
			var randomFrame = buttonFrameObjects[Math.floor(Math.random() * buttonFrameObjects.length)];
			var f = animateFrame.getFrame();
			animateFrame.animate(function(){
				animateFrame.setFrame(randomFrame.getFrame());
			});
			randomFrame.animate(function(){
				randomFrame.setFrame(f);
			});
		};
	},
	getMainContainer: function()
    {
		return this.baseView;
	} 
};
*/
var emptyScreen =
{
	initialize: function()
    {
	},
	
	showAd: function()
    {
		this.showAdWithArgs(gTunables.ad_loc_x, gTunables.ad_loc_y, gTunables.ad_width, gTunables.ad_height);
	},

    showAdWithArgs: function(x, y, width, height)
    {
		NgLogD("showAdWithArgs(): requesting 320x50 ad from Mobclix");
		
		this.removeAd();
	    this.ad = new Mobclix.AdView_320x50();
	    var adf = this.ad.getFrame();
	    this.ad.setFrame([x, y, adf[2], adf[3]]);
		// hide other native items
		this.ad.setOnWillTouchThrough(function(adView)
		{
			//NgLogD("adView.WillTouchThrough started");
			WeGameStateMgr.mLastScreen = WeUiMgr.GetActiveScreen();
			//NgLogD("Last screen - "+WeGameStateMgr.mLastScreen);
			Social.Common.Service.hideCommunityButton(function(error)
			{
				NgLogD("Error hiding community button: "+error);
			});
			Social.Common.Service.hideBalanceButton(function(error)
			{
				NgLogD("Error hiding balance button: "+error);
			});
		});
		this.ad.setOnDidTouchThrough(function(adView)
		{
			//NgLogD ("adView.DidTouchThrough started");
			var screen = WeGameStateMgr.mLastScreen;
			//NgLogD("Last screen - "+screen);
			if (screen == "SocialMapScreen")
			{
				Social.Common.Service.showCommunityButton([1.0,0.0], "dark", function(error)
				{
					NgLogD("ERROR showCommunityButton: "+error);
				});
			}
			else if (screen == "BuildBuyScreen" || screen == "BuyMojoScreen")
			{
				if (Exists(WeGameStateMgr.mBalanceRect))
				{
					Social.Common.Service.showBalanceButton(WeGameStateMgr.mBalanceRect, function(error)
					{
						NgLogD("ERROR showBalanceButton: "+error);
					});
				}
			}
		});
		
		this.ad.addToParent(NGWindow.document);
		this.ad.resumeAdAutoRefresh();
		NgLogD("showAdWithArgs(): Mobclix ad added");
    },

    showAdWebWithArgs: function(x, y, width, height)
    {
		NgLogD("showAdWebWithArgs(): requesting 320x250 ad from Mobclix");
	
		this.removeAd();
	    this.ad = new Mobclix.AdView_300x250();
	    //this.ad.setFrame([x, y, width, height]);
	    var adViewFrame = this.ad.getFrame();
	    adViewFrame[0] = x;
	    adViewFrame[1] = y;
	    this.ad.setFrame(adViewFrame);
	    //this.ad.setFrame([x, y, width, height]);
		this.ad.setOnWillTouchThrough(function(adView)
		{
			WeGameStateMgr.mLastScreen = WeUiMgr.GetActiveScreen();
			Social.Common.Service.hideCommunityButton(function(error)
			{
				NgLogD("Error hiding community button: "+error);
			});
			Social.Common.Service.hideBalanceButton(function(error)
			{
				NgLogD("Error hiding balance button: "+error);
			});
		});
		this.ad.setOnDidTouchThrough(function(adView)
		{
			Social.Common.Service.showCommunityButton([1.0,0.0], "dark", function(error)
			{
				NgLogD("ERROR showCommunityButton: "+error);
			});
			WeProtocol.getAdReward();
			// Force the advertisment to refresh.
			adView.resumeAdAutoRefresh();
		});
		this.ad.addToParent(NGWindow.document);
		this.ad.resumeAdAutoRefresh();
		NgLogD("showAdWebWithArgs(): Mobclix ad added");
    },

	removeAd: function()
    {
        if(this.ad && this.ad !== null)
        {
			NgLogD("removeAd(): cancel Mobclix ad");
			this.ad.pauseAdAutoRefresh();
	//		this.ad.cancelAd();
			this.ad.removeFromParent();
			this.ad.destroy();
           // delete this.ad;
			this.ad = null;
        }
	}
/*
    showAdWithArgs: function(x, y, width, height)
    {	
    	var doShowAd = true; // gConfigs.ShowIpadBannerAd;
    	if (!doShowAd)
    		return;
    	
    	NgLogD("$$$$$> showAdWithArgs x: "+x+" y: "+y+" width: "+width+" height: "+height);

		if (width == 0 && height == 0)
		{
			var dips = Core.Capabilities.getScreenUnits();
			width    = 320 * dips;
			height   = 50 * dips;
		}

	    this.ad = new NGUI.AdView({'frame':[x, y, width, height]});
		this.ad.addToParent(NGWindow.document);
    },

	removeAd: function()
    {
        if(this.ad)
        {
            //NgLogD("$$$$$> Ripping out the ad");
			this.ad.removeFromParent(NGWindow.document);
            delete this.ad;
        }
	}
	*/
};


exports.RuleHome = emptyScreen;
//exports.PlusHome = homeScreen;
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeComposite'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeComposite'] || {}; $MODULE_REGISTRY['weEngine/WeComposite'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeCompositeFactory.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     This Module knows how to construct a Image sprite
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Content = require('weEngine/WeContent').Content;
var WeNode2D = require('weEngine/WeNode2D').WeNode2D;
var WeScreen = require('weEngine/WeScreen2D').WeScreen;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;


exports.WeComposite = WeNode2D.subclass(
{
	classname: 'WeComposite',
	
	 initialize : function($super, parent)
	 {
		 $super(parent);
		 this.mManager= WeUiMgr.mCompositeFactory;
	 },
	 
    destroy : function()
    {
    	if(this.mManager)
    	{
    		this.mManager.ReleaseComposite(this);
    	}
          
        if(Exists(this.xBackground))
        {
            this.xBackground.destroy();
            this.xBackground = null;
        }

        if(Exists(this.xController))
        {
            this.xController.destroy();
            this.xController = null;
        }
        
		//NgLogD("-----$$$$------STARTING GAME WIDGET destroy:[" + this.mItemName + "]-----$$$$------");
		if(this.xChildren)
		{
			for (var i = 0; i < this.xChildren.length; i++)
			{
				
				//REMOVE
				if(this.xChildren[i]==this)
				{
					NgLogD("I am my child");
					printStack();
					objDump(this.xItemDef, 4);
				}
				
				if (Exists(this.xChildren[i].destroy))
				{
					this.xChildren[i].destroy();
				}
				else
				{
					NgLogD("----~~~~~~!!!!!----~~~~~ A UI component in [" + this.xChildren[i].mItemName + "] missing its cleanup code ----~~~~~~!!!!!----~~~~~");
				}
			}
			this.xChildren=undefined;
    	}
        
		//NgLogD("--------$$$$----Composite done shutting down-----$$$$--------")
    }
	
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Animation'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Animation'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Animation'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.Animation = Core.Class.subclass(
/** @lends GL2.Animation.prototype */
{
	classname: 'Animation',
    
	/**
	 * @class The <code>Animation</code> class constructs objects that define application animations. Animations aggregate and control 
	 * the instantiation of <code>Frame</code> objects for manipulation of <code>{@link GL2.Sprite}</code> and
	 * <code>{@link GL2.Primitive}</code> objects. Each <code>Frame</code> object defines a duration and an image display area. 
	 * <code>Frame</code> objects also include a pre-transform 
	 * offset that define the rotation and scale of sprite images. 
	 * @constructs The default constructor.
	 * @augments Core.Class
	 */
    initialize: function()
    {
		Core.ObjectRegistry.register(this);
		
        this._wrapMode = this.WrapMode.WrapNone;
        this._blendEnabled = true;
        this._blendMode = this.BlendMode.Alpha;
        this._filteringEnabled = true;
		this._loopingEnabled = true;
		this._totalDuration = 0;
		this._frames = [];
		
		this._createSendGen(this.__objectRegistryId);
    },

	/**
	 * Destroy this instance and release resources on the backend.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},
	
	/**
	 * Retrieve the specified texture wrap mode for this <code>Animation</code>.
	 * @returns {GL2.Animation#WrapMode} The current texture wrap mode.
	 * @see GL2.Animation#setWrapMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getWrapMode: function()
	{
		return this._wrapMode;
	},
	
	/**
	 * Retrieve the alpha blending state for this <code>Animation</code>.
	 * @returns {Boolean} Returns <code>true</code> if alpha blending is enabled. Returns <code>false</code> in all other cases.
	 * @see GL2.Animation#setBlendEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getBlendEnabled: function()
	{
		return this._blendEnabled;
	},
	
	/**
	 * Retrieve the filtering state for this <code>Animation</code>. 
	 * @returns {Boolean} Returns <code>true</code> if filtering is enabled. Returns <code>false</code> in all other cases.
	 * @see GL2.Animation#setFilteringEnabled
	 */
	getFilteringEnabled: function()
	{
		return this._filteringEnabled;
	},
	
	/**
	 * Retrieve the looping state of this <code>Animation</code>.
	 * @returns {Boolean} Returns <code>true</code> if looping is enabled. Returns <code>false</code> in all other cases.
	 * @see GL2.Animation#setLoopingEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getLoopingEnabled: function()
	{
		return this._loopingEnabled;
	},
	
	/**
	 * Retrieve the total duration of this <code>Animation</code> in milliseconds.
	 * @returns {Number} The current duration. 
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getTotalDuration: function()
	{
		return this._totalDuration;
	},
	
	/**
	 * Retrieve the total number of frames in this <code>Animation</code>.
	 * @returns {Number} The current number of frames. 
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getFrameCount: function()
	{
		return this._frames.length;
	},
	
	/**
	 * Retrieve a frame at the specified index for this <code>Animation</code>.
	 * @param {Number} index The specified index.
	 * @returns {GL2.Animation.Frame} The current frame at the specified index.
	 * @see GL2.Animation#setFrame
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getFrame: function(index)
	{
		return this._frames[index];
	},
    
    /**
	 * Apply a wrap mode to frame textures for this <code>Animation</code>.
	 * @param {GL2.Animation#WrapMode} [wrapMode=0] The new texture wrap mode.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Animation#getWrapMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */						
    setWrapMode: function(wrapMode)
	{
		this._wrapMode = wrapMode;
		
		this._setWrapModeSendGen(wrapMode);
		
		return this;
	},
    
    /**
	 * Set the alpha blending state for this <code>Animation</code>. 
	 * <br><br>
	 * <b>Note:</b> You can improve performance for animations with completely opaque frames by disabling alpha blending.
	 * @param {Boolean} [blendEnabled=true] Set as <code>true</code> to enable alpha blending.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Animation#getBlendEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setBlendEnabled: function(blendEnabled)
	{
		this._blendEnabled = blendEnabled;
		
		this._setBlendEnabledSendGen(blendEnabled);
		
		return this;
	},
	
	/**
	 * Set the alpha blend mode.
	 * @see GL2.Animation#setBlendEnabled
	 * @status Android,AndroidTested
	 */
	setBlendMode: function(blendMode)
	{
		this._blendMode = blendMode;
		
		this._setBlendModeSendGen(blendMode);
		
		return this;
	},
	
	getBlendMode: function()
	{
		return this._blendMode;
	},
	
    /**
	 * Set the filtering state for this <code>Animation</code>.
	 * <br><br>
	 * @param {Boolean} [filteringEnabled=false] Set as <code>true</code> to enable filtering. 
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Animation#getFilteringEnabled
	 */
    setFilteringEnabled: function(filteringEnabled)
	{
		this._filteringEnabled = filteringEnabled;
		
		this._setFilteringEnabledSendGen(filteringEnabled);
		
		return this;
	},
    
    /**
	 * Set the looping state for this <code>Animation</code>.
	 * @param {Boolean} [loopingEnabled=false] Set as <code>true</code> to enable animation looping.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Animation#getLoopingEnabled
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setLoopingEnabled: function(loopingEnabled)
	{
		this._loopingEnabled = loopingEnabled;
		
		this._setLoopingEnabledSendGen(loopingEnabled);
		
		return this;
	},
    
    /**
	 * Add a frame to the end of this <code>Animation</code>.<br><br>
	 * <pre class="code"><font size="2">var animation = new GL2.Animation();
	 * animation.pushFrame(new GL2.Animation.Frame('Content/tank.png', 50, [64, 64], [0.5, 0.5], [0/5, 0, 1/5, 1]));</font></pre>
	 * Calling <code>pushFrame()</code> is equivalent to calling <code>spliceFrames()</code> in the following way: 
	 * <pre class="code"><font size="2">animation.spliceFrames(animation.getFrameCount(), 0, frame);</font></pre>
	 * @param {GL2.Animation.Frame} frame The frame to add.
	 * @see GL2.Animation#spliceFrames
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    pushFrame: function(frame)
	{
		return this.spliceFrames(this._frames.length, 0, frame);
	},
    
    /**
	 * Replace the frame at index <i>i</i>.<br><br>
	 * Calling <code>setFrame()</code> is equivalent to calling <code>spliceFrames()</code> in the following way: 
	 * @example animation.spliceFrames(i, 1, frame)
	 * @param {Number} i Index of the frame to replace.
	 * @param {GL2.Animation.Frame} frame The frame to insert.
	 * @see GL2.Animation#getFrame,
	 * @see GL2.Animation#spliceFrames
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setFrame: function(i, frame)
	{
		return this.spliceFrames(i, 1, frame);
	},
    
    /**
	 * Remove a specific number of frames from this <code>Animation</code> and replace them with specified frames.
	 * <br><br>
	 * <b>Note:</b> This method accepts multiple parameters. The third parameter and beyond define all
	 * <code>Frames</code> to use for replacement.<br><br>
	 * The following example passes in three frames to a <code>spliceFrames()</code> call.
	 * @example animation.spliceFrames(0, 0, frame1, frame2, frame3).
	 * @param {Number} start The index of the first frame to remove.
	 * @param {Number} len The total number of frames to remove.
	 * @param {GL2.Animation.Frame} frames The frames to insert. 
	 * <br><br>
	 * <b>Note:</b> This parameter accepts multiple values.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    spliceFrames: function(start, len, frames)
	{
		var i;
		var frameCount = arguments.length-2;
		var frame;

		// Determine if we should use the v2 version of the messsage, which supports renderTargets.
		// This is so that new javaScript that doesn't use renderTargets will still work with an old binary.
		var useV2 = false;
		for (i = 0; i < frameCount; ++i) {
			frame = arguments[i+2];
			if (frame.getImage().classname === 'RenderTarget')
				useV2 = true;
		}

		// Decrement from total duration.
		for (var i=start; i < start + len; ++i) {
			this._totalDuration -= this._frames[i].getDuration();
		}
		
		this._frames.splice.apply(this._frames, arguments);

		if (useV2) {
			this._spliceFrames2SendGen(start, len, frameCount);
		} else {
			this._spliceFramesSendGen(start, len, frameCount);
		}
		
		for (i = 0; i < frameCount; ++i)
		{
			frame = arguments[i+2];
			var duration = frame.getDuration();
			var size = frame.getSize();
			var anchor = frame.getAnchor();
			var uvs = frame.getUVs();
			var uvOrigin = uvs.getOrigin();
			var uvSize = uvs.getSize();
			var image = frame.getImage();

			// if image is a renderTarget
			var renderTargetID = 0;
			if (image.classname === 'RenderTarget') {
				renderTargetID = image.__objectRegistryId;
				image = '';
			}

			if (useV2) {
				this._frame2SendGen(image,
									renderTargetID,
									duration,
									size.getWidth(),
									size.getHeight(),
									anchor.getX(),
									anchor.getY(),
									uvOrigin.getX(),
									uvOrigin.getY(),
									uvSize.getWidth(),
									uvSize.getHeight());
			} else {
				this._frameSendGen(image,
								   duration,
								   size.getWidth(),
								   size.getHeight(),
								   anchor.getX(),
								   anchor.getY(),
								   uvOrigin.getX(),
								   uvOrigin.getY(),
								   uvSize.getWidth(),
								   uvSize.getHeight());
			}
			this._totalDuration += duration;
		}
		
		return this;
	},
	
	$Frame: Core.Class.subclass(
	/** @lends GL2.Animation.Frame.prototype */
	{
		classname: 'Frame',
		
		/**
		 * @class <code>Frame</code> objects define a path to an image and any properties that support the image as
		 * a single frame in an animation.
		 * @constructs The default constructor. 
		 * @param {String|GL2.RenderTarget} image The directory path to an image, or an instance of GL2.RenderTarget.
		 * @param {Number} duration The time duration of the frame in milliseconds.
		 * @param {Core.Size} size The size of the frame in pixels.
		 * @param {Core.Point} anchor The offset within the frame used for scaling and rotation.
		 * @param {Core.Rect} uvs The image region to use for the frame. The default value is <code>[0,0,1,1]</code> (the entire image) 
		 * with a start coordinate of <code>(0,0)</code> and a size of <code>(1,1)</code>.<br><br> 
		 * <b>Example:</b> To select the lower left region of an image with nine distinct frames (three horizontally, three vertically), 
		 * you would specify <code>[0, 0.66, 0.33, 0.33]</code>. The start coordinate is <code>(0, 0.66)</code>, 
		 * which is the left edge of the image and 2/3rds down. 
		 * The size is <code>(0.33, 0.33)</code> which is a third of the image in each <i>x</i> and <i>y</i> direction.
		 * @see GL2.Animation
		 * @default [0,0,1,1] (the entire image)
		 * @augments Core.Class
		 */
		initialize: function(image, duration, size, anchor, uvs)
		{
			this._image     = image;
			this._duration  = duration || 0;
			this._size   = new Core.Size(size);
			
			if(anchor)
				this._anchor = new Core.Point(anchor);
			else
				this._anchor = new Core.Point(0.5, 0.5);
			
			if(uvs)
				this._uvs = new Core.Rect(uvs);
			else
				this._uvs = new Core.Rect(0, 0, 1, 1);
		},

		/**
		 * Retrieve the image directory path or the renderTarget referenced by this <code>Frame</code>.
		 * @returns {String|GL2.RenderTarget} The current directory path to the image, or a GL2.RenderTarget instance.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getImage:    function()
		{
			return this._image;
		},
		
		/**
		 * Retrieve time duration in milliseconds for this <code>Frame</code>.
		 * @returns {Number} The current time duration for the frame.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getDuration:  function()
		{
			return this._duration;
		},

		/**
		 * Retrieve the pixel size of this <code>Frame</code>.
		 * @returns {Core.Size} The current frame size in pixels.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getSize:    function()
		{
			return this._size;
		},

		/**
		 * Retrieve the offset used for scaling and rotation from within this <code>Frame</code>.
		 * @returns {Core.Point} The current frame offset.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getAnchor:  function()
		{
			return this._anchor;
		},

		/**
		 * Retrieve the texture rectangle for this <code>Frame</code> in UV coordinates.
		 * @returns {Core.Rect} The current UV bounds of the frame within the texture.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getUVs:    function()
		{
			return this._uvs;
		},
	}),
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Enumeration for UV wrapping modes.
	 * @namespace
	 */
	WrapMode:
	{ 
		/** Clamp in both U and V. */
		WrapNone: 0,
		/** Wrap in U, clamp in V. */
		WrapU: 1,
		/** Wrap in V, clamp in U. */
		WrapV: 2,
		/** Wrap in both U and V. */
		WrapUV: 3,
	},
	
	/** 
	 * Enumeration for Blend modes.
	 * @namespace
	 */
	BlendMode:
	{ 
		/** blend func: (src alpha, 1 - src alpha). */
		Alpha: 1,
		/** blend func: (src alpha, 1). */
		Add: 2,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 306
	// Method create = -1
	// Method destroy = 2
	// Method setWrapMode = 3
	// Method setBlendEnabled = 4
	// Method setLoopingEnabled = 5
	// Method spliceFrames = 6
	// Method frame = 7
	// Method setFilteringEnabled = 8
	// Method spliceFrames2 = 9
	// Method frame2 = 10
	// Method setBlendMode = 11
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Animation._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Animation._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[306] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":306,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":306,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_setWrapModeSendGen: function( wrapMode )
	{
		Core.Proc.appendToCommandString( ":306,3," + this.__objectRegistryId + "," + wrapMode  );
	},
	
	/** @private */
	_setBlendEnabledSendGen: function( blendEnabled )
	{
		Core.Proc.appendToCommandString( ":306,4," + this.__objectRegistryId + "," + ( blendEnabled ? 1 : 0 )  );
	},
	
	/** @private */
	_setLoopingEnabledSendGen: function( loopingEnabled )
	{
		Core.Proc.appendToCommandString( ":306,5," + this.__objectRegistryId + "," + ( loopingEnabled ? 1 : 0 )  );
	},
	
	/** @private */
	_spliceFramesSendGen: function( start, len, frameCount )
	{
		Core.Proc.appendToCommandString( ":306,6," + this.__objectRegistryId + "," + start + "," + len + "," + frameCount  );
	},
	
	/** @private */
	_frameSendGen: function( image, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV )
	{
		Core.Proc.appendToCommandString( "," + Core.Base64.encode( image ) + "," + duration + "," + width + "," + height + "," + anchorX + "," + anchorY + "," + startU + "," + startV + "," + sizeU + "," + sizeV  );
	},
	
	/** @private */
	_setFilteringEnabledSendGen: function( filteringEnabled )
	{
		Core.Proc.appendToCommandString( ":306,8," + this.__objectRegistryId + "," + ( filteringEnabled ? 1 : 0 )  );
	},
	
	/** @private */
	_spliceFrames2SendGen: function( start, len, frameCount )
	{
		Core.Proc.appendToCommandString( ":306,9," + this.__objectRegistryId + "," + start + "," + len + "," + frameCount  );
	},
	
	/** @private */
	_frame2SendGen: function( image, renderTargetID, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV )
	{
		Core.Proc.appendToCommandString( "," + Core.Base64.encode( image ) + "," + renderTargetID + "," + duration + "," + width + "," + height + "," + anchorX + "," + anchorY + "," + startU + "," + startV + "," + sizeU + "," + sizeV  );
	},
	
	/** @private */
	_setBlendModeSendGen: function( blendMode )
	{
		Core.Proc.appendToCommandString( ":306,11," + this.__objectRegistryId + "," + blendMode  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setWrapMode: function( wrapMode ) {}
	
	// setBlendEnabled: function( blendEnabled ) {}
	
	// setLoopingEnabled: function( loopingEnabled ) {}
	
	// spliceFrames: function( start, len, frameCount ) {}
	
	// frame: function( image, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV ) {}
	
	// setFilteringEnabled: function( filteringEnabled ) {}
	
	// spliceFrames2: function( start, len, frameCount ) {}
	
	// frame2: function( image, renderTargetID, duration, width, height, anchorX, anchorY, startU, startV, sizeU, sizeV ) {}
	
	// setBlendMode: function( blendMode ) {}
	

// {{/Wg Generated Code}}
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Node'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Node'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Node'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.Node = Core.Class.subclass(
/** @lends GL2.Node.prototype */
{
	classname: 'Node',
	
	/**
	 * @class The <code>Node</code> class constructs base class objects that contain positionable elements in the GL2 module. 
	 * Applications can use <code>Node</code> objects for grouping and organizing the scene graph. 
	 * <p>
	 * Inside the <code>{@link UI.GLView}</code> class, positionable elements are organized into a node hierarchy. This data
	 * structure is analgous to a scene graph or a node tree. Child nodes inherit data for
	 * transform, visibility, and depth from the parent on a conditional basis. Most drawable attributes for nodes, such as size and color, are specified in 
	 * derived classes. 
	 *</p><p>
	 * All derived GL2 classes from <code>Node</code> are native-backed proxies including <code>Node</code>.
	 * When a <code>Node</code> is instantiated on the Javascript side, a C++ object
	 * is instantiated and managed for the user on the native backend. This condition means the application
	 * must explicity destroy any <code>Node</code> that is no longer used.
	 *</p><p>
	 * A <code>Node</code> can exist independent of the scene, but it will only receive draw or touch updates
	 * when it is attached to the root tree.
	 *</p>
	 *<div class="ul">
	 * <li>Add a node as a child to the root of the scene with <code>{@link GL2.Root#addChild}</code>.</li> 
	 * <li>Add a node as a child to another node with <code>{@link GL2.Node#addChild}</code>.</li>
	 * <li>Remove a node from the root of the scene with <code>{@link GL2.Root#removeChild}.</code></li>
	 * <li>Remove a child node from a parent node with <code>{@link GL2.Node#removeChild}</code>.</li> 
	 *</div><br>
	 * <p>
	 * Call <code><a href="GL2.Node.html#destroy">destroy()</a></code> to automatically remove a node from the parent node.
	 * As previously noted, nodes are supported by a native object on the backend. Maintaining a 
	 * node reference outside of the scene instead of calling <code>destroy()</code> and recreating a new node is a recommended best practice.
	 *</p><p>
	 * Absolute positioning of a single node is determined by the following properties in the defined order:
	 *</p>
	 *<div class="ol">
	 * <li>Scale (two-component [x,y] multiple)</li>
	 * <li>Rotation (degrees about z-axis)</li>
	 * <li>Position (two-component translation)</li>
	 *</div><br>
	 * <p>
	 * Each of these properties is applied to the node relative to the parent node. The final transform
	 * for any given node is the concatenation of each transform in the node graph ancestry. The
	 * root ancestor is fixed to the view and composes the scene so that <code>(0,0)</code> is in the upper
	 * left corner. The first anchored
	 * offset to rotate and scale around is not specified because nodes do not inherently contain a size <code>(see {@link GL2.Animation.Frame#getAnchor}</code>). 
	 *</p><p>
	 * The <code>Depth</code> property of a <code>Node</code> object determines that <code>Node</code> sort order when traversing the scene graph.
	 * Depth is roughly equivalent to z-order or index. Each node is sorted among siblings by
	 * <code>Depth</code>, starting with the lowest depth node and sorting in ascending order.
	 *</p><p>
	 * By default, <code>Nodes</code> are grouped 
	 * with their siblings (not interleaved with cousins) and sorted relative to their parent 
	 * as if the parent depth value was <code>0</code>. However, you can modify this behavior for specific use cases 
	 * with <code><a href="GL2.Node.html#setChildrenDepthGrouped">setChildrenDepthGrouped()</a></code>. 
	 *</p><p>
	 * The node depth (order) in the scene graph will dictate the drawing order and determines what the final frame will look like.
	 * When drawing, <code>GL2.Node</code> utilizes the painter's algorithm.
	 * This means lower depth nodes are obscured by higher depth nodes.
	 * Touch priority occurs in reverse order to drawing order. Touches travel through the scene from higher depth to lower depth nodes 
	 * (front of scene earlier to back of scene later).
	 *</p><p>
	 * As a base class, a <code>Node</code> is not drawable but does maintain <code>Color</code> and <code>Alpha</code>
	 * attributes (see <code><a href="GL2.Node.html#getColor">getColor()</a></code> and <code><a href="GL2.Node.html#getAlpha">getAlpha()</a></code>). 
	 * Child nodes that contain drawable derived classes from 
	 * <code>Node</code> inherit these attributes.
	 * As a result, setting the <code>Color</code> for a parent node affects the color of every child node through multiplication
	 * of color components.</p>
	 * <p>Classes derived from Node include:</p>
	 * <div class="ul">
	 * <li>{@link GL2.Primitive}</li>
	 * <li>{@link GL2.Sprite}</li>
	 * <li>{@link GL2.Text}</li>
	 * </div>
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 */
    initialize: function()
    {
		Core.ObjectRegistry.register(this);
        this._parent = null;
        this._position = new Core.Point();
        this._scale = new Core.Vector(1, 1);
        this._color = new Core.Color(1, 1, 1);
        this._alpha = 1;
        this._rotation = 0;
        this._depth = 0;
        this._visible = true;
        this._touchable = true;
		
        this._childrenDepthGrouped = true;
        this._children = [];
		
		this._createSendGen(this.__objectRegistryId);
    },

	/**
	 * The default destructor. Calling <code>destroy()</code> removes the node from the parent, which releases the
	 * native object on the backend. 
	 * <br><br>
	 * <b>Note:</b> Applications must call this explicitly for nodes that are no longer
	 * used.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
		children = this._children;
		while(children.length)
		{
			this.removeChild(children[0]);
		}
			
		if(this._parent)
		{
			this._parent.removeChild(this);
		}
		
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Retrieve the position of this <code>Node</code>.
	 * @returns {Core.Vector} The current node position relative to the parent.
	 * @see GL2.Node#setPosition
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getPosition: function()
	{
		return this._position;
	},
	
	/**
	 * Retrieve the <i>width</i> and <i>height</i> scale multiple of this <code>Node</code>. 
	 * The default scale <code>[1,1]</code> will not modify the resulting transform.
	 * @returns {Core.Vector} The current scale multiple (<i>width</i> and <i>height</i>).
	 * @see GL2.Node#setScale
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getScale: function()
	{
		return this._scale;
	},

	/**
	 * Retrieve the <code>Color</code> component of this <code>Node</code>. Values for <code>Color</code> are based on the RGB color model. 
	 * When drawing, the values for <code>Color</code> are multiplied by the value of each drawable pixel. Child nodes will multiply
	 * the values for <code>Color</code> by the parent composite color before drawing. 
	 * @returns {Core.Color} The current value of all three color components (red, green, blue).
	 *<br><br>
	 * <b>Note:</b> The default RGB triplet <code>[1,1,1]</code> does not produce a color change.
	 * @see Core.Color, 
	 * @see GL2.Node#setColor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getColor: function()
	{
		return this._color;
	},

	/**
	 * Retrieve the <cod>alpha</code> components of this <code>Node</code>.
	 * @returns {Number} The new alpha blending state across the open interval ranging between <code>(0-1)</code>. 
	 * (0 = completely transparent, 1 = completely opaque). Expressed as a float.
	 * @see GL2.Node#setAlpha
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAlpha: function()
	{
		return this._alpha;
	},

	/**
	 * Retrieve the <code>rotation</code> component for this <code>Node</code>.
	 * The default value is 0 degrees about the z-axis.
	 * @returns {Number} The current degree of rotation. Expressed as a float.
	 * @see GL2.Node#setRotation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getRotation: function()
	{
		return this._rotation;
	},

	/**
	 * Retrieve the <code>depth</code> component for this <code>Node</code>.
	 * The default value is <code>0</code>.
	 * Applications will sort nodes with identical depth values by the last 
	 * time the node was attached to the root node graph.
	 * @returns {Number} The current node depth level (z-order). Expressed as a float.
	 * @see GL2.Root and 
	 * @see GL2.Node#setDepth
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getDepth: function()
	{
		return this._depth;
	},

	/**
	 * Retrieve the <code>visible</code> component for this <code>Node</code>.
	 * This component defines visibility of the node.
	 * The default value is <code>true</code>.<br><br>
	 * <b>Note:</b> A node can inherit the value of this component from parent nodes in the scene graph.
	 * @returns {Boolean} Returns <code>true</code> if the node is visible. Returns <code>false</code> in all other cases.
	 * @see GL2.Node#setVisible
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getVisible: function()
	{
		return this._visible;
	},

	/**
	 * Retrieve the <code>touchable</code> component for this <code>Node</code>.
	 * This component defines touch-support for a node.
	 * The default value is <code>true</code>.<br><br>
	 * <b>Note:</b> A node can inherit "not touchable" from parent nodes in the scene graph.
	 * @returns {Boolean} Returns <code>true</code> if a node is touchable. Returns <code>false</code> in all other cases.
	 * @see GL2.Node#setTouchable
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getTouchable: function()
	{
		return this._touchable;
	},
	

	/**
	 * Retrieve <code>childrenDepthGrouped</code> component of this <code>Node</code>.
	 * The default value is <code>true</code>.
	 * When <code>childrenDepthGrouped</code> is <code>false</code>, child nodes sort amongst (interleave 
	 * with) the children of the nearest depthgrouped ancestor.
	 * @returns {Boolean} Returns as <code>true</code> if sorting with ancestor siblings. Returns as <code>false</code> if sorting only with siblings in the graph.
	 * @see GL2.Node#setChildrenDepthGrouped
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getChildrenDepthGrouped: function()
	{
		return this._childrenDepthGrouped;
	},
	
	/**
	 * Retrieve the parent node for this <code>Node</code>.
	 * @returns {GL2.Node} The current parent node.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getParent: function()
	{
		return this._parent;
	},

	/**
	 * Retrieve a copy of the child array for this <code>Node</code>.
	 * @returns {Array GL2.Node} The current list of child nodes.
	 * @status 
	 */
	getChildren: function()
	{
		return this._children.slice();
	},
	
    /**
	 * Set the <code>translation</code> component of the transform for this <code>Node</code>.
	 * You can define the parameter value as a vector or two floats.<br><br>
	 * <b>Note:</b> An application can use this property to translate a group of nodes by
	 * translating the parent. Child nodes inherit this property from the parent node.<br/><br/>
	 * The following code examples illustrate different call styles for <code>setPosition()</code>.<br><br>
	 * 
	 * @example
	 * node.setPosition(new Core.Vector(50, 100));
	 *
	 * @example
	 * node.setPosition(50, 100);
	 * 
	 * @param {Core.Vector} position The new node position relative to the parent.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getPosition,
	 * @see Core.Vector
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setPosition: function(position)
	{
		var p = this._position;
		p.setAll.apply(p, arguments);
		this._setPositionSendGen(p.getX(),p.getY());
		return this;
	},
	
    /**
	 * Set the <i>x</i> and <i>y</i> scale of the transform for this <code>Node</code>.<br><br>
	 * <b>Note:</b> This property affects the coordinate system of child nodes and scales drawing for
	 * derived classes like <code>Sprite</code>, <code>Text</code>, and <code>Primitive</code>.
	 * <br><br>
	 * The following code examples illustrate different call styles for <code>setScale()</code>.<br><br>
	 * 
	 * @example
	 * node.setScale(new Core.Vector(2, 0.5));
	 *
	 * @example
	 * node.setScale(2, 0.5);
	 * 
	 * @param {Core.Vector} scale The new scale multiple (<i>width</i> and <i>height</i>). You can define the parameter value as a vector or two floats.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getScale, 
	 * @see GL2.Primitive, 
	 * @see GL2.Sprite, 
	 * @see GL2.Text
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setScale: function(scale)
	{
		var s = this._scale;
		s.setAll.apply(s, arguments);
		this._setScaleSendGen(s.getX(),s.getY());
		return this;
	},
	/**
	 * Set the color for the specified entity. Call this method either by reference to a single vector object  
	 * or by defining three float parameters.
	 * Every color pixel value for the entity is multiplied by the value of the parameter before drawing.
	 * <br><br>
	 * <b>Example:</b> If you specify an entity to draw an orange pixel <code>(1.0, 0.5, 0)</code>,
	 * but the entity color is purple <code>(0.5, 0, 1.0)</code>, the resulting pixel color is
	 * <code>(0.5, 0, 0)</code>, which is dark red. The application conducts this efficiently for each pixel in the
	 * entity.<br><br>
	 * The following code examples illustrate different call styles for <code>setColor()</code>.<br><br>
	 * 
	 * @example
	 * node.setColor(new Core.Color(1.0, 0.5, 0));
	 *
	 * @example
	 * node.setColor(1.0, 0.5, 0);
	 * 
	 * @param {Core.Color} color Pixel color value to muliply by the entity color value.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Core.Color, 
	 * @see GL2.Node#getColor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setColor: function(color)
	{
		var c = this._color;
		c.setAll.apply(c, arguments);
		this._setColorSendGen(c.getRed(),c.getGreen(),c.getBlue());
		return this;
	},
    /**
	 * Set the alpha blending state for the entity.
	 * Each pixel of the entity blends with the underlying surface. This occurs in proportion to the alpha blending state of the entity.
	 * The application must set the parameter value within the open interval <code>[0, 1]</code>.
	 * <br><br>
	 * <b>Example:</b> Drawing a red entity with an alpha of <code>0.5</code> over a white background results in a light pink entity. 
	 * Drawing an orange pixel <code>(1.0, 0.5, 0)</code> with an alpha of <code>0.66</code> over
	 * a light blue surface <code>(0.0, 1.0, 1.0)</code>, results in a light brown pixel:
	 * @example (1.0, 0.5, 0) * 0.66 + (0.0, 1.0, 1.0) * 0.34 = (0.6, 0.67, 0.34)
	 * @param {Number} alpha The new alpha blending state for the entity ranging between <code>(0-1)</code> 
	 * (0 = completely transparent, 1 = completely opaque). Expressed as a float.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getAlpha
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setAlpha: function(alpha)
	{
		this._alpha = alpha;
		this._setAlphaSendGen(alpha);
		return this;
	},
	
    /**
	 * Set the transform rotation (in degrees) for this <code>Node</code>.<br><br> 	 
	 * <b>Note:</b> This property affects the coordinate system of child nodes and rotates drawing for
	 * derived classes like <code>Sprite</code>, <code>Text</code>, and <code>Primitive</code>.
	 * <br><br>
	 * The following code examples illustrate different call styles for <code>setRotation()</code>.<br><br>
	 * 
	 * Rotate entity 90 degrees.
	 * <pre class="code">node.setRotation(90);</pre> 
	 * Restore entity to original orientation.
	 * <pre class="code">node.setRotation(0);</pre>
	 * Convert radians to degrees.
	 * <pre class="code">var radians = 0.785;
	 * var degrees = radians * Math.PI / 180;</pre>
	 * Convert degrees to radians.
	 * <pre class="code">var degrees = 90;
	 * var radians = degrees * 180 / Math.PI;</pre>
	 *
	 * @param {Number} rotation The new rotation of the entity relative to the parent (in degrees). Expressed as a float.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getRotation, 
	 * @see GL2.Primitive, 
	 * @see GL2.Sprite, 
	 * @see GL2.Text
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setRotation: function(rotation)
	{
		this._rotation = rotation;
		this._setRotationSendGen(rotation);
		return this;
	},
	
    /**
	 * Set the <code>depth</code> component for this <code>Node</code>.
	 * This property affects how a node is sorted when the scene is traversed. Different depth-levels affect
	 * both drawing order (back to front, low to high) and touch priority (front to back,
	 * high to low).<br><br>
	 * <b>Note:</b> Use <code>{@link GL2.Node#setChildrenDepthGrouped}</code> to set how a node will sort with siblings.
	 * @example node.setDepth(20);
	 * @param {Number} depth The new depth for the entity (z-order). Expressed as a float.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getChildrenDepthGrouped, 
	 * @see GL2.Node#setChildrenDepthGrouped
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setDepth: function(depth)
	{
		if(this._depth != depth)
		{
			this._depth = depth;
			this._setDepthSendGen(depth);
		}
		return this;
	},
	
    /**
	 * Set the <code>visible</code> component for this <code>Node</code>.
	 * This component defines visibility of the node.
	 * The default value is <code>true</code>.<br><br>
	 * <b>Note:</b> A node can inherit the value of this component from parent nodes in the scene graph.
	 * @example node.setVisible(true);
	 * @param {Boolean} [visible=true] Set as <code>true</code> if a node is visible.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getVisible
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setVisible: function(visible)
	{
		if(this._visible != visible)
		{
			this._visible = visible;
			this._setVisibleSendGen(visible);
		}
		return this;
	},
	
    /**
	 * Set this <code>Node</code> to support touches.
	 * The <code>touchable</code> property is Boolean and defines a node as supporting touch input.
	 * A node can inherit the value of <code>touchable</code> from parent nodes in the scene graph.<br><br> 
	 * <b>Caution!</b> Instantiating touchable <code>GL2.Node</code> objects will impact performance 
	 * much more than instantiating <code>GL2.Node</code> objects that do not support touch input. If
	 * a node does not need to support touch input, set <code>touchable</code> to <code>false</code>.
	 * @example node.setTouchable(false);
	 * @param {boolean} [touchable=true] Set as <code>true</code> if this node supports touch input.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getTouchahble
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setTouchable: function(touchable)
	{
		this._touchable = touchable;
		this._setTouchableSendGen(touchable);
		return this;
	},
    
	/**
	 * Set whether to sort child nodes adjacent to this <code>Node</code>.
	 * When <code>childrenDepthGrouped</code> is <code>false</code>, the child nodes interleave 
	 * with the children of the nearest similarly grouped ancestor. Applications can use this to sort a distant node
	 * on an independent branch of the graph in close proximity.<br/><br/>
	 * <b>Example:</b> You have multiple group nodes containing a character sprite and a 
	 * shadow sprite. By setting all the shadow sprites to a <code>depth</code> of <code>1</code>, all character sprites to
	 * a <code>depth</code> of <code>2</code>, and setting <code>childrenDepthGrouped</code> to <code>false</code> for each group node, all character sprites will 
	 * sort above shadows when drawn.<br><br>
     * Look at the following structure of nodes.
     * If <code>childrenDepthGrouped</code> is <code>true</code> for the group, the primitive will
     * draw above both the sprite and the text. However, if <code>false</code>,
     * the primitive will draw after the sprite but before the text.
     * <pre class="code">
     * Root
     * +-- Group (depth = 0)
     * |   +-- Sprite (depth = 10)
     * |   +-- Text (depth = -10)
     * |
     * +-- Primitive (depth = 5)
     * </pre>
	 * @param {Boolean} childrenDepthGrouped Set as <code>true</code> to sort with ancestor siblings. Set as <code>false</code> to sort only with siblings in the graph.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#getChildrenDepthGrouped
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setChildrenDepthGrouped: function(childrenDepthGrouped)
	{
		if(this._childrenDepthGrouped != childrenDepthGrouped)
		{
			this._childrenDepthGrouped = childrenDepthGrouped;
			this._setChildrenDepthGroupedSendGen(childrenDepthGrouped);
		}
		return this;
	},
	
	/**
	 * Add a node as a child to this <code>Node</code>.
	 * @example node.addChild(this.mySprite);
	 * @param {GL2.Node} child The child node to add.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#removeChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	addChild: function(child)
	{
		// Add to children list.
		this._children.push(child);
		
		// Tell child.
		child._didAddToParent(this);
		
		this._addChildSendGen(Core.ObjectRegistry.objectToId(child));
		
		return this;
	},
	
	/**
	 * Remove a specified child node and its subtree from this <code>Node</code>.
	 * @example node.removeChild(this.mySprite);
	 * @param {String} child The child node to remove from the current entity.
	 * @throws {removeChild called for a node that is not a child} Specified node is not a child node.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node#addChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	removeChild: function(child)
	{
		// Tell child.
		child._willRemoveFromParent();
		
		// Remove from children list.
		var index = this._children.indexOf(child);
		if(index == -1)
			throw new Error('removeChild called for a node that is not a child');
		this._children.splice(index, 1);
		
		this._removeChildSendGen(Core.ObjectRegistry.objectToId(child));
		
		return this;
	},
	
	/**
	 * Convert the relative location of a scene to the local coordinate space for this <code>Node</code>.
	 * @example var p = Game.getRoot().screenToLocal(touch.getPosition());
	 * @param {Core.Vector} location The relative location for a scene.
	 * @see GL2.Node#localToScreen
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	screenToLocal: function(location)
	{
		var parent = this._parent;
		if(!parent)
			return undefined;
			
		location = parent.screenToLocal(location);
		if(!location)
			return undefined;
		
		var x = location.getX();
		var y = location.getY();
		
		// Undo translation.
		var p = this._position;
		x -= p.getX();
		y -= p.getY();
		
		// Undo rotation.
		var r = this._rotation * Math.PI / 180;
		var cosr = Math.cos(r);
		var sinr = Math.sin(r);
		var tx = cosr*x + sinr*y;
		var ty = -sinr*x + cosr*y;
		x = tx;
		y = ty;
		
		// Undo scale.
		var s = this._scale;
		x /= s.getX();
		y /= s.getY();
		
		return new Core.Point(x, y);
	},
	
	/**
	 * Convert a location within the local coordinate space for this <code>Node</code> to a location within the screen coordinate
	 * space.
	 * @param {Core.Vector} location A location in the local transform for this <code>Node</code>.
	 * @see GL2.Node#screenToLocal
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	localToScreen: function(location)
	{
		var x = location.getX();
		var y = location.getY();
		
		// Undo scale.
		var s = this._scale;
		x *= s.getX();
		y *= s.getY();
		
		// Undo rotation.
		var r = -this._rotation * Math.PI / 180;
		var cosr = Math.cos(r);
		var sinr = Math.sin(r);
		var tx = cosr*x + sinr*y;
		var ty = -sinr*x + cosr*y;
		x = tx;
		y = ty;
		
		// Undo translation.
		var p = this._position;
		x += p.getX();
		y += p.getY();
		
		var parent = this._parent;
		if(!parent)
			return undefined;
		
		location = parent.localToScreen(new Core.Point(x, y));
		if(!location)
			return undefined;
		return location;
	},
	
	_didAddToParent: function(parent)
	{
		if(this._parent)
			this._parent.removeChild(this);
		
		this._parent = parent;
	},
	
	_willRemoveFromParent: function()
	{
		this._parent = null;
	},
	
	_synchronizeNodeRecv: function( cmd )
	{
		var msg = {};
		if(!this._synchronizeNodeRecvGen(cmd, msg))
			return;
		this._position.setAll(msg.x, msg.y);
		this._rotation = msg.rotation;
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 307
	// Method create = -1
	// Method destroy = 2
	// Method setPosition = 3
	// Method setScale = 4
	// Method setColor = 5
	// Method setAlpha = 6
	// Method setRotation = 7
	// Method setDepth = 8
	// Method setVisible = 9
	// Method setTouchable = 10
	// Method setChildrenDepthGrouped = 11
	// Method addChild = 12
	// Method removeChild = 13
	// Method synchronizeNode = 14
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 14:
					instance._synchronizeNodeRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Node._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Node._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[307] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_synchronizeNodeRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 3 )
		{
			NgLogE("Could not parse due to wrong argument count in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 0 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 1 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		obj[ "rotation" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "rotation" ] === undefined )
		{
			NgLogE("Could not parse rotation in Node.synchronizeNode from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":307,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":307,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_setPositionSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( ":307,3," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	_setScaleSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( ":307,4," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	_setColorSendGen: function( red, green, blue )
	{
		Core.Proc.appendToCommandString( ":307,5," + this.__objectRegistryId + "," + red + "," + green + "," + blue  );
	},
	
	/** @private */
	_setAlphaSendGen: function( alpha )
	{
		Core.Proc.appendToCommandString( ":307,6," + this.__objectRegistryId + "," + alpha  );
	},
	
	/** @private */
	_setRotationSendGen: function( rotation )
	{
		Core.Proc.appendToCommandString( ":307,7," + this.__objectRegistryId + "," + rotation  );
	},
	
	/** @private */
	_setDepthSendGen: function( depth )
	{
		Core.Proc.appendToCommandString( ":307,8," + this.__objectRegistryId + "," + depth  );
	},
	
	/** @private */
	_setVisibleSendGen: function( visible )
	{
		Core.Proc.appendToCommandString( ":307,9," + this.__objectRegistryId + "," + ( visible ? 1 : 0 )  );
	},
	
	/** @private */
	_setTouchableSendGen: function( touchable )
	{
		Core.Proc.appendToCommandString( ":307,10," + this.__objectRegistryId + "," + ( touchable ? 1 : 0 )  );
	},
	
	/** @private */
	_setChildrenDepthGroupedSendGen: function( childrenDepthGrouped )
	{
		Core.Proc.appendToCommandString( ":307,11," + this.__objectRegistryId + "," + ( childrenDepthGrouped ? 1 : 0 )  );
	},
	
	/** @private */
	_addChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( ":307,12," + this.__objectRegistryId + "," + child  );
	},
	
	/** @private */
	_removeChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( ":307,13," + this.__objectRegistryId + "," + child  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setPosition: function( x, y ) {}
	
	// setScale: function( x, y ) {}
	
	// setColor: function( red, green, blue ) {}
	
	// setAlpha: function( alpha ) {}
	
	// setRotation: function( rotation ) {}
	
	// setDepth: function( depth ) {}
	
	// setVisible: function( visible ) {}
	
	// setTouchable: function( touchable ) {}
	
	// setChildrenDepthGrouped: function( childrenDepthGrouped ) {}
	
	// addChild: function( child ) {}
	
	// removeChild: function( child ) {}
	
	// _synchronizeNodeRecv: function( cmd ) {}

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Primitive'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Primitive'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Primitive'] = exports; var Node = require('NGCore/Client/GL2/Node').Node;
var Animation = require('NGCore/Client/GL2/Animation').Animation;
var Core = require('NGCore/Client/Core').Core;

exports.Primitive = Node.subclass(
/** @lends GL2.Primitive.prototype */
{
	classname: 'Primitive',
    
	/**
	 * @class The <code>Primitive</code> class constructs objects that draw arbitrary vertex-based geometry.
	 * These objects provide a means of drawing raw 2D <a href="GL2.Primitive.Vertex.html">vertex</a> data as polygons to a <code>{@link UI.View}</code>. Data is
	 * provided by users as a vertex list. 
	 * @constructs The default constructor. 
	 * @augments GL2.Node
	 */
    initialize: function()
    {
        this._animation = null;
		this._ownsAnimation = false;
		
		this._animationCompleteEmitter = new Core.MessageEmitter();
        this._type = this.Type.Triangles;
        this._vertexes = [];
    },

	/**
	 * The default destructor.
	 * This call cleans up any attached <code>Animation</code> and <code>AnimationCompleteEmitter</code>.
	 * @see GL2.Animation
	 * @status iOS, Android, Flash
	 */
	destroy: function()
	{
		this._tryDestroyAnimation();
		this._animationCompleteEmitter.destroy();
	},
	
	/**
	 * Retrieve the number of listed vertices in the geometry of this <code>Primitive</code>.
	 * @returns {Number} The current number of vertices.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getVertexCount: function()
	{
		return this._vertexes.length;
	},
	
	/**
	 * Retrieve a single vertex from the vertex list of this <code>Primitive</code>.
	 * @param {Number} index The vertex list offset to retrieve.
	 * @returns {GL2.Primitive.Vertex} The current vertex at the specified index in the vertex list.
	 * @see GL2.Primitive#setVertex
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getVertex: function(index)
	{
		return this._vertexes[index];
	},
	
	/**
	 * Retrieve the GL draw mode for this <code>Primitive</code>.
	 * @returns {GL2.Primitive#Type} The current draw mode.
	 * @see GL2.Primitive#setType
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getType: function()
	{
		return this._type;
	},
	
	/**
	 * Retrieve the current <code>Texture Animation</code> object of this <code>Primitive</code>.
	 * @returns {GL2.Animation} The current animation.
	 * @see GL2.Primitive#setAnimation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAnimation: function()
	{
		if(this._ownsAnimation) return null;
		
		return this._animation;
	},
	
	/**
	 * Retrieve the complete message emitter for the current animation.
	 * @returns {Core.MessageEmitter} The emitter for the current texture animation.
	 * @see GL2.Animation,  
	 * @see Core.MessageEmitter
	 * @status iOS, Android, Flash
	 */
	getAnimationCompleteEmitter: function()
	{
		return this._animationCompleteEmitter;
	},
    
	/**
	 * Begin playing the specified animation.
	 * Any animation that is not set to loop will trigger the animation complete callback when done.
	 * @example primitive.setAnimation(myAnimation, 30);
	 * @param {GL2.Animation} animation The current animation.
	 * @param {Number} [startTime=0] The starting point of the animation. Expressed as a float.<br><br>
	 * <b>Example:</b> If <code>setAnimation()</code> is called with a <code>startTime</code> equal to half the total duration of the animation, 
	 * playback begins half way through the animation.
	 * @see GL2.Primitive#getAnimation
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setAnimation: function(animation, startTime)
	{
		this._tryDestroyAnimation();
		this._animation = animation;
		
		this._setAnimationSendGen( Core.ObjectRegistry.objectToId(animation), startTime || 0 );
	},
    
    /**
	 * Set a static image as the current animation for this <code>Primitive</code>.
	 * This method instantiates a single frame animation of infinite duration using the
	 * specified image. If the primitive is playing another animation at the time of this call, 
	 * the new animation will take priority over the primitive.
	 * The previous animation will stop and the complete emitter will not respond. 
	 * This is because the animation did not technically complete a full playback cycle. <br><br>
	 * You can define optional parameters for the size, anchor, and UV coordinates of the specified image. 
	 * @example primitive.setImage('./Content/blank.png', [480, 320], [0, 0]);
	 * @param {String} image The directory path to an image referenced by a frame.
	 * @param {Core.Size} [size] The size of the image to display in pixels.
	 * @param {Core.Point} [anchor] The anchor coordinates that indicate the image center in the animation.
	 * @param {Core.Rect} [uvs] The UV coordinates used to specify the subset of an image.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Animation, 
	 * @see GL2.Animation.Frame
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setImage: function(image, size, anchor, uvs)
	{
		this._tryDestroyAnimation();
		
		// Create a single frame animation.
		var args = Array.prototype.slice.call(arguments, 0);
		args.splice(1, 0, 0); // Insert a duration of zero into our arguments.
		var frame = new Animation.Frame();
		frame.constructor.apply(frame, args);
		var animation = new Animation();
		animation.pushFrame(frame);
		
		this._animation = animation;
		this._ownsAnimation = true;
		
		this._setAnimationSendGen(Core.ObjectRegistry.objectToId(animation),0);
		
		return this;
	},
    
    /**
	 * Set the type of geometry on display for this <code>Primitive</code>.
	 * @example primitive.setType(GL2.Primitive.Type.TriangleFan);
	 * @param {GL2.Primitive#Type} type The new GL draw mode.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setType: function(type)
	{
		this._type = type;
		
		this._setTypeSendGen(type);
		
		return this;
	},
    
    /**
     * Add a vertex to the end of the vertex list for this <code>Primitive</code>.<br>
     * <pre class="code"><font size="2">primitive.pushVertex(new Core.Point(w*2/10, h*5/6));</font></pre><br>
     * Calling <code>pushVertex()</code> is equivalent to calling <code>spliceVertexes()</code> in the following way:
     * <pre class="code"><font size="2">primitive.spliceVertexes(primitive.getVertexCount(), 0, vertex);</font></pre>
     * @param {GL2.Primitive.Vertex} vertex The vertex to add.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    pushVertex: function(vertex)
	{
		return this.spliceVertexes(this._vertexes.length, 0, vertex);
	},
    
    /**
	 * Set the vertex at index <i>i</i> for this <code>Primitive</code>.
	 * Calling <code>setVertex()</code> is equivalent to calling <code>spliceVertexes()</code> in the following way:
	 * @example primitive.spliceVertexes(i, 1, vertex)
	 * @param {Number} <i>i</i> The index in the vertex list to set.
	 * @param {GL2.Primitive.Vertex} vertex The new vertex.
	 * @see GL2.Primitive#getVertex
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setVertex: function(i, vertex)
	{
		return this.spliceVertexes(i, 1, vertex);
	},
    
    /**
	 * Replace <code>len</code> vertices, starting at position <code>start</code>, with specified vertices.<br><br>
	 * The following are examples of different call styles for <code>spliceVertexes</code>.<br><br>
	 * Splice a simple textureless quad into the vertex list.
	 * <pre class="code"><font size="2">var c = new Core.Color([1,1,1]);
	 * var w = 100;
	 * var h = 100;
	 * var v = new Array();
	 * v.push(new GL2.Primitive.Vertex([0,0],[0,0],c));
	 * v.push(new GL2.Primitive.Vertex([w,0],[0,0],c));
	 * v.push(new GL2.Primitive.Vertex([w,h],[0,0],c));
	 * v.push(new GL2.Primitive.Vertex([0,h],[0,0],c));</font></pre>
	 * Insert four vertices at position 0 in the vertex list.
	 * <pre class="code"><font size="2">myPrimitive.spliceVertexes.apply(myPrimitive, ([0,0]).concat(v));
	 * myPrimitive.setType(GL2.Primitive.Type.TriangleFan);</font></pre>
	 * @param {Number} start The index from which to remove vertices in the vertex list.
	 * @param {Number} len The number of vertices to replace.
	 * @param {GL2.Primitive.Vertex} vertexes A list of vertices to insert at the start location.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    spliceVertexes: function(start, len, vertexes)
	{
		this._vertexes.splice.apply(this._vertexes, arguments);
		
		var vertexCount = arguments.length-2;
		this._spliceVertexesSendGen(start,len,vertexCount);
		
		for(var i=0; i < vertexCount; ++i)
		{
			var vertex = arguments[i+2];
			var position = vertex.getPosition();
			var uv = vertex.getUV();
			var color = vertex.getColor();
			this._vertexSendGen(
				position.getX(),
				position.getY(),
				uv.getX(),
				uv.getY(),
				color.getRed(),
				color.getGreen(),
				color.getBlue()
			);
		}
		
		return this;
	},

	$Vertex: Core.Class.subclass(
	/** @lends GL2.Primitive.Vertex.prototype */
	{
		classname: 'Vertex',
		
		/**
		 * @class <code>Vertex</code> objects specify location, texture coordinates, and color data
		 * for GL primitive geometry.
		 * @constructs The default constructor. 
		 * @param {Core.Vector|float[2]} position A location.
		 * @param {Core.Vector|float[2]} uv A texture coordinate.
		 * @param {Core.Color|float[3]} color An RGB color triplet.
		 * @see GL2.Primitive
		 * @augments Core.Class
		 */
		initialize: function(position, uv, color)
		{
			this._position = new Core.Point(position);
			this._uv = new Core.Point(uv);
			this._color = new Core.Color(color);
		},
		
		/**
		 * Retrieve the location of this <code>Vertex</code>.
		 * @returns {Core.Vector} The current <i>x</i>,<i>y</i> coordinates for the vertex.
    	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getPosition: function()
		{
			return this._position;
		},
		
		/**
		 * Retrieve the texture coordinates of this <code>Vertex</code>.
		 * @returns {Core.Vector} The current <i>x</i>,<i>y</i> coordinates for the texture.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getUV: function()
		{
			return this._uv;
		},
		
		/**
		 * Retrieve the color of this <code>Vertex</code>.
		 * @returns {Core.Color} The current vertex color as a RGB triplet.
		 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
		 */
		getColor: function()
		{
			return this._color;
		},
	}),
	
	_tryDestroyAnimation: function()
	{
		if(this._ownsAnimation)
		{
			// Set our animation to NULL to unlink ourselves from the animation on the backend
			// or else trying to destory the animation will fail because we are still using it.
			this._setAnimationSendGen(0,0);
		
			this._animation.destroy();
			this._animation = null;
			this._ownsAnimation = false;
		}
		this._animation = null;
		this._image = null;
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Enumeration for primitive types.
	 * @namespace
	 */
	Type:
	{ 
		/** Every three vertices define a unique triangle. */
		Triangles: 0,
		/** Every vertex defines a triangle with the 2 preceding vertices. */
		TriangleStrip: 1,
		/** Every vertex defines a triangle with the first vertex and the previous vertex. */
		TriangleFan: 2,
		/** Every vertex pair defines a line segment. */
		LineList: 3,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 308
	// Method create = -1
	// Method spliceVertexes = 2
	// Method vertex = 3
	// Method setType = 4
	// Method setAnimation = 5
	// Method animationComplete = 6
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 6:
					instance._animationCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Primitive._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Primitive._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[308] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_animationCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Primitive.animationComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":308,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_spliceVertexesSendGen: function( start, len, vertexCount )
	{
		Core.Proc.appendToCommandString( ":308,2," + this.__objectRegistryId + "," + start + "," + len + "," + vertexCount  );
	},
	
	/** @private */
	_vertexSendGen: function( x, y, u, v, red, green, blue )
	{
		Core.Proc.appendToCommandString( "," + x + "," + y + "," + u + "," + v + "," + red + "," + green + "," + blue  );
	},
	
	/** @private */
	_setTypeSendGen: function( type )
	{
		Core.Proc.appendToCommandString( ":308,4," + this.__objectRegistryId + "," + type  );
	},
	
	/** @private */
	_setAnimationSendGen: function( animation, startTime )
	{
		Core.Proc.appendToCommandString( ":308,5," + this.__objectRegistryId + "," + animation + "," + startTime  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// spliceVertexes: function( start, len, vertexCount ) {}
	
	// vertex: function( x, y, u, v, red, green, blue ) {}
	
	// setType: function( type ) {}
	
	// setAnimation: function( animation, startTime ) {}
	
	// _animationCompleteRecv: function( cmd ) {}

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Touch'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Touch'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Touch'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.Touch = Core.Class.subclass(
/** @lends GL2.Touch.prototype */
{
	classname: 'Touch',
	
	/**
	 * @class The <code>Touch</code> class constructs objects that identify and track the life cycle of unique touch events in the system.
	 * @constructs These objects are constructed by the system.
	 * @augments Core.Class
	 */
	initialize: function()
	{
		this._id = 0;
		this._action = {};
		this._position = new Core.Point();
		this._targetIds = null;
	},
	
	/**
	 * Retrieve a list of every <code>TouchTarget</code> object in which this <code>Touch</code> object resides and is marked as touchable.
	 * @returns {GL2.TouchTarget} A prioritized list of every <code>TouchTarget</code> for this <code>Touch</code>.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getTouchTargets: function()
	{
		var ids = this._targetIds;
		var result = [];
		for(var i in ids)
		{
			var t = Core.ObjectRegistry.idToObject(i);
			if(t) result.push(t);
		}
		return result;
	},
	
	/**
	 * Retrieve whether or not this <code>Touch</code> object resides in the specified <code>TouchTarget</code>.
	 * @param {GL2.TouchTarget} touchTarget The <code>TouchTarget</code> to test against.
	 * @returns {Boolean} Returns <code>true</code> when this <code>Touch</code> resides in the <code>TouchTarget</code>.
	 * @status iOS, Android, Flash
	 */
	getIsInside: function(touchTarget)
	{
		// Check if the object's id is in the touchtargets map
		return ( Core.ObjectRegistry.objectToId(touchTarget) in this._targetIds);
	},
	
	/**
	 * Retrieve the location of this <code>Touch</code> object in the global coordinate space.
	 * @returns {Core.Vector} The global coordinates of the <code>Touch</code> location.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getPosition: function()
	{
		return this._position;
	},
	
	/**
	 * Retrieve the ID of this <code>Touch</code> object.
	 * <b>Note:</b> When using this ID as a key, append it to a string so that you can use
	 * it to key an associative array. Otherwise, you will end up with a very large array.
	 * @returns {Number} The current <code>Touch</code> ID.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getId: function()
	{
		return this._id;
	},
	
	/**
	 * Retrieve the phase of this <code>touch</code> event.
	 * Use this method from your listener callback.
	 * The following is an example of a <code>touch</code> event handler for a button.
	 * @example
	 * onTouch: function(touch)
	 * {
	 * 	//getAction() informs us of the type of event being handled.
	 * 	//  In order to get Action.Move and Action.End, we need to return true from Action.Start.
	 * 	switch(touch.getAction())
	 * 	{
	 * 		case touch.Action.Start:
	 * 			//Change the color of our Rectangle
	 * 			this.button.setColor(Defaults.onColor);
	 * 			
	 * 			//Return true here if you want to capture this event for its lifetime.
	 * 			//  returning false will let other, lower priority handlers capture the
	 * 			//  event. In that case we would not want to react to the Action.Start since
	 * 			//  we would not get subsequent Action.End or Action.Move.
	 * 			return true;
	 * 			
	 * 		case touch.Action.End:
	 * 			//Reset the color of our Rectangle
	 * 			this.button.setColor(Defaults.offColor);
	 * 			
	 * 			//We do not need to return anything in Action.End or Action.Move.
	 * 			break;
	 * 		case touch.Action.Move:
	 * 			//The touch object allows us to retrieve metadata about the event.
	 * 			//  If the touch has left our bounds, getIsInside() will return false.
	 * 			if(!touch.getIsInside(this._target))
	 * 			{
	 * 				//If the active touch is outside, reset our Rectangle color.
	 * 				this.button.setColor(Defaults.offColor);
	 * 			}
	 * 			else
	 * 			{
	 * 				//If the active touch is inside, set our Rectangle color to on.
	 * 				this.button.setColor(Defaults.onColor);
	 * 			}
	 * 			break;
	 * 	}
	 * }
	 * @returns {GL2.Touch#Action} The current <code>touch</code> event phase.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAction: function()
	{
		return this._action;
	},
	
	_setId: function(id)
	{
		this._id = id;
	},
	
	_setAction: function(action)
	{
		this._action = action;
	},
	
	_setPosition: function(position)
	{
		this._position.setAll(arguments);
	},
	
	_setTargetIds: function(targetIds)
	{
		// We transfer the array of numeric target IDs into a
		// map so we can support getIsInside call which uses 'in'.
		this._targetIds = {};
		for(var i in targetIds)
			this._targetIds[targetIds[i]] = null;
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Enumeration for touch action.
	 * @namespace
	 */
	Action:
	{ 
		/** Finger began touching screen. */
		Start: 0,
		/** Finger stopped touching screen. */
		End: 1,
		/** Finger moved where it is touching the screen. */
		Move: 2,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 312
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Touch._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Touch._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[312] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	// This class is expected to implement the following methods outside of
	// the generated block:

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/TouchTarget'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/TouchTarget'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/TouchTarget'] = exports; var Node = require('NGCore/Client/GL2/Node').Node;
var Sprite = require('NGCore/Client/GL2/Sprite').Sprite;
var Core = require('NGCore/Client/Core').Core;

exports.TouchTarget = Node.subclass(
/** @lends GL2.TouchTarget.prototype */
{
	classname: 'TouchTarget',
    
	/**
	 * @class <code>TouchTarget</code> class constructs objects that provide applications access to touch events.
	 *<br><br>
	 * A <code>TouchTarget</code> is a node with added size and offset attributes that define a
	 * rectangular area as active. Any <a href"GL2.Touch.html">touch</a> that falls within the active area is broadcast
	 * to the <code>TouchTarget</code> where a <code>MessageListener</code> can respond 
	 * to the event. Attach a listener by calling <code><a href="GL2.TouchTarget.html#getTouchEmitter">getTouchEmitter()</a></code>
	 * to retrieve the emitter.
	 *<br><br>
	 * A <code>TouchTarget</code> is created with a <code>0</code> size and a center offset anchor point <code>(0.5,0.5)</code>.
	 * Set these two properties to define a usable area that supports touch events. Generally,
	 * you set these two values as identical to the values for <code><a href="GL2.Sprite.html">sprite</a></code>, <code><a href="GL2.Text.html">text</a></code>, 
	 * or <code><a href="GL2.Primitive.html">primitive</a></code> and add
	 * the <code>TouchTarget</code> as a child of that visible node with a position of <code>0</code>. The <code>TouchTarget</code> 
	 * inherits the transform for the visible node. 
	 * <br><br>
	 * <b>Note:</b> A <code>TouchTarget</code> is not part of the drawing scene traversal and activates regardless of node
	 * visibility or parent visibility. 
	 * Disable touch support for a node by calling <code><a href="GL2.Node.html#setTouchable">setTouchable()</a></code>.
	 * @constructs The default constructor.
	 * @augments GL2.Node
	 */
    initialize: function()
    {
		this._size = new Core.Size();
		this._anchor = new Core.Point(0, 0);
		this._touchEmitter = new Core.MessageEmitter();
    },
    
	/**
	 * Destroy this instance and release resources on the backend that are associated with this <code>TouchTarget</code> object.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
	},
	
	/**
	 * Return the point size of the <code>TouchTarget</code> area.
	 * @returns {Core.Size} The current size of the <code>TouchTarget</code> area.
	 * @see GL2.TouchTarget#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getSize: function()
	{
		return this._size;
	},
	
	/**
	 * Return the offset values used for scaling and rotating the <code>TouchTarget</code> area.
	 * @returns {Core.Point} The current offset of the target area.
	 * @see GL2.TouchTarget#setAnchor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAnchor: function()
	{
		return this._anchor;
	},
	
	/**
	 * Return the touch emitter for this <code>TouchTarget</code>.
	 * The emitter fires when a captured <code>touch</code> event changes phases. For the initial touch down
	 * phase, this emitter fires when the <code>touch</code> event occurs within the defined touch area. After returning <code>true</code> from
	 * the initial <code>touch</code> event, the emitter fires regardless of where the <code>touch</code> event occurs.<br><br>	 
	 * The following example creates a new <code>TouchTarget</code> in the upper left corner of the scene. 
	 * The listener instance handles the <code>touch</code> events in the <code>onTouch()</code> function.
	 * @example
	 * var target = new GL2.TouchTarget();
	 * target.setAnchor([50,50]);
	 * target.setSize([100,100]);
	 * target.setPosition([50,50]);
	 * 
	 * target.getTouchEmitter().addListener(this, this.onTouch);
	 * 
	 * GL2.Root.addChild(target);
	 * @return {Core.MessageEmitter} The touch emitter for this touch area.
	 * @see GL2.Touch#getAction
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getTouchEmitter: function()
	{
		return this._touchEmitter;
	},
	
    /**
	 * Set the size of this <code>TouchTarget</code> (<i>width</i> and <i>height</i>).
	 * @example this.t = new GL2.TouchTarget();
	 * this.t.setSize(Core.Capabilities.getScreenHeight(), Core.Capabilities.getScreenHeight());
	 * @param {Core.Size} size The new size of the <code>TouchTarget</code> area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setSize: function(size)
	{
		var s = this._size;
		s.setAll.apply(s, arguments);

		this._setSizeSendGen(s.getWidth(),s.getHeight());
		
		return this;
	},
	
    /**
	 * Set the anchor point used to rotate and scale the <code>TouchTarget</code> area.
	 * @example this.t = new GL2.TouchTarget();
	 * this.t.setAnchor(0, 0);
	 * @param {Core.Point} anchor The new anchor point for the <code>TouchTarget</code> area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setAnchor: function(anchor)
	{
		var a = this._anchor;
		a.setAll.apply(a, arguments);
		
		this._setAnchorSendGen(a.getX(),a.getY());
		
		return this;
	},
	
	/**
	 * Translate a global scene location to the local coordinate space.
	 * Use this method when determining <code>touchMoved</code> offsets.
	 * @example var p = Game.getRoot().screenToLocal(touch.getPosition());
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.Vector} location The location to transform.
	 * @status iOS, Android, Flash
	 */
	screenToLocal: function($super, location)
	{
		location = $super(location);
		if(!location)
			return undefined;
		
		var a = this._anchor;
		var s = this._size;
			
		location.setX(location.getX() + a.getX() * s.getWidth());
		location.setY(location.getY() + a.getY() * s.getHeight());
		return location;
	},
	
	/**
	 * Translate a location in the local coordinate space to the global scene coordinate space.
	 * Use this method for translating between local coordinate spaces.
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.Vector} location The location to transform.
	 * @status iOS, Android, Flash
	 */
	localToScreen: function($super, location)
	{
		var a = this._anchor;
		var s = this._size;
			
		location.setX(location.getX() - a.getX() * s.getWidth());
		location.setY(location.getY() - a.getY() * s.getHeight());
		
		location = $super(location);
		if(!location)
			return undefined;
		return location;
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 313
	// Method create = -1
	// Method setSize = 2
	// Method setAnchor = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in TouchTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in TouchTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[313] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":313,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_setSizeSendGen: function( width, height )
	{
		Core.Proc.appendToCommandString( ":313,2," + this.__objectRegistryId + "," + width + "," + height  );
	},
	
	/** @private */
	_setAnchorSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( ":313,3," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setSize: function( width, height ) {}
	
	// setAnchor: function( x, y ) {}
	

// {{/Wg Generated Code}}
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Root'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Root'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Root'] = exports; var Core = require('NGCore/Client/Core').Core;
var Touch = require('NGCore/Client/GL2/Touch').Touch;

exports.Root = Core.Class.singleton(
/** @lends GL2.Root.prototype */
{
	classname: 'Root',
	
	/**
	 * @class The <code>Root</code> class constructs a singleton object that serves as the proxy object for the {@link UI.GLView} node hierarchy.
	 * <code>Root</code> is the root element of the node hierarchy (also known as a scene graph) for <code>GLView</code>.
	 * The <code>Root</code> transform is composed at the upper left corner of the view with a descending <i>y</i> axis.<br><br>
	 * Adding a node to the <code>Root</code> ensures applications include it when determining drawing and touch events.
	 * @constructs The default constructor.
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		
		this._children = [];
		
		this._createSendGen(this.__objectRegistryId);
		
		this._touchTracking = {};
	},
	
	/**
	 * Add a node and the node subtree to the root of the scene graph.
	 * @example var spr = new GL2.Sprite();
	 * ...
	 * GL2.Root.addChild(spr);
	 * @param {GL2.Node} child The node to add.
	 * @see GL2.Root#removeChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	addChild: function(child)
	{
		this._children.push(child);
		child._didAddToParent(this);
		
		this._addChildSendGen(Core.ObjectRegistry.objectToId(child));
	},
	
	/**
	 * Remove the child node and the node subtree from the root of the scene graph.<br><br>
	 * <b>Note:</b> This method will not destroy the node. You can keep or destroy a reference to a node 
	 * if you have no further use for it.
	 * @example GL2.Root.removeChild(spr);
	 * @throws {removeChild called for a node that is not a child} Specified node is not a child node.
	 * @param {GL2.Node} child The node to remove.
	 * @see GL2.Root#addChild
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	removeChild: function(child)
	{
		child._willRemoveFromParent();
		
		var index = this._children.indexOf(child);
		if(index == -1)
			throw new Error('removeChild called for a node that is not a child');
		this._children.splice(index, 1);
		
		this._removeChildSendGen(Core.ObjectRegistry.objectToId(child));
	},
	
	/** 
	 * Translate screen coordinates into node coordinates.
	 * @example var p = Game.getRoot().screenToLocal(touch.getPosition());
	 * @param {Core.Vector} location The screen coordinates to translate.
	 * @returns The location as node coordinates.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	screenToLocal: function(location)
	{
		return location;
	},
	
	/** 
	 * Translate node coordinates into screen coordinates.
	 * @param {Core.Vector} location The node coordinates to translate.
	 * @returns The location as screen coordinates.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	localToScreen: function(location)
	{
		return location;
	},
	
	_onTouchEventRecv: function( cmd )
	{
		var msg = {};
		if(!this._onTouchEventRecvGen(cmd, msg))
			return;
		
		// Build touch object.
		var touchId = msg.touchId;
		var touchAction = msg.touchAction;
		var touch = new Touch();
		touch._setId(touchId);
		touch._setAction(touchAction);
		touch._setPosition(msg.x, msg.y);
		
		// Extract all touch targets.
		var ids = [];
		for(var i=0; i < msg.touchTargetCount; ++i)
		{
			var t = {};
			if(!this._touchTargetRecvGen(cmd, t))
				return;
			// Add an array entry for every touch event that we have gotten from native.
			ids.push(t.nodeId);
		}
		
		touch._setTargetIds(ids);
		
		switch(touchAction)
		{
			case Touch.Action.Start:
				// Dispatch to all touch targets until one handles it.
				for(var key in ids)
				{
					var id=ids[key];
					var o = Core.ObjectRegistry.idToObject(id);
					if(o && o.getTouchEmitter().chain(touch))
					{
						this._touchTracking[touchId] = id;
						break;
					}
				}
				break;
			case Touch.Action.End:
				// Dispatch to tracking object.
				var track = this._touchTracking[touchId];
				if(track)
				{
					var o = Core.ObjectRegistry.idToObject(track);
                    if (o)
                        o.getTouchEmitter().chain(touch);
					delete this._touchTracking[touch.getId()];
				}
				break;
			case Touch.Action.Move:
				// Dispatch to tracking object.
				var track = this._touchTracking[touchId];
				if(track)
				{
					var o = Core.ObjectRegistry.idToObject(track);
                    if (o)
                        o.getTouchEmitter().chain(touch);
				}
				break;
		}
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 309
	// Method create = -1
	// Method addChild = 2
	// Method removeChild = 3
	// Method onTouchEvent = 4
	// Method touchTarget = 5
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 4:
					instance._onTouchEventRecv( cmd );
					break;
				case 5:
					instance._touchTargetRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Root._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Root._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[309] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_onTouchEventRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 5 )
		{
			NgLogE("Could not parse due to wrong argument count in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "touchId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "touchId" ] === undefined )
		{
			NgLogE("Could not parse touchId in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "touchAction" ] = Core.Proc.parseInt( cmd[ 1 ] );
		if( obj[ "touchAction" ] === undefined )
		{
			NgLogE("Could not parse touchAction in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "x" ] = Core.Proc.parseFloat( cmd[ 2 ] );
		if( obj[ "x" ] === undefined )
		{
			NgLogE("Could not parse x in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "y" ] = Core.Proc.parseFloat( cmd[ 3 ] );
		if( obj[ "y" ] === undefined )
		{
			NgLogE("Could not parse y in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		obj[ "touchTargetCount" ] = Core.Proc.parseInt( cmd[ 4 ] );
		if( obj[ "touchTargetCount" ] === undefined )
		{
			NgLogE("Could not parse touchTargetCount in Root.onTouchEvent from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 5);
		return true;
	},
	
	/** @private */
	_touchTargetRecvGen: function( cmd, obj )
	{ 
		if( cmd.length < 1 )
		{
			NgLogE("Could not parse due to wrong argument count in Root.touchTarget from command: " + cmd );
			return false;
		}
		
		obj[ "nodeId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "nodeId" ] === undefined )
		{
			NgLogE("Could not parse nodeId in Root.touchTarget from command: " + cmd );
			return false;
		}
		
		cmd.splice(0, 1);
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":309,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_addChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( ":309,2," + this.__objectRegistryId + "," + child  );
	},
	
	/** @private */
	_removeChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( ":309,3," + this.__objectRegistryId + "," + child  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// addChild: function( child ) {}
	
	// removeChild: function( child ) {}
	
	// _onTouchEventRecv: function( cmd ) {}
	// _touchTargetRecv: function( cmd ) {}

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Sprite'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Sprite'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Sprite'] = exports; var Node = require('NGCore/Client/GL2/Node').Node;
var Animation = require('NGCore/Client/GL2/Animation').Animation;
var Core = require('NGCore/Client/Core').Core;

exports.Sprite = Node.subclass(
/** @lends GL2.Sprite.prototype */
{
	classname: 'Sprite',
	
	/**	 
	 * @class The <code>Sprite</code> class constructs objects that are used to display either a single image file 
	 * (see <code><a href="GL2.Sprite.html#setImage">setImage()</a></code>) or an animation.<br><br>
	 * Sprites apply their composite node transform and color to the final 
	 * rendered output of each <code><a href="GL2.Animation.Frame.html">frame</a></code> they display. Frames manage the
	 * pre-transform offset within the image. The pre-transform offset is used by frames for rotation and scale of the image. Combining these
	 * two features, an application can accurately place an image within the view.<br><br>
	 * Animations that reach the end of the last animation frame will trigger the
	 * <code>AnimationCompleteEmitter</code> (see <code><a href="GL2.Sprite.html#getAnimationCompleteEmitter">getAnimationCompleteEmitter()</a></code>). 
	 * All other cases, such as setting a new
	 * animation, does not trigger the emitter.<br><br>
	 * <b>Note:</b> The tick rate for any animation instantiated through <code>Sprite</code> is set through <code>{@link Core.UpdateEmitter#setTickRate}</code>.
	 * @constructs The default constructor.
	 * @augments GL2.Node
	 */
    initialize: function()
    {
		this._clubObject = null;
        this._animation = null;
		this._ownsAnimation = false;
		
		this._animationCompleteEmitter = new Core.MessageEmitter();
    },

	/**
	 * The default destructor.
	 * This call cleans up any attached <code>Animation</code> and <code>AnimationCompleteEmitter</code> objects.
	 * @see GL2.Animation,
	 * @see GL2.Sprite#getAnimationCompleteEmitter
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
		this._tryDestroyAnimation();
		this._animationCompleteEmitter.destroy();
	},
	
	/**
	 * Retrieve the current <code>Sprite</code> animation.
	 * If the sprite is rendering a single image animation through <code>setImage()</code>,
	 * this method will return <code>undefined</code>.
	 * @returns {GL2.Animation} The current animation. Returns <code>null</code> if the application is not currently playing an animation.
	 * @see GL2.Sprite#setAnimation,
	 * @see GL2.Sprite#setImage
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAnimation: function()
	{
		if(this._ownsAnimation) return null;
		
		return this._animation;
	},
    
    /**
	 * Retrieve the animation complete emitter for this <code>Sprite</code>.
	 *
	 * This emitter is triggered when one of the following conditions occurs:<br><br>
	 *<ul>
	 * <li>The sprite reaches the end of an animation for which the last frame has a duration of <code>0</code>.</li>
	 * <li>A <code>setAnimation()</code> or a <code>setImage()</code> call resets the animation complete emitter.</li>
	 *</ul>
	 * Any code that requires notification when an animation completes should register as a 
	 * listener to this emitter. The emitter callback will pass this sprite as the only parameter.<br><br>
	 * <b>Note:</b> Looping animations and starting new animations do not trigger this emitter.
	 * @returns {Core.MessageEmitter} The emitter that triggers the completion callback.
	 * @see GL2.Sprite#setAnimation,
	 * @see GL2.Sprite#setImage	 
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAnimationCompleteEmitter: function()
	{
		return this._animationCompleteEmitter;
	},
    
    /**
	 * Begin playing the specified animation with this <code>Sprite</code>.
	 * If the sprite is playing another animation at the time of this call, the new animation will take priority over the sprite.
	 * The previous animation will stop and the complete emitter will not respond. This is because the animation did not technically complete a full playback cycle. 
	 * <br><br>
	 * <b>Note:</b> You can release the resources for any animation set with <code>setAnimation()</code> from the native backend if no other frame
	 * contains it.
	 * @example var animation = Animation.getNamed('background');
	 * ...
	 * var sprite = new GL2.Sprite();
	 * sprite.setAnimation(animation);
	 * @param {GL2.Animation} animation The animation to play.
	 * @param {Number} [startTime=0] The time offset where playback should start relative to the actual start of the animation. Expressed in milliseconds.<br><br>
	 * <b>Example:</b> If <code>setAnimation()</code> is called with a <code>startTime</code> equal to half the total duration of the animation, 
	 * playback begins half way through the animation.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setAnimation: function(animation, startTime)
	{
		this._tryDestroyAnimation();
		this._animation = animation;
		
		this._setAnimationSendGen(Core.ObjectRegistry.objectToId(animation), startTime || 0);
		
		return this;
	},
    
    /**
	 * Set a static image as the current animation for this <code>Sprite</code>.
	 * Internally, this method instantiates a single frame animation of infinite duration using the
	 * specified image. If the sprite is playing another animation at the time of this call, the new animation will take priority over the sprite.
	 * The previous animation will stop and the complete emitter will not respond. This is because the animation did not technically complete a full playback cycle. 
	 * <br><br>
	 * <b>Note:</b> You can release the resources for any image set with <code>setImage()</code> from the native backend if no other frame
	 * contains it.
	 * @example var myImage = new GL2.Sprite();
	 * myImage.setImage('./Content/animation.png', size);
	 * @param {String} image The directory path to an image resource.
	 * @param {Core.Size} [size] The size of the image to display (in pixels).
	 * @param {Core.Point} [anchor] The anchor coordinates that indicate the image center in the animation.
	 * @param {Core.Rect} [uvs] The UV coordinates used to specify the subset of an image.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setImage: function(image, size, anchor, uvs)
	{
		this._tryDestroyAnimation();
		
		// Create a single frame animation.
		var args = Array.prototype.slice.call(arguments, 0);
		args.splice(1, 0, 0); // Insert a duration of zero into our arguments.
		var frame = new Animation.Frame();
		frame.constructor.apply(frame, args);
		var animation = new Animation();
		animation.pushFrame(frame);
		
		this._animation = animation;
		this._ownsAnimation = true;
		
		this._setAnimationSendGen(Core.ObjectRegistry.objectToId(animation),0);
		
		return this;
	},
	
	_tryDestroyAnimation: function()
	{
		if(this._ownsAnimation)
		{
			// Set our animation to NULL to unlink ourselves from the animation on the backend
			// or else trying to destory the animation will fail because we are still using it.
			this._setAnimationSendGen(0,0);
		
			this._animation.destroy();
			this._animation = null;
			this._ownsAnimation = false;
		}
		this._animation = null;
	},
	
	_animationCompleteRecv: function(cmd)
	{
		var msg = {};
		if(!this._animationCompleteRecvGen(cmd, msg))
			return;
		
		this._animationCompleteEmitter.emit(this);
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 310
	// Method create = -1
	// Method setAnimation = 2
	// Method animationComplete = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 3:
					instance._animationCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Sprite._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Sprite._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[310] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_animationCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Sprite.animationComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":310,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_setAnimationSendGen: function( animation, startTime )
	{
		Core.Proc.appendToCommandString( ":310,2," + this.__objectRegistryId + "," + animation + "," + startTime  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setAnimation: function( animation, startTime ) {}
	
	// _animationCompleteRecv: function( cmd ) {}

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/Text'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/Text'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/Text'] = exports; var Node = require('NGCore/Client/GL2/Node').Node;
var Core = require('NGCore/Client/Core').Core;

exports.Text = Node.subclass(
/** @lends GL2.Text.prototype */
{
	classname: 'Text',
    
	/**
	 * @class The <code>Text</code> class constructs objects that provide font specifications to the GL2 module. 
	 * <code>Text</code> objects define positionable areas for rendering text strings as application labels.
	 * @constructs The default constructor. 
	 * @augments GL2.Node
	 * @param {String} [text] The text string to render in the constructor.
	 */
    initialize: function(text)
    {
		this._size = new Core.Size();
		this._anchor = new Core.Point(0.5, 0.5);
        this._horizontalAlign = this.HorizontalAlign.Center;
        this._verticalAlign = this.VerticalAlign.Middle;
        this._text = '';
		if (text)
			 this.setText(text);
							 
        this._fontFamily = '';
        this._fontSize = 18;
		this._overflowMode = this.OverflowMode.Multiline;
		this._fontLocation = this.FontLocation.Default;
    },
    
	/**
	 * Destroy this instance and release resources on the backend.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
	},
	
	/**
	 * Retrieve the size of the text area from this <code>Text</code> node.
	 * The text area size is defined through two components: <i>width</i> and <i>height</i>.
	 * A value of <code>0</code> for either component means the text area will expand to the size of the string.
	 * @returns {Core.Vector} The current size of the text area (expressed as points).
	 * @see GL2.Text#setSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getSize: function()
	{
		return this._size;
	},
	
	/**
	 * Retrieve the placement offset for translating before applying the transform of this <code>Text</code> node.
	 * This value is specified as a multiple of the text area size with <code>(0,0)</code> as the top-left corner.
	 * @returns {Core.Vector} The current placement offset.
	 * @see GL2.Text#setAnchor
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getAnchor: function()
	{
		return this._anchor;
	},
	
	/**
	 * Retrieve the horizontal alignment of the text area from this <code>Text</code> node.
	 * @returns {GL2.Text#HorizontalAlign} The current horizontal alignment of the text area.
	 * @see GL2.Text#setHorizontalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getHorizontalAlign: function()
	{
		return this._horizontalAlign;
	},
	
	/**
	 * Retrieve the vertical alignment of the text area from this <code>Text</code> node.
	 * @returns {GL2.Text#VerticalAlign} The curren vertical alignment of the text area.
	 * @see GL2.Text#setVerticalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getVerticalAlign: function()
	{
		return this._verticalAlign;
	},
	
	/**
	 * Retrieve the text string this <code>Text</code> node will render.
	 * @returns {String} The current text string to render in the text area.
	 * @see GL2.Text#setText
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getText: function()
	{
		return this._text;
	},
	
	/**
	 * Retrieve the font family for the text area from this <code>Text</code> node.
	 * The GL2 module uses Arial as the text area font family when this value is undefined.<br><br>
	 * <b>Note:</b> <code>Text</code> nodes default to Arial as the font family when an application cannot load the specified font.
	 * @returns The current font family defined for the text area.
	 * @see GL2.Text#setFontFamily
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getFontFamily: function()
	{
		return this._fontFamily;
	},
	
	/**
	 * Retrieve the font size for the text area from this <code>Text</code> node.
	 * @returns {Number} The current font size defined for the text area.
	 * @see GL2.Text#setFontSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getFontSize: function()
	{
		return this._fontSize;
	},
	
	/**
	 * Retrieve the overflow style of the text area from this <code>Text</code> node. 
	 * @returns {GL2.Text#OverflowMode} The current overflow style defined for the text area.
	 * @see GL2.Text#setOverflowMode,
	 * @see GL2.Text#OverflowMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	getOverflowMode: function()
	{
		return this._overflowMode;
	},
	
    /**
	 * Set the size in pixels of the text area for this <code>Text</code> node.
	 * The text area size is defined through two components: <i>width</i> and <i>height</i>. 
	 * @example var w = Core.Capabilities.getScreenWidth();
	 * var h = Core.Capabilities.getScreenHeight();
	 * ...
	 * var label = new GL2.Text();
	 * label.setSize(w, h);
	 * @param {Core.Vector} size A new vector specifying the text area size in pixels.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Text#getSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setSize: function(size)
	{
		var s = this._size;
		s.setAll.apply(s, arguments);

		this._setSizeSendGen(s.getWidth(),s.getHeight());
		
		return this;
	},
	
    /**
	 * Set the text area offset as a multiple of the area size (<i>width</i> and <i>height</i>).
	 * An <code>Anchor</code> defines a location the text area will rotate and scale around; <code>Anchors</code> are applied
	 * to the drawing prior to the composite transform for the node. When the text size of the text area is <code>0</code> in either
	 * dimension, the offset is measured from the rendered size of the string in that dimension.<br><br>
	 * <b>Example:</b> If you want to display a text area as centered, you can set the <code>horizontalAlign</code> to
	 * <code>centered</code> and set the <code>anchor</code> to <code>[0.5,h]</code> with <i>h</i> representing a vertical offset.
	 * @example text.setAnchor(0.5,h);
	 * @param {Core.Vector} location A new vector specifying the offset location.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Node,
	 * @see GL2.Text#getAnchor,
	 * @see GL2.Text#setHorizontalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setAnchor: function(location)
	{
		var a = this._anchor;
		a.setAll.apply(a, arguments);
		
		this._setAnchorSendGen(a.getX(),a.getY());
		
		return this;
	},
	
    /**
	 * Set the horizontal alignment of the text area for this <code>Text</code> node.
	 * @example var t = new GL2.Text(this._label);
	 * ...
	 * t.setHorizontalAlign(GL2.Text.HorizontalAlign.Center);
	 * @param {GL2.Text#HorizontalAlign} horizontalAlign The new horizontal alignment for the text area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setHorizontalAlign: function(horizontalAlign)
	{
		this._horizontalAlign = horizontalAlign;
		
		this._setHorizontalAlignSendGen(horizontalAlign);
		
		return this;
	},
    
    /**
	 * Set the vertical alignment of the text area for this <code>Text</code> node.
	 * @example var t = new GL2.Text(this._label);
	 * ...
	 * t.setVerticalAlign(GL2.Text.VerticalAlign.Middle);
	 * @param {GL2.Text#VerticalAlign} verticalAlign The new vertical alignment for the text area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Text#getVerticalAlign
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setVerticalAlign: function(verticalAlign)
	{
		this._verticalAlign = verticalAlign;
		
		this._setVerticalAlignSendGen(verticalAlign);
		
		return this;
	},
    
    /**
	 * Set the text string to render in the text area of this <code>Text</code> node.
	 * @example var label = new GL2.Text();
	 * ...
	 * label.setText('This is a label');
	 * @param {String} text The new text string to render in the text area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Text#getText
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setText: function(text)
	{
		this._text = text;
		
		this._setTextSendGen(text);
		
		return this;
	},
    
    /**
	 * Set the font family to use for rendering text strings in the text area of this <code>Text</code> node.<br><br>
	 * Using this call to set application specific fonts (os-independent) requires you to add the font file name with extension (.ttf) to the manifest.json.
	 * The font family file must reside in the <code>Content</code> directory. The font family file name is passed in this call. The font face is applied to each object of type 
	 * <code>GL2.Text</code> that will override the system font.
	 * @example var font = new GL2.Text();
	 * ...
	 * font.setFontFamily("Content/Cacophony.ttf");
	 * @param {String} [fontFamily=Arial] The new font family to render in the text area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Text#getFontFamily
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
    setFontFamily: function(fontFamily)
	{
		this._fontFamily = fontFamily;
		
		this._setFontFamilySendGen(fontFamily);
		
		return this;
	},
    
    /**
	 * Set the text area font size for this <code>Text</code> node.
	 * @example var fontSize = 24;
	 *
	 * var font = new GL2.Text();
	 * ...
	 * font.setFontSize(fontSize);
	 * @param {Number} [fontSize=18pt] The new font size for text strings (expressed in points).
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Text#getFontSize
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setFontSize: function(fontSize)
	{
		this._fontSize = fontSize;
		
		this._setFontSizeSendGen(fontSize);
		
		return this;
	},
	
	/**
	 * Set the overflow style of the text area for this <code>Text</code> node. 
	 * This method defines how a <code>Text</code> node will fit a rendered string inside 
	 * the text area when the string is too long.
	 * @example var font = new GL2.Text();
	 * ...
	 * font.setOverflowMode(GL2.Text.OverflowMode.ReduceFontSize);
	 * @param {GL2.Text#OverflowMode} overflowMode The overflow rendering style for long text strings.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see GL2.Text#getOverflowMode,
	 * @see GL2.Text#OverflowMode
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setOverflowMode: function(overflowMode)
	{
		this._overflowMode = overflowMode;
		
		this._setOverflowModeSendGen(overflowMode);
		
		return this;
	},
	
	/**
	 * Set the directory path to the location of a font used by this <code>Text</code> node.
	 * @example var font = new GL2.Text();
	 * ...
	 * font.setFontLocation(GL2.Text.FontLocation.System);
	 * @param {String} fontLocation The new directory path to a font used in the text area.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	setFontLocation: function(fontLocation)
	{
		this._fontLocation = fontLocation;
		
		this._setFontLocationSendGen(fontLocation);
		
		return this;
	},
	
	/**
	 * Translate a global scene location to the local coordinate space of this <code>Text</code> node.
	 * Use this method when determining <code>touchMoved</code> offsets.
	 * @example var p = Game.getRoot().screenToLocal(touch.getPosition());
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.Vector} location The location to transform.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	screenToLocal: function($super, location)
	{
		location = $super(location);
		if(!location)
			return undefined;
		
		var a = this._anchor;
		var s = this._size;
			
		location.setX(location.getX() + a.getX() * s.getWidth());
		location.setY(location.getY() + a.getY() * s.getHeight());
		return location;
	},
	
	/**
	 * Translate a location in the local coordinate space to the global scene coordinate space of this <code>Text</code> node.
	 * Use this method for translating between local coordinate spaces.
	 * @param {$super} $super This parameter is a reference to the base class implementation and is stripped out during execution. Do not supply it.
	 * @param {Core.Vector} location The location to transform.
	 * @status iOS, Android, Flash, Test, iOSTested, AndroidTested
	 */
	localToScreen: function($super, location)
	{
		var a = this._anchor;
		var s = this._size;
			
		location.setX(location.getX() - a.getX() * s.getWidth());
		location.setY(location.getY() - a.getY() * s.getHeight());
		
		location = $super(location);
		if(!location)
			return undefined;
		return location;
	},
	
// {{?Wg Generated Code}}
	
	// Enums.
	/** 
	 * Enumeration for horizontal alignment modes.
	 * @namespace
	 */
	HorizontalAlign:
	{ 
		/** Align text to the left. */
		Left: 0,
		/** Align text in the center. */
		Center: 1,
		/** Align text to the right. */
		Right: 2,
	},
	
	/** 
	 * Enumeration for vertical alignment modes.
	 * @namespace
	 */
	VerticalAlign:
	{ 
		/** Align text to the top. */
		Top: 0,
		/** Align text in the middle. */
		Middle: 1,
		/** Align text to the bottom. */
		Bottom: 2,
	},
	
	/** 
	 * Enumeration for the behavior when there is too much text to fit on one line.
	 * @namespace
	 */
	OverflowMode:
	{ 
		/** Reduce the font size until the text fits. */
		ReduceFontSize: 0,
		/** Break the text across multiple lines. */
		Multiline: 1,
	},
	
	/** 
	 * Enumeration for location of fonts.
	 * @namespace
	 */
	FontLocation:
	{ 
		/** Use Default fonts. */
		Default: 0,
		/** Use System fonts. */
		System: 1,
		/** Use bundled fonts that ship with engine and available to all apps. */
		Bundled: 2,
		/** Use custom fonts that are loaded with app manifest. */
		Manifest: 3,
	},
	
	///////
	// Class constants (for internal use only):
	// Class ID = 311
	// Method create = -1
	// Method destroy = 2
	// Method setSize = 3
	// Method setAnchor = 4
	// Method setHorizontalAlign = 5
	// Method setVerticalAlign = 6
	// Method setText = 7
	// Method setFontFamily = 8
	// Method setFontSize = 9
	// Method setOverflowMode = 10
	// Method setFontLocation = 11
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Text._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Text._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[311] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":311,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":311,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_setSizeSendGen: function( width, height )
	{
		Core.Proc.appendToCommandString( ":311,3," + this.__objectRegistryId + "," + width + "," + height  );
	},
	
	/** @private */
	_setAnchorSendGen: function( x, y )
	{
		Core.Proc.appendToCommandString( ":311,4," + this.__objectRegistryId + "," + x + "," + y  );
	},
	
	/** @private */
	_setHorizontalAlignSendGen: function( align )
	{
		Core.Proc.appendToCommandString( ":311,5," + this.__objectRegistryId + "," + align  );
	},
	
	/** @private */
	_setVerticalAlignSendGen: function( align )
	{
		Core.Proc.appendToCommandString( ":311,6," + this.__objectRegistryId + "," + align  );
	},
	
	/** @private */
	_setTextSendGen: function( text )
	{
		Core.Proc.appendToCommandString( ":311,7," + this.__objectRegistryId + "," + Core.Base64.encode( text )  );
	},
	
	/** @private */
	_setFontFamilySendGen: function( fontFamily )
	{
		Core.Proc.appendToCommandString( ":311,8," + this.__objectRegistryId + "," + Core.Base64.encode( fontFamily )  );
	},
	
	/** @private */
	_setFontSizeSendGen: function( fontSize )
	{
		Core.Proc.appendToCommandString( ":311,9," + this.__objectRegistryId + "," + fontSize  );
	},
	
	/** @private */
	_setOverflowModeSendGen: function( overflowMode )
	{
		Core.Proc.appendToCommandString( ":311,10," + this.__objectRegistryId + "," + overflowMode  );
	},
	
	/** @private */
	_setFontLocationSendGen: function( fontLocation )
	{
		Core.Proc.appendToCommandString( ":311,11," + this.__objectRegistryId + "," + fontLocation  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setSize: function( width, height ) {}
	
	// setAnchor: function( x, y ) {}
	
	// setHorizontalAlign: function( align ) {}
	
	// setVerticalAlign: function( align ) {}
	
	// setText: function( text ) {}
	
	// setFontFamily: function( fontFamily ) {}
	
	// setFontSize: function( fontSize ) {}
	
	// setOverflowMode: function( overflowMode ) {}
	
	// setFontLocation: function( fontLocation ) {}
	

// {{/Wg Generated Code}}
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/GL2/RenderTarget'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/GL2/RenderTarget'] || {}; $MODULE_REGISTRY['NGCore/Client/GL2/RenderTarget'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.RenderTarget = Core.Class.subclass(
	/** @lends GL2.RenderTarget.prototype */
{
	classname: 'RenderTarget',

	/**
	 * @class The GL2.RenderTarget object is used to render a set of GL2.Nodes into a texture target.
	 * this target can then be attached to GL2.Animation.Frames and rendered attached to a GL2.Sprite or GL2.Primitive node.
	 *
	 * @constructs Constructs a new GL2.RenderTarget object.
	 * @param {Number} width Width of texture, must be power of two.
	 * @param {Number} height Height of texture, must be power of two.
	 * @param {bool} [isOpaque] When false (the default) the texture will include an alpha channel, when true the texture will be opaque.
	 */
	initialize: function (width, height, isOpaque) {
		Core.ObjectRegistry.register(this);
		this._children = [];
		this._width = width;
		this._height = height;
		this._isOpaque = isOpaque ? true : false;
		this._createSendGen(this.__objectRegistryId, width, height, this._isOpaque);
		this._callbackIndexCounter = 1;
		this._callbacks = [];
	},

	/**
	 * Destroys the texture target.
	 */
	destroy: function () {
		var children = this._children;
		while (children.length) {
			this.removeChild(children[0]);
		}
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},

	/**
	 * Adds a GL2.Node object to the RenderTarget.  Visual changes will take effect on the next update.
	 * @param {GL2.Node} child Node to be added.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	addChild: function (child) {
		this._children.push(child);
		child._didAddToParent(this);
		this._addChildSendGen(Core.ObjectRegistry.objectToId(child));
		return this;
	},

	/**
	 * Removes a GL2.Node object from the RenderTarget. Visual changes will take effect on the next update.
	 * @param {GL2.Node} child Node to be removed.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	removeChild: function (child) {
		child._willRemoveFromParent();
		var index = this._children.indexOf(child);
		if (index === -1)
			throw new Error('removeChild called for a node that is not a child');
		this._children.splice(index, 1);
		this._removeChildSendGen(Core.ObjectRegistry.objectToId(child));
		return this;
	},

	/**
	 * Render all the currently attached GL2.Nodes into the texture target.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	update: function () {
		this._updateSendGen();
		return this;
	},

	/**
	 * Automatically render all currently attached GL2.Nodes every frame.
	 * This has the same effect as calling the update method on every frame.
	 * @param {bool} [autoUpdateEnable] Defaults to true, which causes the texture to be updated frame.  Set to false to stop auto updates.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	setAutoUpdate: function (autoUpdateEnable) {
		var enable = (autoUpdateEnable || (autoUpdateEnable === undefined)) ? true : false;
		this._setAutoUpdateSendGen(enable);
		return this;
	},

	/**
	 * Clear texture background before rendering.  By default the background is not cleared.
	 * @param {bool} [clearEnabled] Defaults to true, causing the texture to be cleared before nodes are drawn.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	setClearEnable : function (clearEnable) {
		var enable = (clearEnable || (clearEnable === undefined)) ? true : false;
		this._setClearEnableSendGen(enable);
		return this;
	},

	/**
	 * Set background color of texture.  Can be called with a single Core.color argument or 3 Number arguments.
	 * The default clear color is white.  If the RenderTarget has an alpha component it can be set via the setClearColorAlpha() method.
	 * @param {Number|Core.color} colorOrRed Opaque background color, or the red component if 3 or 4 parameters are given.
	 * @param {Number} [green] Green component of clear color (0, 1).
	 * @param {Number} [blue] Blue component of clear color (0, 1).
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	setClearColor : function () {
		var r, g, b, color;
		if (arguments.length === 1)
		{
			color = arguments[0];
			r = color.getRed();
			g = color.getGreen();
			b = color.getBlue();
		}
		else
		{
			r = arguments[0];
			g = arguments[1];
			b = arguments[2];
		}
		this._setClearColorSendGen(r, g, b);
		return this;
	},

	/**
	 * Set alpha component of background color of texture.
	 * The default clear alpha is 1, opaque.
	 * @param {Number} alpha background color opacity.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 */
	setClearColorAlpha : function (alpha) {
		this._setClearColorAlphaSendGen(alpha);
		return this;
	},

	/**
	 * Save image to the filesystem.
	 * @param {String} filename name of bitmap.
	 * @param {Core.Rect} [rect] Image clip rectangle.  If not specfied the entire RenderTexture will be saved.
	 * @param {Function} [callback] A closure to be executed after image has been saved.  The resulting filename is passed as an argument.
	 */
	save : function (filename, rect, callback) {
		var id = 0;
		if (callback) {
			id = this._callbackIndexCounter++;
			this._callbacks[id] = callback;
		}
		var x = rect ? rect.getOrigin().getX() : -1;
		var y = rect ? rect.getOrigin().getY() : -1;
		var w = rect ? rect.getSize().getWidth() : -1;
		var h = rect ? rect.getSize().getHeight() : -1;
		this._saveSendGen(id, filename, x, y, w, h);
	},

	/**
	 * @private
	 */
	_invokeCallbackRecv: function (cmd)	{
		var msg = {};
		if (!this._invokeCallbackRecvGen(cmd, msg)) {
			return;
		}

		var id = msg.callbackId;
		var err = msg.error;
		if (!id) {
			NgLogE("invokeCallbackRecv command : bad id = " + id);
			return;
		}
		var cb = this._callbacks[id];
		if (!cb) {
			NgLogE("invokeCallbackRecv command : No registered callback found, id = " + id);
			return;
		}
		delete this._callbacks[id];
		cb(err);
	},

	/**
	 * Enable or disable backing store for RenderTarget. Disabled by default
	 * The backing store is used to guarantee that texture will be restored after the application is suspended and restored.
	 * If backing store is not enabled, then the texture is not guaranteed to render correctly after the application is restored.
	 * @param {Bool} [backingStoreEnable] If omitted backing store will be enabled.
	 */
	setBackingStoreEnable: function (backingStoreEnable) {
		var enable = (backingStoreEnable || (backingStoreEnable === undefined)) ? true : false;
		this._setBackingStoreEnableSendGen(enable);
		return this;
	},

// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 353
	// Method create = -1
	// Method destroy = 2
	// Method addChild = 3
	// Method removeChild = 4
	// Method update = 5
	// Method setAutoUpdate = 6
	// Method setClearEnable = 7
	// Method setClearColor = 8
	// Method setClearColorAlpha = 9
	// Method save = 10
	// Method invokeCallback = 11
	// Method setBackingStoreEnable = 12
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 11:
					instance._invokeCallbackRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in RenderTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in RenderTarget._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[353] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_invokeCallbackRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 2 )
		{
			NgLogE("Could not parse due to wrong argument count in RenderTarget.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "callbackId" ] = Core.Proc.parseInt( cmd[ 0 ] );
		if( obj[ "callbackId" ] === undefined )
		{
			NgLogE("Could not parse callbackId in RenderTarget.invokeCallback from command: " + cmd );
			return false;
		}
		
		obj[ "error" ] = Core.Proc.parseString( cmd[ 1 ] );
		if( obj[ "error" ] === undefined )
		{
			NgLogE("Could not parse error in RenderTarget.invokeCallback from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( objectRegistryId, width, height, isOpaque )
	{
		Core.Proc.appendToCommandString( ":353,-1," + objectRegistryId + "," + width + "," + height + "," + ( isOpaque ? 1 : 0 )  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":353,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_addChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( ":353,3," + this.__objectRegistryId + "," + child  );
	},
	
	/** @private */
	_removeChildSendGen: function( child )
	{
		Core.Proc.appendToCommandString( ":353,4," + this.__objectRegistryId + "," + child  );
	},
	
	/** @private */
	_updateSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":353,5," + this.__objectRegistryId );
	},
	
	/** @private */
	_setAutoUpdateSendGen: function( autoUpdateEnable )
	{
		Core.Proc.appendToCommandString( ":353,6," + this.__objectRegistryId + "," + ( autoUpdateEnable ? 1 : 0 )  );
	},
	
	/** @private */
	_setClearEnableSendGen: function( clearEnable )
	{
		Core.Proc.appendToCommandString( ":353,7," + this.__objectRegistryId + "," + ( clearEnable ? 1 : 0 )  );
	},
	
	/** @private */
	_setClearColorSendGen: function( r, g, b )
	{
		Core.Proc.appendToCommandString( ":353,8," + this.__objectRegistryId + "," + r + "," + g + "," + b  );
	},
	
	/** @private */
	_setClearColorAlphaSendGen: function( a )
	{
		Core.Proc.appendToCommandString( ":353,9," + this.__objectRegistryId + "," + a  );
	},
	
	/** @private */
	_saveSendGen: function( callbackId, filename, originX, originY, width, height )
	{
		Core.Proc.appendToCommandString( ":353,10," + this.__objectRegistryId + "," + callbackId + "," + Core.Base64.encode( filename ) + "," + originX + "," + originY + "," + width + "," + height  );
	},
	
	/** @private */
	_setBackingStoreEnableSendGen: function( backingStoreEnable )
	{
		Core.Proc.appendToCommandString( ":353,12," + this.__objectRegistryId + "," + ( backingStoreEnable ? 1 : 0 )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( objectRegistryId, width, height, isOpaque ) {}
	
	// destroy: function(  ) {}
	
	// addChild: function( child ) {}
	
	// removeChild: function( child ) {}
	
	// update: function(  ) {}
	
	// setAutoUpdate: function( autoUpdateEnable ) {}
	
	// setClearEnable: function( clearEnable ) {}
	
	// setClearColor: function( r, g, b ) {}
	
	// setClearColorAlpha: function( a ) {}
	
	// save: function( callbackId, filename, originX, originY, width, height ) {}
	
	// _invokeCallbackRecv: function( cmd ) {}
	// setBackingStoreEnable: function( backingStoreEnable ) {}
	

// {{/Wg Generated Code}}

});; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeContent'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeContent'] || {}; $MODULE_REGISTRY['weEngine/WeContent'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2011-08-11
 *  @file:      WeContent.js
 *  @author:    Tyler Margison
 *  Copyright:  2011, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:     Assists in loading content data from the proper locations.
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;

//////////////////////////////////////////////////////////////////////////////
// globals

//////////////////////////////////////////////////////////////////////////////
/**
 * Class: Content
 */
var _Content = Core.Class.singleton({
    initialize : function()
    {
        this.mContentRoot = "Content";
        this.mAudioRoot = "Audio";
        this.mImageRoot = "Images";
        this.mTextureRoot = "Textures";
        this.mAvatarRoot = "Avatars";
        this.mMainRoot = "Main";
        
        if (Core.Capabilities.getScreenPixelUnits() == 2 && gFixedWidth == 480 && gFixedHeight == 320)
        {
            this.mResolution = gFixedWidth + "x" + gFixedHeight + "_retina";
        }
        else
        {
            this.mResolution = gFixedWidth + "x" + gFixedHeight;
        }
        
        
        this.mPathNameMapAudio = {};
        this.mPathNameMapTextures = {};
        this.mPathNameMapImages = {};
    },
    
    AddMainImage : function(name)
    {
    	this.mPathNameMapImages[name] = this.mContentRoot + "/" + this.mImageRoot  + "/" + this.mMainRoot + "/" + name;
    },

    AddAudioFile : function(name, level)
    {
    	this.mPathNameMapAudio[name] = this.mContentRoot + "/" + this.mAudioRoot + "/"+ level + "/" + name;
    },
    
    AddImageFile : function(name, level)
    {	
    	this.mPathNameMapImages[name] = this.mContentRoot + 
    	"/" + this.mImageRoot + "/" + this.mResolution + "/"+ level + "/" + name;
    	
    },
    
    AddTextureFile : function(name, level)
    {
    	this.mPathNameMapTextures[name] = this.mContentRoot + "/" + this.mTextureRoot + "/" + level + "/" + name;
    },
    
    getAudioPath: function(audio)
    {
    	if (audio.indexOf(this.mContentRoot) != -1)
    	{
    		return audio;
    	}
    	
    	if (audio in this.mPathNameMapAudio)
    	{
    		return this.mPathNameMapAudio[audio];
    	}
    	else
    	{
    		this.AddAudioFile(audio, 0);
    		return this.mPathNameMapAudio[audio];
    	}
    },
    
    getImagePath: function(img)
    {
    	if (img.indexOf(this.mContentRoot) != -1)
    	{
    		return img;
    	}

        if (Core.Capabilities.getScreenPixelUnits() == 2)
        {
    	    var retinaFile = img;
            if (retinaFile.indexOf(".png") > 0 && retinaFile.indexOf("@2x") < 0)
            {
                retinaFile = retinaFile.replace(".png", "@2x.png");
            }
        
            if (retinaFile in this.mPathNameMapImages)
            {
                //return this.mPathNameMapImages[retinaFile];
                if (retinaFile in this.mPathNameMapImages)
                {
                    return this.mPathNameMapImages[retinaFile];
                }
                else
                {
                    return this.getCommonImagePath(retinaFile);
                }                
            }
        }
        
        if (img in this.mPathNameMapImages)
        {
            return this.mPathNameMapImages[img];
        }
        else
        {
        	//
        	//	assume this image was in primary manifest
        	//
            this.AddMainImage(img);
            return this.mPathNameMapImages[img];
        }
    	
    },
    
    getCommonImagePath: function(img)
    {
        var path = "Content/Images/Main/" + img;
        return path;
    },
    
    getIconImagePath: function(img)
    {
        return this.getImagePath(img);
    },
    
    getSpriteSheetPath: function(img)
    {
    	var path; 
    	if (img.indexOf(this.mContentRoot) != -1)
    	{
    		path = img;
    	}
    	
    	path =  this.mPathNameMapTextures[img];

    	return path;
    },
    
    getAvatarPath: function(img)
    {
    	
    	if (img.indexOf(this.mContentRoot) != -1)
    	{
    		return img;
    	}
    	
    	return this.mContentRoot +  "/" + this.mImageRoot + "/" + this.mAvatarRoot +"/" + img;
    	
    }
});

exports.Content = _Content;
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeSprite2D'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeSprite2D'] || {}; $MODULE_REGISTRY['weEngine/WeSprite2D'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-21
 *  @file:      WeSprite2D.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;
var GL2 = require('NGCore/Client/GL2').GL2;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var Content = require('weEngine/WeContent').Content;
var SpriteTable = require('weEngine/WeSpriteParser').SpriteTable;
var SpriteTableHeader = require('weEngine/WeSpriteParser').SpriteTableHeader;

//////////////////////////////////////////////////////////////////////////////
// Globals


//////////////////////////////////////////////////////////////////////////////
/**
 * Class WeSprite2D
 * @brief:
 */
var _WeSprite2D = Core.MessageListener.subclass(
{
	classname: "WeSprite2D",
	
    initialize: function(asset, size, location, parent, anchor, filter)
    {
        if(undefined === filter)
        {
            filter = true;
        }
        
        this.exit_routines = [];
        
        //REMOVE for debug porpuses
        this.exit_routinesCalled = [];
        
        this.mRequiresTap = false;
        this.mStartTouch = false;
		this.mEnableInteraction = true;	// if the button is disabled
        if(!this.IsSubClass())
        {
            anchor = anchor || [0, 0];
            this.mAnimFrame = new GL2.Animation();
            
            if (gDebugMissingAssets)
            {
                var tempAsset = asset;
                Storage.FileSystem.readFile(tempAsset, function(error) { 
            	    if(error) 
            		{
            			NgLogD("######## ASSET MISSING: " + tempAsset + " : " + error);
            		}
            	});
        	}
        	
            this.mAnimFrame.pushFrame(new GL2.Animation.Frame(asset, 100, size, anchor, [0, 0, 1, 1]));
            this.m_Asset = asset;
            this.mSpriteGL2 = new GL2.Sprite();
            this.mParent = parent || GL2.Root;
            this.mSpriteGL2.owner = this;
            this.mSpriteGL2.setPosition(location[0], location[1]);
            this.mSpriteGL2.setRotation(0);
            this.mSpriteGL2.setDepth(location[2] || 0);
            this.mSpriteGL2.setAnimation(this.mAnimFrame, 0);
            this.mParent.addChild(this.mSpriteGL2);
            
            this.enabledTouch = false;
            
            this.mListeners = [];
            
            if(Exists(gTunables.optimizations) && gTunables.optimizations.bilinear_filter_all || filter === false )
            {
                this.mAnimFrame.setFilteringEnabled(false);
            }
        }
    },
    
    destroy: function()
    {
        if (Exists(this.mSpriteGL2))
        {
        	fullRecurseDump(this.exit_routines);
        	
        	for (var i in this.exit_routines)
        	{
        		//REMOVE
	    		if(this.exit_routinesCalled[i])
	    		{
	    			NgLogD("recursive call to destroy");
	    			printStack();
	    		}
	    		this.exit_routinesCalled[i]=true;
        		
        		
        		this.exit_routines[i]();
        	}
        	this.exit_routines = null;
        	
            this.mSpriteGL2.destroy();
            if (Exists(this.mAnimFrame))
            {
                this.mAnimFrame.destroy();
            }
            delete this.mSpriteGL2;
            
            delete this.mAnimFrame;
            this.mSpriteGL2 = null;

            var len = this.mListeners.length;
            for (var i = 0; i < len ; ++i)
            {
                this.mListeners[i].removeListener(this);
            }
            this.mListeners = [];
            if(this.mTouchTarget)
            {
                 this.mTouchTarget.destroy();
            }
        }
        else
        {
            NgLogD("ERROR: Trying to cleanup a non-existant sprite");
        }   
    },
    
    OnExit : function (handle)
    {
        if(Exists(this.exit_routines) && handle)
        {
        	//REMOVE
    		this.exit_routinesCalled.push(false);
    		
    		
	        this.exit_routines.push(handle);
        }
    },
    
    EnableFilter : function()
    {
        this.mAnimFrame.setFilteringEnabled(true);
    },

    DisableFilter : function()
    {
        this.mAnimFrame.setFilteringEnabled(false);
    },
    
    IsSubClass : function()
    {
        return false;
    },

    /**
     * Enable an emitter
     * var sprite = new WeSprite2D(...);
     * sprite.mData = 1;
     * sprite.Enable('UpdateEmitter', function()
     * {
     *    NgLogD("Data = " + this.mData); // outputs Data = 1; 
     * });
     */
    
    Disable: function(name, cb)
    {
    	if(name === "Touch")
    	{
    		if(this.mTouchTarget!==null)
    		{
    			//NgLogD("---in Disable(Touch)---");
    			this.enabledTouch = false;
	            if (Exists(cb))
	            {
	                this.mTouchTarget.getTouchEmitter().removeListener(this, cb);
	            }
	            else
	            {
	                this.mTouchTarget.getTouchEmitter().removeListener(this, this.OnNativeTouchShim);
	            }
	    	
	    		this.mTouchTarget = null;
    		}
    	}
    },
    Enable: function(name, cb, entity)
    {
		if (name === "TouchGrid")
		{
			// Get corner points of entity grid tiles
			var p1 = WorldToScreenPos(new Vec2D(entity.GetStartX(), entity.GetStartY()));
			var p2 = WorldToScreenPos(new Vec2D(entity.GetStartX(), entity.GetEndY()));
			var p3 = WorldToScreenPos(new Vec2D(entity.GetEndX(), entity.GetEndY()));
			var p4 = WorldToScreenPos(new Vec2D(entity.GetEndX(), entity.GetStartY()));

			// Calculate bounding box of grid tiles
			var x1 = Math.min(Math.min(p1.x, p2.x), Math.min(p3.x, p4.x));
			var y1 = Math.min(Math.min(p1.y, p2.y), Math.min(p3.y, p4.y));
			var x2 = Math.max(Math.max(p1.x, p2.x), Math.max(p3.x, p4.x));
			var y2 = Math.max(Math.max(p1.y, p2.y), Math.max(p3.y, p4.y));

			// Expand slightly to make it easier to click
			y1 -= 20;
			y2 += 40;

			this.enabledTouch = true;
			
            this.mTouchTarget = new GL2.TouchTarget();
            this.mSpriteGL2.addChild(this.mTouchTarget);

			var off_x = entity.GetProtoVisual().offset_x;
			var off_y = entity.GetProtoVisual().offset_y;
			
			// Convert bbox to local coordinates
			var bbox_top_left = this.mTouchTarget.screenToLocal(new Core.Vector(x1, y1));
			var bbox_bottom_right = this.mTouchTarget.screenToLocal(new Core.Vector(x2, y2));
			var pos = bbox_top_left - this.mSpriteGL2.getPosition();
			this.mTouchTarget.setSize(new Core.Size(bbox_bottom_right.getX() - bbox_top_left.getX(), bbox_bottom_right.getY() - bbox_top_left.getY()));
			this.mTouchTarget.setPosition([off_x, off_y - (bbox_bottom_right.getY() - bbox_top_left.getY())*0.5]);

            this.mTouchTarget.setDepth(this.GetDepth());
            if (Exists(cb))
            {
                this.mTouchTarget.getTouchEmitter().addListener(this, cb);
            }
            else
            {
                this.mTouchTarget.getTouchEmitter().addListener(this, this.OnNativeTouchShim);
            }
            
            this.mListeners.push(this.mTouchTarget.getTouchEmitter());
		}
        else if (name === "Touch")
        {
            this.enabledTouch = true;
            if(this.mTouchTarget)
            {
                 this.mTouchTarget.destroy();
            }
            this.mTouchTarget = new GL2.TouchTarget();
          //  this.mTouchTarget.setPosition(this.mSpriteGL2.getPosition());
            this.mTouchTarget.setAnchor(this.mSpriteGL2.getAnimation().getFrame(0).getAnchor());
            this.mTouchTarget.m_Asset = this.m_Asset;
            if (Exists(this.mOwner))
            {
                this.mTouchTarget.mOwner = this.mOwner;
            }

            var size = this.mSpriteGL2.getAnimation().getFrame(0).getSize();
            if (this.mScaleTouchX || this.mScaleTouchY)
            {
				// need to convert to using an anchor of 0.5 in order to scale about the center of the touch target
				var x = (0.5 - this.mTouchTarget.getAnchor().getX()) * size.getWidth();
				var y = (0.5 - this.mTouchTarget.getAnchor().getY()) * size.getHeight();
				this.mTouchTarget.setPosition(x, y);	// relative to parent, mSpriteGL2
            	this.mTouchTarget.setAnchor(0.5, 0.5);

				// now we can scale
				if (this.mScaleTouchX)
				{
	            	size.setWidth(size.getWidth() * this.mScaleTouchX);					
				}
				if (this.mScaleTouchY)
				{
	            	size.setHeight(size.getHeight() * this.mScaleTouchY);					
				}
				//NgLogD("scaling touch target " + (this.mScaleTouchX ? this.mScaleTouchX : 1) + " x " + (this.mScaleTouchY ? this.mScaleTouchY : 1));
            }
           	this.mTouchTarget.setSize(size);
            this.mTouchTarget.setDepth(this.GetDepth());
            this.mSpriteGL2.addChild(this.mTouchTarget);
            if (Exists(cb))
            {
                this.mTouchTarget.getTouchEmitter().addListener(this, cb);
            }
            else
            {
                this.mTouchTarget.getTouchEmitter().addListener(this, this.OnNativeTouchShim);
            }
            
            this.mListeners.push(this.mTouchTarget.getTouchEmitter());
        }
        else
        {
            Core[name].addListener(this, cb);
            this.mListeners.push(Core[name]);
        }

		// Debug display of TouchTarget area
		var globals = WeUiMgr.GetJSONGlobals();
		if (Exists(globals) && Exists(globals["debug-touch"]) && globals["debug-touch"])
		{
			if (Exists(this.mTouchTarget))
			{
				this.mTouchSprite = new GL2.Sprite();
				this.mSpriteGL2.addChild(this.mTouchSprite);
				this.mTouchSprite.setImage(Content.getImagePath("black.png"), this.mTouchTarget.getSize(), this.mTouchTarget.getAnchor()); 
				this.mTouchSprite.setPosition(this.mTouchTarget.getPosition());
				this.mTouchSprite.setAlpha(0.4);
			}
		}
    },

	SetInteraction : function(enabled)
	{
		this.mEnableInteraction = enabled;
	},

    GetGL2: function()
    {
        return this.mSpriteGL2;
    },
    
    SetVisible: function(value)
    {
        if (this.mSpriteGL2)
        {
    	   this.mSpriteGL2.setVisible(value);
    	}
    },
    
    GetVisible: function()
    {
    	return this.mSpriteGL2.getVisible();
    },
    
    GetX: function()
    {
        if (this.mSpriteGL2)
        {
            return this.mSpriteGL2.getPosition().getX();
        }
        return null;
    },
    
    GetY: function()
    {
        if (this.mSpriteGL2)
        {
            return this.mSpriteGL2.getPosition().getY();
        }
        
        return null;
    },
    
    GetWidth: function()
    {
        return this.mSpriteGL2.getAnimation().getFrame(0).getSize().getWidth();
    },
    
    GetHeight: function()
    {
        return this.mSpriteGL2.getAnimation().getFrame(0).getSize().getHeight();
    },
    	
    SetWidthUsingScale: function(new_width)
    {
    	var size=this.mSpriteGL2.getAnimation().getFrame(0).getSize();
    	var width=size.getWidth();
    	var scaleX=this.mSpriteGL2.getScale().getX();
    	
    	if( Math.abs(scaleX*width-new_width)>0.01 )
    	{
    		var newScale=new_width/(scaleX*width);
    		this.mSpriteGL2.setScale( newScale, this.mSpriteGL2.getScale().getY());
    	}
    },
    
    GetRotation: function()
    {
       return this.mSpriteGL2.getRotation();
    },
    
    SetRotation: function(rot)
    {
       this.mSpriteGL2.setRotation(rot);
    },
    
    SetPosition: function(x, y, z)
    {
       if (this.mSpriteGL2)
       {
           this.mSpriteGL2.setPosition(x, y);
           if (Exists(z))
           {
               this.SetDepth(z);
           }
       }
    },
    
    SetScale: function(scalex, scaley)
    {
        if (!Exists(scaley))
        {
            scaley = scalex;
        }
		if (this.mSpriteGL2)
        	this.mSpriteGL2.setScale(scalex, scaley);
    },
    
    GetColor: function()
    {
        return this.mSpriteGL2.getColor();
    },
    
	/* it is really hacky, but the easiest way around for now*/
	SetImage : function(asset)
	{
		if (!this.mSpriteGL2 || !this.mSpriteGL2.getAnimation() || !this.mSpriteGL2.getAnimation().getFrame(0))
			return;
		var size = this.mSpriteGL2.getAnimation().getFrame(0).getSize();
		var anchor = this.mSpriteGL2.getAnimation().getFrame(0).getAnchor();

   	 	this.mAnimFrame = new GL2.Animation();
   	  	this.mAnimFrame.pushFrame(new GL2.Animation.Frame(Content.getImagePath(asset), 100, size, anchor));
   	  	this.mSpriteGL2.setAnimation(this.mAnimFrame, 0);
	},

    SetColor: function(r, g, b, a)
    {
        this.mSpriteGL2.setColor(r, g, b);
        if(a)
        {
             this.mSpriteGL2.setAlpha(a);
        }
    },
    
    SetDepth: function(depth)
    {
        this.mSpriteGL2.setDepth(depth || 0);
        if (this.enabledTouch)
		{
			this.mTouchTarget.setDepth(depth || 0);
		}
    },
    
    GetDepth: function()
    {
        return this.mSpriteGL2.getDepth();
    },
    
    SetAlpha: function(alpha)
    {
        if (!this.mSpriteGL2)
        {
			NgLogD("image SetAlpha - mSpriteGL2 does not exist: " + this);
			return;
        }
        this.mSpriteGL2.setAlpha(alpha);
        if(alpha === 0)
        {
            this.mSpriteGL2.setVisible(false);
        }
        else if(!this.mSpriteGL2.getVisible())
        {
            this.mSpriteGL2.setVisible(true);
        }
    },
    OnNativeTouchShim : function(touch)
    {
       return this.OnNativeTouch(touch);  
    },
    OnNativeTouch: function(touch)
        {
			DebugTouch(touch, "WeSprite2D OnNativeTouch()");
			if ( !this.mEnableInteraction)
			{
				NgLogD("OnNativeTouch: mEnableInteraction is false!");
				return false;
			}
            var results = false;
            var touchPosition = touch.getPosition();
            var time = Core.Time.getFrameTime();
            var delta = 0; 
            switch(touch.getAction())
            {
                case touch.Action.Start:
                    this.mStartTouch = false;
                    this.mTouchX = touchPosition.getX();
                    this.mTouchY = touchPosition.getY();
                    this.mLastTime = time;
                    
    				var gotTouch = this.OnTouchDown(touch);
    				if (gotTouch)
    				{
    					this.mTrackingId = touch.getId();
    				}
     
    				if (this.mRequiresTap)
    				{   // Buildings
    				    return false;
    				}
    				else
    				{   // UI
    				    results  = gotTouch || results;
    				    if (results)
    				    {
    				        this.mStartTouch = true;
    				    }
    				}
                    
                    break;
                case touch.Action.End:
                //	if (touch.getId() !== this.mTrackingId) return;
                    delta = time - this.mLastTime;
                    results  = this.OnTouchUp(touch, delta) || results;

                    if (this.mRequiresTap)
                    {
                        if(delta < 500 && Math.abs(this.mTouchX - touchPosition.getX()) < WeUiMgr.GetTouchLeeway() &&
                                Math.abs(this.mTouchY - touchPosition.getY()) < WeUiMgr.GetTouchLeeway())
                        {
                            results  = this.OnTapEvent(touch) || results;
                        }
                    }
                    else if (this.mStartTouch && Math.abs(this.mTouchX - touchPosition.getX()) < 5 * WeUiMgr.GetTouchLeeway() &&
                            Math.abs(this.mTouchY - touchPosition.getY()) < 5 * WeUiMgr.GetTouchLeeway())
                    {
                        results  = this.OnTapEvent(touch) || results;
                    }
                    this.mStartTouch = false;

                    results = this.OnTouchEnd(touch) || results;
                    
                    if (results)
                    {
                        if(this.mSound)
        				{
        					WeEffectsMgr.PlaySoundEffect(this.mSound);
    					}
                    }
                	break;

                case touch.Action.Move:
                    results = this.OnTouchMove(touch, time - this.mLastTime) || results;
                    if (this.mRequiresTap)
        				{
        				    return false;
        				}
                    break;
                default:
                    break;
            }

            return results;
        },
    
    OnTouchDown: function(touch)
    {
    // NgLogD("TOUCH DOWN");
        return false;
    },

    OnTouchUp: function(touch, deltaTime)
    {
    //    NgLogD("TOUCH UP");
        return false;
    },

    OnTouchMove: function(touch, deltaTime)
    {
    //    NgLogD("TOUCH MOVE");
        return false;
    },

    OnTapEvent: function(touch)
    {
     //   NgLogD("TOUCH TAP");
        return false;
    },
    
    OnTouchEnd: function(touch, deltaTime)
    {
     //   NgLogD("TOUCH END");
        return false;
    }
    
});

var _WeAnimatedSprite2D = _WeSprite2D.subclass(
{
	classname: "WeAnimatedSprite2D",
	
    initialize: function(parent, nameOrProto, levelOfDetail, flip, layer, ignoreOffsets, enableAnim)
    {
        this.mStartTouch = false;
        this.mSpriteGL2 = new GL2.Sprite();
        this.mSpriteGL2.owner = this;
        this.mParent = parent;
        this.mRequiresTap = true;
        
        if (Exists(nameOrProto.header_tag))
            this.m_Asset = nameOrProto.header_tag;
        else
            this.m_Asset = nameOrProto;
            
        this.InitAnimation(nameOrProto, levelOfDetail, flip, layer, ignoreOffsets, enableAnim);
       
        //this.mSpriteGL2.setAnimation(this.mAnimFrame, 0);
        this.mParent.addChild(this.mSpriteGL2);

        
        var animation = this.mAnimations[0];
        if (Exists(animation))
        {
        	var frame = animation.getFrame(animation.getFrameCount()-1);

            this.mWidth = frame.getSize().getWidth();
            this.mHeight = frame.getSize().getHeight();
        }
        
        this.mListeners = [];
    },

    IsSubClass : function()
    {
        return true;
    },
    
    GetSpriteDetails : function(spriteName, levelOfDetail)
    {
        var spriteDetails = null;
        try
        {
            if(levelOfDetail == -1)
            {
                spriteDetails = SpriteTableHeader.getSpriteTableData(spriteName, 0);
                levelOfDetail = 0;
            }
            else
            {
                spriteDetails = SpriteTableHeader.getSpriteTableData(spriteName, levelOfDetail);
            }
        }
        catch(e)
        {
            // JMARR This try catch is to hack around that our sprite table is out of date.
            // See above for rest of hack.
            printf('Outdated SpriteSheetTable is missing entry for %s', spriteName);
            printf("  Inner Error: "+e);
            return null;
        }
        
        return spriteDetails;
    },

    InitAnimation: function(nameOrProto, levelOfDetail, flip, layer, ignoreOffsets, enableAnim)
    {
        var animate = true;
        if(undefined !== enableAnim)
        {
            animate = enableAnim;
        }

        this.mLayer = layer;
            
        var flipMult = flip ? 1 : -1;

        if(typeof(nameOrProto) == 'string')
        {
            var spriteName = nameOrProto;			
			var cacheName = spriteName;
			if (flip) // cache flipped anims w/diff key
			{
				cacheName += "_flipped";
			}
            this.mIsAnimating = animate;
            var tmpAnim = gAnimationsByName[cacheName];
            if(tmpAnim === undefined)
            {
                var spriteDetails = this.GetSpriteDetails(spriteName, levelOfDetail);
                this.mAnimations = this.MakeAnimation(spriteName, levelOfDetail, flip, 0, ignoreOffsets, null, spriteDetails);

				// Fallback to 0 LOD
				if(this.mAnimations === null)
				{
                	var spriteDetails = this.GetSpriteDetails(spriteName, 0);
					this.mAnimations = this.MakeAnimation(spriteName, 0, flip, 0, ignoreOffsets, null, spriteDetails);
				}

				if(this.mAnimations === null || this.mAnimations.length == 0)
                {
					if (undefined === gAnimationsByName[GameSpecificVariables.WeSprite2D.FallbackAnimation])
					{
					    spriteDetails = this.GetSpriteDetails(GameSpecificVariables.WeSprite2D.FallbackAnimation, levelOfDetail);
						this.mAnimations = this.MakeAnimation(GameSpecificVariables.WeSprite2D.FallbackAnimation, levelOfDetail, flip, 0, false, null, spriteDetails);

						if(this.mAnimations === null)
						{
							spriteDetails = this.GetSpriteDetails(GameSpecificVariables.WeSprite2D.FallbackAnimation, 0);
							this.mAnimations = this.MakeAnimation(GameSpecificVariables.WeSprite2D.FallbackAnimation, 0, flip, 0, false, null, spriteDetails);
						}
					}
					else
					{
						this.mAnimations = gAnimationsByName[GameSpecificVariables.WeSprite2D.FallbackAnimation];
					}
                }
                if (gAnimationsByName[cacheName])
                {
                    gAnimationsByName[cacheName].destroy();
                }
                gAnimationsByName[cacheName] = this.mAnimations;
            }
            else
            {
                this.mAnimations = tmpAnim;
            }
            this.mAnimationsByName = {Idle: 0};
            this.mSpriteGL2.setAnimation(this.mAnimations[0], 0);
        }
        else if(gAnimationsCachedByProtoId[nameOrProto.id * flipMult])
        {
            this.mIsAnimating = animate;
            this.mAnimations = gAnimationsCachedByProtoId[nameOrProto.id * flipMult];
            this.mAnimationsByName = gAnimationsByNameCachedByProtoId[nameOrProto.id * flipMult];
            this.mSpriteGL2.setAnimation(this.mAnimations[0], 0);
        }
        else
        {
            var protoVisual = nameOrProto;
            var protoAnimations = weProtoDb.getInstance().getProtoAnimationsForProtoVisualId(protoVisual.id);
            
            if(protoVisual.offset_x === null || protoVisual.offset_y === null)
            {
                ignoreOffsets = true;
            }
            if(!protoAnimations)
            {
                this.InitAnimation(nameOrProto.header_tag, levelOfDetail, flip, layer, ignoreOffsets);
                return;
            }

            this.mIsAnimating = animate;
            this.mAnimations = [];
            this.mAnimationsByName = {};
            
            for(var i=0; i < protoAnimations.length; ++i)
            {
                var proto = protoAnimations[i];
                var animName = proto.proto_name;
                var spriteName = proto.header_tag;
                
                var animFlip = proto.flip_horizontal;
                
                // HACK.  Total last second hack to work around issue with mermaids - WeRule only
                // TODO: remove this code, possibly after fixing above-mentioned sprite issue
                if(spriteName == "SPR_mermaidisland_02")
                {
                    spriteName = "SPR_mermaidisland_01";
                }

                var spriteDetails = this.GetSpriteDetails(spriteName, levelOfDetail);
                if (spriteDetails && spriteDetails.spriteSheet.indexOf("_3") > 0 && levelOfDetail != 3)
                {
                    NgLogD("*** SKIPPING LOD3 for " + spriteName);
                    continue;
                }
                  
                if (!spriteDetails)

                {   // we keep going to handle cases where no animation exists for the sprite.
                    // we'll add the fall back animation
                    NgLogD("*** NO DETAILS  for " + spriteName);
                } 

                var animation = this.MakeAnimation(spriteName, levelOfDetail, flip ^ animFlip, -1, ignoreOffsets, proto, spriteDetails);
                if(!Exists(animation))
                {
                    if (spriteName.indexOf("_01") > 0)
                    {
                        spriteName = spriteName.replace("_01", "_idleone");
                        spriteDetails = this.GetSpriteDetails(spriteName, levelOfDetail);
                        animation = this.MakeAnimation(spriteName, levelOfDetail, flip ^ animFlip, -1, ignoreOffsets, proto, spriteDetails);
                    }
                    
                    if (!Exists(animation))
                    {
                        NgLogD("*** MISSING: " + spriteName + " lod: " + levelOfDetail);
                        continue;
                        // levelOfDetail = 2;
                        // var newSpriteName = GameSpecificVariables.WeSprite2D.FallbackCharAnim;
                        // spriteDetails = this.GetSpriteDetails(newSpriteName, levelOfDetail);
                        // animation = this.MakeAnimation(newSpriteName, levelOfDetail, flip ^ animFlip, 1000/12, false, null, spriteDetails);
                    }
                }                
                
                if(animName == 'Idle')
                {
                    // If this is the idle animation, force it to index 0.
                    for(var k in this.mAnimationsByName)
                    {
                        if(true || this.mAnimationsByName.hasOwnProperity(k))
                        {
                            this.mAnimationsByName[k] += 1;
                        }
                    }
                    if (Exists(animation))
                    {
                    	this.mAnimations.unshift(animation[0]);
                        this.mAnimationsByName[animName] = 0;
                    }
                    
                }
                else
                {
                    if (!(spriteName.indexOf("idletwo") >= 0 && animName.indexOf("IdleVariation1") >= 0))
                    {
                    	if (Exists(animation))
                    	{
                    		this.mAnimationsByName[animName] = this.mAnimations.length;
                    		this.mAnimations.push(animation[0]);
                    	}
                    }
                }
            }
            
            if (this.mAnimations.length <= 0)
            {
                NgLogD("*** NO ANIMATIONS for VISUAL ID: " + protoVisual.id + " lod: " + levelOfDetail);
                levelOfDetail = 0;
                var newSpriteName = GameSpecificVariables.WeSprite2D.FallbackCharAnim;
                spriteDetails = this.GetSpriteDetails(newSpriteName, levelOfDetail);
                if (animation && animation.length > 0)
                {
                    for (var i in animation)
                    {
                        if (animation[i])
                        {
                            animation[i].destroy();
                        }
                    }
                }
                
                animation = this.MakeAnimation(newSpriteName, levelOfDetail, flip ^ animFlip, 1000/12, false, null, spriteDetails);
                this.mAnimationsByName[animName] = this.mAnimations.length;
                this.mAnimations.push(animation[0]);
            }
            
            if (gAnimationsCachedByProtoId[nameOrProto.id * flipMult])
            {
                gAnimationsCachedByProtoId[nameOrProto.id * flipMult].destroy();
            }
            gAnimationsCachedByProtoId[nameOrProto.id * flipMult] = this.mAnimations;
            gAnimationsByNameCachedByProtoId[nameOrProto.id * flipMult] = this.mAnimationsByName;
            if (this.mAnimations.length > 0)
            {
            	this.mSpriteGL2.setAnimation(this.mAnimations[0], 0);
            }
            
        }
    },

    MakeAnimation : function(spriteName, levelOfDetail, flip, frameDelay, ignoreOffsets, proto, spriteDetails)
    {
    	
        // HACK.  Total last second hack to work around issue with mermaids - WeRule only
        // TODO: remove this code, possibly after fixing above-mentioned sprite issue
        if(spriteName == "SPR_mermaidisland_02")
        {
            spriteName = "SPR_mermaidisland_01";
        }

        var spriteDetails;
        var spriteDetailsMax;
    
        if( !spriteDetails )
        {
            NgLogD("Trying to make animation with no sprite Details: " + spriteName);
            return null;
        }
        
        if( !spriteDetails )
        {
            NgLogD("We Rule Sprite Tables Not Parsed Yet!");
            return null;
        }
        
        
        var spriteData = SpriteTable.getSpriteTableDataFromNOL(spriteDetails.spriteSheet,
                                                                spriteDetails.offset,
                                                                spriteDetails.length);

        if(frameDelay == -1)
        {
			var spriteDataMax = null;
			spriteDetailsMax = SpriteTableHeader.getSpriteTableDataHigest(spriteName);
			if(spriteDetailsMax)
				spriteDataMax = SpriteTable.getSpriteTableDataFromNOL(spriteDetailsMax.spriteSheet,
                                                                    spriteDetailsMax.offset,
                                                                    spriteDetailsMax.length);
				
            if(!spriteDetailsMax || spriteDataMax.length < spriteData.length)
            {
                frameDelay = frameDelay = 1000.0 / (proto.frames_per_second);
            }
            else
            {
                frameDelay = 1000.0 / (proto.frames_per_second * (1.0 * spriteData.length) / (1.0 * spriteDataMax.length)) ;
            }
        }

        var textureWidthHeight = SpriteTableHeader.getSpriteSheetSize(spriteDetails.spriteSheet);
        var lenOfSprite = spriteData.length;

        var animation = new GL2.Animation();
        if (animation)
        {
            gAnimationsCachedForCleanup.push(animation);
        }
        animation.setFilteringEnabled(false);
        var frame;
        var i = 0;
        if(lenOfSprite>1)
        {
            if (frameDelay === 0)
            {
                // AW: MS doesn't like animations with multiple frames with frameDelay 0.
                // so we are going to set up multiple animations istead
                var list = [];
            //    animation.destroy();
                for(i=0; i<(lenOfSprite); i++)
                {
                    animation = new GL2.Animation();
                    if (animation)
                    {
                        gAnimationsCachedForCleanup.push(animation);
                    }
                    animation.setFilteringEnabled(false);
                    frame =  this.MakeFrame(spriteData[i],
                                            spriteDetails.spriteSheet,
                                            textureWidthHeight,
                                            flip,
                                            frameDelay,
                                            ignoreOffsets);
                    if (Exists(frame))
                    {
                    	animation.pushFrame(frame);
                    	list.push(animation);
                    }
                    else
                    {
             //       	animation.destroy();
                    	return null;
                    }
                }
                
                return list;
            }
            else
            {
                for(i=0; i<(lenOfSprite); i++)
                {
                    frame =  this.MakeFrame(spriteData[i],
                                            spriteDetails.spriteSheet,
                                            textureWidthHeight,
                                            flip,
                                            frameDelay,
                                            ignoreOffsets);
                    if (Exists(frame))
                    {
                    	animation.pushFrame(frame);
                    }
                    else
                    {
               //     	animation.destroy();
                    	return null;
                    }
                    
                    
                }
            }
        }
        else
        {
            frame = this.MakeFrame( spriteData,
                                    spriteDetails.spriteSheet,
                                    textureWidthHeight,
                                    flip,
                                    0,
                                    ignoreOffsets);
            if (Exists(frame))
            {
            	animation.pushFrame(frame);
            }
            else
            {
          //  	animation.destroy();
            	return null;
            }
            
        }

        return [animation];
    },

    MakeFrame : function(spriteData, spriteSheet, textureWidthHeight, flip, frameDelay, ignoreOffsets)
    {
        var uvOne = ((spriteData.mX*1.0)/(textureWidthHeight*1.0));
        var uvTwo = ((spriteData.mY*1.0)/(textureWidthHeight*1.0));
        var uvThree = (spriteData.mX*1.0+spriteData.mWidth*1.0)/(textureWidthHeight* 1.0);
        var uvFour = (((spriteData.mY*1.0)+(spriteData.mHeight*1.0))/(textureWidthHeight*1.0));
        var width = spriteData.mWidth*1.0;
        var height = spriteData.mHeight*1.0;
        
        var xOff = (spriteData.xOffset*1.0)/(width);
        var yOff = (spriteData.yOffset*1.0)/(height);
     
        if(ignoreOffsets)
        {
            xOff = 0.5;
            yOff = 0.5;
        }

        var uvs;
        if( flip )
        {
            uvs = [uvThree, uvTwo, uvOne - uvThree, uvFour - uvTwo];
            xOff = 1-xOff;
        }
        else
        {
            uvs = [uvOne, uvTwo, uvThree - uvOne, uvFour - uvTwo];
        }
        
        //NgLogD("UV  "+uvs[0]+" "+uvs[1]+" "+uvs[2]+" "+uvs[3]);
        
        //NgLogD("Ziurim freimus xOff "+ xOff+" yOff "+yOff+" width "+width+" height "+height+" uv "+uvs);

		// If we can, load compressed texture instead of png
		var sheetPvr = spriteSheet.replace('.png', '.pvr');
		var sheetAtc = spriteSheet.replace('.png', '.atc');

        // TODO: Add some logging and see what filename is. Might not be getting generated properly for the new pipeline.
		if(SpriteTable.imgExists(sheetPvr))
			filename = sheetPvr;
		else if(SpriteTable.imgExists(sheetAtc))
			filename = sheetAtc;
		else
			filename = spriteSheet;
            
        if (gDebugMissingAssets)
        {
            var tempAsset = Content.getSpriteSheetPath(filename);
            Storage.FileSystem.readFile(tempAsset, function(error) { 
        	    if(error) 
        		{
        			NgLogD("######## ASSET MISSING: " + tempAsset + " : " + error);
        		}
        	});
        }
        
        var path = Content.getSpriteSheetPath(filename);
        if (!Exists(path))
        {
        	//
        	//	SZ: do not load missing animations
        	//
        	return;
        }
        
		frame = new GL2.Animation.Frame(path, frameDelay, [width, height], [xOff, yOff], uvs);
		if (this.enabledTouch)
		{
			this.mTouchTarget.setAnchor(xOff, yOff);
		}
		
        return frame;
    },

    PushGamePosition : function ( pos, protoOffset, dbg, isDecal )
    {
        if(undefined === isDecal)
        {
            isDecal = false;
        }
        var tmp = [ pos[ 0 ], pos[ 1 ] ]; 

        if ( protoOffset[ 0 ] === null || protoOffset[ 1 ] === null)
        {
            protoOffset[ 0 ] = 0;
            protoOffset[ 1 ] = this.mHeight/2;
        }
        
        //never used 
        this.protoXoffset = protoOffset[ 0 ];
        this.protoYoffset = protoOffset[ 1 ];
        
        weGamePosToScreenPos ( tmp, 0);//protoOffset[ 2 ] );
        tmp[ 0 ] -= protoOffset[ 0 ];
        tmp[ 1 ] -= protoOffset[ 1 ];
        
        if ( ! protoOffset[ 2 ] )
        {
        	protoOffset[ 2 ]=1;
        }
        this.mSpriteGL2.setPosition (tmp[0], tmp[1]);
        // JMARR Hack, there should be a better way to find the 'mid' point where entities should sort.
        //WeCity
        var useWidth = (this.mWidth / 5)/cTileSizeWidth;
    	var nTemSize=  WeGameStateMgr.GetGameLotGrid().mMaxTileIndexExtent;
    	var z= ((((tmp[ 1 ]  + protoOffset[ 1 ])/cTileSizeWidth)-useWidth)/(nTemSize+nTemSize))+this.mLayer+ (1-protoOffset[ 2 ]*0.0001);
    	if (z <= 0)
		{
			z = 0.015;
		}
        if(isDecal) 
        {
            this.mSpriteGL2.setDepth(z-0.01);    
        }
        else
        {
            this.mSpriteGL2.setDepth(z);
        }
        
        if ( dbg )
        {
            dbgSpritePos ( tmp );
        }
    },   

    SetAnimationByName : function(name, halt)
    {
        if (name === "IdleVariation1")
        {
            var index2 = this.mAnimationsByName["IdleVariation2"];
            
            if (index2 !== undefined)
            {
                if (Math.randint(2) == 0)
                {
                    name = "IdleVariation2";
                }
            }
        }
        var index = this.mAnimationsByName[name];
        
        // If named animation doesn't exist, revert to idle anim at index 0.
        if(index === undefined)
        {
            index = 0;
        }
        if (this.mAnimations.length > 0)
        {
        	this.mSpriteGL2.setAnimation(this.mAnimations[index], 0);
        }
        
    }
});

var _WeFramedSprite2D = _WeSprite2D.subclass(
{
	classname: "WeFramedSprite2D",
	
    initialize: function(asset, size, location, uvs, parent, anchor)
    {
        this.mStartTouch = false;
        anchor = anchor || [0, 0];
        this.mRequiresTap = false;
        this.mAnimFrame = new GL2.Animation();
        if(Exists(gTunables.optimizations) && gTunables.optimizations.bilinear_filter_all)
        {
            this.mAnimFrame.setFilteringEnabled(false);
        }
        if (gDebugMissingAssets)
        {
            var tempAsset = asset;
            Storage.FileSystem.readFile(tempAsset, function(error) { 
        	    if(error) 
        		{
        			NgLogD("######## ASSET MISSING: " + tempAsset + " : " + error);
        		}
        	});
    	}
        this.mAnimFrame.pushFrame(new GL2.Animation.Frame(asset, 100, size, 
            anchor, uvs));
        
        this.mFrameData={"asset":asset, "size":size, "anchor":anchor, "uvs":uvs  };

        this.mSpriteGL2 = new GL2.Sprite();
        this.mParent = parent || GL2.Root;
        this.mSpriteGL2.owner = this;
        this.mSpriteGL2.setPosition(location[0], location[1]);
        this.mSpriteGL2.setRotation(0);
        this.mSpriteGL2.setDepth(location[2] || 0);
        this.mSpriteGL2.setAnimation(this.mAnimFrame, 0);
        this.mParent.addChild(this.mSpriteGL2);
        this.enabledTouch = false;
        this.mListeners = [];

    },

    SetUV: function(uvs)
    {
        if (Exists(this.mAnimFrame))
        {
            this.mAnimFrame.destroy();
        }
    	 this.mAnimFrame = new GL2.Animation();
         if(Exists(gTunables.optimizations) && gTunables.optimizations.bilinear_filter_all)
         {
             this.mAnimFrame.setFilteringEnabled(false);
         }
    	  this.mAnimFrame.pushFrame(new GL2.Animation.Frame(this.mFrameData.asset, 100, this.mFrameData.size, 
    	  this.mFrameData.anchor, uvs));
    	  this.mSpriteGL2.setAnimation(this.mAnimFrame, 0);
    },

    IsSubClass : function()
    {
        return true;
    }
});   

exports.WeSprite2D = _WeSprite2D;
exports.WeAnimatedSprite2D = _WeAnimatedSprite2D;
exports.WeFramedSprite2D = _WeFramedSprite2D;
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeSocialMapMgr'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeSocialMapMgr'] || {}; $MODULE_REGISTRY['weEngine/WeSocialMapMgr'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-23
 *  @file:      WeSocialMapScreen.js
 *  @author:    Jon Guest
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var Color      = require('NGCore/Shared/Color').Color;
var Content = require('weEngine/WeContent').Content;
var Social = require('NGCore/Client/Social').Social;
var NGUI = require('NGCore/Client/UI').UI;

exports.WeSocialMapMgr = Core.MessageListener.singleton(
{
	classname: "WeSocialMapMgr",
	
	// images
	selfImageIndex : 0,
	castleImageIndex : 1,
	selfSocialBGIndex : 2,
	socialBGIndex : 3,
	onlineImageIndex : 4,
	realm1ImageIndex : 5,
	openbubbleImageIndex : 6,
	openImageIndex : 7,
	crownImageIndex : 8,
    selfFrameIndex : 9,
    socialFrameIndex : 10,
    socialAvatarIndex : 11,
	// labels
	nameLabelIndex : 0,
	levelLabelIndex : 1,
	realmsIndex : 2,
	// nodes
	nodesPerScreen : 3,

	//current social map page
	socialMapCurrentPage: -1,
	socialMapMaxPages: 1,
	changeingPage: false,
	isCommunityMap: false,
	showAdCastle: false,
	isLoadingMap: false,

	initialize : function()
	{
	},

	onUpdate : function()
    {
		// UGLY HACK
		// We check the top of the Nav stack in an update loop waiting for it to
		// return undefined - at which point we know the plus screens are done and
		// we trigger a reload.
		//if (UI.NavController.getInstance().getTopView() == undefined)
		{
			// NgLogD("--------- Update Listener for Social Map ---------");
			// NgLogD("Reloading the social map after returning from Plus");
			// NgLogD("--------------------------------------------------");
			Core.UpdateEmitter.removeListener(this);
			if (this.socialMapCurrentPage <= 0)
			{
				this.socialMapCurrentPage = 1;
			}
			//NgLogD("Social map on update");
			WeUiMgr.ShowLoading(true);
			this.launchSocialMap(this.socialMapCurrentPage);
		}
    },

    socialMapRequestCB: function(request)
    {
    	
    },
    
    launchSocialMap : function(page, communityMap)
    {
    	this.social_semaphore=false;
    	this.changeingPage=true;
	    self = this;
	    var socialMapRequestCB = function(request)
	    {
	    	//NgLogD("@@@@ Server responded");
	    	WeUiMgr.ShowLoading(false);
			if (!WeSocialMapMgr.isLoadingMap)
			{
				return;	// we are not loading anything or the loading is cancelled
			}
	        if(request && request.responseText && request.readyState == 4 )
	        {

			    try
                {
                    self.mJSON = JSON.parse(request.responseText);
                    self.socialMapMaxPages    = self.mJSON[0]['max_pages'];
                    self.socialMapCurrentPage = self.mJSON[0]['current_page'];
                    self.showAdCastle = self.mJSON[0]['show_ad_castle'];

                   
                    WeUiMgr.TransitionScreenTo("SocialMapScreen");
    			    WeRenderDevice.EnableGame(false);
					WeSocialMapMgr.isLoadingMap = false;
    			    
    			    //objDump(self.mJSON, 4);
                }
                catch(ex) 
                {
					NgLogD("@@@@ Error retrieving social map data: exception " + ex);
                	//ExitOnError(gErrors.SERVER_MESSAGE_REJECTED_CRITICAL);
                	WeUiMgr.ShowLoading(false);
					WeSocialMapMgr.isLoadingMap = false;
					//Storage.FileSystem.writeFile('./server-error', request.responseText);
				    WeUiMgr.ShowNetworkErrorPopUp();
                }
	        }
			else
			{
				NgLogD("@@@@ Error retrieving social map data: bad request/response");
				//ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
				//Storage.FileSystem.writeFile('./server-error', request.responseText);
				WeUiMgr.ShowNetworkErrorPopUp();
			}
	        self.changeingPage=false;
	        self.social_semaphore=true;
	    };
	    // lets make a request for the social map
	    //NgLogD("@@@@ Making request");
	    
	    WeUiMgr.ShowLoading(true);
	    if (Exists(communityMap))
	    {
	    	this.isCommunityMap = true;
	    }
	    
		this.isLoadingMap = true;
	    if(this.isCommunityMap)
	    {
	    	WeProtocol.getCommunityMaps(page, socialMapRequestCB);
	    }
	    else
	    {
	    	WeProtocol.getSocialMaps(page, socialMapRequestCB);
	    }
	    
	    //WeProtocol.getSocialMaps(page, socialMapRequestCB);
	    //NgLogD("@@@@ Made request");
    },
    
    social_semaphore : true,

    Refresh : function()
    {
    	if(this.social_semaphore)
    	{
    		this.launchSocialMap(1);
    	}
    },
    changeMode : function()
    {
    	if(this.social_semaphore)
    	{
			this.isCommunityMap=!this.isCommunityMap;
			this.launchSocialMap(1);
    	}
    },
	getNodesPerScreen : function()
	{
		return this.nodesPerScreen;
	},
	getFriendCount : function()
	{
		return this.mJSON.length;
	},
	getMapMaxPages: function()
	{
		return this.socialMapMaxPages;
	},
	getMapCurrentPage: function()
	{
		return this.socialMapCurrentPage;
	},
	getInviteSpacesCount : function()
	{
		if(this.isCommunityMap) return 0;
		// always want to have at least one friend position (and there are 3 location spaces per screen)
		var friend_count = this.mJSON.length;
		var iSpaceCount  = (this.nodesPerScreen - (friend_count % this.nodesPerScreen)) + this.nodesPerScreen;
		iSpaceCount = friend_count / this.nodesPerScreen > 2 ? iSpaceCount - this.nodesPerScreen : iSpaceCount;
		return iSpaceCount;
	},
	// this adjusts a passed in itemDef to be consistent with the given index
	modifySocialItem : function(itemDef, kingdom_index)
	{
		var tKingdom=this.mJSON[kingdom_index];
	    if (tKingdom.user_name == gCurKingdomUser)
	    {
	        itemDef.images[this.selfImageIndex].asset = tKingdom.castle_image;
	        itemDef.images[this.castleImageIndex].disabled = true;
	        itemDef.images[this.selfImageIndex].disabled = false;
            itemDef.images[this.selfSocialBGIndex].disabled = false;
            itemDef.images[this.crownImageIndex].disabled = false;
            itemDef.images[this.selfFrameIndex].disabled = false;
            itemDef.images[this.socialFrameIndex].disabled = true;
            itemDef.images[this.socialAvatarIndex].disabled = true;
	    }
	    else
	    {
		    itemDef.images[this.castleImageIndex].asset = tKingdom.castle_image;
		    itemDef.images[this.selfImageIndex].disabled = true;
		    itemDef.images[this.castleImageIndex].disabled = false;
            itemDef.images[this.selfSocialBGIndex].disabled = true;
            itemDef.images[this.crownImageIndex].disabled = true;
            itemDef.images[this.selfFrameIndex].disabled = true;
            itemDef.images[this.socialFrameIndex].disabled = false;
            itemDef.images[this.socialAvatarIndex].disabled = false;
            itemDef.images[this.socialAvatarIndex].args.gamertag = tKingdom.user_name;
	    }

	    itemDef.labels[this.nameLabelIndex].text = tKingdom.user_name;
	    itemDef.labels[this.levelLabelIndex].text = "Level: " + tKingdom.level;
		
		// handles the online status
		if (tKingdom.is_online)
		{
			itemDef.images[this.onlineImageIndex].disabled = false;
		}
		else
		{
			itemDef.images[this.onlineImageIndex].disabled = true;
		}
		
		// handles available jobs
		if (tKingdom.has_available_jobs)
		{
			itemDef.images[this.openImageIndex].disabled = false;
			itemDef.images[this.openbubbleImageIndex].disabled = false;
		}
		else
		{
			itemDef.images[this.openImageIndex].disabled = true;
			itemDef.images[this.openbubbleImageIndex].disabled = true;
		}

		// crown image for current user
		if (tKingdom.user_name == gCurKingdomUser)
		{
			itemDef.images[this.selfSocialBGIndex].disabled = false;
			itemDef.images[this.socialBGIndex].disabled = true;
		}
		else
		{
			itemDef.images[this.selfSocialBGIndex].disabled = true;
			itemDef.images[this.socialBGIndex].disabled = false;
		}
		
		// handles the realm flag count
		itemDef.labels[this.realmsIndex].text = '' + tKingdom.all_kingdoms.length;
	},
	
	
	transitionScreenToKingdom : function()
	{
        if (WeGameStateMgr.IsCurrentUser())
        {
            WeUiMgr.TransitionScreenTo("InGameScreen");
        }
        else
        {
        	WeUiMgr.TransitionScreenTo("InGameScreen_Friend");
        }		
	},

	// kingdom_index represents the index into the list of friend kingdoms, 0 being the players kingdom, 1 being their first friend, etc.
	gotoKingdomFromMap : function(kingdom_index)
	{
		
		var kingdomData = this.mJSON[kingdom_index];
		
	 	if (Exists(kingdomData))
		{
	 		WeRenderDevice.EnableGame(true);
			for ( var  i in kingdomData.all_kingdoms )
	        {
	            if ( kingdomData.all_kingdoms[i].kingdom_type == "main" )
	            {
	            	
	            	WeGameStateMgr.SetIsFriend(kingdomData.is_friend);
					var kid = kingdomData.all_kingdoms[i].kingdom_id;
					
					// already have this kingdom loaded?
					gKingdomName = kingdomData.user_name;
					
					NgLogD("kid: " + kid + "current kingdom id: " +  WeGameStateMgr.GetCurrentKingdomId());
					
					if (kid == WeGameStateMgr.GetCurrentKingdomId())
					{
						//drop into the regular game screen
						this.transitionScreenToKingdom();
       				}
					else
					{
						//
						//	Check if need to download additional content for this kingdom
						//
						if (WeContentDownloader.HaveContent(kingdomData.level))
						{
							if (WeLotLoad(kid))
                            {   
                            	// Set the kingdom user name
                                WeGameStateMgr.SetCurrentKingdomId(kid);
                                WeGameStateMgr.SetCurrentKingdomUser(kingdomData.user_name);
                            }	
                    		else
                    		{
                    			NgLogD("Error loading kingdom");
                    		}
						}
						else
						{
							if (WeContentDownloader.IsDownloading())
							{
								//
								//	wait for the level to be downloaded
								//
								
								var newArgs = {};
	                    	    var desiredLevel = kingdomData.level;
	                    	    var kIndex = kingdom_index;
	                    	    var self = this;
	            				newArgs.OnYes = function(theNewArgs)
	            				{
	            				    WeGameStateMgr.SetGlobalGameWidget(null);
	            				    
	                                var cbAfterDownload = function()
	                                {
	                                	WeUiMgr.ShowLoading(false);
	                                	
	                                	if (WeLotLoad(kid))
	                                    {   
	                                    	// Set the kingdom user name
	                                        WeGameStateMgr.SetCurrentKingdomId(kid);
	                                        WeGameStateMgr.SetCurrentKingdomUser(kingdomData.user_name);
	                                    }
	                            		else
	                            		{
	                            			NgLogD("Error loading kingdom");
	                            		}
	                                };

	                                WeUiMgr.ShowLoading(true);
	                                WeContentDownloader.SetWaitLevelDownloadCallback(cbAfterDownload, desiredLevel);
	            				};

	            				newArgs.OnNo = function(theNewArgs)
	            				{
	            				    WeGameStateMgr.SetGlobalGameWidget(null);
	            				};
	            				
	            				newArgs.popup_label = "Sorry!";
	            				newArgs.popup_text = "This kingdom's content has not downloaded yet. Do you wish to enter and wait for it to finish?  Tap NO to cancel.";
	              
	            				var itemDef = WeUiMgr.GetItemDef("popup_box");
	            				var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
	            				newArgs.xGameWidget = newGameWidget;
	            				newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
								
							}
							NgLogD("need to download additional content");
							
							//
							//	Download additional content
							//
							 
                    	    
            				
						}
					}
				
	            }
	        }
		}
	},
	addFriend : function()
	{
		Social.Common.Service.openUserFinder();
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeGameStateMgr'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeGameStateMgr'] || {}; $MODULE_REGISTRY['weEngine/WeGameStateMgr'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      GameStateMgr.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:
///
//////////////////////////////////////////////////////////////////////////////
var Core       = require('NGCore/Client/Core').Core;
var WeLot      = require('weEngine/WeGround').WeLot;
var WeBoundary = require('weEngine/WeBoundary').WeBoundary;
var WeTime = require('weEngine/WeTime').WeTime;
//////////////////////////////////////////////////////////////////////////////
// Class GameStateMgr
// Encapsulates all our game state code into one accessable API
exports.WeGameStateMgr = Core.Class.singleton(
{
	classname: "WeGameStateMgr",
	
    initialize: function()
    {
        this.mLotEditable = false;
        this.mActiveObject = null;
        this.mLastActiveObject = null;
        this.mGhostObject = null;
        this.mLot = null;
        this.mLotGrid = null;
        this.mPendingObject = null;
        this.mLotInfo = null;
        this.currentKingdomUser = null;
        this.currentKingdomId = gCurKingdomId;
        this.mGlobalGameWidget = null;
        this.mGlobalQueue = [];
        this.mPopupWidget = null;
        this.mPopupQueue = [];
        this.mSavedZoomScale = -1;
        this.mIsCameraMovable = true;
        this.mIsAtMaxJobs = false;
        this.mIsLoadingKingdom = false;
        this.mIsGameUIHidden = false;
        this.mFactoryCount = 0;
        this.mGardenCount = 0;
        this.mCurrentUserKingdomNumBlockingJobs = 0;
        this.mNumBlockingJobs = 0;
		this.mIsFirstLoad = true; // only true for the first loaded kingdom of this session
       	this.mIsSocialJobPlaced = false;
       	this.mTouchAllowed = true;
		this.mStash = null;
		this.mGifts = [];
		this.mGiftUsers = [];
		this.mSEGiftUsers = [];
		this.mGiftingOpen = false;
		this.mFreeOpen = 5;
		this.mCurrentGift = 0;
		this.mDelayedXp = null;
		this.mPlacingOrderInAction = false;
		this.mCollectionBubbleList = [];
        this.mIsGiftsLoading = false;
        this.mIsFriend=false;
        this.mBalanceRect = null;
        this.mLastScreen = null;
        this.mCurrentPhotoId = null;
        this.mAvatarCache = {};
        this.mEventDaysLeft = 0;
        this.mInterstitialURL = null;
        this.mInterstitialCommand = null;
        this.mSuspended = false;
		this.mShowingGiftOpenAnimation = false;
    },
    
    IsFriend : function()
    {
    	return this.mIsFriend;
    },
    
    SetIsFriend: function(value)
    {
    	this.mIsFriend=value;
    },

	Setup : function()
	{
		this.mLot = new WeLot();
	},

    //////////////////////////////////////////////////////////////////////
    // Method: SetCameraMovable
    // @param is the camera now movable
    SetCameraMovable : function(isMovable)
    {
        this.mIsCameraMovable = isMovable; 
    },

    IsCameraMovable : function()
    {
        return this.mIsCameraMovable;
    },

    CalculateNumBlockingJobs : function()
    {
        this.mCurrentUserKingdomNumBlockingJobs = 0; 
        this.mNumBlockingJobs = 0;
        var lot = this.GetGameLotInfo();
        var active_jobs = lot.active_jobs;
        var len = 0;
        if (Exists(active_jobs))
        {
            len = active_jobs.length;
        }
        for(var idx = 0; idx < len; ++idx)
        {
            var job = active_jobs[idx];
            if (job.state === "Working" || job.state === "RequestSent")
            {
                this.mNumBlockingJobs++;
                if (job.request_name === gCurKingdomUser)
                {
                    //NgLogD(job.id + "****  IS BLOCKING " + job.state);
                    this.mCurrentUserKingdomNumBlockingJobs++;
                }
            }
        }
        
        //NgLogD("****  NUM BLOCKING JOBS " + this.mCurrentUserKingdomNumBlockingJobs);
    },

    GetNumBlockingJobs : function()
    {
        return this.mNumBlockingJobs;
    },

    GetCurrentUserKingdomNumBlockingJobs : function()
    {
        return this.mCurrentUserKingdomNumBlockingJobs;
    },

	GetIsFirstLoad : function()
	{
		return this.mIsFirstLoad;
	},
	
	SetIsFirstLoad : function(val)
	{
		this.mIsFirstLoad = val;
	},

    ShowGameUI : function(flag)
    {
        var widget = this.GetGlobalGameWidget();
        if (flag === false && widget !== null && widget.hide_idle === false)
        {
            return;
        }

        this.mIsGameUIHidden = !flag;

        if (this.mLotInfo)
        {
            this.mLotInfo.HideBubbles(!flag);
        }
        
        var len; 
        var idx;
        var images = WeUiMgr.GetImageFactory().mFactoryImages;
        if (images)
        {
            len = images.length;
            for(idx = 0; idx < len; ++idx)
            {
                var image = images[idx];
                if (image.hide_idle)
                {
                	image.SetVisible(flag);
                }
            }
        }

        var labels = WeUiMgr.GetLabelFactory().mFactoryLabels;
        if (labels)
        {
            len = labels.length;
            for(idx = 0; idx < len; ++idx)
            {
                var label = labels[idx];
                if (label.hide_idle)
                {
                	label.SetVisible(flag);
                }
            }
        }
        
        var composites = WeUiMgr.GetCompositeFactory().mFactoryObjects;
        if (composites)
        {
            for(var idx in composites)
            {
                var composite = composites[idx];
                if (composite && composite.hide_idle)
                {
                	composite.SetVisible(flag);
                	this.ShowComposite(composite, flag);
	            	if(composite.xController)
	            	{
	            		this.ShowComposite(composite.xController, flag);
	            	}
                }
            }
        }
        if (widget && widget.hide_idle)
        {
        	widget.SetVisible(flag);
        }
    },
    
    ShowComposite : function(composite, flag)
    {
		var children = composite.xChildren;
	    if (children)
	    {	
	        for(var idx in children)
	        {
	            var child = children[idx];
	            if (child.hide_idle)
	            {
	            	child.SetVisible(flag);
	            	this.ShowComposite(child, flag);
	            	if(child.xController)
	            	{
	            		this.ShowComposite(child.xController, flag);
	            	}
	            }
	        }
	    }
    },

    IsGameUIHidden : function()
    {
        return this.mIsGameUIHidden;
    },

    SetLoadingKingdom : function(loading)
    {
        this.mIsLoadingKingdom = loading;
    },

    IsLoadingKingdom : function()
    {
        return this.mIsLoadingKingdom;
    },

    SetIsAtMaxJobs : function(atMax)
    {
        this.mIsAtMaxJobs = atMax; 
    },

    IsAtMaxJobs : function()
    {
        return this.mIsAtMaxJobs;
    },

    SetCurrentKingdomUser : function(name)
    {
        this.currentKingdomUser = name; 
    },

    IsCurrentUser : function()
    {
        if (gOAuthEnabled && Core.Capabilities.getPlatformOS() != "flash")
        {
            return (this.currentKingdomUser == gCurKingdomUser);
        }
        else
        {
            return true;
        }
    },
    
	HasOpenJobsIn: function(name )
	{
		if(this.mLotInfo.all_jobs)
		{
			var all_jobs = this.mLotInfo.all_jobs;
			for(var id in all_jobs){
				if ( all_jobs[id].kingdom_type == name )
				{
					if(all_jobs[id].has_available_jobs == true)
					{
						return true;
					}
				}
			}
		}
		return false;
	},
	
	UnlockUpgrade: function( name )
	{
	    var unlockUpgrade=null;

	    
	    for(var i = 0; i < weProtoDb.getInstance().proto_upgrades.length; i++ )
	    {
	    	var upgrade=weProtoDb.getInstance().proto_upgrades[i].proto_upgrade;
	    	
	    	if(upgrade.kingdom_type==name)
	    	{
	    		if(unlockUpgrade)
	    		{
	    			if(unlockUpgrade.proto_id>upgrade.proto_id)
	    			{
	    				unlockUpgrade=upgrade;
	    			}
	    		}
	    		else
	    		{
	    			unlockUpgrade=upgrade;
	    		}
	    		
	    	}
	    }
	    return unlockUpgrade;
	},

    GetCurrentKingdomUser : function()
    {
        return this.currentKingdomUser;
    },

    SetCurrentKingdomId : function(id)
    {
    	//old global
    	gCurKingdomId=id;
        this.currentKingdomId = id; 
    },

    GetCurrentKingdomId : function()
    {
        return this.currentKingdomId;
    },

    SetSavedZoomScale : function(scale)
    {
        this.mSavedZoomScale = scale; 
    },

    GetSavedZoomScale : function()
    {
        return this.mSavedZoomScale;
    },

    //////////////////////////////////////////////////////////////////////
    // Method: GetGameLot
    // Get access to the WeLot object used by the game
    // @return WeLot 
    GetGameLot : function()
    {
        return this.mLot;
    },

    GetGameLotGrid : function()
    {
        return this.mLot.mWeLotGrid;
    },

    // (kingdom release 1.14)

    //////////////////////////////////////////////////////////////////////
    // Method: GetGameLot
    // Get access to the WeLot object used by the game
    // @return WeLot 
    GetGameLotInfo : function()
    {
        return this.mLotInfo;
    },

    //////////////////////////////////////////////////////////////////////
    // Method: SetGameLot
    // Get access to the WeLot object used by the game
    // @return WeLot 
    SetGameLotInfo : function(lotInfo)
    {
    	//this.GetGardenCountLimits();
		// NgLogD("[RCDEBUG] Setting game lot info to:"+lotInfo);
    	//this.GetFactoryCountLimits();
    	 
        this.mLotInfo = lotInfo;
        if(this.mLotInfo)
        {
        	this.SetCurrentKingdomId(this.mLotInfo.id);
        }
    },
   
	CountProducingItems : function (kingdom)
	{
	    var protoLen = weProtoDb.getInstance().proto_entities.length;
		var factoryID = -1;

		for (var i = 0; i < protoLen; i++)
		{
			if (weProtoDb.getInstance().proto_entities[i].proto_entity.proto_name == GameSpecificVariables.WeGameState.ProducingItem) {
				factoryID = weProtoDb.getInstance().proto_entities[i].proto_entity.id;
				break;
			}
		}

		var entLen = kingdom.entities.length;
		for (var i = 0; i < entLen; i++)
		{
			var ent = kingdom.entities[i];
			if (ent.proto_entity_id == factoryID) 
			{
				NgLogD("GotLotForLimits: found producing item");
				if (!Exists(ent.sold) || ent.sold == false) {
					this.mFactoryCount += 1;
					NgLogD("IncreasingCountTo: " + this.mFactoryCount);
				}
			}
		}
	},

	IsAnyHarvestable : function()
	{
		var lot = this.mLotInfo.mKingdomObjects;
		for(var i in lot) {
			if(lot[i].IsHarvestable())
				return true;
		}
		return false;
	},

	GetHarvestable : function()
	{
		var buildings = [];
		var lot = this.mLotInfo.mKingdomObjects;
		for(var i in lot)
		{
			var ent = lot[i];
			if(ent.IsHarvestable())
			{
				buildings.push(ent);
			}
		}
		return buildings;
	},

    GetCountLimits: function() 
    {
    	 if (this.mLotInfo != null) {
    		NgLogD("GetCountLimits!");
          	var kingdomsCount =  this.mLotInfo.all_kingdoms.length;

      		this.mFactoryCount = 0;
      		
      		for (var i = 0; i < kingdomsCount; i++) {
      			if (this.mLotInfo.id != this.mLotInfo.all_kingdoms[i].kingdom_id) {
      				WeProtocol.getKingdom(this.mLotInfo.all_kingdoms[i].kingdom_id, this.bind(this.GotLotForLimits));
      			}
      		}     		
      		this.CountProducingItems (this.mLotInfo);
    	 }   	
    },

    //////////////////////////////////////////////////////////////////////
    // Method: CanMoveLotObjects
    // @return: Can the objects be move around
    IsLotObjectsMovable : function()
    {
        var touchCount = WeCamera.getTouchCount();
        return this.mLotEditable && (touchCount < 2);
    },

    //////////////////////////////////////////////////////////////////////
    // Method: SetLotObjectsMoveable
    SetLotObjectsMovable : function(value)
    {
        this.mLotEditable = value;
        if (this.mLotInfo)
        {
            this.mLotInfo.HideBubbles(value);
        }
    },

    //////////////////////////////////////////////////////////////////////
    // Method: SetGlobalGameWidget
    SetGlobalGameWidget : function(widget, useQueue)
    {
        if(null !== this.mGlobalGameWidget && (widget !== this.mGlobalGameWidget)  )
        {
        	if(WeUiMgr.IsRealmsNavigationClosed())
        	{
                if (WeUiMgr.IsNewsWindowClosed())
                {
                    this.mGlobalGameWidget.destroy();
                    this.mGlobalGameWidget=null;
                }
                else
                {
                    WeUiMgr.HideNewsWindow();
                }
        	}
        	else
        	{
                if(null === widget || !Exists(widget.xItemDef) || !Exists(widget.xItemDef.args) || widget.xItemDef.args.type !== "concurrent")
                {
                    WeUiMgr.HideRealmsNavigation();
                    if(!WeUiMgr.IsNewsWindowClosed())
                    {
                        WeUiMgr.HideNewsWindow();
                    }
                }
            }
            if(this.mGlobalGameWidget)
            {
                if((!Exists(this.mGlobalGameWidget.xItemDef)) || (!Exists(this.mGlobalGameWidget.xItemDef.args) || this.mGlobalGameWidget.xItemDef.args.type !== "concurrent"))
                {
                    this.mGlobalGameWidget.destroy();
                }
            }
        }
        this.mGlobalGameWidget = widget;
        WeCamera.clearTouches();
    },

    //////////////////////////////////////////////////////////////////////
    // Method: GetGlobalGameWidget
    GetGlobalGameWidget : function()
    {
        return this.mGlobalGameWidget;
    },

	SetPopupWidget : function(object)
	{
		if (Exists(object))
		{
			if (Exists(this.mPopupWidget))
			{
				NgLogD("Adding to popup queue!");
				this.mPopupQueue.push(object);
				return;
			}
		}
		if (Exists(this.mPopupWidget))
			this.mPopupWidget.destroy();
		var newObj = object;
		if (!Exists(newObj) && this.mPopupQueue.length > 0)
		{
			newObj = this.mPopupQueue[0];
			this.mPopupQueue.splice(0,1);
		}
		if (!Exists(newObj))
			this.mPopupWidget = null;
		else
			this.mPopupWidget = newObj.handle(newObj.args);
	},
	
	GetPopupWidget : function()
	{
		return this.mPopupWidget;
	},

    //////////////////////////////////////////////////////////////////////
    // Method: OnUnhandledTouch
    OnUnhandledTouch : function(touch)
    {
        // WE have an unhandled touch event here!!!
    },

    //////////////////////////////////////////////////////////////////////
    // Method: GetActiveObject
    GetActiveObject : function(){ return this.mActiveObject; },

    //////////////////////////////////////////////////////////////////////
    // Method: GetLastActiveObject
    GetLastActiveObject : function(){ return this.mLastActiveObject; },

    //////////////////////////////////////////////////////////////////////
    // Method: SetActiveObject
    SetActiveObject : function(obj)
    {
		if (obj)
		{
			NgLogD(" Touch  SetActiveObject()");
		}
		
        this.mLastActiveObject = this.mActiveObject;
        if(null !== this.mActiveObject)
        {
        	if(obj!=this.mActiveObject)
        	{
        		this.mActiveObject.LostFocus();
        	}
        }
        this.mActiveObject = obj;
    },

    //////////////////////////////////////////////////////////////////////
    // Method: SetLastActiveObject
    SetLastActiveObject : function(obj){ this.mLastActiveObject = obj; },

    //////////////////////////////////////////////////////////////////////
    // Method: GetGhostObject
    GetGhostObject : function()
    { 
    	return this.mGhostObject; 
    },

    //////////////////////////////////////////////////////////////////////
    // Method: SetGhostObject
    SetGhostObject : function(obj)
    { 
    	this.mGhostObject = obj; 
    },
    
    ShutdownGhostObject : function()
    {
    	if(this.mGhostObject)
		{
    		NgLogD("ShutdownGhostObject");
			this.mGhostObject.destroy();
			this.mGhostObject=null;
		}
    },    

    //////////////////////////////////////////////////////////////////////
    // Method: SetPendingObject
    SetPendingObject : function(obj)
    {
        if(this.mPendingObject)
        {
            this.mLotInfo.ReleaseShellObject();
        }
        this.mPendingObject = obj;
    },

    //////////////////////////////////////////////////////////////////////
    // Method: PlacePendingObjects
    PlacePendingObjects : function(isEventItem)
    {
        var eventFlag = false;
        
        if (Exists(isEventItem))
        {
            eventFlag = isEventItem;
        }
        
        if(this.mPendingObject)
        {
            // Construct the object
            return this.mLotInfo.ConstructShellObject(this.mPendingObject, eventFlag);
        }
        
        return false;
    },
                  
    //////////////////////////////////////////////////////////////////////
    // Method: CurrentObjectiveId access
    GetCurrentObjectiveId : function()
	{
	    if (!Exists(this.mLotInfo))
	    {
	        return;
	    }		
	    //NgLogD("$$$$$$$$ Current objective id: "+this.mLotInfo.current_proto_objective_id);
		return this.mLotInfo.current_proto_objective_id;
	},
    SetCurrentObjectiveId : function(id) { this.mLotInfo.current_proto_objective_id = id; },
    HasRemainingObjectives : function()
	{    	
		return this.GetCurrentObjectiveId() != -1 && this.GetCurrentObjectiveId() != 10	// is this even used anywhere anymore?
				&& this.GetCurrentObjectiveId() < GameSpecificVariables.WeGameState.LastObjective;
	},

    //////////////////////////////////////////////////////////////////////
    // Method: CompletedObjective access
    IsCompletedObjective : function() { return this.mLotInfo.show_current_objective_for_completion; },                   
    
    SetCompletedObjective : function(value) { this.mLotInfo.show_current_objective_for_completion = value; },    
    
    GotLotForLimits: function (request) {    	
    	NgLogD("GotLotForLimits");

    	var kingdom = new weKingdom();
    	kingdom.initWithJson( request.responseText );

    	if(Exists(kingdom.entities))
    	{
    		this.CountProducingItems(kingdom);
    	}
    	
    	delete kingdom;
    	kingdom = null;
    },
   
	GetIsSocialJobPlaced : function()
	{
		return this.mIsSocialJobPlaced;
	},

	SetIsSocialJobPlaced : function(val)
	{
		if (val)
		{
			this.mLotInfo.CancelAvailableJobs();
		}
		
		this.mIsSocialJobPlaced = val;	
	},

	IsPlacingOrder : function(){
		return this.mPlacingOrderInAction;
	},
	
	SetIsPlacingOrder : function(placing)
	{
		this.mPlacingOrderInAction = placing;
	},
	
	IsGiftsLoading : function()
	{
		return this.mIsGiftsLoading;
	},

	SetIsGiftsLoading : function(flag)
	{
		this.mIsGiftsLoading = flag;
		if (WeUiMgr.mActiveScreen == "GiftingScreen")
		{
	    	WeUiMgr.ShowLoading(flag);
		}
	},
	
	IsEventParticipationID : function (protoentity_id)
	{
	    var configs = weProtoConfigs.getInstance().map;
        if (configs.EventParticipationEntityIds != undefined)
        {
            var eventIDstring = configs.EventParticipationEntityIds.toString();
            var eventIDs = eventIDstring.split("|");
            var numEventIDs = eventIDs.length;
            
            for (var j = 0; j < numEventIDs; ++j)
            {
                if (protoentity_id == parseInt(eventIDs[j]))
                {
                    return true;
                }
            }
        }  
        
        return false;
	},

	// remove the entity (the entity id only should appear once)
	RemoveEntityWithId : function( id )
	{
		for (var i = 0; i < this.mLotInfo.entities.length; i++)
		{
			if ( this.mLotInfo.entities[i].id == id )
			{
				this.mLotInfo.entities.splice( i, 1 );
				break;
			}			
		}
	},
		
	GetStash : function() 
	{ 
		return this.mStash; 
	},

	GetRealmName : function()
	{
		// Look at the clouds to determine which realme we're in
		for(var i in Realms)
		{
			if(Realms[i].index == WeCloudManager.mRealmIndex)
				return Realms[i].name;
		}
		return "?";
	},
    
	onShowRealmPurchaseStatic : function(upgrade_id, mState)
	{
	    var args = {};
	    var db = weProtoDb.getInstance();
	    var protoUpgrade = db.getUpgrade(upgrade_id);
	    var costText = "";
	    var mojoText = GameSpecificVariables.Texts.mojoTextU;
	    var cointText = GameSpecificVariables.Texts.cointText;
	    

	    if (mState == WeBoundary.RealmState.LockedLot)
	    {
	        var popup_text = "This upgrade requires level " + protoUpgrade.requires_level+".";
	        args.OnOk = function(args)
	        {
	            WeGameStateMgr.SetGlobalGameWidget(null);
	        };
	        args.popup_text = popup_text;
	    }
	    else if (db.canPurchaseUpgrade(protoUpgrade) == UpgradeStatus.kCanPurchase)
	    {   // they can afford it - show em the details
	        costText = "You need ";
	        if (protoUpgrade.gold_cost <= 0)
	        {
	            costText = "This upgrade is FREE.";
	        }
	        else
	        {
	            if (protoUpgrade.gold_cost > 0)
	            {
	                costText = costText + protoUpgrade.gold_cost + " "+cointText+".\n";
	            }

	            if (protoUpgrade.mana_cost > 0)
	            {
	                costText = costText + protoUpgrade.mana_cost + " "+mojoText+".\n";
	            }
	        }

	        // Setup the purchase dialog...
	        args.OnYes = function(args)
	        {
	            WeProtocol.purchaseUpgrade(args.upgrade_id);
	            WeGameStateMgr.SetGlobalGameWidget(null);
	        };

	        args.OnNo = function(args)
	        {
	            WeGameStateMgr.SetGlobalGameWidget(null);
	        };

	        args.popup_text = protoUpgrade.description + " " + costText;
	        args.upgrade_id = upgrade_id;       
	    }
	    else
	    {   // they can't afford it - show em the details
	        costText = "You need ";
	        if (protoUpgrade.gold_cost > 0 && WeGameStateMgr.mLotInfo.gold < protoUpgrade.gold_cost) 
	        {
	            costText = costText + protoUpgrade.gold_cost + " "+cointText;

	            if (protoUpgrade.mana_cost > 0)
	            {
	                costText = costText + " and " + protoUpgrade.mana_cost + " "+mojoText;
	            }   
	            costText = costText + " to buy this Realm. Use "+mojoText+" to earn "+cointText+" more quickly.";
	        }
	        else if (protoUpgrade.mana_cost > 0 && WeGameStateMgr.mLotInfo.mana < protoUpgrade.mana_cost) 
	        {
	            costText = costText + protoUpgrade.mana_cost + " "+mojoText;
	            costText = costText + " to buy " + direction + " realm. Get more "+mojoText+".";
	        }

	        args.OnOk = function(args)
	        {
	            WeGameStateMgr.SetGlobalGameWidget(null);
	        };
	        args.popup_text = costText;
	    }

	    args.popup_label = protoUpgrade.proto_name;
	    var itemDef = WeUiMgr.GetItemDef("popup_box");
	    var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
	    gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    

	    WeGameStateMgr.SetGlobalGameWidget(gameWidget);
	},
	
	SendAllRelocatedBuildingToServer: function()
	{
		if(WeGameStateMgr.GetActiveObject())
    	{
            WeGameStateMgr.GetActiveObject().LostFocus();
    	}
    	var dirtyList=WeGameStateMgr.GetGameLotGrid().mDirtyList;
        if(dirtyList.length !== 0)
        {
            // We need to send the list of changes up to the server
            var len = dirtyList.length;
            var self = this;
            
            // This building needs to be sold
            var data = {};
            data.entities = [];
            for(var i = 0; i < len; ++i)
            {
                var dataSet = {};
                dataSet.flipped = dirtyList[i].mEntity.flipped;
                dataSet.id = dirtyList[i].mEntity.id;
                dataSet.proto_entity_id = dirtyList[i].mProtoEntity.id;
                dataSet.sell = 'false';
                dataSet.location_x = dirtyList[i].mAnchor.x;
                dataSet.location_y =  dirtyList[i].mAnchor.y;
                data.entities.push(dataSet);
            }
            WeGameStateMgr.GetGameLotGrid().mDirtyList= [];
        
            var kingdomId = WeGameStateMgr.GetCurrentKingdomId();
            WeProtocol.updateBuildingPositions(kingdomId, data, function(request)
            {
                // lets do the actual sell
                if(request.readyState == 4)
                {
                    try
                    {
                        if (Exists(request.responseText))
                        {
                            if (0 === request.responseText.length )
                            {
                                NgLogD("Looks like the item was sold");
                            }
                            else
                            {
                                var obj = JSON.parse(request.responseText);
                                  if(obj.kingdom)
                                  { 
                                      WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.kingdom);
                                  }
                              
                                NgLogD("Hmmm....:" + request.responseText);
                            }
                        }
                        else
                        {
                            NgLogD("SendAllRelocatedBuildingToServer: No response text");
                            WeUiMgr.ShowNetworkErrorPopUp();
                        }
                    }
                    catch(ex)
                    {
                        NgLogD("SendAllRelocatedBuildingToServer: Bad parse");
                        WeUiMgr.ShowNetworkErrorPopUp();
                    }
                }
                else if(request.readyState === 0)
                {
                    ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
                    NgLogD("SendAllRelocatedBuildingToServer: ready state === 0");
                    WeUiMgr.ShowNetworkErrorPopUp();
                }
            });
        }		
	},
	
	// Lock store items before user builds his first farm - so that he wouldn't lock
	// himself out of the game by buying Gone Fishing sign, for example
	lockAllItemsExcept: function ()
	{
		//NgLogD("Looking for current goal...");
		if (Exists(WeGoals.currentGoal))
		{
			//NgLogD("Current goal: ");
			//NgLogD(WeGoals.currentGoal.proto_goal_id+", "+WeGoals.currentGoal.completedCount);
		 	if ( WeGoals.currentGoal.proto_goal_id == gFirstGoalID 
				&& !WeGoals.currentGoal.completedCount)
				return 4; // farm proto id
		}
		return 0;
	}
    
});

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeBoundary'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeBoundary'] || {}; $MODULE_REGISTRY['weEngine/WeBoundary'] = exports;  //////////////////////////////////////////////////////////////////////////////
/// @file:      WeBoundary.js
/// @author:    mpatel@ngmococ.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require block
var GL2 = require('NGCore/Client/GL2').GL2;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;
var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var Content = require('weEngine/WeContent').Content;

var gBoundariesEnabled = true;

var RealmSprites =
[
    ["SPR_expansionsign_northunlock", "SPR_expansionsign_northbuy", "SPR_expansionarrown_01", "SPR_expansionarrowbackup_01", ""],
    ["SPR_expansionsign_southunlock", "SPR_expansionsign_southbuy", "SPR_expansionarrows_01", "SPR_expansionarrowbackdown_01", ""],
    ["SPR_expansionsign_eastunlock", "SPR_expansionsign_eastbuy", "SPR_expansionarrowe_01", "SPR_expansionarrowbackup_01", ""],
    ["SPR_expansionsign_westunlock", "SPR_expansionsign_westbuy", "SPR_expansionarroww_01", "SPR_expansionarrowbackdown_01", ""],
    ["", "", "", "", ""],
    ["", "", "", "", ""],
    ["", "", "", "", ""],
    ["", "", "", "", ""],
    ["", "", "", "", ""]
];

var RealmCoords =
[
    [-1, -1],
    [1, 1],
    [1, -1],
    [-1, 1],
    [-2, 0],
    [0, -2],
    [2, 0],
    [0, 2],
    [0, 0]
];

exports.WeBoundary = MessageListener.subclass(
{
	RealmState : 
	{
	    LockedLot : 0,
	    UnpurchasedLot : 1,
	    PurchasedLot : 2,
	    MainLot : 3,
	    ClosedLot : 4, // closed for others to view
		OpenLot : 12, // has open sing on it
		SubKingdomLot : 16,
		None : 18
	},

	RealmType :	
	{
	    North : { index:0, name: "north", req_level:30, upgrade_id:1000, point_a:[1,1], point_b:[-1,1]  },
	    South : { index:1, name: "south", req_level:15, upgrade_id:2000, point_a:[-1,-1], point_b:[1,-1]  },
	    East : { index:2, name: "east", req_level:25, upgrade_id:3000, point_a:[1,-1], point_b:[1,1] },
	    West : { index:3, name: "west", req_level:20, upgrade_id:4000, point_a:[-1,1], point_b:[-1,-1] },
	    NorthEast : { index:4, name: "northeast", req_level:0, point_a:[0,0], point_b:[0,0] },
	    NorthWest : { index:5, name: "northwest", req_level:0, point_a:[0,0], point_b:[0,0] },
	    SouthEast : { index:6, name: "southeast", req_level:0, point_a:[0,0], point_b:[0,0] },
	    SouthWest : { index:7, name: "southwest", req_level:50, point_a:[0,0], point_b:[0,0] },
	    Main : { index:8, name: "main", req_level:0, point_a:[0,0], point_b:[0,0]  }
	},

	classname: 'WeBoundary',

	initialize : function(parent, direction, lot_multiplier, lot_type, lot_state)
    {
        if(!WeGameStateMgr.IsCurrentUser() && (lot_state === this.RealmState.LockedLot || lot_state === this.RealmState.UnpurchasedLot))
        {
            lot_state = this.RealmState.ClosedLot;
        }
		
	    var offset = cHalfMapWidth * lot_multiplier;
	    var rotation = 26.5;
	    var repeat = offset/128;
	    var alpha = cBoundaryBaseAlpha;
	    var text_offset = GameSpecificVariables.RealmSpriteOffset[lot_state];
	    var boundary_line_x = (offset * 0.5) + (cMapBorderLineThickness * 0.5) - 1;
	    var boundary_line_y = (offset * 0.25) + (cMapBorderLineThickness * 0.25) - 1;
	    var boundary_text_x = boundary_line_x - text_offset;
	    var boundary_text_y = boundary_line_y - (text_offset * 0.5);
	    var x_mult = RealmCoords[lot_type.index][0];
	    var y_mult = RealmCoords[lot_type.index][1];
	    var text_sprite = RealmSprites[lot_type.index][lot_state];

	    // keep track of which realm this square represents
	    this.direction = direction;
	    this.mState = lot_state;
	    this.mRealmType = lot_type;

	    // darken fully closed off lots
	    if (lot_state == this.RealmState.ClosedLot)
	    {
	        alpha = cBoundaryBaseAlpha *1.5;// cBoundaryBaseAlpha *
											// cBoundaryBaseAlpha; // off-limit
											// squares are much darker.
	    }

	    // flip the rotation if this is top-right or bottom-left line
	    if (x_mult == y_mult)
	    {
	        rotation = -rotation;
	    }
	


	    // place this boundary square
		this.mNode = new GL2.Node();
	    this.mNode.setPosition( offset * x_mult + gRawWidth*0.5, offset * 0.5 * y_mult + gRawHeight*0.5);
	
		// primitive for the darkened area
		var color = new Core.Color([0,0,0]);
	    this.mPolygon = new GL2.Primitive();
        this.mPolygon.setImage(Content.getImagePath("black.png"), [1,1], [0.5, 0.5]);
		this.mPolygon.setType(GL2.Primitive.Type.TriangleStrip);
		this.mPolygon.setColor(color);
		this.mPolygon.setDepth(0);
		this.mPolygon.pushVertex(new GL2.Primitive.Vertex([offset,0],[0,0],color));
		this.mPolygon.pushVertex(new GL2.Primitive.Vertex([0,offset*0.5],[0,0],color));
		this.mPolygon.pushVertex(new GL2.Primitive.Vertex([0,-offset*0.5],[0,0],color));
		this.mPolygon.pushVertex(new GL2.Primitive.Vertex([-offset,0],[0,0],color));
		this.mPolygon.setAlpha(alpha);
		this.mNode.addChild(this.mPolygon);

		
	    // Draw the dotted line (never draw it for NE,NW,SE,SW)
	    if ( lot_state != this.RealmState.PurchasedLot && lot_state != this.RealmState.MainLot && lot_type.index < this.RealmType.NorthEast.index )
	    {
			this.mAnim = new GL2.Animation();
			this.mAnim.setWrapMode(GL2.Animation.WrapMode.WrapUV);
			var lines = Content.getImagePath(GameSpecificVariables.Textures.VacantLines);
			this.mAnim.pushFrame(new GL2.Animation.Frame(lines , 1, [cMapHypotenuse * lot_multiplier, cMapBorderLineThickness], [0.5, 0.5], [0, 0, repeat, 1]));
			this.mExpansionLine = new GL2.Sprite();
			this.mExpansionLine.setDepth(2);
			this.mExpansionLine.setAnimation(this.mAnim);
			this.mExpansionLine.setScale(1, 1);
			this.mExpansionLine.setRotation(rotation);
			this.mExpansionLine.setPosition(boundary_line_x * -x_mult, boundary_line_y * -y_mult);
			this.mNode.addChild(this.mExpansionLine);
	    }
	
	    // Add the appropriate realm sprite by the border
	    if (lot_state != this.RealmState.ClosedLot && text_sprite.length>0)
	    {
			this.mExpansionSprite = new WeAnimatedSprite2D(this.mNode, text_sprite, 0, false, 2);
	        // place the expansion sprite text
	        this.mExpansionSprite.SetPosition (boundary_text_x * -x_mult, boundary_text_y * -y_mult, 2);
	        this.mExpansionSprite.SetRotation(rotation);
	
			// Draw open signs, if there is open jobs in lot and user is not
			// current
			if(!WeGameStateMgr.IsCurrentUser())
			{
				var lotHasJobs = this.hasOpenJobs(lot_type);
				if (lotHasJobs)
				{
					var sprite   = GameSpecificVariables.Textures.Signpost;
					this.openSign = new WeAnimatedSprite2D(this.mNode, sprite, 0, false, 2);
					
					var vWidth  = lot_type.name == "east" ? 0 : (lot_type.name == "north" ? - (this.openSign.mWidth / 2) : (this.openSign.mWidth / 2));
					var vHeight = lot_type.name == "east" ? 0 : (this.openSign.mHeight / 2);
					this.openSign.SetPosition(boundary_text_x * -x_mult - vWidth, boundary_text_y * -y_mult - vHeight, 2);
				}
			}
		}


		// these two points represent a line that is used in touch calculations
		var halfMapSize = gStartingMapSize * 0.5;
		this.mPointA = [lot_multiplier * halfMapSize * this.mRealmType.point_a[0], lot_multiplier * halfMapSize * this.mRealmType.point_a[1]];
		this.mPointB = [lot_multiplier * halfMapSize * this.mRealmType.point_b[0], lot_multiplier * halfMapSize * this.mRealmType.point_b[1]];

		// touch handling
		if (lot_type.index < this.RealmType.NorthEast.index )
		{
	        this.mTouchTarget = new GL2.TouchTarget();
	        this.mTouchTarget.setPosition([boundary_line_x * -x_mult, boundary_line_y * -y_mult]);
	        this.mTouchTarget.setAnchor([0.5,0.5]);
	        this.mTouchTarget.setSize([offset,offset/2]);
	        this.mTouchTarget.setDepth(50);
			this.mTouchTarget.getTouchEmitter().addListener(this, this.onHitTest);
	        this.mNode.addChild(this.mTouchTarget);
		}
	},
	destroy : function()
	{
	    this.mNode.removeChild(this.mPolygon);
		this.mPolygon.destroy();
		delete this.mPolygon;
		
		if (this.mAnim)
		{
		    this.mAnim.destroy();
		    delete this.mAnim;
		}
		
	    if(this.mExpansionLine)
	    {
	        this.mNode.removeChild(this.mExpansionLine);
	        this.mExpansionLine.destroy();
	        delete this.mExpansionLine;
	    }

	    if(this.mExpansionSprite)
	    {
			this.mExpansionSprite.destroy();
	        delete this.mExpansionSprite;
	    }
	
		if(this.openSign)
		{
			this.openSign.destroy();
	        delete this.openSign;
		}
		
		if (this.mTouchTarget)
		{
		    this.mTouchTarget.destroy();
		}
		
		this.mNode.destroy();
	},
	getNode : function()
	{
		return this.mNode;
	},
	// //////////////////////////////////////////////////////////////////////////////
	// Methid onHitTest: Uses a dot product to determine which side of the line
	// a touch came in on:
	// +1 constitutes outside of the main realm
	// -1 constitutes inside the main realm
	onHitTest : function(touch)
	{
        if(gBoundariesEnabled)
        {
            var touchAction = touch.getAction();
            // var pos = touch.getPosition();
          // * FOR ORIENTATION
        	var pos = FixTouchPositionForOrientation( touch.getPosition() );

        // */
    // NgLogD("------------------");
    // NgLogD("Yarr I got a hit: " + this.direction);
    // NgLogD("Position: " + touch.getPosition().getX() + ", " +
	// touch.getPosition().getY());
    // NgLogD("------------------");
            var LocA = GetGamePosToScreenLoc(this.mPointA);
            var LocB = GetGamePosToScreenLoc(this.mPointB);

            var Ax = LocA[0];
            var Ay = LocA[1];
            var Bx = LocB[0];
            var By = LocB[1];
            var Cx = pos.getX();
            var Cy = pos.getY();

            var Dot = ((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax));
            if (Dot > 0)
            {
                if (touchAction === touch.Action.Start)
                {
                    this.mTouchX = pos.getX();
                    this.mTouchY = pos.getY();
                    this.xTouchTime = Core.Time.getFrameTime();
                    this.xTouchId = touch.getId();
                    return true;
                }
                else if (touchAction === touch.Action.End &&
                        this.xTouchId == touch.getId() &&
                        (Core.Time.getFrameTime() - this.xTouchTime) < 500 &&
                        Math.abs(this.mTouchX - pos.getX()) < 2 &&
                        Math.abs(this.mTouchY - pos.getY()) < 2)
                {
                    this.onBoundaryTouch();
                    return true;
                }
            }
        }
        return false;
	},
	// //////////////////////////////////////////////////////////////////////////////
	// Method: onBoundaryTouch
	onBoundaryTouch : function()
	{
	    // grab the kingdom info...
	    var kingdom = WeGameStateMgr.GetGameLotInfo();
	    if (kingdom === null)
	    {
	        return false;
	    }

	    // Invalid click states
	    if (this.mState == this.RealmState.ClosedLot)
	    {
	        return false;
	    }

	    // Give the purchase option (if they're the owner)
	    if (this.mState == this.RealmState.UnpurchasedLot || this.mState == this.RealmState.LockedLot)
	    {
	        if (WeGameStateMgr.IsCurrentUser())
	        {
	            WeGameStateMgr.SetActiveObject(null);
	            WeGameStateMgr.SetLastActiveObject(null);
	            if(WeGameStateMgr.GetGameLotInfo())
	            {
	            	WeGameStateMgr.GetGameLotInfo().ReleaseShellObject();
	            }
	            this.onShowRealmPurchase();
	        }
	        return true;
	    }
	
		var redesignScreen = WeUiMgr.GetActiveScreen() == "RedesignScreen";
	    // Head to the chosen realm if it's a valid lot
	    if ((this.mState == this.RealmState.PurchasedLot || this.mState == this.RealmState.MainLot) && !redesignScreen)
	    {
			if(WeGameStateMgr.IsPlacingOrder())
			{
				this.IsPlacingOrder();
				return;
			}
			
	        var dest_realm = (this.mState == this.RealmState.MainLot) ? "main" : this.mRealmType.name;
	        // Flush all game state objects for now
	        WeGameStateMgr.SetActiveObject(null);
	        WeGameStateMgr.SetLastActiveObject(null);
	        if(WeGameStateMgr.GetGameLotInfo())
	        {
	        	WeGameStateMgr.GetGameLotInfo().ReleaseShellObject();
	        }

	        var all_kingdoms = kingdom.all_kingdoms;
	        var len = all_kingdoms.length;
	        for(var idx = 0; idx < len; ++idx)
	        {
	            if( all_kingdoms[idx].kingdom_type == dest_realm)
	            {   // go to this kingdom
	                WeLotLoad(all_kingdoms[idx].kingdom_id);    
	                WeGameStateMgr.SetCurrentKingdomId(all_kingdoms[idx].kingdom_id);
	                return true;
	            }
	        }
	        NgLogD("ERROR: Couldn't find the destination kingdom!");
	    }
	    return false;
	},
	// //////////////////////////////////////////////////////////////////////////////
	// Method: onShowRealmPurchase
	onShowRealmPurchase : function()
	{
		WeGameStateMgr.onShowRealmPurchaseStatic(this.mRealmType.upgrade_id, this.mState);
	},
	IsPlacingOrder:function(){
		
		var args = {};
		
		args.OnOk = function(args) { WeGameStateMgr.SetGlobalGameWidget(null); };
		args.popup_label = "Wait a second";
		args.popup_text  = "Placing new building!";
		
	    var itemDef = WeUiMgr.GetItemDef("popup_box");
	    var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
	    gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);    

	    WeGameStateMgr.SetGlobalGameWidget(gameWidget);
	},
	
	hasOpenJobs: function(lot_type ){
		if(WeGameStateMgr.mLotInfo.all_jobs){
			var all_jobs = WeGameStateMgr.mLotInfo.all_jobs;
			for(var id in all_jobs){
				if ( all_jobs[id].kingdom_type == lot_type.name )
				{
					if(all_jobs[id].has_available_jobs == true)
						return true;
				}
			}
		}
		return false;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeCloudMgr'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeCloudMgr'] || {}; $MODULE_REGISTRY['weEngine/WeCloudMgr'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeCloudManager.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;

// general controls
var cCloudSystem_CloudHeight = 12;
var cCloudSystem_CloudZ = 100;
var cCloudSystem_CloudsPerRealm = 2;
// alpha rates
var cCloudSystem_CloudAlpha = 0.95;
var cCloudSystem_CloudSpawnInRateAlpha = 0.01;
var cCloudSystem_CloudSpawnOutRateAlpha = 0.01;
// timing controls
var cCloudSystem_MinCloudLifeSpan = 20000; // seconds * 1000
var cCloudSystem_LifeSpanRange = 20000;
var cCloudSystem_SpawnDelay = 15000; 
// speed controls
var cCloudSystem_MinCloudSpeed = 0.7;
var cCloudSystem_CloudSpeedRange = 1.2;

var CloudState =
{
	PreSpawn : 0,
	Spawning : 1,
	Idle : 2,
	Despawning : 3
};

//////////////////////////////////////////////////////////////////////////////
// Class WeCloud
var _WeCloud = Core.Class.subclass(
{
	classname: 'WeCloud',
	
    initialize : function()
    {
        //WeLotEntity.call(this);
        this.mPosition = [0,0,100];
        this.mVelocity = [0,0,100];
        this.mSpriteCloud = null;
        this.mSpriteShadow = null;
        this.mRealmExtent = gStartingMapSize;
    },
   
    //////////////////////////////////////////////////////////////////////////////
    // method: Shutdown
    destroy : function()
    {
        this.mSpriteCloud.destroy();
        this.mSpriteCloud = null;

        this.mSpriteShadow.destroy();
        this.mSpriteShadow = null;
    },

    Name : function()
    {
        return "WeCloud";
    },
    
    //////////////////////////////////////////////////////////////////////////////
    // method: Setup
    Setup : function(cloudSprite, cloudSpriteShadow)
    {
      //  WeCloud.superclass.Init.call(this);
        this.mAlpha = 0;
        this.mState = CloudState.PreSpawn;
        this.mLifeSpan = cCloudSystem_MinCloudLifeSpan + Math.floor(Math.random() * cCloudSystem_LifeSpanRange);
        this.mSpawnDelay = Math.floor(Math.random() * cCloudSystem_SpawnDelay);
        // Create the cloud and shadow
        this.mSpriteCloud = new WeAnimatedSprite2D(WeRenderDevice.GetGameUiRoot(), cloudSprite, 0, false, 100);
        this.mSpriteShadow = new WeAnimatedSprite2D(WeRenderDevice.GetGameUiRoot(), cloudSpriteShadow, 0, false, 99);

        this.mSpriteCloud.SetAlpha(0);
        this.mSpriteShadow.SetAlpha(0);
        this.mSpriteCloud.SetDepth(100);
        this.mSpriteShadow.SetDepth(99);
    },

    Recycle : function()
    {
        this.mAlpha = 0;
        this.mState = CloudState.PreSpawn;
        this.mLifeSpan = cCloudSystem_MinCloudLifeSpan + Math.floor(Math.random() * cCloudSystem_LifeSpanRange);
        this.mSpawnDelay = Math.floor(Math.random() * cCloudSystem_SpawnDelay);
    //	NgLogD("Recycling Cloud:" + this.mState + " delay:" + this.mSpawnDelay + "lifespan:" + this.mLifeSpan);
    },

    //////////////////////////////////////////////////////////////////////////////
    // method: Enable
    Enable : function(enabled)
    {
        if (this.mSpriteCloud !== null && this.mSpriteShadow !== null)
        {
	        if (enabled)
	        {
                this.mLastTickTime = Core.Time.getFrameTime();
                this.mSpriteCloud.mSavedAlpha = this.mSpriteCloud.mAlpha;
                this.mSpriteShadow.mSavedAlpha = this.mSpriteShadow.mAlpha;
                //this.mSpriteCloud.SetAlpha(0);
                //this.mSpriteShadow.SetAlpha(0);
	        }
	        else
	        {
                this.mLastTickTime = 0;
                this.mSpriteCloud.mSavedAlpha = 0;
                this.mSpriteShadow.mSavedAlpha = 0;
                //this.mSpriteCloud.SetAlpha(this.mSpriteCloud.mSavedAlpha);
                //this.mSpriteShadow.SetAlpha(this.mSpriteShadow.mSavedAlpha);
	        }
            this.mSpriteCloud.SetAlpha(0);
            this.mSpriteShadow.SetAlpha(0);
        }
    },

    //////////////////////////////////////////////////////////////////////////////
    // method: Sets up the spawning extent for this cloud
    SetExtents : function(extent)
    {
        this.mRealmExtent = extent;
    },

    SetWind : function(wind)
    {
        this.mVelocity[0] = wind[0];
        this.mVelocity[1] = wind[1];
    },

    //////////////////////////////////////////////////////////////////////////////
    // method: onUpdate
    onUpdate : function()
    {
        var tick = Core.Time.getFrameTime();
        var deltaTime = tick - this.mLastTickTime;
        this.mLastTickTime = tick;

        // Velocity is set in "Grids" per second
        this.mPosition[0] += this.mVelocity[0] * deltaTime * 0.001;
        this.mPosition[1] += this.mVelocity[1] * deltaTime * 0.001;

        if(this.mSpriteCloud && this.mSpriteShadow)
        {
            switch(this.mState)
            {
                case CloudState.PreSpawn:
                    this.mSpawnDelay -= deltaTime;
                    if (this.mSpawnDelay <= 0)
                    {
                        var StartingX = Math.floor(Math.random() * this.mRealmExtent) - (this.mRealmExtent * 0.5);
                        var StartingY = Math.floor(Math.random() * this.mRealmExtent) - (this.mRealmExtent * 0.5);
                        this.mPosition = [StartingX, StartingY, cCloudSystem_CloudZ];
                        this.mState = CloudState.Spawning;
                    }
                    break;
                case CloudState.Spawning:
                    if (this.mAlpha >= cCloudSystem_CloudAlpha)
                    {
                        this.mState = CloudState.Idle;
                    }
                    else
                    {
                        this.mAlpha = this.mAlpha + cCloudSystem_CloudSpawnInRateAlpha;
                        if (this.mAlpha > cCloudSystem_CloudAlpha)
                        {
                            this.mAlpha = cCloudSystem_CloudAlpha;
                        }
                    }
                    break;
                case CloudState.Idle:
                    this.mLifeSpan -= deltaTime;
                    if (this.mLifeSpan <= 0)
                    {
                        this.mState = CloudState.Despawning;
                    }
                    break;
                case CloudState.Despawning:
                    if(this.mAlpha > 0.0)
                    {
                        this.mAlpha = this.mAlpha - cCloudSystem_CloudSpawnOutRateAlpha;
                        if(this.mAlpha < 0.0)
                        {
                            this.mAlpha = 0.0;
                        }
                    }
                    else
                    {
                        // Re-cycle this cloud for re-use
                        this.Recycle();
                    }
                    break;
                default:
                    break;
            }
            this.mSpriteCloud.SetAlpha(this.mAlpha);
            this.mSpriteCloud.PushGamePosition(this.mPosition, [0, 0, 0]);
            //this.mSpriteCloud.SetPosition(this.mSpriteCloud.GetX(), this.mSpriteCloud.GetY()); 
            this.mSpriteCloud.SetDepth(100);
            var shadowPos = [this.mPosition[0] - cCloudSystem_CloudHeight, this.mPosition[1] - (cCloudSystem_CloudHeight / 2), this.mPosition[2]];
            this.mSpriteShadow.SetAlpha(this.mAlpha);
            this.mSpriteShadow.PushGamePosition(shadowPos, [0, 0, 0]);
            //this.mSpriteShadow.SetPosition(this.mSpriteShadow.GetX(), this.mSpriteShadow.GetY()); 
            this.mSpriteShadow.SetDepth(99);

        }
    }
});


//////////////////////////////////////////////////////////////////////////////
//
// Class: WeCloudManager
//
//////////////////////////////////////////////////////////////////////////////
exports.WeCloudManager = Core.Class.singleton(
{
    initialize : function()
    {
        var WindDirections = [0, 90, 180, 270];
        // Grab a random orientation angle
        var angle = WindDirections[Math.floor(Math.random()*WindDirections.length)];

        // Grab a random velocity mag
        var mag = cCloudSystem_MinCloudSpeed + Math.floor(Math.random() * cCloudSystem_CloudSpeedRange);
        var convert = (2 * Math.PI) / 360.0;

        // create the wind vector
        this.mWind = [Math.cos(angle * convert) * mag, Math.sin(angle * convert) * mag];

        // setup data vars
        this.mActive = false;
        this.mClouds = new Array(5);
        for (var i = 0; i < 5; i++)
        {
            this.mClouds[i] = new Array(0);
        }
        this.mRealmIndex = Realms.MainRealm.index;
    },
    
	classname: "WeCloudManager",

    EnableClouds : function(realm_index)
    {
        var multiplier = WeGameStateMgr.mLot.calculateLotMultiplier();			
        var extents = Math.floor(multiplier * gStartingMapSize);
        for (var i = 0; i < cCloudSystem_CloudsPerRealm; i++)
        {
            this.mClouds[this.mRealmIndex][i].Enable(false);
            this.mClouds[realm_index][i].Enable(true);
            this.mClouds[realm_index][i].SetWind(this.mWind);		
            this.mClouds[realm_index][i].SetExtents(extents);
        }
        this.mRealmIndex = realm_index;
    },

    LoadRealm : function(realm_name, cloudSprite, cloudSpriteShadow)
    {
        // Only create the clouds once...
        if (!this.mActive)
        {
            // add X clouds for each realm
            for (var i = 0; i < 5; i++)
            {
                for (var j = 0; j < cCloudSystem_CloudsPerRealm; j++)
                {
                    this.AddCloud(i, cloudSprite, cloudSpriteShadow);
                }
            }
            this.mActive = true;
        }
        

        switch(realm_name)
        {
            case "main":
                this.EnableClouds(Realms.MainRealm.index);
                break;
            case "north":
                this.EnableClouds(Realms.NorthRealm.index);
                break;
            case "south":
                this.EnableClouds(Realms.SouthRealm.index);
                break;
            case "east":
                this.EnableClouds(Realms.EastRealm.index);
                break;
            case "west":
                this.EnableClouds(Realms.WestRealm.index);
                break;
            default:
                break;
        }
    },
		
    //////////////////////////////////////////////////////////////////////
    // Method: AddCloud
    AddCloud : function(realm_index, cloudSprite, cloudSpriteShadow)
    {
        var cloud = new _WeCloud();
        cloud.Setup(cloudSprite, cloudSpriteShadow);
        this.mClouds[realm_index].push(cloud);
    },
    
    //////////////////////////////////////////////////////////////////////
    // Method: Update
    // method which process the screen state machine for the game
    Update : function(frameDelta)
    {
        if (this.mActive)
        {
            var len = this.mClouds[this.mRealmIndex].length;
            for(var i = 0; i < len; i++)
            {
                this.mClouds[this.mRealmIndex][i].onUpdate();
            }
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeRealms'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeRealms'] || {}; $MODULE_REGISTRY['weEngine/WeRealms'] = exports; var Core = require('NGCore/Client/Core').Core;
var WeBoundary = require('weEngine/WeBoundary').WeBoundary;

var WeRealms = Core.Class.subclass(
{
	classname: 'WeRealms',
	
	indexNameMap: 
	{
		0: "northwest",
		1: "north",
		2: "northeast",
		3: "west",
		4: "main",
		5: "east",
		6:"southwest",
		7:"south",
		8:"southeast"
	},

	initialize: function()
	{
		this.page=0;
		this.pageCount=1;
		this.pages={};
	},
	
	GetUpgrade: function(name)
	{
		NgLogD("GetUpgrade to value this.page "+this.page);
		if(this.pages[this.page][name])
		{
			return this.pages[this.page][name].upgrade;
		}
		return null;
	},
	
	GetRealmName: function(name)
	{
		var upgrade=this.GetUpgrade(name);
		if(!upgrade) return name;
		return upgrade.kingdom_type;
	},
	
	GetRealm: function(name)
	{
		var upgrade=this.GetUpgrade(name);
		if(!upgrade) return null;
		
		var kingdom = WeGameStateMgr.GetGameLotInfo();
	    var all_kingdoms = kingdom.all_kingdoms;
		var realName= upgrade.kingdom_type;
	    for(var idx in all_kingdoms)
	    {
	        if( all_kingdoms[idx].kingdom_type == realName)
	        {   
	        	return all_kingdoms[idx];
	        }
	    }
		return null;
	},
	
	GetState: function(name)
	{
		var realName= this.pages[this.page][name].name;
		if( realName.indexOf("none")!=-1 )
		{
			return WeBoundary.RealmState.None;
		}
		
    	var kingdom = WeGameStateMgr.GetGameLotInfo();
	    var all_kingdoms = kingdom.all_kingdoms;
	    var len = all_kingdoms.length;
		var realm=this.GetRealm(name);
		var state= WeBoundary.RealmState.PurchasedLot;
	    if(!realm)
	    {
	    	if(this.pages[this.page][name] && this.pages[this.page][name].upgrade && this.pages[this.page][name].upgrade.requires_level > kingdom.mLevel )
	    	{
	    		state= WeBoundary.RealmState.LockedLot;
	    	}
	    	else
	    	{
	    		state= WeBoundary.RealmState.UnpurchasedLot;
	    	}
	    }
	    return state;
	},
	
	GetAsset: function(name, state)
	{
		switch(state)
		{
		case WeBoundary.RealmState.PurchasedLot:
			return getAssets("realm_available_" + name);
		case WeBoundary.RealmState.LockedLot:
			return getAssets("realm_locked");
		case WeBoundary.RealmState.None:
			return getAssets("realms_coming_soon");
		default:
			return getAssets("realm_purchase_" + name);
		}
	},
	
	CreateRealmsData: function()
	{
		
    	var kingdom = WeGameStateMgr.GetGameLotInfo();
    	//var kingdom = WeGameStateMgr.GetGameLotInfo();
	    var all_kingdoms = kingdom.all_kingdoms;
    	
    	  
    	var info = WeGameStateMgr.GetGameLotInfo();
	    var upgrades=info.upgrades;
		
		this.pages[0]={};
		for(var i in this.indexNameMap)
		{
			var currentName= this.indexNameMap[i];
			var unlockUpgrade=WeGameStateMgr.UnlockUpgrade(currentName);
			if (unlockUpgrade)
			    this.pages[0][ currentName ]={ "upgradeId": unlockUpgrade.proto_id, "upgrade":unlockUpgrade, "name":currentName };
		}
		
		//wtf in all places json but in this bullshit format
		//AdditionalRealms: 15000 none,9000 north,16000 none,12000 west,17000 main,11000 east,13000 none,10000 south,14000 none
		this.pageCount=1;
		if(gConfigs.AdditionalRealms)
		{
			var realms=gConfigs.AdditionalRealms.split(",");
			if(realms.length>0)
			{
				if(realms.length%9==0)
				{
					this.pageCount=1+parseInt(realms.length/9);
				}
				else
				{
					this.pageCount=2+parseInt(realms.length/9);
				}
			}
			for(var i=0; i<realms.length; i++)
			{
				var realm=realms[i];
				var realmSplit= realm.split(" ");
				
				var page=parseInt(i/9)+1;
				
				if(!this.pages[page])
				{
					this.pages[page]={};
				}
				var index=i%9;
				var upgradeRealm=null;
				//TODO create map upgrades proto_id for performance
				upgradeRealm=weProtoDb.getInstance().getUpgrade(realmSplit[0]);
				/*
				for(var i = 0; i < weProtoDb.getInstance().proto_upgrades.length; i++ )
			    {
			    	var upgrade=weProtoDb.getInstance().proto_upgrades[i].proto_upgrade;
			    	
			    	if(upgrade.id==realmSplit[0])
			    	{
			    		upgradeRealm=upgrade;
			    	}
			    }
			    */
				this.pages[page][ this.indexNameMap[index] ]={ "upgradeId": realmSplit[0], "upgrade":upgradeRealm, "name":realmSplit[1] };
			}
		}
		//fullRecurseDump(this.pages, 4, 0);
	},
	
	SetPage: function(value)
	{
		NgLogD("SetPage to value"+value);
		this.page=value;
	},
	
	GetPageCount: function()
	{
		return this.pageCount;
	},
	
	GetPage: function()
	{
		return this.page;
	},

	PageBack: function()
	{
		if(this.page>0)
		{
			this.page--;
			return true;
		}
		return false;
	},
	
	PageForward: function()
	{
		if(this.page<this.pageCount-1)
		{
			this.page++;
			return true;
		}
		return false;
	}
});

exports.WeRealms = new WeRealms();
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeCoinsCrowns'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeCoinsCrowns'] || {}; $MODULE_REGISTRY['weEngine/WeCoinsCrowns'] = exports; var Core = require('NGCore/Client/Core').Core;
var Storage = require('NGCore/Client/Storage').Storage;

var WeCoinsCrowns = Core.Class.subclass(
{
	classname: 'WeCoinsCrowns',
	//_CoinsOrCrowns need sync with file coins_crowns.json
	_CoinsOrCrowns:
	{
		"crowns" : "coins",
		"Crowns" : "Coins",
		"small_coin_icon.png" : "small_coin_icon@iOS.png",
		"res_coins.png" : "res_coins@iOS.png", 
		"ad_coin.png" : "ad_coin@iOS.png",
		"resIcon_gold.png" : "resIcon_gold@iOS.png",
		"SPR_resIcon_crown" : "SPR_resIcon_gold",
		"small_mojo_icon.png" : "small_mojo_icon@iOS.png",
		"use_mojo_btn_off.png" : "use_mojo_btn_off@iOS.png"
		
	},
	
	initialize: function()
	{ 
		this.mCrownsInfo = null;
		this.readCoinsFromFile();	
	},

	getPlatformOS: function()
	{
		return Core.Capabilities.getPlatformOS();
	},
	isCoinImage: function(imageDefAsset)
	{   
		if(this.getPlatformOS()==="iPhone OS" || this.getPlatformOS()==="iOS")
		//if(this.getPlatformOS()==="Android")
		{
			if (typeof(imageDefAsset) === 'string')
			{
				if ((imageDefAsset.indexOf("use_mojo_btn_off")!==-1 || imageDefAsset.indexOf("small_mojo_icon")!==-1 || imageDefAsset.indexOf("_coin")!==-1 || imageDefAsset.indexOf("resIcon_crown")!==-1 || imageDefAsset.indexOf("resIcon_gold")!==-1) && imageDefAsset.indexOf("/")===-1 && imageDefAsset.indexOf("@")===-1)
					return true;
			}
		}	
		return false;
	},
	isCoinText: function(labelDefText)
	{
		if(this.getPlatformOS()==="iPhone OS" || this.getPlatformOS()==="iOS")
		//if(this.getPlatformOS()==="Android")
		{
			if(typeof(labelDefText) === 'string')
			{
				if(labelDefText.search(/crowns/i)!==-1)
					return true;
			}
		}
		return false;
	},
	getCoinsOrCrowns: function(imageAsset)
	{		
		if(typeof(imageAsset) === 'string')
		{
			if(undefined !== this.mCrownsInfo[imageAsset])
			{
				return this.mCrownsInfo[imageAsset];
			}
		}
		return imageAsset;
	},
	replaceCoinText: function(labelDefText)
	{
		if(typeof(labelDefText) === 'string')
		{
			 if(labelDefText.search("crowns")!==-1)
			               return labelDefText.replace("crowns",this.mCrownsInfo["crowns"]);
			           else if(labelDefText.search("Crowns")!==-1)
			               return labelDefText.replace("Crowns",this.mCrownsInfo["Crowns"]);
			    
		}
		return labelDefText;
	},
    readCoinsFromFile : function()
    {
        var fs = Storage.FileSystem;
        var self = this;
        self.mCrownsInfo=null;
        ReadFile(fs, "./Configs/coins_crowns.json", {'blocking': false}, function(err, data)
        {
            if(!err)
            {
                try
                {
                	//NgLogD("trying read and parse file");
                	//fullRecurseDump(data);
                    var obj = JSON.parse(data);
                    //fullRecurseDump(obj);
                    //NgLogD("trying read and parse file END");
                    
                    self.mCrownsInfo = obj.fileCoinsOrCrowns;
                }
                catch(ex)
                {
                    NgLogD("Failed to load the crownscoins config file.  Drop out");
                }
            }
            else
            {
                self.mCrownsInfo = self._CoinsOrCrowns;
            }
        });
    }
});
exports.WeCoinsCrowns = new WeCoinsCrowns();
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeEventGame'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeEventGame'] || {}; $MODULE_REGISTRY['weEngine/WeEventGame'] = exports; //
//	
//

var Core = require('NGCore/Client/Core').Core;
var NGUI = require('NGCore/Client/UI').UI;
var WeDropItem = require('weEngine/WeDropItem').WeDropItem;
var Content = require('weEngine/WeContent').Content;

var WeEventGame = Core.Class.subclass(
{
		classname: "WeEventGame",
	
	    initialize : function() 
	    {
			this.mPoints = 0;
			this.mEarnedPoints = 0;	// record the delta
			this.mEventCollectionProtoId = -1;	// the current active event collection's proto id
			this.mEventCollectionProgress = null;	// the progress of the event's current collection
			this.eventItems = null;
			this.mEventItemCount = 0;
			this.mEventPointsLabel = null;
	        this.mActiveItemsOnScreenCount = [];
			this.mShareCount = 0;
			this.mEventPointProgressFillImage = null;
			this.mEventPointProgressRightImage = null;
			this.mEventPointProgressW = 0;
			this.mEventPointProgressH = 0;
			this.mEventPointProgressX = 0;
			this.mEventPointProgressY = 0;
			this.mEventPointProgressGemY = 0;
			this.mEventPointProgressGemW = 0;
			this.mEventPointProgressNextItemIcon = null;
			this.mTotalPoints = 0;	// the total point that the user have earned (to unlock the buildings)
			this.mBoosts = 0;		// the boosts the user has earned from the spinner
			this.currentViewingCollection = -1; //Collection currently being seen by the user
			this.mSpinHintLabel = [];
			this.mCollectionStatusLabel = [];
			this.mEventView = null;	// to check which tab we are in (for synchronization reason)
			this.mCompletedCollections = [];
	    },

	    setup : function()
	    {
	        var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
	        if (gameEvent)
	        {
	            for (var item in gameEvent.items)
    	        {
    	            this.mActiveItemsOnScreenCount[item] = 0;
    	        }
	        }
	    },
	    
		// from the server
		refreshEventItems : function()
		{
			var self = this;
	        WeProtocol.refreshEventItems( function(request)
			{
				NgLogD("Refresh event items");
				var obj = WeProtocol.getRequestResponse(request);
				
				if (obj)
				{
					// actually get some response
					self.showEventPoints();
					self.setEventPointProgress();					
				}
				// do not need to do anything else
			}
			);
		},

		setSpinHintLabel : function()
		{
			if (!this.mSpinHintLabel)
				return;

			var hint = " ";
			if (this.isShowingSpinnerView())
			{
				hint = Exists(gConfigs.eventSpinnerHintText) ? gConfigs.eventSpinnerHintText : "Boost guarantees to spin a gnome for your collection.";
			}
			else if (this.isShowingGiftingView())
			{
				hint = Exists(gConfigs.eventGiftingHintText) ? gConfigs.eventGiftingHintText : "Users who have sent you gems today have a heart icon.";
			}
			else if (this.isShowingCollectionView())
			{
				var collection = this.getGameEventCollection();
				if (collection && collection.hint_text)
					hint = collection.hint_text;
			}
			else if (this.isShowingStoreView())
			{
				hint = " ";
			}

			for (var i = 0; i < this.mSpinHintLabel.length; i++)
			{
				if (this.mSpinHintLabel[i])
					this.mSpinHintLabel[i].SetText(hint);
			}
		},

		isCollectionCompleted : function(collection_proto_id)
		{
		    for (var completed in this.mCompletedCollections)
		    {
		        if (parseInt(this.mCompletedCollections[completed]) == collection_proto_id)
		        {
		            return true;
		        }
		    }
			return false;
		},

		getCollectionStatus : function(collection_proto_id)
		{
			if (collection_proto_id == this.mEventCollectionProtoId)
			{
				return " ";	// in progress shows nothing
			}
			else if (this.isCollectionCompleted(collection_proto_id))
			{
				return "Completed";
			}
			else	// not unlocked yet
			{
				return "Locked";
			}
		},

		showCollectionStatus : function()
		{
			if (!this.mCollectionStatusLabel)
				return;
			for (var i = 0; i < this.mCollectionStatusLabel.length; i++)
			{
				if (this.mCollectionStatusLabel[i])
					this.mCollectionStatusLabel[i].SetText(this.getCollectionStatus(this.currentViewingCollection));
			}			
		},

		isShowingCollectionView : function()
		{
			return this.mEventView == "SpecialEventCollectionView";
		},

		isShowingSpinnerView : function()
		{
			return this.mEventView == "SpecialEventSpinnerView";
		},

		isShowingGiftingView : function()
		{
			return this.mEventView == "SpecialEventGiftSendView";
		},

		isShowingStoreView : function()
		{
			return this.mEventView == "SpecialEventStoreView";
		},
		
		doEventBookGlow : function ()
		{
            var image = WeUiMgr.GetImageFactory().FindImageOfName("event_glow");  
            if (!image)
            {
                return;
            }

		    var animation = new NumberAnimation (2.0, 1.0, 0.0);
		    if (image.animation)
		    {
		        image.animation.Stop();
		    }
		    image.animation = animation;
		    var self = image;
        	animation.setLoop(false);
    		animation.SetNumber = function(value)
    		{			
    			image.SetAlpha(  (Math.sin(2*Math.PI*value)+1)*0.8 );
    		};
    		animation.OnStop = function()
    		{
                this.destroy();
                self.animation = null;
                self.SetAlpha(0.0);
    		};

    		image.OnExit(function()
    	    {
    			animation.Stop();
    	    });
		  
		  
		},
		
		decrementActiveItems : function(proto_item_id)
		{
		    this.mActiveItemsOnScreenCount[""+proto_item_id]--;
    	      if (this.mActiveItemsOnScreenCount[""+proto_item_id] < 0)
    	      {
    	          this.mActiveItemsOnScreenCount[""+proto_item_id] = 0;
    	          NgLogD("** ITEM COUNT ERROR!!! SHOULDN'T HAPPEN!");
    	      }
    	      NgLogD("** ACTIVE ITEM COUNT " + this.mActiveItemsOnScreenCount[""+proto_item_id]);
		},
    	
    	createEventDropItem : function (proto_item_id, x, y, dir)
    	{
    	    var self = this;
    	    var OnExit = function () {
    	      self.decrementActiveItems(this.proto_item_id);
    	    };
    	    
    	    var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
    	    var asset = gameEvent.items[""+proto_item_id].image_kingdom_spawn_icon;
    	    
            var flyOff = new WeDropItem(WeRenderDevice.GetGameUiRoot(), x, y, asset, dir, proto_item_id);
            flyOff.OnExit = OnExit;
            this.mActiveItemsOnScreenCount[""+proto_item_id]++;
    	  //  this.mActiveEventDropItemSprites.push(flyOff);
    	},

    	getFirstEventProducingEntityProtoId : function ()
    	{
    	    var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
    	    
    	    if (gameEvent && gameEvent.producing_building_id && gameEvent.producing_building_id.length >= 1)
			{
				return gameEvent.producing_building_id[0];
			}
            return null;
    	},

    	isEventProducingID : function (protoentity_id)
    	{
    	    var gameEvent = weProtoDb.getInstance().getProtoGameEvent();

    	    if (gameEvent && gameEvent.producing_building_id)
			{
				var numEventIDs = gameEvent.producing_building_id.length;
				for (var i = 0; i < numEventIDs; ++i)
				{
				    if (protoentity_id == gameEvent.producing_building_id[i])
					{
						return true;
					}
				}
			}
            return false;
    	},

    	handleEventData : function(eventData)
    	{
    		NgLogD("HandleEventData: " + JSON.stringify(eventData));
    		var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			this.mEarnedPoints = eventData.points - this.mPoints;	// record the difference
    		this.mPoints = eventData.points;
    		this.mCompletedCollections = eventData.completed_collections;
			if (eventData.active_collection)
			{
				this.mEventCollectionProtoId = eventData.active_collection.proto_id;
				this.currentViewingCollection = eventData.active_collection.proto_id;
				/* a typical progress object is like { proto_collection_item's proto_id: {"total":count to complete, "count":user's currentcount}}
				  {"7":{"total":1,"count":0},
				   "8":{"total":1,"count":0},
				   "9":{"total":1,"count":1} } */
				this.mEventCollectionProgress = eventData.active_collection.progress;
			}
			
			if (eventData.data)
			{
				if (eventData.data.max_points)
					this.mTotalPoints = eventData.data.max_points;
				if (eventData.data.boosts)
					this.mBoosts = eventData.data.boosts;
			}
    	},
	    
	    handleEventItems : function(eventItems)
    	{
    		NgLogD("HandleEventItems: " + JSON.stringify(eventItems));
    		this.eventItems = eventItems;
			this.mEventItemCount = 0;
			if (this.eventItems && this.eventItems.acquired)
			{
				for (var proto_event_item_id in this.eventItems.acquired)
				{
					this.mEventItemCount += this.eventItems.acquired[proto_event_item_id];
				}
			}
       	},

    	/* get a collection item's user progress for the current event collection.
		proto_collection_item_id: the proto_id of the proto_collection_item. A collection item's progress object is like:
		{"total":1,"count":0}
 		*/
		getCollectionItemProgress : function(proto_collection_item_id)
		{
			if (this.mEventCollectionProgress)
				return this.mEventCollectionProgress["" + proto_collection_item_id];
				
			return null;
		},

    	getAcquiredEventItemsCount : function()
    	{
			return this.mEventItemCount;
    	},

		getAcquiredEventItemProtoId : function(count)
		{
			if (Exists(this.eventItems) && this.eventItems.acquired)
			{
				for (var proto_event_item_id in this.eventItems.acquired)
				{
					if (this.eventItems.acquired[proto_event_item_id] >= count)	// has at least count of unit
					{
						return proto_event_item_id;
					}
				}
			}  
			return null;
		},
		
		showEventPoints : function()
		{
            var points = '' + this.getEventPoints();
            if (this.mEventPointsLabel && this.mEventPointsLabel.GetGL2())
            {
				var gl2 = this.mEventPointsLabel.GetGL2();
				if  (gl2.getText() != points)
            		gl2.setText(points);
            }			
		},

		getEventPointsLabelPosition : function()
		{
			var destPos = (this.mEventPointsLabel && this.mEventPointsLabel.GetGL2()) ? this.mEventPointsLabel.GetGL2().getPosition() : null;
			return destPos;	
		},

		setEventPointProgress : function()
		{
			var next_item = this.getNextAvailableItem();
			if (!next_item)
				return;
			var percent = this.getTotalEventPoints() * 100 / next_item.points_unlock;
			if (percent > 100)
				percent = 100;
			this.setEventPointProgressBar(percent);
			
			/* set the icon for the next item */
			if (this.mEventPointProgressNextItemIcon)
			{
				var protoEntity = weProtoDb.getInstance().getProtoEntityById (parseInt(next_item.entity_id));
				if (protoEntity)
					this.mEventPointProgressNextItemIcon.SetImage(protoEntity.store_image_url);
			}
		},
		
		/* percent: 0~100 */
		setEventPointProgressBar : function(percent)
		{
			try
			{
				if (!this.mEventPointProgressFillImage || !this.mEventPointProgressRightImage)
					return;
				var gemX = this.mEventPointProgressX + this.mEventPointProgressW * percent / 100 - this.mEventPointProgressGemW / 2;
				this.mEventPointProgressRightImage.SetPosition(gemX, this.mEventPointProgressGemY);
				this.mEventPointProgressFillImage.SetScale(percent / 100.0, 1.0);
				this.mEventPointProgressFillImage.SetPosition(this.mEventPointProgressX, this.mEventPointProgressY);
			}
			catch(ex)
			{
				NgLogD("setEventPointProgressBar error: " + ex);
			}
		},
		
		/* the earned points from one operation - like a loot etc*/
    	getEarnedPoints : function()
    	{
    	  return this.mEarnedPoints;
    	},

		/* the current available points for exchange*/
    	getEventPoints : function()
    	{
    	  return this.mPoints;  
    	},

		/* the total event points that are earned (including the used points)*/
    	getTotalEventPoints : function()
    	{
    	  return this.mTotalPoints;  
    	},

		/* store_item is like:
		{
	        "name": "test",
	        "points_cost": "40",
	        "entity_id": "30",
	        "points_unlock": "5"
	    }
		*/
		isStoreItemLocked : function(store_item)
		{
			var collection_reward_item_with_no_stash = (store_item && store_item.points_cost == 0 && weProtoDb.getInstance().getStoreItemStashCount(store_item) == 0);
			if (collection_reward_item_with_no_stash)
			{
				return true;
			}
			return (store_item && parseInt(store_item.points_unlock) > parseInt(this.getTotalEventPoints()));
		},

        getEventStoreItemById : function(proto_id)
        {
            var points_store = this.getPointsStore();
            for (var key in points_store)
			{
				var store_item = points_store[key];
				
				if (store_item.entity_id == proto_id)
				{
				    return store_item;
				}
			}
        },
        
		HasGameEvent : function()
		{
            var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
            if (gameEvent)
            {
                return true;
            }
		  
		    return false;  
		},

		getGameEventNoEventItemPopupText : function()
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.no_event_item_text)
			{
				return gameEvent.no_event_item_text;
			}
			else
			{
				return "You don't have enough " + this.getEventItemName() + ". Please play the game to get more.";	//default value
			}			
		},
	
		getGameEventAssetsFolder : function()
		{
			try
			{
				var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
				if (gameEvent && gameEvent.assets_folder)
				{
					return gameEvent.assets_folder + "/";
				}
				else
				{
					return "spinner/";	//default value
				}
			}
			catch (ex)
			{
				NgLogD("getGameEventAssetsFolder error: " + ex);				
			}
		},
		
		isStoreEnabled : function()
		{
            var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
            if (gameEvent && gameEvent.store_enabled)
            {
                return gameEvent.store_enabled;
            }
		  
		    return false;  
		},
		
		isSpinnerEnabled : function()
		{	// only returns true when the user can still collect
			return this.isCollectionEnabled();
		},

		isCollectionEnabled : function()
		{
            var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
            if (gameEvent && gameEvent.collection_enabled)
            {
                if (gameEvent.collection_enabled == "FALSE")
                    return false;
                return gameEvent.collection_enabled;
            }
		  
		    return false;  
		},
		
		canShowSellEventItems : function()
		{
		  if (this.isCollectionEnabled() == false && this.isStoreEnabled() && thisgetAcquiredEventItemsCount() > 0)
		  {
		      return true;
		  }
		  return false;
		},

		getPointsStore : function()
		{
		/* getPointsStore returns:
		A list of items:
		    "1": {
		        "name": "test",
		        "points_cost": "40",
		        "entity_id": "30",
		        "points_unlock": "5"
		    },
		    "2": {
		        "name": "test",
		        "points_cost": "10",
		        "entity_id": "20",
		        "points_unlock": "5"
		    },
		    "3": {
		        "name": "test",
		        "points_cost": "10",
		        "entity_id": "20",
		        "points_unlock": "5"
		    },
		    "4": {
		        "name": null,
		        "points_cost": "10",
		        "entity_id": "10",
		        "points_unlock": "5"
		*/

			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.points_store)
			{
				return gameEvent.points_store;
			}
			return null;			
		},

		/* return with the next item that I will be able to unlock. If no item is locked, return with the item with maximum unlock points*/
		getNextAvailableItem : function()
		{
			var items = this.getPointsStore();
			if (!items)
				return null;
			var nextItem = null;
			var nextItemMinimalUnlockPoint = 99999999;
			for (var key in items)
			{
				if (this.getTotalEventPoints() < parseInt(items[key].points_unlock) && parseInt(items[key].points_unlock) <= nextItemMinimalUnlockPoint)
				{
					nextItemMinimalUnlockPoint = parseInt(items[key].points_unlock);
					nextItem = items[key];
				}
			}
			if (!nextItem)	// return the item with the maximum unlock point
			{
				var maxUnlockPoint = 0;
				for (var key in items)
				{
					if (maxUnlockPoint <= parseInt(items[key].points_unlock))
					{
						maxUnlockPoint = parseInt(items[key].points_unlock);
						nextItem = items[key];
					}
				}
			}
			return nextItem;
		},

		/* get the current game event's collection object. A typical collection object has the following info:
        "generator_boost_cost_tier_2": "2",
  	    "generator_reel_count":"3",
	    "point_value":"100",
	    "image":null,
	    "repeatable":"FALSE"
        "items": {
            "1": {
                "image_progress": "spinnerevent_collection_gnomebakerred_progress.png",
                "count": "1",
                "image_silhouette": "spinnerevent_collection_gnomebakerred_silhouette.png",
                "points_value": "10"
            },
            "2": {
                "image_progress": "spinnerevent_collection_gnomeminerred_progress.png",
                "count": "1",
                "image_silhouette": "spinnerevent_collection_gnomeminerred_silhouette.png",
                "points_value": "10"
            },
            "3": {
                "image_progress": "spinnerevent_collection_gnomejesterred_progress.png",
                "count": "2",
                "image_silhouette": "spinnerevent_collection_gnomejesterred_silhouette.png",
                "points_value": "10"
            }
       } */
		getGameEventCollection : function()
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.collections)
			{
				return gameEvent.collections["" + this.mEventCollectionProtoId];
			}
			return null;			
		},

		viewNextCollection : function()
		{
			var collections = weProtoDb.getInstance().getProtoGameEvent().collections_order;
			var active_collection = this.mEventCollectionProtoId;
			var viewing_collection = this.currentViewingCollection;
			var is_smaller_than_current = true;
			if (!Exists(collections)) return;
			for (var i = 0; i < collections.length; i++)
			{
				if (collections[i] == active_collection)
				{
					is_smaller_than_current = false;
					break;
				}
				if (collections[i] == viewing_collection) break;
			}
			if (is_smaller_than_current) this.currentViewingCollection += 1;
		},
		
		viewPreviousCollection: function()
		{
			var collections = weProtoDb.getInstance().getProtoGameEvent().collections_order;
			var active_collection = this.mEventCollectionProtoId;
			var viewing_collection = this.currentViewingCollection;

			if (!Exists(collections)) return;
			
			if (collections[0] == viewing_collection) return;
			if (collections[0] == active_collection) return;
			
			this.currentViewingCollection -= 1;
		},
		
		getEventItemName : function()
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.event_item_name)
			{
				return gameEvent.event_item_name;
			}
			return "Gems";	// by default			
		},

		getGameEventCollectionWithProtoId : function(proto_id)
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.collections)
				return gameEvent.collections[proto_id];
			else
				return null;
		},

		getInactiveGameEventCollection : function()
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			var collections = [];
			if (gameEvent && gameEvent.collections)
			{
				for (eventKey in gameEvent.collections)
				{
					if (eventKey == this.mEventCollectionProtoId) continue;
					collections.push(gameEvent.collections[eventKey]);
					
				}
			}
			return collections;			
		},
		
		getNextCollection: function(current_collection_id)
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.collections)
			{
				for (eventKey in gameEvent.collections)
				{
					if (parseInt(eventKey) == parseInt(current_collection_id))
					{
						if (Exists(gameEvent.collections[(parseInt(eventKey) + 1) + ""]))
						{
							this.currentViewingCollection += 1;
							break;
						}
						else
						{
							break;
						}
					}
					
				}
			}
			return;
		},
		
		getPreviousCollection: function(current_collection_id)
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.collections)
			{
				for (eventKey in gameEvent.collections)
				{
					if (parseInt(eventKey) == parseInt(current_collection_id))
					{
						if (Exists(gameEvent.collections[(parseInt(eventKey) - 1) + ""]))
						{
							this.currentViewingCollection -= 1;
							break;
						}
						else
						{
							break;
						}
					}
					
				}
			}
			return;
		},
		
		/* proto_id: the proto_id of the collection item - since the collection item is not necessarily in the current collection, we should search for all the collections */
		getCollectionItemWithProtoId : function(proto_id)
		{
			var gameEvent = weProtoDb.getInstance().getProtoGameEvent();
			if (gameEvent && gameEvent.collections)
			{
				for (var collection_proto_id in gameEvent.collections)
//  should be changed to only check with the current collection
				{
					var items = gameEvent.collections[collection_proto_id].items;
					var key = "" + proto_id;
					if (items && items[key])
					{
						return items[key];
					}
				}
			}
			return null;
		},
		
		isShareUserInReceivedFrom : function(name)
        {
            var length = WeGameStateMgr.mSEReceivedFrom.length;
            for (var i=0; i < length; i++)
            {
                if (WeGameStateMgr.mSEReceivedFrom[i] === name)
                {
                    return true;
                }
                
            }
            
            return false;
        },
        
        createDropsFromActiveItems : function(x, y)
        {
            if (Exists(this.eventItems) && Exists(this.eventItems.active))
    		{   // we only create the set of items when none on screen
    		    // this prevents the same active items from appearing after another harvest.	    
    		    var active = this.eventItems.active;
    		    var dir = 1;
    		    for (var proto_event_item_id in active)
    		    {
            		var count = active[proto_event_item_id];
            		if (this.mActiveItemsOnScreenCount[""+proto_event_item_id] < count)
            		{
            		    var i = 0;
            		    var num = 0;
            		    var offset = 0;
            		    NgLogD("CREATE " + count + "ITEM with proto_id " + proto_event_item_id);
        				for (i = this.mActiveItemsOnScreenCount[""+proto_event_item_id]; i < count ; i++)
        				{
                			this.createEventDropItem(proto_event_item_id, x + offset*dir, y, dir);
        	        		dir = dir * -1;
        	        		num = num + 1;	
        	        		offset = num * 15;
                		}
            		}
        		}

    		}
        },
        
		showEventWebview : function(event_webview)
		{
			if (event_webview && event_webview.length > 0)	/* should not be an empty url */
			{
				NgLogD("Show event's webview:" + event_webview);
				var obj = {};
				var self = this;
				obj.handle = function ()
	         	{ 
					var gameWidget = WeUiMgr.CreateFullScreenWebView(event_webview);
	          		return gameWidget;
	         	};
	         	obj.args = null;

				WeGameStateMgr.SetPopupWidget(obj);
			}			
		},

        getCollectionPanelItemAsset : function (index)
        {
            var count = 0;
            var keys = [];
            var items = [];
            for (var i in this.mEventCollectionProgress)
            {
                var collection = this.mEventCollectionProgress[i];
                items.push(collection);
                keys.push(i);
            }

            if (items.length < index+1)
                return null;

            var item = items[index];
            var group = this.getGameEventCollection();
            if (!group)
                return null;
            var current = group.items[keys[index]];
            var asset = "";
            NgLogD(item.count + "*** TEST " + current.count);
            if (item.count >= current.count)
            {
                asset = Content.getIconImagePath(this.getGameEventAssetsFolder() + current.image_spinner_collection_color);
            }
            else
                asset = Content.getIconImagePath(this.getGameEventAssetsFolder() + current.image_spinner_collection_sillouett);
                
            return asset;
        },
        
        updateCollectionPanelImages : function()
        {
            var asset = this.getCollectionPanelItemAsset(0);
            this.mCollectionPanelItemImage1.SetImage(asset);
            
            var asset = this.getCollectionPanelItemAsset(1);
            this.mCollectionPanelItemImage2.SetImage(asset);
            
            var asset = this.getCollectionPanelItemAsset(2);
            this.mCollectionPanelItemImage3.SetImage(asset);	
        }
		
});

exports.WeEventGame = new WeEventGame();
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeEventSpinner'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeEventSpinner'] || {}; $MODULE_REGISTRY['weEngine/WeEventSpinner'] = exports; var Core = require('NGCore/Client/Core').Core;
var WeEventGame = require('weEngine/WeEventGame').WeEventGame;
var Content = require('weEngine/WeContent').Content;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;

var WeEventSpinner = Core.Class.subclass(
{
	classname: "WeEventSpinner",

    initialize : function()
    {
		this.showCompletionUrl = null;

		this.mSpinMachine = null;
		this.mBoostSpinMojoCost = null;
		this.mSpinSpout = null;
		this.mSpinLootReveal = null;
		this.mSpinners = [];	// spinners
		this.mSpinResults = [];	// spinner's results
		this.mSpinFanfare = null;
		this.mResultImage = null;	// loot result images
		this.mLootItem = null;	// the currently generated item
		this.mLootItemValue = null;	// the loot item count label ( only used for the loots of points, like 20 points, 40 points )
		this.mLootItemMultiplier = null;
		this.mLootItemEarnedPointsLabelDef = null;
		this.mLootItemEarnedPointsLabel = null;	// show the flyoff of the earned points from the loot item
		this.mLootItemEarnedPointsPos = null;	// show the flyoff of the earned points from the loot item
		this.mEarnedPointStrokeLabels = [];
		this.mPointLootLabel = null;	// the point loot's second slot's read
		this.mEventSpinBtn = null;
		this.mEventBoostBtn = null;
		this.setIsSpinning(false);
		this.mLastGenerateLootTime = null;
		this.mCollectionNameLabel = null;
		this.mLastLootTier = -1;
		
		this.mTotalPointsBefore = 0;
    },

	deleteImageAndAnimation : function(image)
	{
		if (!image)
			return;
		WeUiMgr.GetImageFactory().ReleaseImage(image);
		if (image.animation)
		{
			image.animation.setLoop(false);
			image.animation.Stop();
			image.animation.destroy();
			delete image.animation;
		}
		image.destroy();
	},

    cleanSpinner : function()
	{
        try
        {
			this.stopAnimation();
			this.deleteEarnedPointStrokeLabels();
			this.cleanLootResult();
		}
        catch(ex)
        {
            NgLogD("Error: cleanSpinner " + ex);
        }		
	},

	/* update the user data from generationg a loot */
	updateUserData : function(user_object)
	{
		if (user_object)
		{
			WeGameStateMgr.GetGameLotInfo().xp = user_object.xp;
			WeGameStateMgr.GetGameLotInfo().gold = user_object.gold;
			WeGameStateMgr.GetGameLotInfo().mana = user_object.mana;
		}
	},

	showFirstTimeEarnedEventPoints : function()
	{
		if (!Exists(gConfigs.showFirstEarnEventPoints) || gConfigs.showFirstEarnEventPoints)
		{
			WeUiMgr.ShowFirstEarnEventPoints();
		}
	},

	showCurrentCollectionName : function()
	{
		var collection = WeEventGame.getGameEventCollection();
		var name = collection ? collection.name : "";
		if (this.mCollectionNameLabel && this.mCollectionNameLabel.GetGL2())
		{
			this.mCollectionNameLabel.GetGL2().setText(name);	/* the point value */
			
		}
	},

	showFinalStats : function()
	{
		WeEventGame.updateCollectionPanelImages();
		WeEventGame.showEventPoints();
		WeEventGame.setEventPointProgress();
		this.showCollectionCompletionWebview();
		
		if (this.mTotalPointsBefore == 0 && WeEventGame.getTotalEventPoints() > 0)
		{
			this.showFirstTimeEarnedEventPoints();
		}
		this.showCurrentCollectionName();
	},

    generateLoot : function(item_id, tier)
	{
		var self = this;
		this.setIsSpinning(true);
		this.cleanLootResult();
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.EventSpinAnimation);
		this.startObjectAnimation(this.mSpinMachine, {"frame_speed": 0.3});
		this.mLastGenerateLootTime = new Date();
		this.mLastLootTier = tier;
        for (var i = 0; i < this.getReelCount(); i++)
        {
			if (i == 0)
			{
				var spinTimeOutSecond = gConfigs.eventSpinTimeOutSecond ? gConfigs.eventSpinTimeOutSecond : 20;
				var spinningSpeed = gConfigs.eventSpinningSpeed ? gConfigs.eventSpinningSpeed : 0.35;
				this.startObjectAnimation(self.mSpinners[i], {"frame_speed": spinningSpeed, "check_time_out": spinTimeOutSecond /* wait for how many seconds before times out*/});
			}
			else
			{
				this.startObjectAnimation(self.mSpinners[i], {"frame_speed": 0.23});				
			}
        }
		this.mTotalPointsBefore = WeEventGame.getTotalEventPoints();
        WeProtocol.generateEventLoot(item_id, tier, function(request)
		{
			var obj = WeProtocol.getRequestResponse(request);
			if (obj && obj.generator_result)
			{
				NgLogD("generator_result is: " + JSON.stringify(obj.generator_result));
				if (obj.generator_result.user)
				{
					self.updateUserData(obj.generator_result.user);
				}
				if (obj.generator_result.kingdom && obj.generator_result.kingdom.kingdom)
				{
					self.updateUserData(obj.generator_result.kingdom.kingdom);
				}
				if (obj.generator_result.stash && obj.generator_result.stash.stash)
				{
					NgLogD("Updated stash: " + JSON.stringify(obj.generator_result.stash.stash));
					WeProtocol.updateStash(obj.generator_result.stash.stash);
				}
				if (obj.generator_result.newly_completed_collection)
				{
					var completedCollection = WeEventGame.getGameEventCollectionWithProtoId(obj.generator_result.newly_completed_collection);
					// show completion view
			        if(Exists(completedCollection.completion_webview) && completedCollection.completion_webview.length > 0)
			        {
						self.showCompletionUrl = completedCollection.completion_webview;
			        }
				}
				else
					self.showCompletionUrl = null;
					
				if (!WeEventGame.isShowingSpinnerView())	// already switched to another tab
				{
					self.showFinalStats();
					return;
				}
				self.setCurrentLootItem(obj.generator_result);
			}
			else	/* for some reason the loot is not generated (might be out of gem?)*/
			{
				self.showCompletionUrl = null;
				self.startAnimation();
				self.setCurrentLootItem(null);
				self.setIsSpinning(false);
			}
        });
    },

	delayForCallback : function(seconds, cb)
	{
		var animation;
		animation = new NumberAnimation(seconds, 0, 1.01);
		animation.setLoop(false);

        animation.SetNumber=function(value)
        {
			if (!WeEventGame.isShowingSpinnerView())
			{
				return;
			}
			if (value >= 1.0)
			{
				animation.Stop();
			}
        };

        animation.OnStop=function()
        {
			cb();
        };		
	},

	showSpinnerResult : function(index, max)
	{
		if (!WeEventGame.isShowingSpinnerView() || !this.mSpinResults[index] ||!this.mSpinResults[index].image || index < 0 || index > max || !this.mLootItem || !this.mLootItem.item)
			return;

		/* the last reel is for the multiplier image */
		var image_name;
		if (index == max)
		{
			if (this.mLootItem.multiplier)
				image_name = this.mLootItem.multiplier["image_spinner_window_1"];
			else
				image_name = "empty";	//there should be an empty slot for the item that can not be multiplied
		}
		else
		{
			image_name = this.mLootItem.item["image_spinner_window_" + (index + 1)];
		}
		var image_path = image_name ? (WeEventGame.getGameEventAssetsFolder() + image_name) : "alpha2.png";

		if (index == 1 && this.mLootItem.item.type == "points" && this.mPointLootLabel)
		{
			this.mPointLootLabel.GetGL2().setText(this.mLootItem.item.value);	/* the point value */
			this.mPointLootLabel.SetVisible(true);
		}
		this.stopObjectAnimation(this.mSpinners[index]);
		this.mSpinners[index].image.SetImage(this.mSpinners[index].stop_image);
		this.mSpinResults[index].image.SetImage(image_path);
        this.mSpinResults[index].image.SetVisible(true);
		
		var self = this;
		var delay_seconds = gConfigs.eventSlotResultSecond ? gConfigs.eventSlotResultSecond: (this.mSpinResults[index].delay_seconds ? this.mSpinResults[index].delay_seconds : 1.0);
		this.delayForCallback(delay_seconds, function() {
			if (index < max)
            {
				/* show next spinner */
				self.showSpinnerResult(index + 1, max);
			}
			else
			{
				self.revealLoot();
			}			
		}
		);
	},

	revealLoot : function()
	{
		var self = this;
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.EventRevealAward);
		this.stopObjectAnimation(this.mSpinMachine);
		var fanfareFrameSpeed = gConfigs.eventSpoutFrameSpeed ? gConfigs.eventSpoutFrameSpeed : 0.2;
		this.startObjectAnimation(this.mSpinSpout, {"frame_speed": fanfareFrameSpeed});
		this.startObjectAnimation(this.mSpinLootReveal, {"frame_speed": 0.32, "animation_second":1.5, "only_play_once": true}, function()
		{
			self.showCurrentLootImage();
			self.showCurrentLootMultiplier();
			var fanfareFrameSpeed = gConfigs.eventFanfareFrameSpeed ? gConfigs.eventFanfareFrameSpeed : 0.35;
			var fanfareAnimationSecond = gConfigs.eventFanfareAnimationSecond ? gConfigs.eventFanfareAnimationSecond : 4;
			
			self.mSpinFanfare.animation_frames = [];
			if (self.mLastLootTier == 1 && self.mLootItem && self.mLootItem.item && self.mLootItem.item.type == "points")
			{
				self.mSpinFanfare.animation_frames = self.mSpinFanfare.mAnimationsA;
			}
			else	// tier is 2
			{
				self.mSpinFanfare.animation_frames = self.mSpinFanfare.mAnimationsB;				
			}
			self.startObjectAnimation(self.mSpinFanfare, {"frame_speed": fanfareFrameSpeed, "animation_second": fanfareAnimationSecond});
			self.stopObjectAnimation(self.mSpinSpout);
			self.showLootEarnedPointsFlyOff();
		});
	},

	showCollectionCompletionWebview : function()
	{
		if (this.showCompletionUrl)
		{
			WeEventGame.showEventWebview(this.showCompletionUrl);
		}
	},

	showCurrentLootMultiplier : function()
	{
		if (!WeEventGame.isShowingSpinnerView())
			return;

		if (this.mLootItemMultiplier && this.mLootItemMultiplier.GetGL2())
		{
			var multiplierText = "";
			if (this.mLootItem.multiplier && this.mLootItem.multiplier.value)
			{
				multiplierText = "x " + this.mLootItem.multiplier.value.replace("x", "");
			}
			this.mLootItemMultiplier.GetGL2().setText(multiplierText);
            this.mLootItemMultiplier.SetVisible(true);
		}			
	},

	showCurrentLootImage : function()
	{
		if (!WeEventGame.isShowingSpinnerView())
			return;

		if (this.mResultImage && this.mLootItem && this.mLootItem.item)
		{
			this.stopObjectAnimation(this.mSpinLootReveal);
			if (this.mSpinLootReveal.image)
			{
				this.mSpinLootReveal.image.SetVisible(false);
				this.mSpinLootReveal.image.SetImage("alpha2.png");
			}

			if (this.mLootItemValue && this.mLootItemValue.GetGL2())
			{
				this.mLootItemValue.SetVisible(false);
			}

			var image_path = "";
			if (this.mLootItem.item.type == "collection_item")
			{
				var item = WeEventGame.getCollectionItemWithProtoId(this.mLootItem.item.value); /* the collection item's proto_id */
				image_path = WeEventGame.getGameEventAssetsFolder() + item.image_outcome;
			}
			else if (this.mLootItem.item.type == "points")
			{
				image_path = getAssets("spinner_generated_item_points_icon");
				if (this.mLootItemValue && this.mLootItemValue.GetGL2())
				{
					this.mLootItemValue.GetGL2().setText(this.mLootItem.item.value);	/* the point value */
					this.mLootItemValue.SetVisible(true);
				}
                // TODO
			}
			else if (this.mLootItem.item.type == "boost")
			{
				image_path = getAssets("spinner_generated_item_boost_icon");
                // TODO
			}

			this.mResultImage.SetImage(image_path);
           	this.mResultImage.SetVisible(true);
		}
	},

	SetAnimationObject : function(object, image, param)
	{
		if (!object || !image || !param || !param.animation_frame_count)
			return;

		object.image = image;	// save for later use
		object.animation_frames = [];
		object.atFrame = 0;

		for (var i = 1; i <= param.animation_frame_count; i++)
		{
			object.animation_frames.push(param["animation_frame_" + i]);
		}
	},

	stopObjectAnimation : function(object)
	{
		if (object && object.animation && object.image)
		{
			object.animation.setLoop(false);
			object.animation.Stop();
			object.animation.destroy();
			object.animation = null;
		}		
	},

	startObjectAnimation : function(object, args, cb)
	{
		if (!WeEventGame.isShowingSpinnerView() || !object || !object.image || !object.animation_frames)
		{
			return;
		}
	
		var frame_speed = 1;
		var animation_second = 0;	// default value is 0: to always loop
		if (args)
		{
			if (args.frame_speed)
				frame_speed = args.frame_speed;
			if (args.animation_second)
				animation_second = args.animation_second;
		}
		if (object.animation)
		{
			this.stopObjectAnimation(object);
		}
		object.atFrame = -1;
		var frames = object.animation_frames.length;
		var animation;
		if (!animation_second || animation_second == 0)
		{
			animation = new NumberAnimation(frames * frame_speed, 0, frames - 0.01);
			animation.setLoop(true);
		}
		else
		{
			animation = new NumberAnimation(animation_second, 0, parseInt(animation_second / frame_speed) - 0.01);
			animation.setLoop(false);
		}
		object.image.SetVisible(true);

		var self = this;
        animation.SetNumber=function(value)
        {
			if (!object.image)
			{
				return;
			}
			if (!WeEventGame.isShowingSpinnerView())
			{
				return;
			}
			if (args && args.check_time_out && args.check_time_out > 0 && self.mLastGenerateLootTime)
			{
				var nowTime = new Date();
				var time_elapsed = nowTime.getSeconds() - self.mLastGenerateLootTime.getSeconds();
				if (time_elapsed > args.check_time_out)
				{
					NgLogD("Stop animation because of timeout " + args.check_time_out + ": " + nowTime + ", " + self.mLastGenerateLootTime);
					self.stopAnimation();
					self.setIsSpinning(false);
					return;
				}
			}
			var frame = parseInt(value) % frames;
			if (args && args.only_play_once && frame < object.atFrame)
			{
				return;	// if only play once, do not backwind
			}
			if (frame != object.atFrame)
			{
				object.atFrame = frame;
				if (object.animation_frames[frame])
					object.image.SetImage(object.animation_frames[frame]);
				return;
			}
        };

		if (cb)
        	animation.OnStop = cb;

        object.animation = animation;
	},

	createEarnedPointStrokeLabels : function()
	{
		var newDef = ObjectUtils.GetCloneOfObject(this.mLootItemEarnedPointsLabelDef);
		delete newDef.tag;
		newDef.pos_z = newDef.pos_z - 0.01;
		newDef.color_r = 255;
		newDef.color_g = 255;
		newDef.color_b = 255;	//white
		for (var i = 0; i < 4; i++)
		{
			this.mEarnedPointStrokeLabels[i] = WeUiMgr.mLabelFactory.CreateLabel(newDef, WeUiMgr.GetScreen().GetNode());
		}
	},

	deleteEarnedPointStrokeLabels : function()
	{
		NgLogD("Delete earned point stroke labels");
		for (var i = 0; i < this.mEarnedPointStrokeLabels.length; i++)
		{
			this.mEarnedPointStrokeLabels[i].SetVisible(false);
			this.mEarnedPointStrokeLabels[i].destroy();
			this.mEarnedPointStrokeLabels[i] = null;
		}
		this.mEarnedPointStrokeLabels = [];
	},

	earnedPointLabelsSetPosition: function(x, y)
	{
		if (this.mLootItemEarnedPointsLabel && this.mLootItemEarnedPointsLabel.GetGL2())
			this.mLootItemEarnedPointsLabel.GetGL2().setPosition(x, y);
		//mimic the white stroke
		var xoffsets = [0, 1, 0, -1];
		var yoffsets = [1, 0, -1, 0];
		
		var factor = this.mLootItemEarnedPointsLabelDef.font_size * 0.06;
		for (var i = 0; i < this.mEarnedPointStrokeLabels.length; i++)
		{
			if (this.mEarnedPointStrokeLabels[i] && this.mEarnedPointStrokeLabels[i].GetGL2())
				this.mEarnedPointStrokeLabels[i].GetGL2().setPosition(x + xoffsets[i] * factor, y + yoffsets[i] * factor);
		}
	},

	earnedPointLabelsSetAlpha: function(alpha)
	{
		if (this.mLootItemEarnedPointsLabel)
			this.mLootItemEarnedPointsLabel.SetAlpha(alpha);

		for (var i = 0; i < this.mEarnedPointStrokeLabels.length; i++)
		{
			if (this.mEarnedPointStrokeLabels[i])
				this.mEarnedPointStrokeLabels[i].SetAlpha(alpha);
		}
	},

	showLootEarnedPointsFlyOff : function()
	{
		if (!WeEventGame.isShowingSpinnerView())
		{
			return;
		}

		if (this.mLootItemEarnedPointsLabel && this.mLootItemEarnedPointsLabel.GetGL2() && this.mLootItemEarnedPointsPos)
		{
	        var earnedPointLabelGl2 = this.mLootItemEarnedPointsLabel.GetGL2();
			earnedPointLabelGl2.setText("" + WeEventGame.getEarnedPoints());
			this.mLootItemEarnedPointsLabelDef.text = "" + WeEventGame.getEarnedPoints();
			this.mLootItemEarnedPointsLabel.SetVisible(WeEventGame.getEarnedPoints() > 0);
			if (WeEventGame.getEarnedPoints() > 0)
			{
				this.createEarnedPointStrokeLabels();
				this.earnedPointLabelsSetPosition(this.mLootItemEarnedPointsPos.getX(), this.mLootItemEarnedPointsPos.getY());
				this.earnedPointLabelsSetAlpha(1.0);
			}
			var destPos = WeEventGame.getEventPointsLabelPosition();
			var x1 = this.mLootItemEarnedPointsPos.getX();
			var x2 = destPos.getX();
			var y1 = this.mLootItemEarnedPointsPos.getY();
			var y2 = destPos.getY();
			var cNumberAnimation= new NumberAnimation(3.5, -1.5, 2.0);
			cNumberAnimation.setLoop(false);
			var self = this;

			/* preparing for drawing an arc */
			var rX = Math.abs(x1 - x2);
			var rY = Math.abs(y1 - y2);
			
			cNumberAnimation.SetNumber=function(value)
			{
				if (!WeEventGame.isShowingSpinnerView())
				{
					return;
				}
				if (value < 0)	/* number blinking */
				{
/*					var scaleFactor = parseInt(value * 10) % 10;
					var scale = 1 + ((scaleFactor < 5) ? scaleFactor : (9 - scaleFactor)) * 0.14;
					earnedPointLabelGl2.setScale(scale, scale);  */
				}
				else if (value <= 1)	// from 0~1
				{
					if (value >= 0.8)	//hacky, to make the cure more smooth
					{
						value = 1.0 - (1.0 - value) / 5;
					}
					var dx = (x2 - x1) * value;
					var dy = Math.sqrt(rY * rY - dx * dx * rY * rY / (rX * rX));
					var x = x1 + dx;// - self.mLootItemEarnedPointsLabel.GetWidth() / 2;
					var y = y2 - dy;
					self.earnedPointLabelsSetPosition(x, y);
				}
				else	// fade out
				{
					self.earnedPointLabelsSetAlpha(2.0 - value);
				}
			};
			
		    cNumberAnimation.OnStop=function()
		    {
				self.showFinalStats();
				if (!WeEventGame.isShowingSpinnerView())
				{
					self.setIsSpinning(false);
					return;
				}
				self.stopObjectAnimation(self.mSpinFanfare);
				self.mSpinFanfare.image.SetVisible(false);
				self.mSpinFanfare.image.SetImage("alpha2.png");
				self.startAnimation();
		        if (self.mLootItemEarnedPointsLabel)
		        {
					self.mLootItemEarnedPointsLabel.SetVisible(false);
				}
				self.deleteEarnedPointStrokeLabels();
				self.setIsSpinning(false);
		    };
		}
		else
		{
			this.setIsSpinning(false);
		}
	},

	setCurrentLootItem : function(loot_item)
	{
		this.mLootItem = loot_item;
		var self = this;
		this.delayForCallback(1.5, function()
		{
			if (!WeEventGame.isShowingSpinnerView())
			{
				return;
			}
			self.setIsSpinning(true);
			self.showSpinnerResult(0, self.getReelCount() - 1);			
		});
	},

	getCurrentLootItem : function()
	{
		return this.mLootItem;
	},

	/* get the current game event's collection's reel count */
	getReelCount : function()
	{
		var collection = WeEventGame.getGameEventCollection();
		if (collection)
			return collection.generator_reel_count;
		return 3;	// the default value
	},

	/* get the current game event's collection's boost mojo cost */
	getBoostCost : function()
	{
		var collection = WeEventGame.getGameEventCollection();
		if (collection)
			return collection.generator_boost_cost_tier_2;
		return 0;	// the default value
	},
    
    stopAnimation : function()
    {
        var i;
        for (i = 0; i < this.getReelCount(); i++)
        {
			this.stopObjectAnimation(this.mSpinners[i]);
			this.mSpinners[i].image.SetImage(this.mSpinners[i].stop_image);
        }
		this.stopObjectAnimation(this.mSpinMachine);
		this.stopObjectAnimation(this.mSpinSpout);
		this.stopObjectAnimation(this.mSpinFanfare);
		this.mSpinFanfare.image.SetVisible(false);
		this.mSpinFanfare.image.SetImage("alpha2.png");
		this.stopObjectAnimation(this.mSpinLootReveal);
		this.mSpinLootReveal.image.SetVisible(false);
		this.mSpinLootReveal.image.SetImage("alpha2.png");
    },

	cleanLootResult : function()
	{
		this.deleteEarnedPointStrokeLabels();
		if (!WeEventGame.isShowingSpinnerView())
		{
			return;
		}

		for (i = 0; i < this.mSpinResults.length; i++)
		{
			if (this.mSpinResults[i] && this.mSpinResults[i].image)
			{
				this.mSpinResults[i].image.SetVisible(false);
			}				
		}
		
        if (this.mPointLootLabel)
        {
			this.mPointLootLabel.SetVisible(false);
		}
        if (this.mResultImage)
        {
            this.mResultImage.SetVisible(false);
        }
        if (this.mLootItemMultiplier)
        {
            this.mLootItemMultiplier.SetVisible(false);
        }
		if (this.mLootItemValue)
		{
			this.mLootItemValue.SetVisible(false);
		}
	},

    startAnimation : function()
    {
		if (!WeEventGame.isShowingSpinnerView())
		{
			return;
		}

        var self = this;
        var i;
        var image;
    },
	
	setIsSpinning : function(spinning)
	{
		this.mIsSpinning = spinning;
		if (!WeEventGame.isShowingSpinnerView())
		{
			return;
		}
		
		var interactionEnabled = (!spinning) && WeEventGame.isSpinnerEnabled();
		var alpha = (!interactionEnabled) ? 0.5 : 1;
		
		// mask the button a bit to avoid being clicked
		if (this.mEventSpinBtn && this.mEventSpinBtn.GetVisible())
		{
			this.mEventSpinBtn.SetAlpha(alpha);
			this.mEventSpinBtn.SetInteraction(interactionEnabled);		
		}
		if (this.mEventBoostBtn && this.mEventBoostBtn.GetVisible())
		{
			this.mEventBoostBtn.SetAlpha(alpha);			
			this.mEventBoostBtn.SetInteraction(interactionEnabled);
		}
		if (this.mBoostSpinMojoCost && this.mBoostSpinMojoCost.GetGL2())
		{
			this.mBoostSpinMojoCost.SetAlpha(alpha);
			this.mBoostSpinMojoCost.GetGL2().setText("" + this.getBoostCost());
		}
	},

	isSpinning : function()
	{
		return this.mIsSpinning;
	},

	onSpinButtonClicked : function(tier)
	{
		if (!WeEventGame.isShowingSpinnerView())
			return;
		if (!WeEventGame.isSpinnerEnabled())
			return;
		if (this.isSpinning())
		{
			NgLogD("It is spinning! Please wait!");
			return;
		}

		if (tier == 2 && this.getBoostCost() > WeGameStateMgr.GetGameLotInfo().mana)
		{
			WeUiMgr.ShowNotEnoughMojoPopup();
			return;
		}
		
		if (tier == 1 && WeEventGame.getAcquiredEventItemsCount() < 1)
		{
			WeUiMgr.ShowNotEnoughEventItem();
			return;
		}
        NgLogD("SPIN SPIN! with tier " + tier);
        var item_id = (tier == 2) ? -1 /*does not need event item*/ : WeEventGame.getAcquiredEventItemProtoId(1);	/* need one event item */
		if (item_id)
		{
			this.generateLoot(item_id, tier);
		}
		else
		{
			NgLogD("Not enough event item to spin! " + JSON.stringify(WeEventGame.eventItems));
		}
	}
}
);

exports.WeEventSpinner = new WeEventSpinner();
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeSpriteParser'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeSpriteParser'] || {}; $MODULE_REGISTRY['weEngine/WeSpriteParser'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-21
 *  @file:      WeSpriteParser.js
 *  @author:    Chris Jimison
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;

//////////////////////////////////////////////////////////////////////////////
// globals
var _SpriteTableForceUsePNG = true;

exports.SpriteTableForceUsePNG = _SpriteTableForceUsePNG;
//////////////////////////////////////////////////////////////////////////////
/**
 * Class: SpriteTable 
 */
var _SpriteTable = Core.Class.singleton({

    initialize : function()
    {
        this.linkSpriteTableData = {};
		this.imgNames = [];
    },

	addImg : function(name)
	{
		this.imgNames.push(name);
	},

	imgExists : function(name)
	{
		for(var i in this.imgNames)
		{
			if(name === this.imgNames[i])
				return true;
		}
		return false;
	},

    download : function(sprite_table)
    {
    	this.onDownloadResponse(sprite_table);
        //this.onDownloadResponse(SpriteData.sprite_table);
    },

    onDownloadResponse : function(response)
    {
        var j=0;
        var linesFromFile = response.split("\\n\\\n");
        var len = linesFromFile.length;
        for(var i = 0; i < len; ++i)
        {
            var lineFromFile = linesFromFile[i];
            indiData = lineFromFile.split(",");
            var e = { };
            e.textureNumber = indiData[0];
            e.mX =            indiData[1];
            e.mY =            indiData[2];
            e.mWidth =        indiData[3];
            e.mHeight =       indiData[4];
            e.xOffset =       indiData[5];
            e.yOffset =       indiData[6];
            e.flags =         indiData[7];
            this.linkSpriteTableData[ j++ ] = e;
        }
        
        if( this.callback )
            this.callback();
    },

    getSpriteTableDataFromNOL : function(spriteSheetName,spriteOffset,spriteLength)
    {
        if(spriteLength==1)
        {
            return this.linkSpriteTableData[spriteOffset];
        }
        else
        {
            this.spriteEntriesRequired = [];
            for(var k=spriteOffset, i=0; k<(spriteOffset+spriteLength) && i<spriteLength; ++k,++i)
            {
                this.spriteEntriesRequired[i] = this.linkSpriteTableData[k];
            }
            return this.spriteEntriesRequired;
        }
    },

    setCallback : function( func )
    {
        this.callback = func;
    }
});
exports.SpriteTable = _SpriteTable;

//////////////////////////////////////////////////////////////////////////////
/**
 * Class: SpriteTableHeader 
 */
var _SpriteTableHeader = Core.Class.singleton(
{
    initialize: function()
    {
        this.headerTagData = {};
        this.headerSizeData = {};
    },
    download : function(sprite_table_headers, sprite_table)
    {
    	//SpriteData.sprite_table_headers SpriteData.sprite_table
        this.onDownloadResponse(sprite_table_headers, sprite_table);
    },

    onDownloadResponse : function(response, sprite_table)
    {
        var linesFromFile = response.split("\\n\\\n");
        var currentSpriteSheetName = null;
        var nextSpriteSheetName = null;
        var previousIndex = -1;
        var previousTag = null;
        var sizeLength = 0;
        var spriteSheetSize = {};
        
        var len = linesFromFile.length;

        for(var i = 0; i < len; ++i)
        {
            var spritesTag = "// sprites/";
            var lineFromFile = linesFromFile[i];
            if(lineFromFile.indexOf(spritesTag) != -1)
            {
                var spritesTagPosition = lineFromFile.indexOf(spritesTag);
                var fileTypePosition = lineFromFile.indexOf(".png");
                if(fileTypePosition == -1)
                    fileTypePosition = lineFromFile.indexOf(".pvr");
                
                var spriteSheetNamePosition = spritesTagPosition +  spritesTag.length;
                var sizeStart = fileTypePosition + 5;
                sizeLength = lineFromFile.indexOf("x", sizeStart) - sizeStart;
                spriteSheetSize.resolution = lineFromFile.substr(sizeStart,sizeLength);
                
                var spriteSheetName = "";
                var length = fileTypePosition - spriteSheetNamePosition;
                if (_SpriteTableForceUsePNG)
                    spriteSheetName = lineFromFile.substr(spriteSheetNamePosition, length) + ".png";
                else
                    spriteSheetName = lineFromFile.substr(spriteSheetNamePosition, length);
                
                if (!currentSpriteSheetName)
                    currentSpriteSheetName = spriteSheetName;
                else
                    nextSpriteSheetName = spriteSheetName;
                this.headerSizeData[spriteSheetName] = spriteSheetSize.resolution;


            }
            else if (lineFromFile.indexOf("#define") != -1)
            {
                var defineData = lineFromFile.replace(/\s\s+/, " ").split(" ");
                var key = defineData[1];
                var currentIndex = parseInt(defineData[2]);
                
                if (!isNaN(currentIndex) && currentIndex !== 0)
                {
                    var sizeofSpriteTableEntry = 1;
                    var spriteDatabase = { };
                    spriteDatabase.spriteSheet = currentSpriteSheetName;
                    //sprite no from start
                    spriteDatabase.offset = previousIndex * sizeofSpriteTableEntry;
                    //no of frames per sprite
                    spriteDatabase.length = (currentIndex - previousIndex) * sizeofSpriteTableEntry;
                    //The last character of each SpriteSheet name defines level of detail of the sprites
                    var lastCharacterLocation = currentSpriteSheetName.length - 5;
                    var lastCharacterRange = 1;
                    var levelOfDetail = parseInt(currentSpriteSheetName.substr(lastCharacterLocation, lastCharacterRange), 10);
                    if (isNaN(levelOfDetail))
                        levelOfDetail = 0;
                    
                    var idx = previousTag + "_" + levelOfDetail;
                    this.headerTagData[idx] = spriteDatabase;
                }
                
                previousIndex = currentIndex;
                previousTag = key;
                
                if (nextSpriteSheetName)
                {
                    currentSpriteSheetName = nextSpriteSheetName;
                    nextSpriteSheetName = null;
                }
                
                if (key == "SPR_MAX")
                    break;
            }
        }
        //this.DumpTagData();
        _SpriteTable.download(sprite_table);
    },

    DumpTagData : function()
    {
        var dumpLayer = function(obj, tab)
        {
            var tabSpace = "";
            for(var tabIdx = 0; tabIdx < tab; ++tabIdx)
            {
                tabSpace = "----" + tabSpace;
            }

            for(var idx in obj)
            {
                if(typeof(obj[idx]) == 'object')
                {
                    NgLogD(tabSpace + " " + idx);
                    dumpLayer(obj[idx], tab + 1);
                }
                else
                {
                    var out = tabSpace + idx + ": " + obj[idx];
                    NgLogD(out);
                }
            }
        };

        dumpLayer(this.headerTagData, 0);
    },

    getLowestLod : function ( headerTag, start )
    {
        for( var lod = start; lod < 5; ++lod )
        {
            var key = headerTag + "_" + lod;
            if ( this.headerTagData[ key ] )
			{
                return key;
			}
        }
    },
    
    getHighestLod : function ( headerTag )
    {   
        for( var lod = 4; lod >= 0; --lod )
        {
            var key = headerTag + "_" + lod;
            if ( this.headerTagData[ key ] )
                return key;
        }
    },

    //Returns Data of all particular spritename_levelofdetail
    getSpriteTableData : function(headerTag, levelOfDetail)
    {
    	// Try to return proper LOD first
    	var key = headerTag + "_" + levelOfDetail;
        var res = this.headerTagData[ key ];
        if (levelOfDetail > 0 && !res)
        {
    		// Try LOD 1 first, since it usally has animation
    		res = this.headerTagData[ this.getLowestLod ( headerTag, 1 ) ];
    		if(!res)
    			// Fallback to lowest LOD
    			res = this.headerTagData[ this.getLowestLod ( headerTag, 0 ) ];
        }
		return res;
    },

    getSpriteTableDataHigest : function(headerTag)
    {
        return this.headerTagData[this.getHighestLod (headerTag)];
    },

    //Returns texture size of argumented spritesheet
    getSpriteSheetSize : function(spriteSheetName)
    {
        return this.headerSizeData[spriteSheetName];
    }
});

exports.SpriteTableHeader = _SpriteTableHeader;

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeDropItem'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeDropItem'] || {}; $MODULE_REGISTRY['weEngine/WeDropItem'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeDropItem.js
/// @author:    awong@ngmoco.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     
///
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var GL2 = require('NGCore/Client/GL2').GL2;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var Content = require('weEngine/WeContent').Content;

// ////////////////////////////////////////////////////////////////////////////
// Class WeDropItem
var gFlyOffVelY = 2;
var gFlyOffVelX = 0;
var gSpriteNumberFrameWidth = 16;
var gSpriteNumberFrameHeight = 24;
var gNumberSheetWidth = 256;
var gNumberSheetHeight = 32;
var gFlyOffNumberOffsetFromRes = 30;
var gDropOffTime = 500;
var gFlyOffTime = 10000;
var gNumberFontSpacing = 17;
var gDropItemDestX = 745;
var gDropItemDestY = 329;
exports.WeDropItem = Core.MessageListener.subclass(
{
	classname : "WeDropItem",

	initialize : function(screen, x, y, sprite, dir, proto_item_id) {
		this.mCanvas = null;
		this.mImage = null;
		this.mEndTime = null;
		this.mIsUpdatable = true;
		this.mSpriteNumbers = [];
        this.mDir = dir;
		this.mNodeGL2 = new GL2.Node();
		this.parent = screen;
		this.parent.addChild(this.mNodeGL2);
        this.proto_item_id = proto_item_id;
		this.mImage = new WeSprite2D(Content.getImagePath(sprite), [ 53, 53 ], [ 0.5, 0.5 ],
				this.mNodeGL2, [ 0.5, 0.5 ]);
        this.mImage.SetDepth(100);        
		this.mNodeGL2.setPosition(x, y);
		this.mNodeGL2.setDepth(100);
		this.mEndTime = Core.Time.getFrameTime() + gDropOffTime;
        this.mFlyTime = Core.Time.getFrameTime() + gFlyOffTime;
        this.mIsFlying = false;
		this.updating = true;
		Core.UpdateEmitter.addListener(this, this.OnUpdate);
		
		this.mImage.Enable("Touch");
	//	this.mImage.mRequiresTap = true;
        this.origX = x;
        this.origY = y;
        
		var self = this;
		var image = this.mImage;

		this.mImage.OnTouchDown = function(touch) { return true; };
		this.mImage.OnTapEvent = function(touch)
		{
		    NgLogD("TOUCH DROP ITEM " + self.entity);
		    if (!self.mIsFlying)
		    {
                self.FlyOut();
            }
		};
	},

	destroy : function() {
	    
	    if(this.OnExit)
	    {
	        this.OnExit();
	    }
	    
		if (Exists(this.mNodeGL2)) {
			this.mNodeGL2.destroy();
			delete this.mNodeGL2;
		}

		this.mImage.destroy();
	},

    FlyOut : function() {
	      
        this.mIsFlying = true;
        this.parent.removeChild(this.mNodeGL2);
	    
	    WeRenderDevice.GetUiRoot().addChild(this.mNodeGL2);
	    
//	    this.mNodeGL2.setPosition(this.origX, this.origY);
	    var image = WeUiMgr.GetImageFactory().FindImageOfName("se_background");
	    var imagex = gDropItemDestX;
	    var imagey = gDropItemDestY;
	    
	    if (image)
	    {
	        imagex = image.GetX();
	        imagey = image.GetY();
	    }
	    
	    var posx = this.mNodeGL2.getPosition().getX();
	    var posy = this.mNodeGL2.getPosition().getY();
	    NgLogD("POS " + posx + " " + posy);
	    var scale = WeRenderDevice.GetScaleRoot().GetScale().getX();
         posx += WeCamera.getX() ;
         posy += WeCamera.getY() ;
         posx *= scale;
         posy *= scale;
           
	    
		var cNumberAnimation= new MoveAnimation(0.5,  posx, imagex,  posy, imagey);
		cNumberAnimation.setLoop(false);
        var self = this;
        
        WeProtocol.acquireItem(this.proto_item_id, function(request)
		{
            var obj = WeProtocol.getRequestResponse(request);
        });
        
		
		
        cNumberAnimation.SetNumber=function(value1, value2)
	    {
	        NgLogD("MOVING " + value1 + " " + value2);
			self.mNodeGL2.setVisible(WeUiMgr.isInOwnGameScreen());
			self.mNodeGL2.setPosition(value1, value2);
	    };
	    
        cNumberAnimation.OnStop=function()
        {
   //         NgLogD("STOP DROP ITEM");
            WeEventGame.doEventBookGlow();
			this.destroy();
			self.destroy();	
        };
    },
    
	OnUpdate : function(delta) {
		var tick = Core.Time.getFrameTime();
		if (tick > this.mEndTime) {
		    
		    if (tick > this.mFlyTime && !this.mIsFlying) {
			    this.FlyOut();
		    }
		} else {
			var position = this.mNodeGL2.getPosition();
			this.mNodeGL2.setPosition(position.getX() + gFlyOffVelX * this.mDir, position.getY()
					+ gFlyOffVelY);
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeGround'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeGround'] || {}; $MODULE_REGISTRY['weEngine/WeGround'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeLot.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     A lot is a base piece of land that the game is played on.
///             It is also the base object for all in game touches 
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var Content = require('weEngine/WeContent').Content;
var WeLotGrid = require('weEngine/WeLotGrid').WeLotGrid;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;
var WeEffectsMgr = require('weEngine/WeEffects').WeEffectsMgr;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var Vec3D = require('weEngine/WeMath').Vec3D;

var WeBuildingState =
{
   None :              0,
   Move :              1 << 0,
   Produce :           1 << 1,
   HelpProduce :       1 << 2,
   Build :             1 << 3,
   HelpBuild :         1 << 4,
   Create :            1 << 5,
   ServerRoundTrip :   1 << 6,

   Available :         1 << 7,
   Busy :              1 << 8,
   Ready :             1 << 9,
   Spoiled :           1 << 10,
   Constructing :      1 << 11,
   Collecting :        1 << 12,
   Shell :             1 << 13,

   Movable :           1 << 14,
   Decal :             1 << 15,
   Product :           1 << 16,
   JobProduct :        1 << 17,
   AutoProducing :     1 << 18,
   Player :            1 << 19,
   Ghost :             1 << 20
};


//////////////////////////////////////////////////////////////////////////////
// Class WeLot
// this is the base object in the game, everything should live about this
exports.WeLot = Core.MessageListener.subclass(
{
	classname: 'WeLot',
	
    initialize : function()
    {
        var repeat = 9;
        this.mNode = new GL2.Node();
        this.handled = false;
        //this.mMoveDelta=null;
        this.mObjectDeltaFromAnchor = null;

        this.mWidth = 512 * repeat;
        this.mHeight = 512 * repeat;
        this.mTouchPriority = 0.01;
		
		// Load the map tile. If we can, load compressed texture instead of png
		var self = this;
		
        var img = Content.getImagePath('map_tile.png');
        /*
		Storage.FileSystem.readFile(img+'.pvr', function(error) { 
			if (!error) 
			{
				self._loadMapTile( img+'.pvr', repeat);
			}
			else
			{
				Storage.FileSystem.readFile(img+'.atc', function(error) { 
					if (!error)
					{
						self._loadMapTile( img+'.atc', repeat);
					}
					else
					{
						self._loadMapTile( img+'.png', repeat);
					}
				});
			}
		});
		*/
		this._loadMapTile(img, repeat);
                
        // this.mIsUpdatable = true;
        //    this.mBlend = NgSprite2DBlendModes.None;
        //    this.mWrap = NgSprite2DWrapModes.WrapUV;
        // 
        this.mWeLotGrid = new WeLotGrid();
        
        // just the bounds of the lot
        var cAllScreenTarget = new GL2.TouchTarget();
        cAllScreenTarget.setAnchor([0,0]);
        cAllScreenTarget.setPosition(-this.mWidth*0.5, -this.mHeight*0.5);
        //this.mTargetNative.setSize([Core.Capabilities.getScreenWidth(), Core.Capabilities.getScreenHeight()]);
        cAllScreenTarget.setSize([this.mWidth, this.mHeight]);
        cAllScreenTarget.getTouchEmitter().addListener(this, this.onAllScreenTouch);
        cAllScreenTarget.setDepth(100);
        //this.mNode.addChild(cAllScreenTarget);
        
        GL2.Root.addChild(cAllScreenTarget);
        
        this.mAllScreenTarget=cAllScreenTarget;

        // bounds for whole screen to capture camera touches
        this.mTargetTouch = new GL2.TouchTarget();
        this.mTargetTouch.setAnchor([0,0]);
        this.mTargetTouch.setPosition(-this.mWidth*0.5, -this.mHeight*0.5);
        //this.mTargetTouch.setSize([Core.Capabilities.getScreenWidth(), Core.Capabilities.getScreenHeight()]);
        this.mTargetTouch.setSize([this.mWidth, this.mHeight]);
        this.mTargetTouch.getTouchEmitter().addListener(this, this.onTouch);
        this.mTargetTouch.setDepth(5);
        //WeRenderDevice.GetUiRoot().addChild(this.mTargetTouch);
        WeRenderDevice.GetGameRoot().addChild(this.mTargetTouch);
        
        // just the bounds of the lot
        this.mTargetNative = new GL2.TouchTarget();
        this.mTargetNative.setAnchor([0,0]);
        this.mTargetNative.setPosition(-this.mWidth*0.5, -this.mHeight*0.5);
        //this.mTargetNative.setSize([Core.Capabilities.getScreenWidth(), Core.Capabilities.getScreenHeight()]);
        this.mTargetNative.setSize([this.mWidth, this.mHeight]);
        this.mTargetNative.getTouchEmitter().addListener(this, this.onNativeTouch);
        this.mTargetNative.setDepth(0);
        this.mNode.addChild(this.mTargetNative);
               
        WeRenderDevice.GetGroundRoot().addChild( this.mNode );
        Core.UpdateEmitter.addListener(this, this.onUpdate);
        this.mTrackingId = NaN;
        
        this.touchedObject = null;
        //* FOR ORENTATION
        /**
         * $TODO this code is removed for MWC DEMO.  Put back after demo
         */
       
        //Device.OrientationEmitter.addListener(this, this.onOrentationChange);
        
    },
    
	// Load the map tile. If we can, load compressed texture instead of png
	_loadMapTile: function(tile, repeat)
	{	
        if (Exists(this.mAnimFrame))
    	{
    	    this.mAnimFrame.destroy();
    	    delete this.mAnimFrame;
    	    this.mAnimFrame=null;
    	}
		 
        this.mAnimFrame = new GL2.Animation();
        this.mAnimFrame.setFilteringEnabled(false);
        this.mAnimFrame.setWrapMode(GL2.Animation.WrapMode.WrapUV);
        this.mAnimFrame.pushFrame(new GL2.Animation.Frame(tile, 100,
                                    [this.mWidth, this.mHeight], [0,0], [ 0, 0, repeat, repeat ]));
        

        if(!Exists(this.mGroundSprite))
        {
        	this.mGroundSprite = new GL2.Sprite();
        	this.mGroundSprite.setDepth(0);
        	this.mNode.addChild(this.mGroundSprite);
        }
        this.mGroundSprite.setPosition(-this.mWidth*0.5,-this.mHeight*0.5);
        this.mGroundSprite.setAnimation(this.mAnimFrame, 0);
	},
    
    //////////////////////////////////////////////////////////////////////////////
    // Method:Shutdown 
    destroy : function()
    {
    	this.mNode.destroy();
    	this.mWeLotGrid.destroy();
    	
    	if (Exists(this.mAnimFrame))
    	{
    	    this.mAnimFrame.destroy();
    	    this.mAnimFrame = null;
    	}
    	
    	if(Exists(this.mGroundSprite))
        {
        	this.mGroundSprite.destroy();
        	this.mGroundSprite = null;
        }
        var device = WeRenderDevice.Instance(); 
        device.GetGroundRoot().removeChild( this );
        this.unregister();
    },

    LoadMapTile : function()
    {
		var self = this;
        var img = Content.getImagePath('map_tile.png');
        
        this._loadMapTile( img, 9);
        /*
        Storage.FileSystem.readFile(img+'.pvr', function(error) { 
			if (!error) 
			{
				self._loadMapTile( img+'.pvr', repeat);
			}
			else
			{
				Storage.FileSystem.readFile(img+'.atc', function(error) { 
					if (!error)
					{
						self._loadMapTile( img+'.atc', repeat);
					}
					else
					{
						self._loadMapTile( img+'.png', repeat);
					}
				});
			}
		});
		*/
    },
    
    //////////////////////////////////////////////////////////////////////////////
    // Method:Init 
    Init : function()
    {
        var multiplier = this.calculateLotMultiplier();
        this.CreateNewMap(multiplier);
        this.SetCameraForNewMapSize(multiplier);
        this.mIdleTime = Core.Time.getFrameTime();
		
	    	this.SwitchGroundType();
    },

    
        
	//////////////////////////////////////////////////////////////////////////////
    // Method:SwitchGroundType
    SwitchGroundType : function ()
    {
    	// Check if the kingdom is set
    	if (WeGameStateMgr.GetGameLotInfo().kingdom_type)
    	{
			// Set the ground texture from the current realm if defined in RuleGlobals.js
		
				
			/*
			switch(WeGameStateMgr.GetGameLotInfo().kingdom_type)
			{
				case "main":
					groundType = Realms.MainRealm.groundTexture;
					break;
				case "north":
					groundType = Realms.NorthRealm.groundTexture;
					break;
				case "south":
					groundType = Realms.SouthRealm.groundTexture;
					break;
				case "east":
					groundType = Realms.EastRealm.groundTexture;
					break;
				case "west":
					groundType = Realms.WestRealm.groundTexture;
					break;
				default:
					groundType = Realms.MainRealm.groundTexture;
					break;
			}*/

    		groundType = 'map_tile.png';
    			
			// check if groundType is set
			if (groundType)
			{	
				// Replace the old ground texture with the new one
				var repeat = 9;
				this.mWidth = 512 * repeat;
				this.mHeight = 512 * repeat;
				
				this._loadMapTile(Content.getImagePath(groundType), repeat);
			}
		}
    },
    ReInitForNewMapSize : function()
    {
        var multiplier = this.calculateLotMultiplier();
        this.SetMapForNewMapSize(multiplier);
        this.SetCameraForNewMapSize(multiplier);
    },
    
    SetCameraForNewMapSize: function(multiplier)
    {
	   gTunables.camera_zoom_min = gRawHeight / (multiplier * gStartingMapSize * cTileSizeHeight);
        if(Exists(gTunables.optimizations) && Exists(gTunables.optimizations.global_camera_zoom_min) &&
                (gTunables.camera_zoom_min <  gTunables.optimizations.global_camera_zoom_min))
        {
            gTunables.camera_zoom_min = gTunables.optimizations.global_camera_zoom_min;
        }
        WeCamera.Reset();

        //TODO wtf
        //gTunables.camera_zoom_min = gRawHeight / (multiplier * gStartingMapSize * cTileSizeHeight);
        //WeCamera.Reset();
    },
    
    SetMapForNewMapSize: function(multiplier)
    {
        var maxMultiplier = weProtoDb.getInstance().calculateMaxLotMultiplier();
        var mapSize = Math.floor(multiplier * gStartingMapSize * 0.5);
        this.mWeLotGrid.SetExtent(mapSize);
    },
    
    CreateNewMap: function(multiplier)
    {
        var maxMultiplier = weProtoDb.getInstance().calculateMaxLotMultiplier();
        var mapSize = Math.floor(multiplier * gStartingMapSize * 0.5);
        var maxMapSize = Math.floor(maxMultiplier * gStartingMapSize * 0.5);
        this.mWeLotGrid.Setup(mapSize, maxMapSize);
    },

    GetType : function(){ return "WeLot"; },

    mUpdateRealmCounter: 0,
    //////////////////////////////////////////////////////////////////////////////
    // Method: onUpdate
    onUpdate : function()
    {
        if (this.mIdleTime < Core.Time.getFrameTime() - gGameIdleHideUITime)
        {   // hide UI
            if (WeGameStateMgr.IsGameUIHidden() === false)
            {
                WeGameStateMgr.ShowGameUI(false);
            }
        }
        this.ApplyMove();
        /*
        this.mUpdateRealmCounter++;
        if(this.mUpdateRealmCounter==313)
        {
        	this.mUpdateRealmCounter=0;
        	
        	var nId=WeGameStateMgr.GetCurrentKingdomId();
        	
        	WeProtocol.getKingdom ( nId, function(request)
			{
        		 if(request && request.responseText!==null && request.responseText.length>0)
        		 {
        			 try
    			    {
    			       // var json = JSON.parse ( request.responseText );
    			       // objDump(json);
    			       // fullRecurseDump(json.kingdom, 10, 5);
    			        WeGameStateMgr.GetGameLotInfo().initWithJson( request.responseText);
    			    }
    			    catch(error)
    			    {
    			        NgLogD("****************** jason parse error");
    			    }
    			    
    			    WeGameStateMgr.CalculateNumBlockingJobs();
    		        WeGameStateMgr.GetGameLotInfo().UpdateJobBubbles();
        			 WeGameStateMgr.GetGameLotInfo().; 
        			 
        		 }
			});
        }
        */
        
    },

    //////////////////////////////////////////////////////////////////////////////
    // Method: FlushGhosting
    FlushGhosting : function()
    {
        var ghost = WeGameStateMgr.GetGhostObject();
        if(ghost)
        {
            var activeObj = WeGameStateMgr.GetActiveObject();
            if(!activeObj.IsStateSet(BuildingState.Shell))
            {
            	activeObj.SetColor(1, 1, 1, 1);
        	}
            activeObj.GhostRemoved();
            WeGameStateMgr.ShutdownGhostObject();
        }
        WeGameStateMgr.SetActiveObject(null);
        WeCamera.clearTouches();
        WeGameStateMgr.SetLastActiveObject(null);
    },

    Highlight : function(obj)
    {
		if(obj.mbTouched)
		{
        	var temp=111/255;
        	obj.SetColor(temp, temp, temp, 1);
		}
    },

    Unhighlight : function(obj)
    {
    	if(!obj.IsStateSet(BuildingState.Shell))
    	{
    		obj.SetColor(1, 1, 1, 1);
    	}
    },

    BuildGhost : function(obj, ghost, gameLoc)
    {
        //FIXME: need to build ghost :)
        //NgLogD("****************** will BuildGhost!");
        var header = null;
        var offset;
        var darkcolor = 111/255;
        if(obj.mProtoVisual)
        {
            header =  obj.mProtoVisual.header_tag;
            offset = new Vec3D( obj.mProtoVisualOffsetX,
                                obj.mProtoVisualOffsetY,
                                obj.mProtoVisualOffsetZ);
        }
        else
        {
            header = obj.mProtoVisualDecal.header_tag;
            offset = new Vec3D( obj.mProtoVisualDecalOffsetX,
                                obj.mProtoVisualDecalOffsetY,
                                obj.mProtoVisualDecalOffsetZ);
        }

        if(null === ghost)
        {
        	var self=this;
            ghost = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), header, 0, obj.IsFlipped(), 2);
            
            ghost.OnTouchUp= function(touch, deltaTime)
            {
               var ghost = WeGameStateMgr.GetGhostObject();
               if(ghost)
               {
                   WeGameStateMgr.ShutdownGhostObject();
                   var activeObj = WeGameStateMgr.GetActiveObject();
                   if (activeObj)
                   {
                	   if (!activeObj.IsStateSet(BuildingState.Shell))
                	   {
                    	   self.Unhighlight(activeObj);
                	   }
                       activeObj.OpenLotActionMenu();
                       WeGameStateMgr.SetActiveObject(null);
                   }
    
               }                
                return true;
            };
            
            ghost.Enable('Touch');
            WeGameStateMgr.SetGhostObject(ghost);
        }
        if(null != ghost)
       { 
       		var activeObj = WeGameStateMgr.GetActiveObject();
       		if (!activeObj.IsStateSet(BuildingState.Shell))
				this.Unhighlight(activeObj);
       	       
            var x = (gameLoc.x - obj.mAnchor.x);
            var y = (gameLoc.y - obj.mAnchor.y);
            distSqr = x*x + y*y;
            
            if(distSqr > 30.0)
            {
                ghost.SetColor(1, darkcolor, darkcolor, 0.8); 
            }
            else
            {
                ghost.SetColor(1, 1, 1, 0.8);
            }
                
            if (obj.IsStateSet(BuildingState.Shell))
            {
                obj.SetColor(darkcolor, darkcolor, darkcolor, 1);  
            }  
            
            if(obj.IsFlipped)
            {
                ghost.PushGamePosition([gameLoc.x, gameLoc.y, 10], [ -offset.x , offset.y , offset.z] ); 
            }
            else
            {
                ghost.PushGamePosition([gameLoc.x, gameLoc.y, 10], [ offset.x , offset.y , offset.z] ); 
            }
            ghost.SetPosition(ghost.GetX(), ghost.GetY(), 100);
       }
    },
    //* FOR ORIENTATION    
    onOrentationChange: function( touch )
    {
        if(touch==Device.OrientationEmitter.Orientation.LandscapeLeft)
        {
            WeRenderDevice.GetUiRoot().setRotation(0);
            WeRenderDevice.GetUiRoot().setPosition(0,0);
            WeRenderDevice.GetScaleRoot().mNode.setRotation(0);
            WeRenderDevice.GetScaleRoot().mNode.setPosition(0,0);
        }
        /*
        else if(touch==Device.OrientationEmitter.Orientation.LandscapeRight)
        {
            WeRenderDevice.GetUiRoot().setRotation(180);
            WeRenderDevice.GetUiRoot().setPosition(gRawWidth,gRawHeight);
            WeRenderDevice.GetScaleRoot().mNode.setRotation(180);
            WeRenderDevice.GetScaleRoot().mNode.setPosition(gRawWidth,gRawHeight);          
        }     
        */  
    },
   // */
    onAllScreenTouch: function( touch )
    {
        this.mIdleTime = Core.Time.getFrameTime();

        if (WeGameStateMgr.IsGameUIHidden())
        {
            WeGameStateMgr.ShowGameUI(true);
        }
        //Mega HACK for object focus lost
        var touchAction = touch.getAction();
        if(touchAction == touch.Action.End)
        {
        	this.TestIsFocusOfGhostObjectLost();
        	if(WeGameStateMgr.GetActiveObject())
        	{
                //WeGameStateMgr.GetActiveObject().LostFocus();
        	}
        }
        return false;
    },

    //////////////////////////////////////////////////////////////////////////////
    // Method: onNativeTouch
    // Handles moving building in redesign mode.
    // Note: SOME additional logic is handle in the touch for WeBuilding
    onNativeTouch : function( touch )
    {
		DebugTouch(touch, "WeLot onNativeTouch()");
			
    	if( touch.getAction() == touch.Action.Start )
    	{
    		if(WeGameStateMgr.GetGlobalGameWidget()!=null)
    		{
    			if (WeGameStateMgr.GetActiveObject() != null && !WeGameStateMgr.GetActiveObject().IsStateSet(BuildingState.Shell) )
    			{
    				WeGameStateMgr.SetActiveObject(null);
    			}
    		}
    		WeGameStateMgr.SetGlobalGameWidget(null);
    	}
    	
        var activeObj = WeGameStateMgr.GetActiveObject();
        if(null !== activeObj && !(activeObj.IsStateSet(WeBuildingState.Collecting)))
        {       	
        	//Super Hack for camera 2 point touch
        	if( Core.Capabilities.getPlatformOS() === "Android")
			{
        	    if(touch.getId()!=1 || WeCamera.getTouchCount()===2)
            	{
    				activeObj.LostFocus();
    				WeGameStateMgr.SetGlobalGameWidget(null);
    				WeGameStateMgr.SetActiveObject(null);
            		return false;
            	}
        	}
        	
        	if (activeObj.IsTouched() && this.touchedObject !== activeObj)
        	{
        		this.touchedObject = activeObj;
                WeEffectsMgr.PlaySoundEffect("buttonpress_4.mp3");        		
        	}         	
            // var touchPosition = touch.getPosition();
         //*    FOR ORIENTATION
            var touchPosition = FixTouchPositionForOrientation( touch.getPosition() );

        //*/
            var screenLoc = new Vec2D(touchPosition.getX(), touchPosition.getY());
            var gridLoc = ScreenToWorldPos([touchPosition.getX(), touchPosition.getY()]);
            var touchAction = touch.getAction();
		
            if (touchAction == touch.Action.Start)
            {
                // attach a timer value to this active object
            	activeObj.xTime = Core.Time.getFrameTime();
            }
         
            var touchTime = Core.Time.getFrameTime();
            var deltaTime = touchTime - (activeObj.xTime ? activeObj.xTime : 0);
            
            var objTouchLoc = new Vec2D(activeObj.mAnchor.x + Math.floor(activeObj.GetSizeX() * 0.5),
                    activeObj.mAnchor.y + Math.floor(activeObj.GetSizeY() * 0.5));  

			if (touchAction == touch.Action.Start || this.mObjectDeltaFromAnchor === null)
			{
				this.mTouchGridLocation = null;

				// create an offset from the touch point to the root of the object, 
				// so that the part of the object that you touch stays under your finger
				this.mObjectDeltaFromAnchor = new Vec2D(activeObj.mAnchor.x - gridLoc.x, activeObj.mAnchor.y - gridLoc.y);
			}
			else if (touchAction == touch.Action.Move && deltaTime > 200)
			{
				if(!activeObj.IsTouched())
				{
					if (!activeObj.IsStateSet(BuildingState.Shell))
					{
						this.Unhighlight(activeObj);
						
						WeGameStateMgr.SetActiveObject(null);
						WeCamera.clearTouches();
						WeGameStateMgr.ShutdownGhostObject();
						
					}
					return true;
				}
				this.mTouchGridLocation = gridLoc;
			}
			else if (touchAction == touch.Action.End)
			{   // touch up on the ground.  If there's an activeobj, clear it
				//Old
				//this.mMoveDelta = null;
				if(activeObj && !activeObj.IsStateSet(BuildingState.Shell))
				{
					this.Unhighlight(activeObj);  
				}
				this.touchedObject = null;   
				this.mObjectDeltaFromAnchor = null;
		
				//if(activeObj && !activeObj.IsStateSet(BuildingState.Shell))
				// TODO: more logical solution for lotActionMenu showing/ hiding
				WeGameStateMgr.SetActiveObject(null);
				WeCamera.clearTouches();
				WeGameStateMgr.ShutdownGhostObject();
			}
            return true;
        }
        
        return false; 
    },
    
    ApplyMove : function()
    {
    	 var activeObj = WeGameStateMgr.GetActiveObject();
    	 if (activeObj && this.mObjectDeltaFromAnchor && this.mTouchGridLocation)
    	 {
			var ghost = WeGameStateMgr.GetGhostObject();
    		var gridLoc = this.mTouchGridLocation;
	    	activeObj.CloseLotActionMenu();
	    	
	    	var newGridLocation = new Vec2D(gridLoc.x + this.mObjectDeltaFromAnchor.x, gridLoc.y + this.mObjectDeltaFromAnchor.y);
	    	
	    	if (activeObj.MoveToPositionOnGrid(this.mWeLotGrid, newGridLocation))
			{   // location is ok, so remove ghost. 
				WeGameStateMgr.ShutdownGhostObject();
	            this.Highlight(activeObj);
			}
			else
			{   // bad location, create ghost
				this.BuildGhost(activeObj, ghost, gridLoc);
			}
	    	this.mTouchGridLocation = null;
    	 }
    },
    
    TestIsFocusOfGhostObjectLost: function()
    {
    	if(WeGameStateMgr.GetGhostObject())
    	{
    		this.mObjectDeltaFromAnchor = null;
			WeGameStateMgr.SetActiveObject(null);
			WeGameStateMgr.SetGlobalGameWidget(null);
			WeCamera.clearTouches();
			WeGameStateMgr.ShutdownGhostObject();
    	}
    },

    // For moving camera and scaling
    onTouch : function( touch )
    {
		DebugTouch(touch, "WeLot onTouch()");
        
        if ( WeUiMgr.GetActiveScreen() === "SocialMapScreen")
		{
            return false;
        }
 
        var targets = SortTouchTargetsGround(touch);

        var hadled=false;
        for(var t in targets)
        {   // let other touch targets handle first.
            var item = targets[t];
            if (item != this.mTargetTouch)
            {
            	var cTE=item.getTouchEmitter();
            	if(cTE != undefined && cTE!=null)
            	{
            		if( cTE.chain(touch) )
		            {
            			hadled=true;
		                break;
		            }
            	}
            }
        }
        if(!hadled)
        {
        	if( touch.getAction() == touch.Action.Start )
        	{
        		WeGameStateMgr.SetGlobalGameWidget(null);
        	}
        }
        if(WeGameStateMgr.IsCameraMovable())
        {
            return WeCamera.onTouch( touch );
        }
        return true;
    },

    onGetName : function(  )
    {
        return "WeLot";
    },

    //-------------------------------------------
    // Loop through the kingdom upgrades and apply
    // any size upgrades to the main lot
    calculateLotMultiplier : function()
    {
        var info = WeGameStateMgr.GetGameLotInfo();
        var db = weProtoDb.getInstance();
        if ( info === null || db === null )
        {
            return 1;
        }
        
        var kingdom_type = info.kingdom_type;
        var length = 0; 
        if (Exists(info.upgrades))
        {
        	length = info.upgrades.length;
        }
        var multiplier = 1.0;
        for ( var i = 0; i < length; i++ )
        {
            var upgrade = db.getUpgrade(info.upgrades[i].proto_upgrade_id);
                     
            //HACK removing dublicated updetes 
            var bIsValid=true;
            
            for(var j=0; j < i; j++)
            {
                var upgrade2 = db.getUpgrade(info.upgrades[j].proto_upgrade_id);
                if(upgrade !== null && upgrade2 !== null && upgrade.id==upgrade2.id)
                {
                    bIsValid=false;
                    break;
                }
            }            
             
            if ( upgrade !== null && upgrade.kingdom_type == kingdom_type && bIsValid)
            {
            	//NgLogD("######## Lot upgrades: ");
            	//objDump(upgrade);
                multiplier += upgrade.map_expand_reward;
            }
        }
        return multiplier;
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeTime'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeTime'] || {}; $MODULE_REGISTRY['weEngine/WeTime'] = exports; var Core       = require('NGCore/Client/Core').Core;

exports.WeTime = Core.Class.singleton(
{
	classname: "WeTime",

	mLastTime : 0,
	mServerTimeOffset : 0,
	mWaitingResponse : false,

	initialize: function()
	{
		this.mServerTime = 0;
		this.mServerTimeSetAt = 0;
		
	},
		
	
	SetServerTime : function(time)
	{
		this.mServerTime = time;
		this.mServerTimeSetAt = new Date().getTime();
	},
	
	    
    GetGameTime : function()
    {
		//
		//	we always use server time as game time. 
		//
		return this.mServerTime + (Date.now() - this.mServerTimeSetAt);;  
    },

    GetGameDate : function()
    {
        return new Date(this.GetGameTime());
    },

        
	ConvertToNiceTime : function(delta)
	{
		var time = "";
		var days = Math.floor(delta / (3600000 * 24));
		delta -= days * (3600000 * 24);
		var hours = Math.floor(delta / 3600000);
		delta -= hours * 3600000;
		var minutes = Math.floor(delta / 60000);
		delta -= minutes * 60000;
		var seconds = Math.floor(delta / 1000);
		if (hours === 24)
		{
			days = 1;
			hours = 0;
		}
		if (days !== 0)
		{
			time += days + "d";
		}
		if (hours !== 0)
		{
			time += (days !== 0) ? ', ' : ' ';
			time += hours + "h";
		}
		if (minutes !== 0 && days === 0)
		{

			time += (hours !== 0) ? ', ' : ' ';
			time += minutes + "m";
		}
		if (seconds !== 0 && hours === 0 && days === 0)
		{
			time += (minutes !== 0) ? ', ' : ' ';
			time += seconds + "s";
		}
		time += " ";

		return time;
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeLotGrid'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeLotGrid'] || {}; $MODULE_REGISTRY['weEngine/WeLotGrid'] = exports; //////////////////////////////////////////////////////////////////////////////
/**
 * @file:      WeLotGrid.js
 * @author:    cjimison@gmail.com
 * @copyright: 2010 NGMOCO:) All rights reserved
 * 
 * @brief:     This is the basic lot logic
 */
//////////////////////////////////////////////////////////////////////////////

var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;


//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;

/**
 * Obstruction types
 * None  = 0
 * Full  = 1 
 * Decal = 2
 */

/**
 * Binary value layout
 *
 * 32 bits
 * 0000 0000 0000 0000 0000 0000 0000 0000 
 * IIII IIII IIII IIII cccc cccc oooo Aatt

 * t = obstruction type for cell -> should be cast to uint
 * a = agent has a lock on cell but it will use it soon (a frame or two)
 * A = agent has a lock on cell and is using it
 * o = overlap decal count -> Should cast to a uint
 * c = cost to path over spot -> 0 - 255
 * I = Tag info open for users to set
 */

var gType = 0x00000007;
var gTypeOffset = 0;

var gAgentLock = 0x0000000C;
var gAgentLockOffset = 2;

var gOverlap = 0x000000F0;
var gOverlapOffset = 4;
var gOverlapMax = 14;

var gCost = 0x0000FF00;
var gCostOffset = 8;
var gCostMax = 255;

var gTag = 0x7FFF0000;
var gTagOffset = 16;
var gTagMax = 32767;

var ObstructionType =
{
    None  : 0,
    Full  : 1 , 
    Decal : 1 << 1,
    Agent : 1 << 2
};

var Anchor = 
{
    LR    : 0,  // The lower right anchor
    UL    : 1  // The upper left anchor
};

exports.WeLotGrid = Core.MessageListener.subclass(
{
    initialize : function()
    {
        this.mMap = [];
        this.mCount = 0;

        this.mTileIndexExtent = 0;
        this.mMaxTileIndexExtent = 0;
        this.mArrayDimensionSize = 0;
        this.mNumElementsInternalArray = 0;
        this.mTotalNumElements = 0;
        this.mDirtyList = [];

        this.mTagList = [];
    },
    
    classname: "WeLotGrid",

    Flush : function()
    {
        this.mMap = [];   
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * function Initalize
     * The lot grid is a container for all the entity objects within the game
     * Buildings, people, etc, etc
     */
    Setup : function(extent, maxExtent)
    {
        if(this.mMap)
        {
            delete this.mMap;
        }
        this.mMap = [];   
        this.mTileIndexExtent = extent;// + 1;
        this.mMaxTileIndexExtent = maxExtent;
        this.mArrayDimensionSize = this.mMaxTileIndexExtent * 2;
        this.mNumElementsInternalArray = this.mMaxTileIndexExtent * 2 * this.mMaxTileIndexExtent * 2;
    },

    GetPositionIdx : function(position)
    {
        var index = ((position.x + this.mMaxTileIndexExtent) * this.mArrayDimensionSize) + position.y + this.mMaxTileIndexExtent;
        return index;
    },

    GetPosIdx : function(x, y)
    {
        var index = ((x + this.mMaxTileIndexExtent) * this.mArrayDimensionSize) + y + this.mMaxTileIndexExtent;
        return index;
    },

    SetExtent : function(extent)
    {
        if(extent <= this.mMaxTileIndexExtent)
        {
            this.mTileIndexExtent = extent;
        }
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: GetTypeAtIndex
     * @param {integer} index into the map
     * @return {integer} type set for this element
     */
    GetTypeAtIndex : function(index)
    {
        var type = 0;
        var data = this.mMap[index];
        if(undefined !== data)
        {
            type = (data & gType) >>> gTypeOffset;
        }
        return type;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: SetTypeAtIndex
     * @param {integer} index into the map
     * @param {integer} type to set
     */
    SetTypeAtIndex : function(index, type)
    {
        var data = this.mMap[index];
        if(undefined === data)
        {
            data = 0;
        }

        // 1) scrub any existing bits and set the new value
        this.mMap[index] = (data & ~gType) | (type << gTypeOffset);
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: IsCellLocked
     * @param {integer} index into the map
     * @return{boolean} is the cell locked
     */
    IsCellLocked : function(index)
    {
        var data = this.mMap[index];
        if(undefined === data)
        {
            return false;
        }
        
        return (data & ~(gAgentLock >>> gAgentLockOffset)) > 0;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: SetLockCell 
     * @param {integer} index into the map
     * @param {boolean} lock because someone is standing there: 1 will lock it, 0 will unlock it
     * @param {boolean} lock because someone is going there: 1 will lock it, 0 will unlock it
     */
    SetLockCell : function(index, current, next)
    {
        var data = this.mMap[index];
        if(undefined === data)
        {
            data = 0;
        }
        
        // 1) scrub any existing bits and set the new value
        this.mMap[index] = (data & ~gAgentLock) | ((current << 1 | next) << gAgentLockOffset);
    },
  
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: GetOverlapCount
     * @param {integer} index into the map
     * @param {integer} number of overlaps this cell has
     */
    GetOverlapCount : function(index)
    {
        var count = 0;
        var data = this.mMap[index];
        if(undefined !== data)
        {
            count = (data & gOverlap) >>> gOverlapOffset;
        }
        return count;
    },

    FindValidLocation : function()
    {
        var locFound = false;
        var maxAttempts = 20;
        
        var cResult= new Vec2D(0, 0);
        // NOTE .. this is bad code.  It can lock you into an inf. loop.  Fix it before you check in
        do
        {
        	cResult.x = Math.floor( Math.random()* ((this.mTileIndexExtent + 1)-(-this.mTileIndexExtent)) ) + (-this.mTileIndexExtent);
        	cResult.y = Math.floor( Math.random()* ((this.mTileIndexExtent + 1)-(-this.mTileIndexExtent)) ) + (-this.mTileIndexExtent);
            var index = this.GetPositionIdx(cResult);
            var curValue = this.GetTypeAtIndex(index);
            locFound = (ObstructionType.Full & curValue) ==0 ;
            --maxAttempts;
        }while(!locFound && maxAttempts);

        return cResult;
    },

	RandomLocation : function()
	{
		var cResult = new Vec2D(0, 0);
	 	cResult.x = Math.floor( Math.random()* ((this.mTileIndexExtent + 1)-(-this.mTileIndexExtent)) ) + (-this.mTileIndexExtent);
       	cResult.y = Math.floor( Math.random()* ((this.mTileIndexExtent + 1)-(-this.mTileIndexExtent)) ) + (-this.mTileIndexExtent);
   		return cResult;   
	},

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: SetOverlapCount
     * @param {integer} index into the map
     * @param {integer} value for the overlap
     * @param {boolean} did the set take
     */
    SetOverlapCount : function(index, val)
    {
        if(val > gOverlapMax || val < 0)
        {
            return false;
        }

        var data = this.mMap[index];
        if(undefined === data)
        {
            data = 0;
        }
        
        // 1) scrub any existing bits and set the new value
        this.mMap[index] = (data & ~gOverlap) | ((val) << gOverlapOffset);
        return true;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: AddOverlap
     * @param {integer} index into the map
     * @param {boolean} did the set take
     */
    AddOverlap : function(index)
    {
        return this.SetOverlapCount(index, this.GetOverlapCount(index) + 1);
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: RemoveOverlap
     * @param {integer} index into the map
     * @param {boolean} did the set take
     */
    RemoveOverlap : function(index)
    {
        return this.SetOverlapCount(index, this.GetOverlapCount(index) - 1);
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: GetCost
     * @param {integer} index into the map
     * @param {integer} the cost to trave
     */
    GetCost : function(index)
    {
        var data = this.mMap[index];
        var cost = this.mDefaultCost;
        if(undefined !== data)
        {
            cost = (data & gCost) >>> gCostOffset;
        }
        return cost;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: SetOverlapCount
     * @param {integer} index into the map
     * @param {integer} value for the overlap
     * @param {boolean} did the set take
     */
    SetCost : function(index, val)
    {
        if(val > gCostMax || val < 0)
        {
            return false;
        }

        var data = this.mMap[index];
        if(undefined === data)
        {
            data = 0;
        }
        
        // 1) scrub any existing bits and set the new value
        this.mMap[index] = (data & ~gCost) | ((val) << gCostOffset);
        return true;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: GetCost
     * @param {integer} index into the map
     * @param {integer} the cost to trave
     */
    GetTag : function(index)
    {
        var tag = 0; 
        if(undefined !== this.mTagList[index])
        {
            tag = this.mTagList[index];
        }
        //var data = this.mMap[index];
        //var tag = 0;
        //if(undefined !== data)
        //{
        //    tag = (data & gTag) >>> gTagOffset;
        //}
        return tag;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: SetOverlapCount
     * @param {integer} index into the map
     * @param {integer} value for the overlap
     * @param {boolean} did the set take
     */
    SetTag : function(index, val)
    {

        this.mTagList[index] = val;
    /*
        if(val > gTagMax || val < 0)
        {
            return false;
        }

        var data = this.mMap[index];
        if(undefined === data)
        {
            data = 0;
        }
        
        // 1) scrub any existing bits and set the new value
        this.mMap[index] = (data & ~gTag) | ((val) << gTagOffset);
        */
        return true;
    },
    
    DebugDumpMapInfo : function()
    {
    	var indexes = "";
        for ( var y = this.mTileIndexExtent; y >= -this.mTileIndexExtent; --y)
        {
            var vTemp = "";
            for ( var x = -this.mTileIndexExtent; x <= this.mTileIndexExtent; ++x)
            {
                var index = this.GetPosIdx(x, y);
                if (this.mMap[index] == undefined)
                {
                    vTemp = vTemp + "0";
                } else
                {
                    vTemp = vTemp + this.mMap[index];
                    indexes += index + ',';
                }

            }
            NgLogD("> " + vTemp);
        }
        NgLogD(indexes);
    },

    // ////////////////////////////////////////////////////////////////////////////
    /**
     * Method: DebugDumpMap
     * 
     * @param {string}
     *            name of the data to access this.DebugDumpMap("Tag")
     */
    DebugDumpMap : function(name)
    {
        var accessor = 'Get' + name;
        if(this[accessor])
        {
            var row = 0; 
            var count = 0; 
            var data = "Row = ";
            NgLogD("******* GRID DUMP *********\nArray DimensionSize = " + this.mArrayDimensionSize);
            for(var idx = 0; idx < this.mNumElementsInternalArray; idx++)
            {
                data += this[accessor](idx);
                if(row == (this.mArrayDimensionSize -1))
                {
                    NgLogD(data);
                    data = "Row = ";
                    row = 0;
                }
                else
                {
                    row++;
                }
                
                if(this.mMap[idx] > 0)
                {
                    count++;
                }
            }
        }
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: RemoveObstruction
     * @param {WeEntity} removes the entity from the grid
     */
    RemoveObstructionOld : function(entity)
    {
        // Every entity should have 2 achor points.  A lower right anchor and an
        // upper right anchor.
        var lowerBounds = entity.mAnchor;
        var upperBounds = new Vec2D(lowerBounds.x + entity.mSize.x, lowerBounds.y + entity.mSize.y);

        if( lowerBounds.x < -this.mTileIndexExtent ||
            lowerBounds.y < -this.mTileIndexExtent ||
            upperBounds.x > this.mTileIndexExtent ||
            upperBounds.y > this.mTileIndexExtent )
        {
            return false;
        }
        // Every entity should have 2 achor points.  A lower right anchor and an
        // upper right anchor.
        //var xMin = lowerBounds.x - (-this.mMaxTileIndexExtent);
        //var yMin = lowerBounds.y - (-this.mMaxTileIndexExtent);
        //var xMax = upperBounds.x - (-this.mMaxTileIndexExtent);
        //var yMax = upperBounds.y - (-this.mMaxTileIndexExtent);
        
        var dCount = 0;
        var value = entity.IsDecal() ? ObstructionType.Decal : ObstructionType.Full;
         
        for(var x = upperBounds.x; x < lowerBounds.x; ++x)
        {
            for(var y = lowerBounds.x; y < upperBounds.y; ++y)
            {
                var index = this.GetPosIdx(x, y);
                var curValue = this.GetTypeAtIndex(index);
                
                switch(curValue)
                {
                    case ObstructionType.Decal:
                        // Decals are a special case.  Decals can
                        // overlap but not full obstructions
                        if(value == ObstructionType.Decal)
                        {
                            dCount = this.GetOverlapCount(index);
                            --dCount;
                            this.SetOverlapCount(index, dCount);
                            if(0 === dCount)
                            {
                                this.SetTypeAtIndex(index, ObstructionType.None);
                            }
                        }
                        break;

                    case ObstructionType.None:
                        break;
                    case ObstructionType.Agent:
                        break;
                    case ObstructionType.Full:
                        dCount = this.GetOverlapCount(index);
                        if(value == ObstructionType.Decal)
                        {
                            --dCount;
                            this.SetOverlapCount(index, dCount);
                            if(0 === dCount)
                            {
                                this.SetTypeAtIndex(index, ObstructionType.None);
                            }
                        }
                        else if(dCount > 0)
                        {
                            this.SetTypeAtIndex(index, ObstructionType.Decal);
                        }
                        else
                        {
                            this.SetTypeAtIndex(index, ObstructionType.None);
                        }
                        break;
                    default:
                        return false;
                }
            } 
        }
        return true;
    },

    TouchOnObstruction : function(entity, touch)
    {
        var gameLoc = ScreenToWorldPos([touch.getPosition().getX(), touch.getPosition().getY()]);
        gameLoc.floor();
        
		NgLogD("TouchOnObstruction: is (" + gameLoc.x + ", " + gameLoc.y + ") in (" + entity.GetStartX() + ", " + entity.GetStartY() + ") -> (" + entity.GetEndX() + ", " + entity.GetEndY() + ")");

		return (entity.GetStartX() <= gameLoc.x && gameLoc.x < entity.GetEndX() && entity.GetStartY() <= gameLoc.y && gameLoc.y < entity.GetEndY());
    },
    
    AddObstructionIgnoreOnlyBounds : function(entity)
    {
        var startX = entity.GetStartX();
        var startY = entity.GetStartY();
        var endX= entity.GetEndX();
        var endY= entity.GetEndY();
        
        var isDecal = entity.IsDecal(); 
        var value =  isDecal ? ObstructionType.Decal : ObstructionType.Full;

        var idxArray = [];
        for (var x = startX; x < endX; ++x)
        {
            for(var y = startY; y < endY; ++y)
            {
                var index = this.GetPosIdx(x, y);
                var posVal = this.mMap[index] || ObstructionType.None;
                if( (posVal & ObstructionType.Full)!=0 && !isDecal)
                {
                    return false;
                }
                else 
                {
                    idxArray.push(index);
                }
            }
        }
        
        var len = idxArray.length;
        for(var idx = 0; idx < len; ++idx)
        {
        	var nValue = this.mMap[idxArray[idx]];
        	if(undefined === nValue)
        	{
        		nValue=0;
        	}
        	nValue = nValue | value;
        	this.mMap[idxArray[idx]] = nValue;
        }
        //this.DebugDumpMapInfo();
        return true;
    },
    
    AddObstructionIgnoreBounds : function(entity)
    {
        var startX = entity.GetStartX();
        var startY = entity.GetStartY();
        var endX= entity.GetEndX();
        var endY= entity.GetEndY();
        
        var isDecal = entity.IsDecal(); 
        var value =  isDecal ? ObstructionType.Decal : ObstructionType.Full;

        var idxArray = [];
        for (var x = startX; x < endX; ++x)
        {
            for(var y = startY; y < endY; ++y)
            {
            	if(this.IsPointInGrid(x, y))
            	{
            		var index = this.GetPosIdx(x, y);
            		var nValue = this.mMap[index] || ObstructionType.None;
            		if(undefined === nValue)
                	{
                		nValue=0;
                	}
                	nValue = nValue | value;
                	this.mMap[index] = nValue;
            		
            	}  
            }
        }
        //this.DebugDumpMapInfo();
        return true;   
    },
    
    AddObstructionDecalAsObstruction : function(entity, ignoreBounds)
    {
        var startX = entity.GetStartX();
        var startY = entity.GetStartY();
        var endX= entity.GetEndX();
        var endY= entity.GetEndY();
        
        if(!ignoreBounds)
        {
            if( startX < -this.mTileIndexExtent ||
                startY < -this.mTileIndexExtent ||
                endX > this.mTileIndexExtent ||
                endY > this.mTileIndexExtent )
            {
                return false;
            }
        }               

        var idxArray = [];
        for (var x = startX; x < endX; ++x)
        {
            for(var y = startY; y < endY; ++y)
            {
                var index = this.GetPosIdx(x, y);
                var posVal = this.mMap[index] || ObstructionType.None;
                if( posVal === ObstructionType.None )
                {
                	idxArray.push(index);
                }
                else 
                {
                	return false;
                }
            }
        }
        
        var isDecal = entity.IsDecal(); 
        var value =  isDecal ? ObstructionType.Decal : ObstructionType.Full;
        var len = idxArray.length;
        for(var idx = 0; idx < len; ++idx)
        {
        	var nValue = this.mMap[idxArray[idx]] || ObstructionType.None;
        	nValue = nValue | value;
        	this.mMap[idxArray[idx]] = nValue;
        }
        return true;
    },

    AddObstruction : function(entity, ignoreBounds)
    {
        if(ignoreBounds)
        {
        	return this.AddObstructionIgnoreBounds(entity);
        }  
    	
        var startX = entity.GetStartX();
        var startY = entity.GetStartY();
        var endX= entity.GetEndX();
        var endY= entity.GetEndY();

        if( startX < -this.mTileIndexExtent ||
                startY < -this.mTileIndexExtent ||
                endX > this.mTileIndexExtent ||
                endY > this.mTileIndexExtent )
        {
            return false;
        }        
        
        var isDecal = entity.IsDecal(); 
        var value =  isDecal ? ObstructionType.Decal : ObstructionType.Full;

        var idxArray = [];
        for (var x = startX; x < endX; ++x)
        {
            for(var y = startY; y < endY; ++y)
            {
                var index = this.GetPosIdx(x, y);
                var posVal = this.mMap[index] || ObstructionType.None;
                if( (posVal & ObstructionType.Full)!=0 && !isDecal)
                {
                    return false;
                }
                else 
                {
                    idxArray.push(index);
                }
            }
        }
        
        var len = idxArray.length;
        for(var idx = 0; idx < len; ++idx)
        {
        	var nValue = this.mMap[idxArray[idx]];
        	if(undefined === nValue)
        	{
        		nValue=0;
        	}
        	nValue = nValue | value;
        	this.mMap[idxArray[idx]] = nValue;
        }
        //this.DebugDumpMapInfo();
        return true;
    },
    //TODO remove code dulication
    RemoveObstruction : function(entity)
    {
        var startX = entity.GetStartX();
        var startY = entity.GetStartY();
        var endX= entity.GetEndX();
        var endY= entity.GetEndY();

        var isDecal = entity.IsDecal(); 
        var value =  isDecal ? ObstructionType.Decal : ObstructionType.Full;

        for (var x = startX; x < endX; ++x)
        {
            for(var y = startY; y < endY; ++y)
            {
            	if(this.IsPointInGrid(x, y))
            	{
            		var index = this.GetPosIdx(x, y);
            		 var posVal = this.mMap[index] || ObstructionType.None;
     				this.mMap[index] = posVal & ~value;
            	}
            }
        }
        return true;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: AddObstruction
     * @param {WeEntity} entity that will be added as an obstruction
     */
    AddObstructionOld : function(entity, ignoreBounds)
    {
        var lowerBounds = entity.mAnchor;
        var upperBounds = new Vec2D(lowerBounds.x + entity.mSize.x, lowerBounds.y + entity.mSize.y);
        ignoreBounds = ignoreBounds || false;

        if(!ignoreBounds)
        {
            if( lowerBounds.x < -this.mTileIndexExtent ||
                lowerBounds.y < -this.mTileIndexExtent ||
                upperBounds.x > this.mTileIndexExtent ||
                upperBounds.y > this.mTileIndexExtent )
            {
                return false;
            }
        } 

        var indexArray = [];
        var indexArrayLen = 0;

        var decalIndexArray = [];
        var decalIndexArrayLen = 0;

        var value = entity.IsDecal() ? ObstructionType.Decal : ObstructionType.Full;
         
        for(var x = upperBounds.x; x < lowerBounds.x; ++x)
        {
            for(var y = lowerBounds.x; y < upperBounds.y; ++y)
            {
                var index = this.GetPosIdx(x, y);
                var curValue = this.GetTypeAtIndex(index);
                
                switch(curValue)
                {
                    case ObstructionType.Decal:
                        // Decals are a special case.  Decals can
                        // overlap but not full obstructions
                        if(value == ObstructionType.Decal)
                        {
                            if(this.GetOverlapCount(index) < (gOverlapMax-1))
                            {
                                decalIndexArray[decalIndexArrayLen] = index;
                                ++decalIndexArrayLen;
                            }
                        }
                        else
                        {
                            indexArray[indexArrayLen] = index;
                            ++indexArrayLen;
                        }
                        break;

                    case ObstructionType.None:
                    case ObstructionType.Agent:
                        indexArray[indexArrayLen] = index;
                        ++indexArrayLen;
                        if(value == ObstructionType.Decal)
                        {
                            decalIndexArray[decalIndexArrayLen] = index;
                            ++decalIndexArrayLen;
                        }
                        break;
                    case ObstructionType.Full:
                        if(value == ObstructionType.Decal)
                        {
                            if(this.GetOverlapCount(index) < (gOverlapMax-1))
                            {
                                decalIndexArray[decalIndexArrayLen] = index;
                                ++decalIndexArrayLen;
                            }
                            else
                            {
                                return false;
                            }
                        }
                        else
                        {
                            return false;
                        }
                        break;
                    default:
                        return false;
                }
            } 
        }
        var idx = 0;
        for(idx = 0; idx < indexArrayLen; ++idx)
        {
            this.SetTypeAtIndex(indexArray[idx], value);
        }
        
        // For decals we have to do a second pass to increase the count
        for(idx = 0; idx < decalIndexArrayLen; ++idx)
        {
            var dCount = this.GetOverlapCount(decalIndexArray[idx]);
            ++dCount;
            this.SetOverlapCount(decalIndexArray[idx], dCount);
        }
       
        var results = indexArrayLen > 0 || decalIndexArrayLen > 0; 
        return results;
    },

    CanFit : function (loc, size)
    {
        // Assuming the 
        for(var x = loc.x; x < loc.x + size.x; ++x)
        {
            for(var y = loc.y; y < loc.y + size.y; ++y)
            {
                var index = this.GetPosIdx(x, y);
                var curValue = this.GetTypeAtIndex(index);
                if( (curValue & ObstructionType.Full) !=0 )
                {
                    return false;
                }
            }
        }
        return true;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * entity position is set to new found position 
     */
    AddObstructionClosest : function(entity, requestedPosition, bDecalAsObstruction)
    {   
        var originalX = entity.mAnchor.x;
        var originalY = entity.mAnchor.y;
        entity.mAnchor.x = requestedPosition.x; 
        entity.mAnchor.y = requestedPosition.y; 
        
        var found=false;
        if(bDecalAsObstruction)
        {
        	found = this.AddObstructionDecalAsObstruction(entity);
        }
        else
        {
        	found = this.AddObstruction(entity);
        }
        if(found)
        {
            entity.PositionUpdated();
            return true;
        }
        else
        {   
            var nMaxX=this.mTileIndexExtent - entity.GetSizeX();
            var nMaxY=this.mTileIndexExtent - entity.GetSizeY();
            var sortFunc = function(a, b){ return a.xDist - b.xDist;};
            var range = 1;
            var maxRange = this.mTileIndexExtent*2;
            while(!found && (range <= maxRange))
            {
                // Build out the list of items
                
                var maxX = requestedPosition.x + range;
                if(maxX > nMaxX+1 )
                {
                    maxX=nMaxX;
                }
                
                var maxY = requestedPosition.y + range;
                if(maxY > nMaxY+1 )
                {
                    maxY=nMaxY;
                }
                
                var minX = requestedPosition.x - range;
                if(minX < -this.mTileIndexExtent )
                {
                    minX= -this.mTileIndexExtent;
                }
                
                var minY = requestedPosition.y - range;
                if(minY < - this.mTileIndexExtent )
                {
                    minY=-this.mTileIndexExtent;
                }
                
                var list = [];
                for(var y = minY; y <= maxY; ++y)
                {
                    if(y == minY || y == maxY)
                    {
                        for(var x = minX; x <= maxX; ++x)
                        {
                            var loc = new Vec2D(x, y);
                            if(this.IsPointInGrid(x, y) && this.CanFit(loc, entity.GetSize()))
                            {
                                loc.xDist = WeMath.DistanceSqr2D(loc, requestedPosition);
                                list.push(loc);
                            }
                        }
                    }
                    else
                    {
                        var edgeLoc = new Vec2D(minX, y);
                        if(this.IsPointInGrid(minX, y) && this.CanFit(edgeLoc, entity.GetSize()))
                        {
                            edgeLoc.xDist = WeMath.DistanceSqr2D(edgeLoc, requestedPosition);
                            list.push(edgeLoc);
                        }
                        
                        edgeLoc = new Vec2D(maxX, y);
                        if(this.IsPointInGrid(maxX, y) && this.CanFit(edgeLoc, entity.GetSize()))
                        {
                            edgeLoc.xDist = WeMath.DistanceSqr2D(edgeLoc, requestedPosition);
                            list.push(edgeLoc);
                        }
                    }
                }

                var len = list.length;
                if(len > 0)
                {
                    // Lets sort on distance.
                    // $TODO take this sort out and embed the logic into the evaluation of x and y points.
                    // should be pretty easy but I want to get something working fast.
                    list.sort(sortFunc);

                    for(var idx = 0; idx < len; ++idx)
                    {
                        entity.mAnchor.x = list[idx].x;
                        entity.mAnchor.y = list[idx].y;
                        
                        if(bDecalAsObstruction)
                        {
                        	found = this.AddObstructionDecalAsObstruction(entity);
                        }
                        else
                        {
                        	found = this.AddObstruction(entity);
                        }
                        if(found)
                        {
                            entity.PositionUpdated();
                            return true;
                        }
                    }
                }

                ++range;
            }
        }
        entity.mAnchor.x = originalX;
        entity.mAnchor.y = originalY;
        return found;
    },
    
    IsPointInGrid : function(x, y)
    {
        if( 
                x > this.mTileIndexExtent ||
                x < -this.mTileIndexExtent ||
                y > this.mTileIndexExtent ||
                y < -this.mTileIndexExtent )
        {
            return false;
        }
        return true;
    },
    
    MovePositionToBounds : function(entity, requestedPosition)
    {
        // First lets check if this position is in bounds
        
        if(requestedPosition.x < - this.mTileIndexExtent )
        {
            requestedPosition.x= - this.mTileIndexExtent;
        }
        else if(requestedPosition.x+ entity.GetSizeX()-1 > this.mTileIndexExtent )
        {
            requestedPosition.x= this.mTileIndexExtent-entity.GetSizeX();
        }
        
        if(requestedPosition.y < - this.mTileIndexExtent )
        {
            requestedPosition.y= - this.mTileIndexExtent;
        }
        else if(requestedPosition.y+ entity.GetSizeY()-1 > this.mTileIndexExtent )
        {
            requestedPosition.y= this.mTileIndexExtent-entity.GetSizeY();
        }
        
        // Make sure the position is grid aligned
        requestedPosition.x = Math.floor(requestedPosition.x);
        requestedPosition.y = Math.floor(requestedPosition.y);
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     *
     */
    UpdateObstruction : function(entity, requestedPosition)
    {
        // First lets check if this position is in bounds
        this.MovePositionToBounds(entity, requestedPosition);
        var pos = entity.mAnchor;
        
        this.RemoveObstruction(entity);
        
        entity.mAnchor = requestedPosition;
        var results = this.AddObstruction(entity);
        if(results)
        {
            entity.PositionUpdated();
            this.AddToDirtyList(entity);
        }
        else
        {
            // Failed to add the guy at the position so put him back
            entity.mAnchor = pos;
            var resultsTmp = this.AddObstruction(entity);
        }
        return results;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: IsValidLocation
     * @param {Vec2D} loc to see if it is valid.  A.K.A in the grid
     * @return {Boolean} is the location a valid grid location?
     */
    IsValidLocation : function(loc)
    {
        if( loc.x < -this.mTileIndexExtent || loc.y < -this.mTileIndexExtent ||
            loc.x > this.mTileIndexExtent || loc.y > this.mTileIndexExtent)
        {
            return false;
        }
        var idx = this.GetPositionIdx(loc);
        return (ObstructionType.Full & this.mMap[idx])==0;
    },
    
    IsValidLocationRaw : function(x, y)
    {
        if( x < -this.mTileIndexExtent || y < -this.mTileIndexExtent ||
           x > this.mTileIndexExtent || y > this.mTileIndexExtent)
        {
            return false;
        }
        var idx = this.GetPosIdx(x, y);
        return (ObstructionType.Full & this.mMap[idx])==0;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     *
     */
    AddToDirtyList : function(entity)
    {
        // Check if the list has the item in it already
        var len = this.mDirtyList.length;
        for(var i = 0; i < len; ++i)
        {
           if(this.mDirtyList[i] == entity)
           {
                return;
           }
        }

        this.mDirtyList.push(entity);
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: CalculateH
     * creates the heuristical value for the fringe search algorithm
     * @param start = array [x, y] object
     * @param end = array [x, y] object
     */
    CalculateH : function(a, b)
    {
        var X = a.x - b.x;
        var Y = a.y - b.y;
        return Math.sqrt(X * X + Y * Y); 
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     *
     */
    GetNeighbors : function(node)
    {
        if(!this.IsValidLocation(node))
        {
            return null;
        }
        
        var neighbors = [];
        
        var hasLeft = false;
        var left = new Vec2D(node.x - 1, node.y);
        if(this.IsValidLocation(left))
        {
            neighbors.push(left);
            hasLeft = true;
        }
        
        var hasRight = false;
        var right = new Vec2D(node.x + 1, node.y);
        if(this.IsValidLocation(right))
        {
            hasRight = true;
            neighbors.push(right);
        }
        
        var hasTop = false;
        var top = new Vec2D(node.x, node.y + 1);
        if(this.IsValidLocation(top))
        {
            hasTop = true;
            neighbors.push(top);
        }
        
        var hasBottom = false;
        var bottom = new Vec2D(node.x, node.y - 1);
        if(this.IsValidLocation(bottom))
        {
            hasBottom = true;
            neighbors.push(bottom);
        }

        var upperLeft = new Vec2D(node.x -1, node.y + 1);
        if(this.IsValidLocation(upperLeft) && hasTop && hasLeft)
        {
            neighbors.push(upperLeft);
        }

        var lowerLeft = new Vec2D(node.x -1, node.y - 1);
        if(this.IsValidLocation(lowerLeft) && hasLeft && hasBottom)
        {
            neighbors.push(lowerLeft);
        }

        var upperRight = new Vec2D(node.x + 1, node.y + 1);
        if(this.IsValidLocation(upperRight) && hasRight && hasTop)
        {
            neighbors.push(upperRight);
        }
            
        var lowerRight = new Vec2D(node.x + 1, node.y - 1);
        if(this.IsValidLocation(lowerRight) && hasRight && hasBottom)
        {
            neighbors.push(lowerRight);
        }
        
        return neighbors;
    },
    
    //////////////////////////////////////////////////////////////////////////////
    /**
     *
     */
    GetNeighborsTo : function(node, end)
    {
        if(!this.IsValidLocation(node))
        {
            return null;
        }
        
        var neighbors = [];
        
        var nMoveByX=end.x-node.x;
        if( nMoveByX < 0 )
        {
        	nMoveByX= -1;
        }
        else if( nMoveByX > 0 )
        {
        	nMoveByX= 1;
        }

        var hasX = false;
        
        if(nMoveByX!==0)
        {
	        var left = new Vec2D(node.x +nMoveByX, node.y);
	        if(this.IsValidLocation(left))
	        {
	            neighbors.push(left);
	            hasX = true;
	        }
        }
        
        var nMoveByY=end.y-node.y;
        if( nMoveByY < 0 )
        {
        	nMoveByY= -1;
        }
        else if( nMoveByY > 0 )
        {
        	nMoveByY= 1;
        }        
        var hasY = false;
        if(nMoveByY!==0)
        {
	        var movey = new Vec2D(node.x, node.y +nMoveByY);
	        if(this.IsValidLocation(movey))
	        {
	            neighbors.push(movey);
	            hasY = true;
	        }
        }      
        
        if(hasY && hasX)
        {
            var xy = new Vec2D(node.x +nMoveByX, node.y+nMoveByY);
            if(this.IsValidLocation(xy))
            {
                neighbors.push(xy);
            }        	
        }
        return neighbors;
    },    

	// This is more memory-efficient version of GetNeighborsTo,
	// it doesn't allocate any new memory, only uses scratch 'out' buffer
	GetNeighborsThree : function(node, end, out)
    {
		var cnt = 0;
		var parent = this;

		var AddNode = function(x, y)
		{
			if(parent.IsValidLocationRaw(x, y)) 
			{
				out[cnt].x = x;
				out[cnt++].y = y;
				return true;
			}
			return false;
		};

        if(!this.IsValidLocation(node))
        {
            return null;
        }
        
        var nMoveByX=end.x-node.x;
        if( nMoveByX < 0 )
        {
        	nMoveByX= -1;
        }
        else if( nMoveByX > 0 )
        {
        	nMoveByX= 1;
        }

        var hasX = false;
        
        if(nMoveByX!==0) 
		{
			if(AddNode(node.x + nMoveByX, node.y))
			{
				hasX = true;
			}
		}
        
        var nMoveByY=end.y-node.y;
        if( nMoveByY < 0 )
        {
        	nMoveByY= -1;
        }
        else if( nMoveByY > 0 )
        {
        	nMoveByY= 1;
        }        
        var hasY = false;
        if(nMoveByY!==0)
        {
			if(AddNode(node.x, node.y + nMoveByY))
			{
				hasY = true;
			}
        }      
        
        if(hasY && hasX)
        {
			AddNode(node.x + nMoveByX, node.y + nMoveByY);
        }

        return cnt;
    }, 

    //////////////////////////////////////////////////////////////////////////////
    // Method: FindPath
    // The find path employes the Fringe Search algorithm.  The cool thing about
    // Fringe is there is no need to do a sort and there isn't very much expensive
    // math so my hope is it should work out well for a javascript based implementation
    // @param start = array [x, y] object
    // @param end = array [x, y] object
    FindPath : function(start, end)
    {
        // Precondition block
        if(!start || !end)
        {
            return null;
        }
        else if(!this.IsValidLocation(start) || !this.IsValidLocation(end))
        {
           return null; 
        }
        else if(start.x == end.x && start.y == end.y)
        {
            return null;
        }
        
        var startNode = {};
        startNode.mLoc = start;
        startNode.mG = 0;
        startNode.mIdx = this.GetPositionIdx(start);
        startNode.mParent = null;
        startNode.mNext = null;
        startNode.mLast = null;

        var fringe = startNode;
        var head = fringe;

        var cache = [];

        var found = false;
        var fLimit = WeMath.Distance2D(start, end);
        var endIdx = this.GetPositionIdx(end);

		// Init scratch buffer
		var out = [];
		for(var i = 0; i < 5; ++i)
		{
			out[i] = new Vec2D(0, 0);
		}	

        while(!found && fringe)
        {
            var fMin = Number.MAX_VALUE;
            while ( fringe )
            {
                var f = fringe.mG + WeMath.Distance2D(fringe.mLoc, end);

                if( f > fLimit )
                {
                    fMin = Math.min(f, fMin);
                    fringe = fringe.mNext;
                    continue;
                }
                if(fringe.mIdx == endIdx)
                {
                    found = true;
                    break;
                }

                //var children = this.GetNeighbors(fringe.mLoc);
                //var children = this.GetNeighborsTo(fringe.mLoc, end);
                //var childrenLen = children.length;
				var childrenLen = this.GetNeighborsThree(fringe.mLoc, end, out);
                for(var childIdx = 0; childIdx < childrenLen; ++childIdx)
                {
                    var child = out[childIdx];
                    var s = this.GetPositionIdx(child);
                    var gs = WeMath.Distance2D(child, start);

                    var nodePrime = cache[s];
                    if( nodePrime )
                    {
                        if( gs >= nodePrime.mG )
                        {
                            continue;
                        }
                        nodePrime.mG = gs;

                        if( nodePrime.mNext || nodePrime.mLast )
                        {
                            if(nodePrime.mLast)
                            {
                                nodePrime.mLast.mNext = nodePrime.mNext;
                            }
                            else
                            {
                                head = nodePrime.mNext;
                            }

                            if(nodePrime.mNext)
                            {
                                nodePrime.mNext.mLast = nodePrime.mLast;
                            }
                               
                            nodePrime.mNext = null;
                            nodePrime.mLast = null;
                        }
                    }
                    else
                    {
                        // Create the new node
                        nodePrime = {};
                        nodePrime.mLoc = new Vec2D(child.x, child.y);
                        nodePrime.mG = gs;
                        nodePrime.mIdx = s;
                        nodePrime.mParent = fringe;
                        nodePrime.mNext = null;
                        nodePrime.mLast = null;
                    }
                    
                    // Insert into fringe
                    nodePrime.mLast = fringe;
                    nodePrime.mNext = fringe.mNext;
                    if(fringe.mNext)
                    {
                        fringe.mNext.mLast = nodePrime;
                    }
                    fringe.mNext = nodePrime;

                    // Insert into cache/update
                    cache[s] = nodePrime;
                }

                // Remove this node from the fringe
                if(fringe.mLast)
                {
                    fringe.mLast.mNext = fringe.mNext;
                }
                else
                {
                    head = fringe.mNext;
                }
                if(fringe.mNext)
                {
                    fringe.mNext.mLast = fringe.mLast;
                }

                var tmp = fringe;
                fringe = fringe.mNext;
                
                tmp.mNext = null;
                tmp.mLast = null;
            }
            fLimit = fMin;
            fringe = head;
        }
        
        var path = null;
        if(found)
        {
            path = [];
            var theNode = cache[endIdx];
            while(theNode)
            {
                path.unshift(theNode.mLoc);
                theNode = theNode.mParent;
            }

        }

        return path;
    }
});

; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeEffects'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeEffects'] || {}; $MODULE_REGISTRY['weEngine/WeEffects'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      webgame.js
/// @author:    
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     This is the "main.c" file for the system if you want to think
///             about it that way...
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Audio = require('NGCore/Client/Audio').Audio;
var Storage = require('NGCore/Client/Storage').Storage;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var Content = require('weEngine/WeContent').Content;

var gLastSoundEffect = "";
var gAudioUseEffect = true;
//////////////////////////////////////////////////////////////////////////////
/**
 * Class WeEffectsMgr
 */
var _WeEffectsMgr = Core.MessageListener.subclass(
{
	classname: 'EffectsMgr',
	
    initialize: function()
    {
        this.mSpinner = null;
        this.mRotation = 0;
        this.mBackgroundMusic = [];
        this.mMusicEnabled = true;
		this._lastPlayed = {};
		this._effects = {};
    },

    Setup : function(_MusicInfoDefault)
    {
        Core.UpdateEmitter.addListener(this, this.OnUpdate);
        this.MusicInit(_MusicInfoDefault);
    },

    ShowSpinner : function()
    {
    	/*
        this.mButtonSize = 32;
        var screenDef = WeRenderDevice.GetScreenInfo();
        var position = [screenDef.mWidth * 0.5, screenDef.mWidth * 0.5, 100000];

        this.mSpinner = new WeSprite2D("btnFlip.png", [32, 32], position, 
                                        GL2.Root, [0.5, 0.5]);
        this.mSpinner.SetPosition(200, 200, 9);
        var spinner = this.mSpinner;
        this.mSpinner.Enable('UpdateEmitter', function (delta)
        {
            spinner.SetRotation( spinner.GetRotation() + 15.0 );
        });
        */
    },

    HideSpinner : function()
    {
    	/*
		if (Exists(this.mSpinner))
		{
	        this.mSpinner.Shutdown();
	        this.mSpinner = null;
		}
		*/
    },

    PlaySoundEffect : function(sound)
    {
    	//return; // DO AWAY WITH SOUND!
         if(sound && this.mMusicEnabled)
         {
			 // Don't play same sound twice less than 500ms apart
			 var skip = false;
		 	 var t = Core.Time.getRealTime();
			 if(this._lastPlayed[sound]) 
			 	if(t - this._lastPlayed[sound] < 500)
					skip = true;
			 this._lastPlayed[sound] = t;
			 if(skip)
			 	return;
			
             if(-1 != sound.indexOf('+'))
             {
                 return;
             }
 
             var theSound = sound.substring(0, sound.indexOf('.'));
 
             var os = Core.Capabilities.getPlatformOS();
             
             if( os == "Android" )
             {
                 theSound +=  gAndroidAudioExt;
             }
             else if( os == "flash" )
             {
                 // Sound effects not currently supported for flash
                 return;
                 //theSound += '.mp3';
             }
             else if( os == "iPhone OS" )
             {
                 return;
                 //theSound += '.caf';
             }
             
         	try
        	{
				NgLogD("@@@@@@ will play sound: "+ theSound +" @@@@@@");
         		if (gAudioUseEffect)
         		{
         		    var effect = this.GetAudioEffect(Content.getAudioPath(theSound));
         		    //NgLogD("@@@@@ Creating active effect for "+effect);
         		    var activeEffect = new Audio.ActiveEffect(effect);
     		        
         		    //NgLogD(" --- Adding listener to playCompleteEmitter");
         	        activeEffect.getPlayCompleteEmitter().addListener(this, this.OnUpdateEffect);
         	        //NgLogD(" --- Starting to play actual effect");
                	activeEffect.play();
                	//NgLogD(" --- Effect played!");
                    
					this.mActiveEffect = activeEffect;
         		}
         		else
         		{
         		    Audio.Device.playDetached(Content.getAudioPath(theSound));
         		}
        	}
        	catch(ex)
            {
                NgLogD("Failed in : "+ex);
            }
         }
    },

    GetAudioEffect : function(file)
    {
        NgLogD("@@@@@@ GETTING AUDIO: " + file);
        if(this._effects[file]) 
        {
        	//NgLogD(" --- Returning existing effect");
		 	return this._effects[file];
	 	}

		//NgLogD(" --- Creating new effect");
        var effect = new Audio.Effect(file);
        //NgLogD(" --- Registering effect");
        this._effects[file] = effect;
        //NgLogD(" --- Done with new effect");
        return this._effects[file];
    },
    
    OnUpdateEffect : function(ae)
    {
        NgLogD("*** DESTROY EFFECT");
        if( Core.Capabilities.getPlatformOS() !== "Android" && ae.effectFile)
	    {
	        if (this._effects[ae.effectFile])
	        {
	            this._effects[ae.effectFile].destroy();
            }
	        this._effects[ae.effectFile] = null;
        }
        ae.getPlayCompleteEmitter().removeListener(this);
        ae.destroy();
        // Get the background music back to the front.
        Audio.Music.setVolume(this.mMusicInfo.config.volume);
    },
    
    MusicInit : function(_MusicInfoDefault)
    {
    	//return; // DO AWAY WITH SOUND!
        var fs = Storage.FileSystem;
        var self = this;
        self.mMusicInfo=null;
        ReadFile(fs, "./Configs/music.json", {'blocking': false}, function(err, data)
        {
            if(!err)
            {
                try
                {
                    var obj = JSON.parse(data);
                    self.mMusicInfo = obj;
                }
                catch(ex)
                {
                    NgLogD("Failed to load the sound config file.  Drop out");
                }
            }
            else
            {
                self.mMusicInfo = _MusicInfoDefault;
            }

            try
            {
	            if(self.mMusicInfo && self.mMusicInfo.config.enabled)
	            {
	                self.mFade = false;
	                self.mMusic = self.mMusicInfo.tracks;
	                self.mIdx = 0;
	                Audio.Music.setPath(Content.getAudioPath(self.mMusic[0].name));
	                Audio.Music.setVolume(self.mMusicInfo.config.volume);
	                Audio.Music.play();
	                
	                self.mNextTrack = Core.Time.getRealTime() + self.mMusic[0].len;
	                //Old
	                //self.mNextTrack = new Date();
	                //self.mNextTrack.setTime(self.mNextTrack.getTime() + self.mMusic[0].len);
	            }
            }
            catch(ex)
            {
                NgLogD("Failed to play music: "+ex);
            }
        });
    },

    OnSongBegin : function()
    {
    	//return; // DO AWAY WITH SOUND!
    	try
    	{
	        Audio.Music.stop();
	        Audio.Music.setPath(Content.getAudioPath(this.mMusic[this.mIdx].name));
	        Audio.Music.setVolume(this.mMusicInfo.config.volume);
	        Audio.Music.play();
	        if (!this.mMusicEnabled)
	        	Audio.Music.pause();
    	}
    	catch(ex)
        {
            NgLogD("Failed in OnSongBegin: "+ex);
        }
    },


    OnUpdate : function(delta)
    {
    	//return;
        if(this.mMusicInfo &&  this.mMusicInfo.config && this.mMusicInfo.config.enabled)
        {
            var now = Core.Time.getRealTime();
            if(now >= this.mNextTrack)
            {
                ++this.mIdx;
                if(this.mIdx >= this.mMusic.length)
                {
                    this.mIdx = 0;
                }
                this.OnSongBegin();
                this.mNextTrack=now + this.mMusic[this.mIdx].len;
            }
        }
    }
});

exports.WeEffectsMgr = new _WeEffectsMgr();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio'] = exports; /**
 * <p>Classes and objects contained by the Audio module.</p>
 * @name Audio
 * @namespace 
 * @description <p>The Audio module is a collection of classes that support manipulation of audio effects in an application. 
 * Each class handles a specific aspect of the module implementation and contains APIs that support the class:</p>
 *<ul>
 *<li><code>{@link Audio.ActiveEffect}</code>: Construct objects for controlling the reproduction of <code>Effect</code> objects.</li>
 *<li><code>{@link Audio.Device}</code>: A singleton object that controls device sound effects volume.</li>
 *<li><code>{@link Audio.Effect}</code>: Construct objects that load sound resources into memory.</li>
 *<li><code>{@link Audio.Music}</code>: A singleton object that controls the reproduction of application background music.</li>
 *</ul>
 */
exports.Audio = {};

exports.Audio.__defineGetter__("ActiveEffect", function() {
	delete this.ActiveEffect;
	return this.ActiveEffect = require('NGCore/Client/Audio/ActiveEffect').ActiveEffect;
});
exports.Audio.__defineGetter__("Effect", function() {
	delete this.Effect;
	return this.Effect = require('NGCore/Client/Audio/Effect').Effect;
});
exports.Audio.__defineGetter__("Device", function() {
	delete this.Device;
	return this.Device = require('NGCore/Client/Audio/Device').Device;
});
exports.Audio.__defineGetter__("Music", function() {
	delete this.Music;
	return this.Music = require('NGCore/Client/Audio/Music').Music;
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/ActiveEffect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/ActiveEffect'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/ActiveEffect'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.ActiveEffect = Core.Class.subclass(
/** @lends Audio.ActiveEffect.prototype */
{
	/**
	 * @class The <code>ActiveEffect</code> class constructs objects that control 
	 * the reproduction of an audio effect. Audio effects in Mobage applications are captured as <code>{@link Audio.Effect}</code> objects. 
	 * <code>{@link Audio.Effect}</code> objects handle and load data for an audio effect into memory. 
	 * This seperation allows applications to manage effect data independently of effect reproduction.
	 * <br><br>
	 * <b>Note:</b> You can only specify <code>{@link Audio.Effect}</code> objects to reproduce at instantiation.
	 * 
	 * @example
	 *
	 *   var effect = new Audio.Effect('some_effect.wav');
	 *   var activeEffect = new Audio.ActiveEffect(effect);
	 *   activeEffect.play();
	 * @constructs The default constructor. 	 
	 * @augments Core.Class
	 * @param {Audio.Effect} effect The <code>{@link Audio.Effect}</code> that this <code>ActiveEffect</code> object plays.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function(effect)
	{
		this._volume  = 1.0;
		this._loops   = false;
		this._playing = false;
		this._paused  = false;

		this._playCompleteEmitter = new Core.MessageEmitter();

		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._setEffect(effect);
	},
	
	/**
	 * Destroy this instance and releases resources on the backend.
	 * <b>Note:</b> This call does not automatically destroy the associated <code>{@link Audio.Effect}</code>.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
		this.stop();
		this._effect = null;
		this._playCompleteEmitter.destroy();
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},
	
	/**
	 * Return the volume level for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Number} The current volume level.
	 * @see Audio.ActiveEffect#setVolume
	 * @status iOS, Android, Test
	 */
	getVolume: function()
	{
		return this._volume;
	},
	
	/**
	 * Set the volume level for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * Calling this changes the volume even if an application is in the middle of reproducing an <code>{@link Audio.Effect}</code> object.
	 * The new volume level applies to any subsequent reproductions of the <code>{@link Audio.Effect}</code> object.
	 * @example Audio.ActiveEffect.setVolume(0.5);
	 * @param {Number} [volume=1] The new volume level. Supported values range between <code>(0-1)</code>. 
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Audio.ActiveEffect#getVolume
	 * @status iOS, Android
	 */
	setVolume: function(volume)
	{
		if (volume < 0.0) volume = 0.0;
		if (volume > 1.0) volume = 1.0;

		this._volume = volume;
		this._setVolumeSendGen(volume);
		return this;
	},
	
	/**
	 * Return the loop status for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Boolean} Returns <code>true</code> if looping is enabled.
	 * @see Audio.ActiveEffect#setLoops
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getLoops: function()
	{
		return this._loops;
	},
	
	/**
	 * Set the loop state for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * A looped effect wraps seamlessly from begining to end.
	 * @example Audio.ActiveEffect.setLoops(true);
	 * @param {Boolean} loops Set as <code>true</code> to enable looping.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Audio.ActiveEffect#getLoops
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	setLoops: function(loops)
	{
		this._loops = loops;
		this._setLoopsSendGen(loops);
		return this;
	},
	
	/**
	 * Return the <code>Play Complete</code> emitter for the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * The <code>Play Complete</code> emitter notifies applications when reproduction of an <code>{@link Audio.Effect}</code> is complete.<br><br>
	 * <b>Notes:</b>
	 * <ul>
	 *   <li>Any <code>{@link Audio.Effect}</code> object that does not loop uses the <code>Play Complete</code> emitter. </li>
	 * </ul>
	 * @returns {Core.MessageEmitter} The current state of the <code>Play Complete</code> emitter.
	 * @status iOS
	 */
	getPlayCompleteEmitter: function()
	{
		return this._playCompleteEmitter;
	},
	
	/**
	 * Return the play status of the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Boolean} Returns <code>true</code> if this <code>ActiveEffect</code> is reproducing an <code>{@link Audio.Effect}</code>.
	 * @see Audio.ActiveEffect#play
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getIsPlaying: function()
	{
		return this._playing;
	},
	
	/**
	 * Return the pause status of the <code>{@link Audio.Effect}</code> this <code>ActiveEffect</code> is reproducing.
	 * @returns {Boolean} Returns <code>true</code> if this <code>(@link Audio.Effect}</code> is in a paused state.
	 * @see Audio.ActiveEffect#pause
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getIsPaused: function()
	{
		return this._paused;
	},
	
	/**
	 * Begin reproducing an <code>{@link Audio.Effect}</code>.
	 * <ul>
	 * <li>If this <code>{@link Audio.Effect}</code> is new or in a stopped state,
	 * reproduction starts at the beginning.</li>
	 * <li>If this <code>{@link Audio.Effect}</code> is in a paused state, reproduction resumes from the previous position.</li>
	 * <li>If this <code>{@link Audio.Effect}</code> is playing, this call does nothing.</li>
	 * </ul>
	 * @see Audio.ActiveEffect#getIsPlaying
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	play: function()
	{
		this._playing = true;
		this._paused  = false;
		this._playSendGen( );
	},
	
	/**
	 * Pause reproduction of an <code>{@link Audio.Effect}</code>.
	 * <ul>
	 * <li>If this <code>ActiveEffect</code> is in the process of reproducing an <code>{@link Audio.Effect}</code>, this call pauses reproduction.</li>
	 * <li>If the <code>{@link Audio.Effect}</code> is in a stopped or paused state, this call does nothing.</li>
	 * </ul>
	 * <b>Note:</b> Calling this does not trigger the <code>Play Complete</code> emitter.
	 * @see Audio.ActiveEffect#getIsPaused
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	pause: function()
	{
		this._playing = false;
		this._paused  = true;
		this._pauseSendGen( );
	},
	
	/**
	 * Stop reprodution of an <code>{@link Audio.Effect}</code> object.
	 * <ul>
	 * <li>If this <code>ActiveEffect</code> is currently reproducing an <code>{@link Audio.Effect}</code> or the <code>{@link Audio.Effect}</code> is in a paused state, this call stops reproduction.</li>
	 * <li>If the <code>{@link Audio.Effect}</code> is in a stopped state, this call does nothing.</li>
	 * </ul>
	 * <b>Note:</b> Calling <code>stop()</code> does not trigger the <code>Play Complete</code> emitter.
	 * @status iOS, Android, Test, iOSTested, AndroidTested	 
	 */
	stop: function()
	{
		this._playing = false;
		this._paused  = false;
		this._stopSendGen( );
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 328
	// Method create = -1
	// Method destroy = 2
	// Method setVolume = 3
	// Method setLoops = 4
	// Method play = 5
	// Method pause = 6
	// Method stop = 7
	// Method setEffect = 8
	// Method playComplete = 9
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 9:
					instance._playCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in ActiveEffect._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in ActiveEffect._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[328] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_playCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in ActiveEffect.playComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":328,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":328,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_setVolumeSendGen: function( volume )
	{
		Core.Proc.appendToCommandString( ":328,3," + this.__objectRegistryId + "," + volume  );
	},
	
	/** @private */
	_setLoopsSendGen: function( loops )
	{
		Core.Proc.appendToCommandString( ":328,4," + this.__objectRegistryId + "," + ( loops ? 1 : 0 )  );
	},
	
	/** @private */
	_playSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":328,5," + this.__objectRegistryId );
	},
	
	/** @private */
	_pauseSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":328,6," + this.__objectRegistryId );
	},
	
	/** @private */
	_stopSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":328,7," + this.__objectRegistryId );
	},
	
	/** @private */
	_setEffectSendGen: function( effectId )
	{
		Core.Proc.appendToCommandString( ":328,8," + this.__objectRegistryId + "," + effectId  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setVolume: function( volume ) {}
	
	// setLoops: function( loops ) {}
	
	// play: function(  ) {}
	
	// pause: function(  ) {}
	
	// stop: function(  ) {}
	
	// setEffect: function( effectId ) {}
	
	// _playCompleteRecv: function( cmd ) {}

// {{/Wg Generated Code}}

	_setEffect: function(effect)
	{
		this._effect  = effect;
		this._setEffectSendGen(this._effect.__objectRegistryId);
		return this;
	},

	_playCompleteRecv: function( cmd )
	{
		var msg = {};
		if(!this._playCompleteRecvGen(cmd, msg))
			return;

		this._playing = false;
		this._paused  = false;

		this._playCompleteEmitter.emit(this);
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Effect'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Effect'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Effect'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.Effect = Core.Class.subclass(
/** @lends Audio.Effect.prototype */
{
	/**
	 * @class The <code>Effect</code> class constructs objects for handling audio resources that comprise an audio effect.
	 * Instantiating these objects allocates resources on the backend.
	 * After creating an <code>Effect</code> object, applications can control reproduction through an <code>{@link Audio.ActiveEffect}</code> object.<br><br>
	 * @example
	 * var effect = new Audio.Effect('Content/explosion.wav');
	 * @constructs The default constructor.<br><br>
	 * The following code is an example of constructing a new <code>Effect</code> object.
	 * @augments Core.Class
	 * @param {String} path A directory path that points to the audio file to load.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	initialize: function(path)
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._setPath(path);
	},
	
	/**
	 * Destroy this instance and release resources on the backend.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	destroy: function()
	{
		this._destroySendGen();
		Core.ObjectRegistry.unregister(this);
	},
	
	/**
	 * Set a directory path to the audio file resource for this <code>Effect</code> object.
	 * @param {String} path The new directory path.
	 * @returns Calls to <code>setPath()</code> return <code>this</code> to support method invocation chaining.
	 */
	_setPath: function(path)
	{
		this._path = path;
		this._setPathSendGen(path);
		return this;
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 326
	// Method create = -1
	// Method destroy = 2
	// Method setPath = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Effect._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Effect._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[326] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":326,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":326,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_setPathSendGen: function( path )
	{
		Core.Proc.appendToCommandString( ":326,3," + this.__objectRegistryId + "," + Core.Base64.encode( path )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setPath: function( path ) {}
	

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Device'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Device'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Device'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.Device = Core.Class.singleton(
/** @lends Audio.Device.prototype */
{
	classname: 'Device',

	/**
	 * @class The <code>Device</code> class constructs a singleton object that contains audio device properties.
	 * Applications can use <codeDevice</code> objects to control global audio effects volume 
	 * and reproduce detached audio effects.
	 * <br><br>
	 * <b>Note:</b> An application should never directly allocate a singleton.
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 */
	 
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._volume = undefined; // default value

		var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;
		var initialValues = KeyValueCache.global("Audio.Device.InitialValues");

		var self = this;
		initialValues.getItem("effectsVolume", function(error, value) {
			self._volume = parseFloat(value);
		});
	},
	
	/**
	 * Return the global sound effects volume for this <code>Device</code> object.
	 * @returns {Number} The current global sound effects volume.
	 * @see Audio.Device#setEffectsVolume	 
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getEffectsVolume: function()
	{
		return this._volume;
	},
	
	/**
	 * Set the global sound effects volume for this <code>Device</code> object.
	 * Volume for each active effect multiplies
	 * by this value to produce a new volume level. 
	 * For example, if the global sound effects volume is set to 0.5, each active effect will play at half the volume set on the effect.
	 * @param {Number} [effectsVolume=1] The new volume for global sound effects. 
	 * Supported values range between <code>(0-1)</code>. 
	 * @example Audio.Device.setEffectsVolume(0.5);
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Audio.Device#getEffectsVolume
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	setEffectsVolume: function(effectsVolume)
	{
		if (effectsVolume < 0.0) effectsVolume = 0.0;
		if (effectsVolume > 1.0) effectsVolume = 1.0;

		this._volume = effectsVolume;
		this._setEffectsVolumeSendGen(effectsVolume);
		return this;
	},
	
	/**
	 * Play an audio effect in a way that is completely detached from upstream or downstream processing.
	 * Using this call is a simple, high-level way to reproduce an audio effect.<br><br>
	 * The specified audio effect is only reproduced once.
	 * There is no control over the effect volume or effect playback.
	 * Resource allocation automatically occurs on the backend when playback begins. Resources are automatically released when playback ends.	 
	 * The following code is an example of a <code>playDetached()</code> call.
	 * @example
	 * Audio.Device.playDetached('Content/explosion.wav');
	 * @param {String} path A relative directory path to the audio file.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	playDetached: function(path)
	{
		this._playDetachedSendGen( path );
		return this;
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 327
	// Method create = -1
	// Method setEffectsVolume = 2
	// Method playDetached = 3
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Device._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Device._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[327] = h; return h;})(),
	
	/////// Private recv methods.
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":327,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_setEffectsVolumeSendGen: function( effectsVolume )
	{
		Core.Proc.appendToCommandString( ":327,2," + this.__objectRegistryId + "," + effectsVolume  );
	},
	
	/** @private */
	_playDetachedSendGen: function( path )
	{
		Core.Proc.appendToCommandString( ":327,3," + this.__objectRegistryId + "," + Core.Base64.encode( path )  );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// setEffectsVolume: function( effectsVolume ) {}
	
	// playDetached: function( path ) {}
	

// {{/Wg Generated Code}}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Audio/Music'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Audio/Music'] || {}; $MODULE_REGISTRY['NGCore/Client/Audio/Music'] = exports; var Core = require('NGCore/Client/Core').Core;

exports.Music = Core.Class.singleton(
/** @lends Audio.Music.prototype */
{
	classname: 'Music',

	/**
	 * @class The <code>Music</code> class constructs a singleton object that provides control over reproduction
	 * of application background music.
	 * This object is constructed independently of <code>Device</code> objects because many devices
	 * already provide hardware-accelerated streaming and decode
	 * for a single background music track. Some
	 * devices gracefully mute a background music track
	 * if the user is playing a music track from their own library.
	 * <br><br>
	 * <b>Note:</b> Applications should never directly allocate a singleton.
	 * @example 
	 * var background = new Audio.Music('Content/music.mp3');
	 * @constructs The default constructor. 
	 * @augments Core.Class
	 */
	initialize: function()
	{
		Core.ObjectRegistry.register(this);
		this._createSendGen(this.__objectRegistryId);
		this._path    = null;
		this._playing = false;
		this._paused  = false;
		this._volume  = 1.0;
	},
	
	/**
	 * Return the directory path to the background music file used as a resource for this <code>Music</code> object.
	 * @returns {String} The directory path to a music file.
	 * @see Audio.Music#setPath
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getPath: function()
	{
		return this._path;
	},
	
	/**
	 * Set the directory path for the background music file that this <code>Music</code> object loads.<br><br>
	 * <b>Note:</b> If the application is reproducing music when this is called, reproduction will stop.
	 * The application must call <code>play()</code> again to start reproduction of the new resource.<br><br>
	 * The code in the following example sets a directory path to a music resource and plays that resource.
	 * @example
	 * Audio.Music.setPath('Content/music.mp3');
	 * Audio.Music.play();
	 *
	 * @param {string} path The new directory path to a music file.
	 * @see Audio.Music#getPath,
	 * @see Audio.Music#play
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	setPath: function(path)
	{
		this._path = path;
		this._setPathSendGen(path);
	},
	
	/**
	 * Return the volume level used for reproduction of this <code>Music</code> object.
	 * @returns {Number} The current volume level.
	 * @see Audio.Music#setVolume
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getVolume: function()
	{
		return this._volume;
	},
	
	/**
	 * Set the volume level used for reproduction of this <code>Music</code> object.
	 * This call instantly modifies the background music volume level.
	 * Any subsequent reproductions of background music will play at the specified volume.
	 * @example Audio.Music.setVolume(0.5);
	 * @param {Number} [volume=1] The new volume. Supported values range between <code>(0-1)</code>.
	 * @returns This function returns <code>this</code> to support method invocation chaining.
	 * @see Audio.Music#getVolume
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	setVolume: function(volume)
	{
		if (volume < 0.0) volume = 0.0;
		if (volume > 1.0) volume = 1.0;

		this._volume = volume;
		this._setVolumeSendGen(volume);
		return this;
	},
	
	/**
	 * Return the playback state of this <code>Music</code> object. 
	 * @returns {Boolean} Returns <code>true</code> if an application is reproducing background music.
	 * @see Audio.Music#play
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getIsPlaying: function()
	{
		return this._playing;
	},
	
	/**
	 * Return the pause state of this <code>Music</code> object.
	 * @returns {Boolean} Returns <code>true</code> if an application is reproducing background music.
	 * @see Audio.Music#pause
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	getIsPaused: function()
	{
		return this._paused;
	},
	
	/**
	 * Begin reproduction of this <code>Music</code> object.
	 * <ul>	
	 * <li>If this <code>Music</code> object is a new background music track, or the application has stopped the current background music track, 
	 * this call begins reproduction from the beginning.</li>
	 * <li>If the background music track is in a paused state, this call resumes reproduction from the previous position.</li>
	 * <li>If the background music track is currently playing, this call does nothing.</li>
	 * </ul>
	 * @see Audio.Music#getIsPlaying,
	 * @see Audio.Music#pause,
	 * @see Audio.Music#stop
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	play: function()
	{
		this._playing = true;
		this._paused  = false;
		this._playSendGen( );
	},
	
	/**
	 * Pause reproduction of this <code>Music</code> object.
	 * <ul>
	 * <li>If an application is currently reproducing a background music track, this call pauses reproduction.</li>
	 * <li>If the background music track is in a paused or stopped state, this call does nothing.</li>
	 * </ul>
	 * @see Audio.Music#getIsPaused
	 * @see Audio.Music#play,
	 * @see Audio.Music#stop
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	pause: function()
	{
		this._playing = false;
		this._paused  = true;
		this._pauseSendGen( );
	},
	
	/**
	 * Stop reproduction of this <code>Music</code> object.
	 * <ul>
	 * <li>If the background music track is playing or in a paused state, this call stops playback.</li>
	 * <li>If the background music track is in a stopped state, this call does nothing.</li>
	 * </ul>
	 * @see Audio.Music#play,
	 * @see Audio.Music#pause
	 * @status iOS, Android, Test, iOSTested, AndroidTested
	 */
	stop: function()
	{
		this._playing = false;
		this._paused  = false;
		this._stopSendGen( );
	},
	
// {{?Wg Generated Code}}
	
	///////
	// Class constants (for internal use only):
	// Class ID = 329
	// Method create = -1
	// Method destroy = 2
	// Method setPath = 3
	// Method setVolume = 4
	// Method play = 5
	// Method pause = 6
	// Method stop = 7
	// Method playComplete = 8
	
	/** 
	 * Command dispatch.
	 * @private
	 */
	$_commandRecvGen: (function() { var h = (function ( cmd )
	{
		var cmdId = Core.Proc.parseInt( cmd.shift(), 10 );
		
		if( cmdId > 0 )	// Instance Method.
		{
			var instanceId = Core.Proc.parseInt( cmd.shift(), 10 );
			var instance = Core.ObjectRegistry.idToObject( instanceId );
			
			if( ! instance )
			{
				NgLogE("Object instance could not be found for command " + cmd + ". It may have been destroyed this frame.");
				return;
			}
			
			switch( cmdId )
			{
				
				case 8:
					instance._playCompleteRecv( cmd );
					break;
				default:
					NgLogE("Unknown instance method id " + cmdId + " in Music._commandRecvGen from command: " + cmd );
					return;
			}
		}
		else			// Static method.
		{
			switch( cmdId )
			{
				
				default:
					NgLogE("Unknown static method id " + cmdId + " in Music._commandRecvGen from command: " + cmd );
					return;
			}
		}
	}); if(typeof(PROC_DISPATCH_TABLE) == 'undefined') PROC_DISPATCH_TABLE = {}; PROC_DISPATCH_TABLE[329] = h; return h;})(),
	
	/////// Private recv methods.
	
	/** @private */
	_playCompleteRecvGen: function( cmd, obj )
	{ 
		if( cmd.length != 0 )
		{
			NgLogE("Could not parse due to wrong argument count in Music.playComplete from command: " + cmd );
			return false;
		}
		
		return true;
	},
	
	/////// Private send methods.
	
	/** @private */
	$_createSendGen: function( __objectRegistryId )
	{
		Core.Proc.appendToCommandString( ":329,-1," + __objectRegistryId  );
	},
	
	/** @private */
	_destroySendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":329,2," + this.__objectRegistryId );
	},
	
	/** @private */
	_setPathSendGen: function( path )
	{
		Core.Proc.appendToCommandString( ":329,3," + this.__objectRegistryId + "," + Core.Base64.encode( path )  );
	},
	
	/** @private */
	_setVolumeSendGen: function( volume )
	{
		Core.Proc.appendToCommandString( ":329,4," + this.__objectRegistryId + "," + volume  );
	},
	
	/** @private */
	_playSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":329,5," + this.__objectRegistryId );
	},
	
	/** @private */
	_pauseSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":329,6," + this.__objectRegistryId );
	},
	
	/** @private */
	_stopSendGen: function(  )
	{
		Core.Proc.appendToCommandString( ":329,7," + this.__objectRegistryId );
	},
	
	// This class is expected to implement the following methods outside of
	// the generated block:
	// $create: function( __objectRegistryId ) {}
	
	// destroy: function(  ) {}
	
	// setPath: function( path ) {}
	
	// setVolume: function( volume ) {}
	
	// play: function(  ) {}
	
	// pause: function(  ) {}
	
	// stop: function(  ) {}
	
	// _playCompleteRecv: function( cmd ) {}

// {{/Wg Generated Code}}

	_playCompleteRecv: function( cmd )
	{
		var msg = {};
		if(!this._playCompleteRecvGen(cmd, msg))
			return;

		this._playing = false;
		this._paused  = false;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/PlusRequest'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/PlusRequest'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/PlusRequest'] = exports; var OAuthReq  = require('NGCore/Client/Plus/oauth');
var CoreReq = require('NGCore/Client/Core');
var SessionReq = require('NGCore/Client/Plus/Session');
var Network = require('NGCore/Client/Network').Network;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

// turn this off if your platform doesn't support Storage yet. This will be removed at some point.
var StorageEnabled = true;

/**
 * Synthesizes a getter and setter for various property names, and assigns them to the class' prototype
 * TODO Decide if we want to reuse something like this, replace it with Classes, or remove it outright
 *
 * @param classObj The class object (something with a prototype) that you want to extend with synthesized getters/setters
 * @param {Array{String}} propertyNames An array of names that you want synthesized getters (where "foo" becomes "setFoo" and "getFoo")
 */
var NgDefineProperties = function(classObj, propertyNames){
	var defPropFn = function(key) {
		var casedKey = "" + key.substr(0,1).toUpperCase() + key.substr(1, key.length - 1);
		classObj.prototype["set" + casedKey] = function(obj){
			this[key] = obj;
		};
		classObj.prototype["get" + casedKey] = function(){
			return this[key];
		};
	};
	for(var idx=0; idx<propertyNames.length; idx++){
		defPropFn(propertyNames[idx]);
	}
};

/**
 * PlusRequest represents an HTTP request to the Plus+ servers. It manages HTTP including authentication, as well as
 * parsing JSON responses. It is used by the classes in the Plus module as the foundation class for server communication, and
 * should generally be used through those APIs. To use an PlusRequest, you typically:
 * - Create one with `new PlusRequest()`,
 * - Set the API method and appropriate options, and
 * - Call send(), with a callback function to receive on completion.
 *
 * All completion callbacks follow this general pattern:
 * - an error object (if an error occurred),
 * - the response data (if no error occurred) as a string, or as a hash if the object was JSON,
 * - a hash of response headers, and
 * - an HTTP status code
 *
 * When writing a wrapper API, it is recommended to follow this pattern whenever possible, including the error object first.
 *
 * PlusRequest has a few properties that you can set:
 * - apiMethod (required) The name of the API endpoint to use.
 * - entityTag (optional) Supplies the entity tag passed as an If-None-Match header. Defaults to undefined.
 * - secure (optional) Determines if the request goes over HTTPS or not. Defaults to true for production, false for staging.
 * - httpHeaders (optional) A hash of HTTP headers to be sent. Defaults to an empty hash.
 * - httpMethod (optional) The type of HTTP method to use (GET, POST, PUT, DELETE, etc.) Defaults to GET.
 * - postBody (optional) Either a string of data to send, or a hash of objects to turn into encoded form data.
 *
 * @constructor
 * @class PlusRequest
 */
var PlusRequest = function(){
	PlusRequest._initialize();

	this.secure = (PlusRequest.getServerMode() == PlusRequest.serverModes.production);
	this.apiMethod = "";
	this.attachments = [];
	this.httpMethod = "GET";
	this.httpHeaders = {};
};

/**
 * Does some deferred setup to determine the correct hostname to route API requests to.
 * It overwrites itself after execution to speed up subsequent requests.
 * 
 * @private
 */
PlusRequest._initialize = function(){
	// We need to wait until the capabilities object is setup to do this check
	if(Capabilities.getPlatformOS().toLowerCase() == "flash"){
		// this is a proxy server needed for Flash which also serves a XSS access policy file
		PlusRequest.apiDomain = "10.15.100.241";
		/*
		 * TODO - fbarthelemy - 2010-12-07 web browsers don't all
		 * support storage yet.
		 */
		StorageEnabled = false;
	}else if(PlusRequest.apiDomain === null){ // if it's not null, someone already set the server mode
		PlusRequest.setServerMode(PlusRequest.serverModes.partner);
	}

	// No need to waste time on this later
	PlusRequest._initialize = function(){};
};

NgDefineProperties(PlusRequest, ["apiMethod", "entityTag", "secure", "httpHeaders", "httpMethod", "postBody"]);

PlusRequest.apiDomain = null; // this will get initialized by PlusRequest.setServerMode
PlusRequest.apiVersion = "1";

PlusRequest.platformAccessToken = null;
PlusRequest.platformAccessSecret = null;
PlusRequest.platformConsumerKey = null;
PlusRequest.platformConsumerSecret = null;

PlusRequest.serverModes = {
	staging: "staging",
	integration: "integration",
	partner: "partner",
	production: "production",
	unknown: "unknown"
};

PlusRequest.getServerMode = function(){
	var apiDomain = PlusRequest.apiDomain;
	var serverModes = PlusRequest.serverModes;
	var mode = serverModes.unknown;

	if(apiDomain == "staging.plusplus.com"){
		mode = serverModes.staging;
	}else if(apiDomain == "partner.plusplus.com"){
		mode = serverModes.partner;
	}else if(apiDomain == "integration.plusplus.com"){
		mode = serverModes.integration;
	}else if(apiDomain == "app.plusplus.com"){
		mode = serverModes.production;
	}
	
	NgLogD("Getting server mode: " + mode);
	return mode;
};

PlusRequest.setServerMode = function(mode){
	var serverModes = PlusRequest.serverModes;
	if(mode == serverModes.staging){
		PlusRequest.apiDomain = "staging.plusplus.com";
	}else if(mode == serverModes.partner){
		PlusRequest.apiDomain = "partner.plusplus.com";
	}else if(mode == serverModes.integration){
		PlusRequest.apiDomain = "integration.plusplus.com";
	}else if(mode == serverModes.production){
		PlusRequest.apiDomain = "app.plusplus.com";
	}
};

PlusRequest.serverModeIsProduction = function(){
	return (PlusRequest.getServerMode() === PlusRequest.serverModes.production);
};

/**
 * Builds and sends the request, and sends a callback when the request completes (successfully or not).
 * The callback receives:
 *
 * All completion callbacks follow this general pattern:
 * - an error object (if an error occurred),
 * - the response data (if no error occurred) as a string, or as a hash if the object was JSON,
 * - a hash of response headers
 * - an HTTP status code
 *
 * @param {Function(error, contents, responseHeaders, statusCode)} cb The completion callback.
 */
PlusRequest.prototype.send = function(cb){
	var request = this._prepareRequest();
	var headers;
	request.onreadystatechange = function(){
		if (request.readyState == 4) {
			headers = request.getUnflattenedResponseHeaders();
			var data = request.responseText;
			var error = request.error;
			var contentType = request.getResponseHeader("Content-Type") || "text";
			if(contentType.indexOf("application/json") != -1){
				try{
					data = JSON.parse(data);
				} catch(e){
					NgLogD("EXCEPTION - Could not parse JSON data: " + e + " - " + data);
					error = e;
				}
				
				if(data && data.error_msg){
					error = data.error_msg;
				}
			}
			
			if(request.status !== 200 && request.status !== 304){
				// HACK: probably shouldn't rely on this, but Plus+ server returns 200 unless catastrophe strikes
				// ...unless it's a 304 for etags.
				error = "Error connecting to server";
			}

			cb(error, data, headers, request.status);
		}
	};
	request.send(this._postData);
	if ((typeof PlusRequest.mockXHR) != 'undefined') {
		// mock invoke the callback
		request.mockCallBack(cb);
	}
};

/**
 * Adds an attachment to the request, which causes the request to submit with a Content-Type of multipart/form-data.
 * The request must have (httpMethod == "GET") for attachments to be sent with the request.
 *
 * @param {String} attachment The contents of the attachment. Required.
 * @param {String} name The name of the attachment. Defaults to filename, or "value" if both are undefined.
 * @param {String} filename The filename of the attachment. Defaults to name, or "value" if both are undefined.
 * @param {String} type The Content-Type of the attachment
 */
PlusRequest.prototype.addAttachmentWithNameAndFilenameOfType = function(attachment, name, filename, type){
	if(!attachment){
		return;
	}

	if(!name && filename){
		name = filename;
	}else if(!filename && name){
		filename = name;
	}else if(!name && !filename){
		name = filename = "value";
	}

	if(!type){
		type = "application/octet-stream";
	}

	this.attachments.push({
		data: attachment,
		name: name,
		filename: filename,
		type: type
	});
};

// Utility APIs

/**
 * Returns the name of the app for sending information to the Plus server
 * @return The app name.
 */
PlusRequest.appKey = function(){
	return SessionReq.Session.getCurrentSession().appKey();
};

/**
 * Returns the version of the app for sending information to the Plus server
 * @return The app version.
 */
PlusRequest.appVersion = function(){
	return SessionReq.Session.getCurrentSession().appVersion();
};

/**
 * Returns the version of the SDK for sending information to the Plus server
 * @return The SDK version.
 */
PlusRequest.getPlatformVersion = function(){
	return "1.0";
};

/**
 * Returns a hash of OAuth info needed for the request
 * @return The hash of OAuth info.
 */
PlusRequest.getPlatformOAuthInfo = function(){
	return SessionReq.Session.getCurrentSession().OAuthConsumerInfo();
};

// Platform APIs

/**
 * Checks the status of the current logged-in session.
 *
 * @param {CompletionCallback} cb The completion callback (passing back the error and data)
 * @return the PlusRequest that is handling the call
 */

PlusRequest.checkSessionStatus = function(cb){
	var request = new PlusRequest();
	request.setApiMethod("session");
	request.setHttpMethod("GET");
	request.setPostBody(SessionReq.Session.getCurrentSession()._loginParameters());
	request.setSecure(false);

	request.send(function(err, data){
		cb(err, data);
	});
	return request;
};

/**
 * Establishes a new session with the user's username and password. These values should not be saved.
 *
 * @param {String} username The username of the password to login.
 * @param {String} password The password of the password to login.
 * @param {CompletionCallback} cb The completion callback. Returns the error (on failure) and the logged-in User (on success).
 * @return the PlusRequest that is handling the call
 */

PlusRequest.loginWithUsernameAndPassword = function(username, password, cb){
	SessionReq.Session.getCurrentSession().loginWithUsernameAndPassword(username, password, cb);
};

/**
 * Establishes a new session with the user's old auth token. This is stored automatically.
 *
 * @param {CompletionCallback} cb The completion callback. Returns the error (on failure) and the logged-in User (on success).
 * @return the PlusRequest that is handling the call
 */

PlusRequest.loginWithSession = function(cb){
	SessionReq.Session.getCurrentSession().loginWithSession(cb);
};

/**
 * Sends a password reset email to the supplied email address.
 *
 * @param {String} address The email address of the user
 * @param {CompletionCallback} cb The completion callback.
 * @return the PlusRequest that is handling the call.
 */

PlusRequest.sendPasswordResetEmailWithAddress = function(address, cb){
	if(!address){
		cb("No email address", null);
		return;
	}
	
	var request = new PlusRequest();
	request.setSecure(true);
	request.setApiMethod("users/reset_password");
	request.setHttpMethod("POST");
	request.setPostBody({
		email: address
	});

	request.send(function(err, data){
		if(err || (data && !data.success)){
			cb(err, null);
		}else{
			cb(null, data);
		}
	});
};

/**
 * Establishes a new session with the logged in user for the game.
 *
 * @param {String} consumerKey The OAuth consumer key of the game for logging into Plus+
 * @param {CompletionCallback} cb The completion callback. Returns the error (on failure) and the logged-in User (on success).
 * @return the PlusRequest that is handling the call
 */

PlusRequest.getSessionTokensForConsumerKey = function(consumerKey, cb){
	var request = new PlusRequest();
	request.setApiMethod("oauth/authorize_new");
	request.setHttpMethod("POST");
	request.setPostBody({
		key: consumerKey
	});

	request.send(function(err, data){
		NgLogD("getSessionTOkensForConsumerKey *" + err + "* - **" + data + "**");
		cb(err, data);
	});
	return request;
};


/**
 * Update device_token so gserver may use it to send Apple APN or Google c2dm
 * notification(s) to a user.  One way to check that this was successful is
 * to log into staging.plusplus.com/admin and check the device_token field
 * of the logged in user.
 *
 * @param {String} devToken The up-to-date device token obtained from system
 *                 binding callback
 * @param {CompletionCallback} cb The completion callback. Returns the server
 *                             response.
 * @return the PlusRequest that is handling the call
 */

PlusRequest.updateSessionDeviceToken = function(devToken, cb){
	var request = new PlusRequest();
	request.setApiMethod("session");
	// supposedly, PUT should be used to perform the update.  However, on
	// staging, PUT did not work but POST did
	request.setHttpMethod("POST");
	request.setPostBody({
		device_token: devToken
	});
	request.send(function(err, data) {
		cb(err, data);
	});
	return request;
};


// Private APIs

/**
 * Generates the request URL from the environment
 * @return the request URL
 * @private
 */

PlusRequest.prototype._getRequestURL = function(){
	var appKeyString = PlusRequest.appKey();
	var path = [
		PlusRequest.apiDomain,
		PlusRequest.apiVersion,
		appKeyString,
		this.apiMethod
	];
	var urlString = "" + (this.secure ? "https" : "http") + "://" + path.join("/");
	return urlString;
};

/**
 * Builds, but does not send, the request object:
 *
 * - Generates the request URL, embedding the post body parameters if the request is a GET
 * - Signs the request with OAuth
 * - Sets the HTTP headers and entity tag
 * - Adds attachments
 * - Sets the Content-Type
 *
 * @return the raw NgXHR request
 * @private
 */
PlusRequest.prototype._prepareRequest = function(){
	var key;
	var method = this.getHttpMethod();
	var path = this._getRequestURL();

	this._postData = this.postBody;

	// mix the key/value pairs needed for OAuth into a hash
	var oauthParameters = {};
	for(key in this._postData) {
	 if (this._postData.hasOwnProperty(key)) {
		oauthParameters[key] = this._postData[key];
	 }
	}

	var credentials = PlusRequest.getPlatformOAuthInfo();

	// build the OAuth signature
	var message = {
		action: path,
		method: method,
		parameters: oauthParameters
	};
	OAuthReq.OAuth.completeRequest(message, credentials);

	// append the post body parameters to the URL if the HTTP method is a GET
	if(method == "GET"){
		var pathBits = [];
		for(key in this.postBody) {
			if (this.postBody.hasOwnProperty(key)) {
				key = OAuthReq.OAuth.percentEncode(key);
				var value = OAuthReq.OAuth.percentEncode(this.postBody[key]);
				pathBits.push("" + key + "=" + value);
			}
		}
		if(pathBits.length > 0){
			path = path + "?" + pathBits.join("&");
		}
		NgLogD("New URL: " + path);
	}

	// setup the request
	if ((typeof PlusRequest.mockXHR) == 'undefined') {
		this.request = new Network.XHR();
	} else {
		// Use mock NgXHR for tests
		this.request = PlusRequest.mockXHR;
	}

	this.request.open(message.method, path, true);

	// set the OAuth signature on the request
	this.request.setRequestHeader("Authorization", OAuthReq.OAuth.getAuthorizationHeader(undefined, message.parameters));

	// set some headers for the Plus+ servers
	var userAgent = "" + PlusRequest.appKey() + "/" + PlusRequest.appVersion() + " PlusPlus/" + PlusRequest.getPlatformVersion();
	this.request.setRequestHeader("User-Agent", userAgent);
	this.request.setRequestHeader("Accept", "application/binary-plist, application/json");

	// determine if this platform supports GZip in the HTTP response
	var supportsGZip = false;
	if (// TODO: gerald - workaround ngCapabilities bug for now
		(typeof Capabilities.getPlatformOS() == "undefined") ||
	    (Capabilities.getPlatformOS().toLowerCase() != 'android' && Capabilities.getPlatformOS().toLowerCase() != "flash")) {
		NgLogD("GZIP supported: " + Capabilities.getPlatformOS());
			supportsGZip = true;
	}
	this.request.setRequestHeader("Accept-Encoding", (supportsGZip ? "gzip" : ""));
	
	// TODO: Locale
	this.request.setRequestHeader("Accept-Language", "en_US");

	// iterate through the headers and set them on the request
	if(this.httpHeaders){
		for(key in this.httpHeaders) {
			if (this.httpHeaders.hasOwnProperty(key)){
				this.request.setRequestHeader(key, this.httpHeaders[key]);
			}
		}
	}
	
	// send the Analytics SID to the Plus server
	this.request.setRequestHeader("X-Stat-Session", CoreReq.Core.Analytics._getPipe().getMeta("sid"));

	// set the Etg, if one exists
	if(this.entityTag){
		this.request.setRequestHeader("If-None-Match", this.entityTag);
	}

	if(this._postData && this.httpMethod != "GET"){
		if(this.attachments.length > 0){
			// if we have attachments, generate multipart form data for the request
			var boundary = "---ABlkjasfdkjsdifsdf098asdfa3lka90aflallyourbasekjas09ds0fjasdkal3lj0sa";
			var newline = '\r\n';
			var boundaryLine = "--" + boundary + newline;

			var body = [];
			body.push(this._multipartPostBodyFromDataWithBoundary(this._postData, boundary));

			for(var index in this.attachments){
				var attachment = this.attachments[index];

				var type = attachment.type;
				if(!type) {
					type = "application/octet-stream";
				}

				body.push(boundaryLine);
				body.push("Content-Disposition: form-data; name=\"" + attachment.name + "\"; filename=\"" + attachment.filename + "\"" + newline);
				body.push("Content-Type: " + type + newline + newline);
				body.push(attachment.data);
				body.push(newline);
			}

			body.push("--" + boundary + "--" + newline);

			this._postData = body.join("");
			
			this.request.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);

		}else{
			// if we don't have attachments, generate encoded form data for the request
			if(!this.request.getRequestHeader("Content-Type")){
				this.request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			}
			this._postData = this._getStringRepresentationOfPostData();
		}
	}
	return this.request;
};

/**
 * Turns a data hash and a boundary string into a string of form data
 * @param data The hash of key/values to turn into form data
 * @param boundary A string boundary, defined in the multipart form data
 * @return The string representation of the data (this is not a complete multipart form-data body!)
 * @private
 */
PlusRequest.prototype._multipartPostBodyFromDataWithBoundary = function(data, boundary){
	var newline = '\r\n';
	var boundaryLine = "--" + boundary + newline;
	var buffer = [];
	for(var key in data){
		var value = data[key];
		buffer.push(boundaryLine);
		buffer.push("Content-Disposition: form-data; name=\"" + key + "\"" + newline + newline);
		buffer.push(value);
		buffer.push(newline);
	}
	return buffer.join("");
};

/**
 * Recursively turns a hash of data into a URL-encoded form string recursively.
 * WARNING: Do not include something that has a circular dependency, as this method will not detect it.
 * @param {Object} data The hash to turn into a URL-encoded form string
 * @return The URL-encoded form string
 * @private
 */
PlusRequest.prototype._getStringRepresentationOfPostData = function(data, previousKey){
	if(data === null){
		return "";
	}

	if(data === undefined){
		data = data || this.postBody;
	}

	var dataString = this._flattenedResultsForPostData(data, "");
	data = dataString.join("&");

	return data;
};

PlusRequest.prototype._flattenedResultsForPostData = function(data, prefix){
	var flattenedData = [];
	for(var key in data){
		if (data.hasOwnProperty(key)) {
			var value = data[key];
			if(prefix && prefix.length > 0){
				key = "" + prefix + "[" + key + "]";
			}

			NgLogD("Getting " + key + ": " + (typeof value));
			if(typeof value == "object"){
				flattenedData = flattenedData.concat(this._flattenedResultsForPostData(value, key));
			}else{
				flattenedData.push("" + key + "=" + value);
			}
		}
	}
	return flattenedData;
};

// cleanup
for(var key in PlusRequest.prototype){
	if (PlusRequest.prototype.hasOwnProperty(key)) {
		var fn = PlusRequest.prototype[key];
		fn.displayName = "PlusRequest." + key + "()";
	}
}

PlusRequest.noOp = function(){};

exports.PlusRequest = PlusRequest;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/oauth'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/oauth'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/oauth'] = exports; /*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here's some JavaScript software for implementing OAuth.

   This isn't as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: "GET", action: "http://server.com/path", parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [["a", 1], ["b", 2], ["a", 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: "GET", action: "http://server/path", parameters: {p: "x y"}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn't a valid OAuth request, since it lacks a signature etc.)
   Note that the object "x y" is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn't percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

    script src="OAuth.js?oauth_timestamp=<?=time()?>" ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var b64_hmac_sha1_req = require('NGCore/Client/Plus/sha1');

var OAuth;
if ((typeof OAuth == "undefined") || (OAuth === null)) { OAuth = {}; }

OAuth.setProperties = function setProperties(into, from) {
    if (into !== null && from !== null) {
        for (var key in from) {
			if (from.hasOwnProperty(key)) {
				into[key] = from[key];
			}
		}
    }
    return into;
};

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if ((typeof s == "undefined") || (s === null)) {
            return "";
        }
        if (s instanceof Array) {
            var e = "";
            for (var i = 0; i < s.length; ++s) {
                if (e !== "") {
					e += '&';
				}
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn't do
        // encodeURIComponent ignores: - _ . ! ~ * ' ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, "%21");
        s = s.replace(/\*/g, "%2A");
        s = s.replace(/\'/g, "%27");
        s = s.replace(/\(/g, "%28");
        s = s.replace(/\)/g, "%29");
        return s;
    },
    decodePercent: function decodePercent(s) {
        if (s !== null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, " ");
        }
        return decodeURIComponent(s);
    },
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if ((typeof parameters == "undefined") || (parameters === null)) {
            return [];
        }
        if (typeof parameters != "object") {
            return OAuth.decodeForm(parameters + "");
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
			if (parameters.hasOwnProperty(p)){
				list.push([p, parameters[p]]);
			}
        }
        return list;
    },
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if ((typeof parameters == "undefined") || (parameters === null)) {
            return {};
        }
        if (typeof parameters != "object") {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + ""));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p < parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    },
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p < parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    },
    formEncode: function formEncode(parameters) {
        var form = "";
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p < list.length; ++p) {
            var value = list[p][1];
            if ((typeof value == "undefined") || value === null) { value = ""; }
            if (form !== "") { form += '&'; }
            form += OAuth.percentEncode(list[p][0]) +
              '='+ OAuth.percentEncode(value);
        }
        return form;
    },
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split('&');
        for (var n = 0; n < nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp === "") {
                continue;
            }
            var equals = nvp.indexOf('=');
            var name;
            var value;
            if (equals < 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    },
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p < parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    },
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i < list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    },
    /** Fill in parameters to help construct a request message.
        This function doesn't fill in every parameter.
        The accessor object should be like:
        {consumerKey:'foo', consumerSecret:'bar', accessorSecret:'nurn', token:'krelm', tokenSecret:'blah'}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if ((typeof message.method == "undefined") || message.method === null) {
            message.method = "GET";
        }
        var map = OAuth.getParameterMap(message.parameters);
        if ((typeof map.oauth_consumer_key == "undefined") || map.oauth_consumer_key === null) {
            OAuth.setParameter(message, "oauth_consumer_key", accessor.consumerKey || "");
        }
        if ((typeof map.oauth_token == "undefined") || map.oauth_token === null && accessor.token !== null) {
            OAuth.setParameter(message, "oauth_token", accessor.token);
        }
        if ((typeof map.oauth_version == "undefined") || map.oauth_version === null) {
            OAuth.setParameter(message, "oauth_version", "1.0");
        }
        if ((typeof map.oauth_timestamp == "undefined") || map.oauth_timestamp === null) {
            OAuth.setParameter(message, "oauth_timestamp", OAuth.timestamp());
        }
        if ((typeof map.oauth_nonce == "undefined") || map.oauth_nonce === null) {
            OAuth.setParameter(message, "oauth_nonce", OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    },
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, "oauth_timestamp", OAuth.timestamp());
        OAuth.setParameter(message, "oauth_nonce", OAuth.nonce(6));
    },
    addToURL: function addToURL(url, parameters) {
        var newURL = url;
        if ((typeof parameters != 'undefined') && parameters !== null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length > 0) {
                var q = url.indexOf('?');
                if (q < 0) { newURL += '?'; }
                else       { newURL += '&'; }
                newURL += toAdd;
            }
        }
        return newURL;
    },
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = 'OAuth ';
		if(realm){
			parameters = parameters.slice();
			parameters.realm = realm;
		}
		var added = 0;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p < list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf("oauth_") === 0 || name.indexOf("realm") === 0) {
                header += (added++ === 0 ? '' : ',') + OAuth.percentEncode(name) + '="' + OAuth.percentEncode(parameter[1]) + '"';
            }
        }
        return header;
    },
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || "oauth_timestamp";
		return;
		/*
		 * 2010-10: gerald@ngmoco
		 *   This code will always return because there is no document
		 *   object in NGCore environment
		 *
        var scripts = document.getElementsByTagName('script');
        if (scripts === null || !scripts.length) { return; }
        var src = scripts[scripts.length-1].src;
        if (!src) { return; }
        var q = src.indexOf("?");
        if (q < 0) { return; }
        var parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t === null) { return; }
        OAuth.correctTimestamp(t);
		*/
    },
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    },
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    },
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = "";
        for (var i = 0; i < length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor !== null && previous !== null) {
        for (var key in previous) {
            if (key != "prototype") {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
};

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, "SignatureMethod", function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, "oauth_signature", signature);
        return signature; // just in case someone's interested
    },
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if ((typeof accessor.accessorSecret != 'undefined') &&
	        accessor.accessorSecret !== null &&
            name.length > 9 &&
            name.substring(name.length-9) == "-Accessor")
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret) +
             "&"+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: "lakjsdflkj...", consumerSecret: "QOUEWRI..", accessorSecret: "xcmvzc..."}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if ((typeof name == "undefined") || name === null || name === "") {
            name = "HMAC-SHA1";
            OAuth.setParameter(message, "oauth_signature_method", name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    },
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if ((typeof impl != "undefined") && (impl !== null)) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error("signature_method_rejected");
        var acceptable = "";
        for (var r in OAuth.SignatureMethod.REGISTERED) {
			if ( OAuth.SignatureMethod.REGISTERED.hasOwnProperty(r)) {
				if (acceptable !== "") {
					acceptable += '&';
				}
				acceptable += OAuth.percentEncode(r);
			}
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    },
    /** A map from signature method name to constructor. */
    REGISTERED : {},
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n < names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    },
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren't any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    },
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf('?');
        var parameters;
        if (q < 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a < toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase()) +
         '&'+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL)) +
         '&'+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    },
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == "http" && uri.port == 80) ||
                       (scheme == "https" && uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(":");
            if (index >= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = "/"; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + "://" + authority + path;
    },
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) { uri[o.key[i]] = m[i] || ""; }
        return uri;
    },
    normalizeParameters: function normalizeParameters(parameters) {
        if ((typeof parameters == 'undefined') || parameters === null) {
            return "";
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p < list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != "oauth_signature") {
                sortable.push([ OAuth.percentEncode(nvp[0]) +
                                " " + // because it comes before any character that can appear in a percentEncoded string.
                                OAuth.percentEncode(nvp[1]), nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] < b[0]) { return  -1; }
                          if (a[0] > b[0]) { return 1; }
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s < sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass(["PLAINTEXT", "PLAINTEXT-Accessor"],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass(["HMAC-SHA1", "HMAC-SHA1-Accessor"],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
			/*
			 * 2010-10: gerald@ngmoco:
			 *    Bad idea to set global of sha1.js like this, this bug
			 *    took a few hours to find!
            b64pad = '=';
			 */
            var signature = b64_hmac_sha1_req.b64_hmac_sha1(this.key, baseString, '=');
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}

// Exports for node.js
if((typeof exports != "undefined") && exports)
{
	exports.OAuth = OAuth;
}
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/Session'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/Session'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/Session'] = exports; var Storage = require('NGCore/Client/Storage').Storage;
var PlusRequestReq = require('NGCore/Client/Plus/PlusRequest');
var UserReq = require('NGCore/Client/Plus/User');
var CoreReq = require('NGCore/Client/Core');
var UpdaterReq = require('NGCore/Client/Plus/Updater');
var MessageEmitterReq = require('NGCore/Shared/MessageEmitter');
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;

var Session = exports.Session = MessageEmitterReq.MessageEmitter.subclass({
	classname: "Session",
	initialize: function(gameData){
		gameData = gameData || {};
		
		this._consumerKey = gameData._consumerKey || null;
		this._consumerSecret = gameData._consumerSecret || null;
		this._appName = gameData._appName || null;
		this._appVersion = gameData._appVersion || null;

		this.accessToken = null;
		this.accessTokenSecret = null;
		this.user = null;
	},
	loginWithExistingSession: function(cb){
		var session = this;
		Storage.KeyValueCache.local.getItem("com.ngmoco.plus.session.auth_token", function(err, auth_token){
			if(!auth_token){
				cb("No auth_token", session);
				return;
			}
			NgLogD("Logging in with existing session");

			var request = new PlusRequestReq.PlusRequest();
			request.setApiMethod("session");
			request.setHttpMethod("POST");
			var params = session._loginParameters();
			params.auth_token = auth_token;
			request.setPostBody(params);

			request.send(function(err, data, headers, status){
				session._handleLoginResponse(err, data, headers, status, cb);
			});
		});
	},
	loginWithUsernameAndPassword: function(username, password, cb){
		var session = this;
		var request = new PlusRequestReq.PlusRequest();
		request.setApiMethod("session");
		request.setHttpMethod("POST");
		var params = session._loginParameters();
		params.gamertag = username;
		params.password = password;
		request.setPostBody(params);

		var self = this;
		request.send(function(err, data, headers, status){
			self._handleLoginResponse(err, data, headers, status, cb);
		});
	},
	
	getSessionTokensForConsumerKey: function(consumerKey, cb){
		return PlusRequestReq.PlusRequest.getSessionTokensForConsumerKey(consumerKey, cb);
	},

	authenticatedUser: function(){
		return this.user;
	},
	appKey: function(){
		return this._appName;
	},
	appVersion: function(){
		return this._appVersion;
	},
	OAuthConsumerInfo: function(){
		return {
			token: this.accessToken,
			tokenSecret: this.accessSecret,

			consumerKey: this._consumerKey,
			consumerSecret: this._consumerSecret			
		};
	},
	/**
	 * Handles a login response by parsing and setting the User appropriately
	 * @private
	 */
	_handleLoginResponse: function(err, data, headers, status, cb){
        var session = this,
            oldUser = false; //is there a user that is being logged out.
		if(!err && data && data.success === true){
			this.accessToken = data.oauth_token;
			this.accessSecret = data.oauth_secret;

			NgLogD("UserLogin: Get user with data " + JSON.stringify(data.profile));
			var user = UserReq.User.getUserWithData(data.profile);
			if(!user){
				cb("Could not get user from good data", null);
				return;
			} else {
				oldUser = true;
				CoreReq.Core.Analytics._getPipe().sessionEndEvent();
			}

			UpdaterReq.Updater.stop();

            UserReq.User.setCurrentUser(user);
			this.user = user;
			
			this.emit({user: user});

            UpdaterReq.Updater.start();

			if (oldUser) {
				CoreReq.Core.Analytics._getPipe().initialize();
			}
			var auth_token = data.auth_token;
		    NgLogD("Setting local storage - 'com.ngmoco.plus.session.auth_token': '" + auth_token + "'");
		    Storage.KeyValueCache.local.setItem("com.ngmoco.plus.session.auth_token", auth_token, function(){
		    	cb(err, session);
		    });
		}else{
			err = data.error_msg;
			//err = data.error_msg;
			if(data && data.error_msg){
				err = data.error_msg;
			}
			cb(err, session);
		}
	},

	/**
	 * Gets the login parameters
	 * @return A hash of login parameters
	 * @private
	 */
	_loginParameters: function(){
		var devId = Capabilities.getUniqueId();
		var platformOS        = Capabilities.getPlatformOS();
		var platformOSVersion = Capabilities.getPlatformOSVersion();

		if (platformOS == "Mac OS" || platformOS == "flash") {
			platformOS = "flash";
			platformOSVersion = "4.1";
			devId = "2800B673-5927-5B58-895C-363C1260B309";
		}

		// TODO Locale
		// TODO Timezone
		return {
			timezone: "US/Pacific (PDT) offset -25200 (Daylight)",
			device_type: platformOS,
			os_version:  platformOSVersion,
			id: devId,
			locale: "en_US"
		};
	},
	
	end: function(){
		
	}
});

/*
 Begins a game session. This should be called when a game is launched. It sets
 all of the required fields needed for making requests to Plus and handles
 logging users in and out of Plus. 

 keys required: consumerKey, consumerSecret, appName, appVersion
*/
Session.beginGameSessionWithData = function(gameData, cb){
	if(!gameData){
		throw "Missing game data, cannot connect to Plus";
	}
	
	var consumerKey = gameData.consumerKey;
	var consumerSecret = gameData.consumerSecret;
	var appName = gameData.appName;
	var appVersion = gameData.appVersion;
	
	if(!consumerKey){
		throw "Missing consumerKey, cannot connect to Plus+";
	}
	
	if(!consumerSecret){
		throw "Missing consumerSecret, cannot connect to Plus+";
	}
	
	if(!appName){
		throw "Missing appName, cannot connect to Plus+";
	}
	
	if(!appVersion){
		throw "Missing appVersion, cannot connect to Plus+";
	}
	
	var session = new Session();
	session._consumerKey = consumerKey;
	session._consumerSecret = consumerSecret;
	session._appName = appName;
	session._appVersion = appVersion;
	
	Session._currentSession = session;
	
	session.loginWithExistingSession(cb || function(){});
	CoreReq.Core.Analytics.instantiate();
};

Session.endGameSession = function(){
	
};

Session.getCurrentSession = function(){
	return Session._currentSession;
};
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/sha1'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/sha1'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/sha1'] = exports; // THIS FILE EXISTS ONLY FOR COMPATIBILITY: Use req("./NGCore/Client/Core").SHA1 instead. Full word require omitted to avoid parsing

var SHA1 = require('NGCore/Client/Core/SHA1').SHA1;
exports.b64_hmac_sha1 = SHA1.b64_hmac_sha1;
exports.hex_sha1 = SHA1.hex_sha1;
exports.b64_sha1 = SHA1.b64_sha1;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/User'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/User'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/User'] = exports; var PlusRequestReq = require('NGCore/Client/Plus/PlusRequest');
var DataModelReq = require('NGCore/Client/Plus/DataModel');
var UserListReq = require('NGCore/Client/Plus/UserList');
var MessageEmitterReq = require('NGCore/Shared/MessageEmitter');
var sha1 = require('NGCore/Client/Plus/sha1');

var CurrentUserAuthTokenDefaultsKey = "com.ngmoco.authentication.auth_key";
var CurrentUserUsernameDefaultsKey = "com.ngmoco.authentication.username";
var CurrentUserAvatarDefaultsKey = "com.ngmoco.authentication.avatar_id";
var UserCacheDefaultsKey = "com.ngmoco.authentication.lastUserObject";
var PlatformCacheDBCurrentUserInstanceKey = "CurrentUser";
var PlatformCacheDBCurrentFriendsInstanceKey = "CurrentUserFriends";
var PlatformCacheDBCurrentFollowersInstanceKey = "CurrentUserFollowers";
//var PlatformCacheDBCurrentGamesInstanceKey = "CurrentGames";
var kUserKey = "user";
var kErrorKey = "error";
var kListKey = "list";
var kTargetKey = "target";
var kActionKey = "action";

var UserRecordIdKey = "user_id";

var User = DataModelReq.DataModel.subclass({
/** @lends Plus.User.prototype */
    classname: "User",
    initialize: function($super, recordID, dict) {
        $super(recordID);

		/*
		 * Email_hash is only returned in some cases. For example,
		 * when doing a search based on email hashes.  This code
		 * takes care not to overwrite any existing email_hash value.
		 */
		if ((typeof dict[User.EmailHashKey]) != 'undefined') {
			this.emailHash = dict[User.EmailHashKey];
        	if (this.emailHash) {
            	this.emailHash = this.emailHash.toLowerCase();
        	}
		}
        this.gamertag = dict[User.GamertagKey];
        this.avatarId = dict[User.AvatarKey];
        this.motto = dict[User.MottoKey];
        if (!this.motto || this.motto === null) {
            this.motto = "";
        }
        this.relation = dict[User.RelationKey];
        this.sparse = true;
    },
    addBuddy: function(buddyUser, cb) {
        var myUser = this;
        var request = new PlusRequestReq.PlusRequest();
        request.setApiMethod("users/" + myUser.recordID + "/buddies");
        request.setHttpMethod("POST");
        request.setPostBody({
            id: buddyUser.recordID,
            enemy: "false"
        });
        request.send(function(err, data) {
            cb(err, data);
        });
    },
    deleteBuddy: function(buddyUser, cb) {
        var myUser = this;
        var request = new PlusRequestReq.PlusRequest();
        request.setApiMethod("users/" + myUser.recordID + "/buddies/" +
        buddyUser.recordID);
        request.setHttpMethod("DELETE");
        request.send(function(err, data) {
            cb(err, data);
        });
    },
    getUserDetails: function(cb) {
        var myUser = this;
        var cachedUser = DataModelReq.DataModel.getObjectWithRecordID(User.classname, myUser.recordID);
        if ((cachedUser !== null) && (typeof cachedUser.sparse != 'undefined') &&
        (cachedUser.sparse === false)) {
            cb(undefined, cachedUser);
            return;
        }
        var request = new PlusRequestReq.PlusRequest();
        request.setApiMethod("users/" + myUser.recordID);
        request.setHttpMethod("GET");
		request.setEntityTag(this.entityTag);
        request.send(function(err, data, status, headers) {
            var user = null;
            if (!err) {
                if (status == 304) {
                    user = User.getUserWithRecordID(myUser.recordID);
                } else {
                    // Call getUserDataWithData to fetch any previously returned object
                    // instance, so "mutability property" can be maintained
                    user = User.getUserWithData(data);
                    user.photoId = data[User.PhotoKey];
                    if ((typeof user.photoId == "undefined") ||
                    (0 === user.photoId.length)) {
                        user.photoId = null;
                    }

                    // If any of these fields are empty, just set them to empty strings.
                    user.emailAddress = data[User.EmailAddressKey];
                    if (!user.emailAddress || null === user.emailAddress) {
                        user.emailAddress = "";
                    }

					/*
					 * Email_hash is only returned in some cases. For example,
					 * when doing a search based on email hashes.  This code
					 * takes care not to overwrite any existing email_hash value.
					 */
					if ((typeof data[User.EmailHashKey]) != 'undefined') {
						user.emailHash = data[User.EmailHashKey];
			        	if (user.emailHash) {
			            	user.emailHash = user.emailHash.toLowerCase();
			        	}
					}

                    user.phoneNumber = data[User.PhoneNumberKey];
                    if (!user.phoneNumber || null === user.phoneNumber) {
                        user.phoneNumber = "";
                    }

                    user.password = data[User.PasswordKey];

                    user.firstName = data[User.FirstNameKey];
                    user.lastName = data[User.LastNameKey];

                    user.hideFullName = data[User.PrivacyKey];
                    user.ageRestricted = data[User.AgeRangeKey];
                    user.isNewRelationship = data[User.NewBuddyKey];
                    user.isMutualFriend = data[User.IsMutualFriendKey];

                    //		        user.capabilities = [UserCapabilities objectFromCacheRepresentation:data[User.CapabilitiesKey]];
                    user.showsPresence = !data[User.HidePresenceKey];
                    user.onlyShowFriendNotifications = data[User.OnlyShowFriendNotificationsKey];

                    // gamerscore/level
                    user.gamerscore = data[User.GamerScoreKey] || 0;
                    user.gamerLevel = data[User.LevelNumberKey] || 0;
                    user.gamerLevelName = data[User.LevelNameKey];
                    user.gamerLevelScore = data[User.CurrentLevelScoreKey] || 0;
                    user.gamerNextLevelScore = data[User.NextLevelScoreKey] || 0;

                    // load games
                    if (data[User.GamesKey]) {
                        var thegames = [];
                        for (var gameDict in data[User.GamesKey]) {
                            if (data[User.GamesKey].hasOwnProperty(gameDict)) {
                                //						var game = new NGCore(gameDict);
                                //						thegames.push(game);
                                NgLogD("TODO: not implemented. would have loaded game" +
                                " at: " + gameDict);
                            }
                        }
                        user.games = thegames;
                    }
                    else {
                        user.games = [];
                    }

					user.entityTag = headers.etag;

                    user.sparse = false;
                    cb(undefined, user);
                }
            }
        });
    },
    getFollowersList: function(pageSize) {
        // Call getUserList to fetch any previously returned object
        // instance, so "mutability property" can be maintained
        var list = UserListReq.UserList.getUserList(this.recordID, "followers", pageSize);
        return list;
    },
    getBuddiesList: function(pageSize) {
        // Call getUserList to fetch any previously returned object
        // instance, so "mutability property" can be maintained
        var list = UserListReq.UserList.getUserList(this.recordID, "buddies", pageSize);
        return list;
    }
});

DataModelReq.DataModel.defineSetterCallbacks(User, [
	"gamertag",
	"avatarId",
	"motto",
	"relation",
	"sparse",
	"photoId",
	"emailAddress",
	"emailHash",
	"phoneNumber",
	"password",
	"firstName",
	"lastName",
	"hideFullName",
	"ageRestricted",
	"isNewRelationship",
	"isMutualFriend",
	"showsPresence",
	"onlyShowFriendNotifications",
	"capabilities",
	"gamerscore",
	"gamerLevel",
	"gamerLevelName",
	"gamerLevelScore",
	"gamerNextLevelScore",
	"games"
]);

User._loopUsersDetails = function(cb, err, total, offset, pagesize, users, retlist) {
    if (users.length <= 0) {
        cb(err, retlist, total, offset, pagesize);
        return;
    }
    var myUser = users.pop();
    if (myUser.sparse) {
        var loopUsersCl = function(err2, user) {
            if (!err2) {
                retlist.unshift(user);
                User._loopUsersDetails(cb, err, total, offset, pagesize, users, retlist);
            } else {
                // NOTE: currently system returns last error, previous errors
                // are simply not available
                retlist.unshift(myUser);
                User._loopUsersDetails(cb, err2, total, offset, pagesize, users, retlist);
            }
        };
        myUser.getUserDetails(loopUsersCl);
    } else {
        retlist.unshift(myUser);
        User._loopUsersDetails(cb, err, total, offset, pagesize, users, retlist);
    }
};

User.findUsersWithEmailHashes = function(hashes, cb){
	var batches = [];
	while(hashes.length > 0){
		if(hashes.length > 100){
			batches.push(hashes.splice(0,100));
		}else{
			batches.push(hashes.splice(0, hashes.length));
		}
	}
	
	var requests = 0;
	var results = [];
	var requestCallback = function(err, users){
		requests--;
		for(var idx=0; idx<users.length; idx++){
			results[users.offset + idx] = users[idx];
		}
		
		if(requests === 0){
			cb(err, results);
		}
	};
	
	for(var idx=0; idx < batches.length; idx++){
		var batch = batches[idx];
		var batchString = batch.join(",");
		requests++;

		User.findUsersWithEmail(batchString, requestCallback);
	}
};

User.findUsersWithEmail = function(email, cb){
	var request = new PlusRequestReq.PlusRequest();
	request.setHttpMethod("GET");
	request.setApiMethod("users/search");
	request.setPostBody({
		email_hash: User.emailAddressLooksValid(email) ? User.hashForEmail(email) : email
	});

	request.send(function(err, data){
		if(!(data && !err && data.success === true)){
			data = {profiles: [], total: 0, offset: 0};
		}
		var profiles = data.list;
		var users = [];

		for(var idx in profiles){
			var profile = profiles[idx];
			var user = User.getUserWithData(profile);
			users.push(user);
		}

		users.offset = data.offset;
		users.total = data.total;

		cb(err, users);
	});
};

User.findUsersFromContactList = function(contacts, cb){
	var hashes = [];
	var hashesToContacts = {};
	for(var contactIdx in contacts){
		var contact = contacts[contactIdx];
		var emails = contact.lowercaseEmails || [];
		for(var emailIdx=0; emailIdx < emails.length; emailIdx++){
			var email = emails[emailIdx];
			var hash = User.hashForEmail(email);
			
			if(!hashesToContacts[hash]){
				hashesToContacts[hash] = [];
				hashes.push(hash);
			}

			hashesToContacts[hash].push(contact);
		}
	}
	
	User.findUsersWithEmailHashes(hashes, function(err, users){
		for(var idx=0; idx<users.length; idx++){
			var user = users[idx];
			var hash = user.emailHash;
			
			var userContacts = hashesToContacts[hash];
			for(var contactIdx = 0; contactIdx < userContacts.length; contactIdx++){
				var userContact = userContacts[contactIdx];
				user.displayName = userContact.displayName;
				contacts.splice(contacts.indexOf(userContact), 1);
			}
		}
		
		cb(err, contacts, users);
	});
};

User.emailAddressLooksValid = function(email){
	return email.match(/\b[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b/);
};

User.hashForEmail = function(email){
	return sha1.hex_sha1(email);
};

User.sendFriendInviteToEmail = function(email, cb){
	var request = new PlusRequestReq.PlusRequest();
	request.setHttpMethod("POST");
	request.setApiMethod("invitations");
	request.setPostBody({
		email: email
	});

	request.send(cb);
};

User.GamertagKey = "gamertag";
User.AvatarKey = "badge_id";
User.MottoKey = "motto";
User.RelationKey = "relation";
User.FirstNameKey = "first_name";
User.LastNameKey = "last_name";
User.BirthdateKey = "birth_date";
User.GenderKey = "gender";
User.PrivacyKey = "fullname_privacy";
User.PhotoKey = "photo_url";
User.EmailAddressKey = "email";
User.EmailHashKey = "email_hash";
User.PhoneNumberKey = "phone_number";
User.AgeRangeKey = "age_restricted";
User.SpamKey = "opt_in";

User.PasswordKey = "password";
User.PasswordConfirmKey = "password_confirmation";
User.GamesKey = "games";
User.CapabilitiesKey = "capabilities";
User.NewBuddyKey = "new_buddy";
User.IsMutualFriendKey = "mutual_friends";
User.HidePresenceKey = "hide_presence";
User.OnlyShowFriendNotificationsKey = "friend_only_notification";

User.GamerScoreKey = "gamerscore";
User.LevelNumberKey = "level_position";
User.LevelNameKey = "level_name";
User.CurrentLevelScoreKey = "level_points";
User.NextLevelScoreKey = "level_next_points";

// properties that are not returned in sparse search results
User.NonSparseKeys = [User.PhotoKey, User.EmailAddressKey,
User.EmailHashKey, User.PhoneNumberKey, User.PasswordKey,
User.FirstNameKey, User.LastNameKey, User.PrivacyKey,
User.AgeRangeKey, User.NewBuddyKey, User.IsMutualFriendKey,
User.CapabilitiesKey, User.HidePresenceKey,
User.OnlyShowFriendNotificationsKey, User.GamerScoreKey,
User.LevelNumberKey, User.LevelNameKey, User.CurrentLevelScoreKey,
User.NextLevelScoreKey, User.GamesKey];

User._currentUser = null;
User._emitter = null;

User.currentUser = function() {
    return User._currentUser;
};

User.setCurrentUser = function(user) {
    User._currentUser = user;

	if(User._emitter){
		User._emitter.emit({user: user});
	}
};

User.addCurrentUserListener = function(listener, callback, priority){
	if(!User._emitter){
		User._emitter = new MessageEmitterReq.MessageEmitter();
	}
	
	User._emitter.addListener(listener, callback, priority);
};

User.removeCurrentUserListener = function(listener){
	if(User._emitter){
		User._emitter.removeListener(listener);
	}
};

User.getUserWithData = function(data) {
    var recordID = data[UserRecordIdKey];
    var cachedUser = DataModelReq.DataModel.getObjectWithRecordID(User.classname, recordID);
    if (cachedUser !== null) {
        return cachedUser;
    }

    var user = new User(recordID, data);
    // Enter this user object into the cache to maintain 'mutability' property
    cachedUser = user._registerWithLocalCache();
    return cachedUser;
};

exports.User = User;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/Updater'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/Updater'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/Updater'] = exports; var ClassReq = require('NGCore/Client/Core/Class');
var DataModelReq = require('NGCore/Client/Plus/DataModel');
var PlusRequestReq = require('NGCore/Client/Plus/PlusRequest');

var kDefaultMinRefreshInterval = 5;
var kDefaultMaxRefreshInterval = 240;

var Updater = exports.Updater = ClassReq.Class.singleton({
	classname: "Updater",
	_running: false,
	_requestedIntervals: {}, // map: interval -> count

	_updateTimer: {
		uid: null,
		time: null
	},
	_updateInterval: {
		minimum: kDefaultMinRefreshInterval,
		maximum: kDefaultMaxRefreshInterval,
		current: kDefaultMinRefreshInterval
	},
	initialize: function(){
		
	},
	start: function(){
		if(!this._running){
			this._running = true;
			this._scheduleCheck();
		}
	},
	stop: function(){
		if(this._running){
			this._running = false;
			this._stopTimer();
		}
	},
	checkNow: function(){
		NgLogD("PlusUpdater: Checking");
		this._stopTimer();
		
		var request = new PlusRequestReq.PlusRequest();
		request.setApiMethod("user_updates");
		request.setHttpMethod("GET");
		request.send(this.bind(this.handleUpdates));
	},
	handleUpdates: function(err, data){
		if(data && data.success){
			this._updateInterval.minimum = (data.update_interval || this._updateInterval.minimum);
			
			var onlineUsers = [];
			for(var idx in data.online_friends){
				var userID = data.online_friends[idx];
				onlineUsers.push(DataModelReq.DataModel.getObjectWithRecordID("User", userID));
			}

			// TODO set online users somewhere
			
			// TODO handle data.updates
			
			if(data.update_interval){
				this._updateInterval.minimum = data.update_interval;
			}
			
			this._recalculateInterval();
			this._scheduleCheck();
		}
	},
	updateInterval: function(){
		var interval = this._updateInterval;
		return (interval.current > interval.minimum ? interval.current : interval.minimum);
	},
	pushUpdateInterval: function(interval){
		var count = (this._requestedIntervals[interval] || 0);
		this._requestedIntervals[interval] = count + 1;
		this._recalculateInterval();
	},
	popUpdateInterval: function(interval){
		var count = this._requestedIntervals[interval];
		if(count){
			this._requestedIntervals[interval] = count - 1;
		}
		this._recalculateInterval();
	},
	_scheduleCheck: function(time){
		if(!time) time = this._updateInterval.current;
		
		this._stopTimer();
		
		var self = this;
		this._updateTimer.uid = setTimeout(function(){
			self.checkNow();
		}, time * 1000);
		NgLogD("PlusUpdater: Updating in " + time + "s");
	},
	_stopTimer: function(){
		if(this._updateTimer.uid){
			clearTimeout(this._updateTimer.uid);
			this._updateTimer.uid = null;
		}
	},
	_recalculateInterval: function(){
		var previousInterval = this.updateInterval();

		// find the shortest interval
		var minimum = kDefaultMaxRefreshInterval;
		for(var index = 0; index < this._requestedIntervals.length; index++){
			var interval = this._requestedIntervals[index];
			if(interval < minimum){
				minimum = interval;
			}
		}
		
		this._updateInterval.current = minimum;
		
		// reset the timer if necessary
		var newInterval = this.updateInterval();
		if(newInterval < previousInterval){
			
		}
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/DataModel'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/DataModel'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/DataModel'] = exports; var ClassReq = require('NGCore/Client/Core/Class');
var MessageEmitterReq = require('NGCore/Shared/MessageEmitter');
var FileSystemReq = require('NGCore/Client/Storage/FileSystem');

/**
 * DataModel is super class for data that can be fetched from Plus+ API.
 *
 * Mutability Property:  instances of DataModel are "mutable".  This means
 * that:
 *
 * - request for same object will return the same pointer
 *
 * - when an action results in an updated object, all existing pointer(s)
 *   to that object will see the updated values (beacuse those pointers
 *   point to the same instance)
 *
 * This design means this restriction: never use 'new' method to get
 * a data model object.  Instead, always use the public API methods.  Note
 * also that this design takes advantage of the fact that JavaScript
 * is single-threaded and event-driven.  This design will break if
 * somehow the JavaScript application is no longer single-threaded.
 *
 * This design gives this advantage:  UI code holding onto object pointers can
 * simply render the values from those objects, and they are the most
 * up-to-date value that client library currently keeps.  This simplicity makes
 * it easier for developers.
 *
 * @class DataModel
 */
var DataModel = MessageEmitterReq.MessageEmitter.subclass({
/** @lends Plus.DataModel.prototype */
	classname: "DataModel",
	entityTag: null,
	initialize: function($super, recordID){
		$super();
		this.recordID = recordID;
	},
//  cache utils
	_classname: function(){
		var classname = this.classname;
		return classname;
	},
	_registerWithLocalCache: function(){
		var classname = this._classname();
		var category = DataModel._localCache[classname];
		if(!category){
			category = {};
			DataModel._localCache[classname] = category;
		}

		var object = category[this.recordID];
		if(object){
			return object;
		}else{
			category[this.recordID] = this;
			return this;
		}
	},
	_deregisterWithLocalCache: function(){
		var classname = this._classname();
		var category = DataModel._localCache[classname];
		if(category){
			category[this.recordID] = undefined;
		}
	},
	_existsInLocalCache: function(){
		var classname = this._classname();
		var category = DataModel._localCache[classname];
		return (category && (category[this.recordID] == this));
	},
	_serializedHash: function(){
		var theClass = this.constructor;
		var hash = {classname: theClass.classname, recordID: this.recordID,  data: {}};
		
		var properties = this.constructor._serializableProperties || [];
		for(var idx = 0; idx < properties.length; idx++){
			var propertyName = properties[idx];
			var propertyValue = this[propertyName];
			
			if(propertyValue instanceof(DataModel)){
				propertyValue = propertyValue._serializedHash();
			}
			
			hash.data[propertyName] = propertyValue;
		}
		
		return hash;
	},
	_deserializeFromHash: function(hash){
		var classname = hash.classname;
		var data = hash.data;
		for(var key in data){
			var value = data[key];
			if(value && value.hasOwnProperty && value.hasOwnProperty("classname") && value.hasOwnProperty("data") && value.hasOwnProperty("recordID")){
				var theClassname = value.classname;
				var theClass = DataModel._subclasses[theClassname];
				var theRecordID = value.recordID;
				if(theClass && theRecordID){
					var theInstance = DataModel.getObjectWithRecordID(theClassname, theRecordID);
					if(!theInstance){
						theInstance = new theClass(theRecordID);
					}
					
					theInstance._deserializeFromHash(value.data);
					theInstance._registerWithLocalCache();

					value = theInstance;
				}
			}
			this[key] = value;
		}
	}
});

DataModel._subclasses = {};

var oldSubclass = DataModel.subclass;
DataModel.subclass = function(hash){
	var name = hash.classname;
	
	var theClass = oldSubclass.call(DataModel, hash);
	
	DataModel._subclasses[name] = theClass;
	return theClass;
};

DataModel.defineSetterCallbacks = function(theClass, names){
	for(var idx=0; idx<names.length; idx++){
		var idxName = names[idx];
		
		(function(name){
			theClass.prototype.__defineSetter__(name, function(value){
				this["___" + name] = value;
				this.emit({name: value});
			});
			theClass.prototype.__defineGetter__(name, function(value){
				return this["___" + name];
			});
		})(idxName);
	}
	
	theClass._serializableProperties = names;
};

DataModel._localCache = {};

DataModel.getObjectWithRecordID = function(classname, recordID){
	var category = DataModel._localCache[classname];
	if(category){
		return category[recordID] || null;
	}else{
		return null;
	}
};

DataModel._saveCachedObjects = function(path, cb){
	var hashes = [];
	for(var theClassname in DataModel._localCache){
		var category = DataModel._localCache[theClassname];
		for(var recordID in category){
			var object = category[recordID];
			var hash = object._serializedHash();
			hashes.push(hash);
		}
	}
	
	var data = JSON.stringify(hashes);
	FileSystemReq.FileSystem.writeFile(path, data, false, function(err){
		if(err){
			NgLogD("Plus.DataModel: Couldn't save cache " + JSON.stringify(err));
 		}
		cb(err);
	});
};

DataModel._loadCachedObjects = function(path, cb){
	FileSystemReq.FileSystem.readFile(path, false, function(err, data){
		if(err){
			NgLogD("Plus.DataModel: Couldn't load cache " + JSON.stringify(err));
			cb(err);
			return;
		}
		
//		NgLogD("Loading cached objects from " + path + ": " + data);
		
		var hashes = JSON.parse(data);
		var objects = [];
		
		for(var idx = 0; idx < hashes.length; idx++){
			var hash = hashes[idx];
//			NgLogD("Loading cached object from hash: " + JSON.stringify(hash));
			if(hash.hasOwnProperty("classname") && hash.hasOwnProperty("data") && hash.hasOwnProperty("recordID")){
				var theClassname = hash.classname;
				var theClass = DataModel._subclasses[theClassname];
				var theRecordID = hash.recordID;
//				NgLogD("Loading cached class " + theClassname + " with record ID " + theRecordID + "(" + theClass + ")");
				if(theClass && theRecordID){
					var theInstance = DataModel.getObjectWithRecordID(theClassname, theRecordID);
					if(!theInstance){
//						NgLogD("Generating new " + theClassname + " instance with record ID " + theRecordID);
						theInstance = new theClass(theRecordID, {});
					}

					theInstance._deserializeFromHash(hash);
					theInstance._registerWithLocalCache();
				}
			}
		}
		
		cb(null);
	});
};

exports.DataModel = DataModel;
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Plus/UserList'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Plus/UserList'] || {}; $MODULE_REGISTRY['NGCore/Client/Plus/UserList'] = exports; var DataModelReq = require('NGCore/Client/Plus/DataModel');
var PlusRequestReq = require('NGCore/Client/Plus/PlusRequest');
var UserReq = require('NGCore/Client/Plus/User');

var UserList = DataModelReq.DataModel.subclass({
/** @lends Plus.UserList.prototype */
	classname: "UserList",
    initialize: function($super, userid, relation, pageSize) {
        var recordID = userid + "--" + relation + "--" + pageSize;
        $super(recordID);
		this._userid = userid;
		this._relation = relation;
        this._pageSize = pageSize;
    },
	getUserListPage: function(pageNum, fieldlist, cb) {
		if(!pageNum) { pageNum = 0; }
		if(!fieldlist) { fieldlist = []; }
		
		var sparseMode = true;
		for (var key in fieldlist) {
			if (fieldlist.hasOwnProperty(key)) {
				var field = fieldlist[key];
				if (UserReq.User.NonSparseKeys.indexOf(field) > -1) {
					sparseMode = false;
					break;
				}
			}
		}
		
		var self = this;

		/*
		 * TODO - currently there is no cache check for friend / buddy
		 * list results.  If they do become cached they should maintain 'mutabiblity
		 * property' because DataModel is caching them.
		 *
		 * Also need to
		 * investigate what triggers cache invalidation:  maybe game restart,
		 * maybe hints from user_update?
		 */
	    var request = new PlusRequestReq.PlusRequest();
        var params = {
			slim: false,
        	relation: this._relation,
        	offset: (pageNum * this._pageSize),
        	count: this._pageSize
        };
	    request.setApiMethod("users/" + this._userid + "/buddies");
	    request.setHttpMethod("GET");
		request.setEntityTag(this.entityTag);
		request.setPostBody(params);
	    request.send(function(err, data, headers, status) {
            if (!err) {
                var success = data.success && data.list.length > 0;
                if (success) {
                    var retlist = [];
                    for (var idx in data.list) {
                        if (data.list.hasOwnProperty(idx)) {
                            var item = data.list[idx];
                            var userObj = UserReq.User.getUserWithData(item);
                            retlist.push(userObj);
                        }
                    }
					
					self._usersInfo = {
						users: retlist,
						total: data.total,
						offset: data.offset
					};
					self.entityTag = headers.etag;
					
					if (sparseMode) {
                		cb(err, self._usersInfo.users, self._usersInfo.total, self._usersInfo.offset, self._pageSize);
					} else {
						UserReq.User._loopUsersDetails(cb, err, data.total, data.offset, self._pageSize, retlist, []);
					}
                    return;
                }else if(status == 304){
            		cb(null, self._usersInfo.users, self._usersInfo.total, self._usersInfo.offset, self._pageSize);
				}
            }
            cb(err, null, null, null, null);
		});
	}
});

// helper function to get a 'mutable' object
UserList.getUserList = function(userid, relation, pageSize) {
    var recordID = userid + "--" + relation + "--" + pageSize;
	var cachedUserList = DataModelReq.DataModel.getObjectWithRecordID(UserList.classname, recordID);
	if (cachedUserList !== null) {
		return cachedUserList;
	}

	var list = new UserList(userid, relation, pageSize);
	// Enter this user object into the cache to maintain 'mutability' property
	cachedUserList = list._registerWithLocalCache();
    return cachedUserList;
};

exports.UserList = UserList;
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeAnimController'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeAnimController'] || {}; $MODULE_REGISTRY['weEngine/WeAnimController'] = exports; /////////////////////////////////////////////////////////////////////////////
/// @file:      WeAnimController.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     Some items require some type of "animation".  This controller
///             will handle such requests
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Class: WeScalAnimMgr 

var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;

var gYOffsetVariance = 0.5;
var gScaleAnimFrameFactor = 30;



exports.WeScaleAnimSyncronizer = Core.Class.singleton(
{
	classname: "WeScaleAnimSyncronizer",
	
    initialize: function()
    {
        this.mDefs = {};
    },
    
    RegisterDef : function(def)
    {
        var key = '' + def.mValueX + '' + def.mValueY + '' + def.mTime;
        if(!Exists(this.mDefs[key]))
        {
            this.mDefs[key] = def;
        }
        return this.mDefs[key];
    },
    
    Update : function()
    {
        var tick = Core.Time.getFrameTime();

        if (!Exists(this.mLastFrameTime))
        {
            this.mLastFrameTime = Core.Time.getFrameTime();
        }

        if (tick < this.mLastFrameTime + gScaleAnimFrameFactor)
        {
            return;
        }
        this.mLastFrameTime = tick;
        
                
        for(var defKey in this.mDefs)
        {
            if (this.mDefs.hasOwnProperty(defKey))
            {
                var def = this.mDefs[defKey];
                var updateX = false;
                var updateY = false;
                var x = def.mScaleX;
                var y = def.mScaleY;
                var yOffset = 0;
                if(def.mGrowing)
                {
                    if(def.mScaleX < def.mValueX)
                    {
                        x += def.mTime;
                        updateX = true;
                        if (x > def.mValueX)
                        {
                            x = def.mValueX;
                        }
                    }
                    if(def.mScaleY < def.mValueY)
                    {
                        y += def.mTime;
                        updateY = true;
                        if (y > def.mValueY)
                        {
                            y = def.mValueY;
                        }
                    }
                    def.mYOffset = -gYOffsetVariance; 
                }
                else
                {
                    if(def.mScaleX > def.mBaseX)
                    {
                        x -= def.mTime;
                        updateX = true;
                        
                        if (x < def.mBaseX)
                        {
                            x = def.mBaseX;
                        }
                    }
                    if(def.mScaleY > def.mBaseY)
                    {
                        y -= def.mTime;
                        updateY = true;
                        if (y < def.mBaseY)
                        {
                            y = def.mBaseY;
                        }
                    }
                    def.mYOffset = gYOffsetVariance; 
                }
                def.mScaleX = x;
                def.mScaleY = y;
                if( !updateX && !updateY)
                {
                    def.mGrowing = !def.mGrowing;
                }
            }
        }
    }
});

var WeScaleAnimSyncronizer = require('weEngine/WeAnimController').WeScaleAnimSyncronizer;

/////////////////////////////////////////////////////////////////////////////
/// @class: WeScaleAnimController

exports.WeScaleAnimController = Core.Class.subclass(
{
	classname: "WeScaleAnimController",
	
    initialize: function(_FactoryMethod)
    {
    	this.mFactoryMethod=_FactoryMethod;
    },
    
    /////////////////////////////////////////////////////////////////////////////
    /// @method: Shutdown
    destroy : function()
    {
        if(null !== this.mItem)
        {
            this.mItem.destroy(); 
        }
    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: Init
    /// @param itemType JSON def for the item to fill in scroll controller
    /// @param dataSource the source to populate the item struct with (which proto_TYPE)
    //          to pull from
    /// @param dataType the "type" of data we want from the data source
    /// @param numRows  the number of rows the Scroll List should have
    /// @param the number of columns the scroll list should have
    /// @param Parent object to attach the scroll list to
    Init : function(itemDef, container, X, Y, time)
    {
        this.mContainer = container;
        //this.mValueX = X;
        //this.mValueY = Y;
        //this.mBaseX = 1.0;
        //this.mBaseY = 1.0;
        //this.mTime = time;
        // This is really crappy but oh well.  The container will be attached to a composite,
        // and a composites parent will be the widget this is attached to, and the widgets
        // parent should be the root object attached this guy.. $TODO figure a better way
        // of doing this...
        this.mObjSource = container.source;
        this.mItemType = itemDef;
        //this.mGrowing = true;

        var defRef = {};
        defRef.mValueX = X;
        defRef.mValueY = Y;
        defRef.mBaseX = 1.0;
        defRef.mBaseY = 1.0;
        defRef.mTime = time;
        defRef.mScaleX = 1.0; 
        defRef.mScaleY = 1.0;
        defRef.mYOffset = 0;
        defRef.mGrowing = true;

        this.mDefRef = WeScaleAnimSyncronizer.RegisterDef(defRef);
    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: Display
    Display : function()
    {
    	this.mItem = this.mFactoryMethod(this.mItemType, this.mObjSource, this.mContainer);
    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: StartAnim
    WStartAnim : function()
    {

    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: StopAnim
    StopAnim : function()
    {

    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: ResetAnim
    ResetAnim : function()
    {

    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: OnControllerUpdate
    OnControllerUpdate : function()
    {
        var p = this.mContainer.getParent();
        var adjustedScale = 1 / WeRenderDevice.GetScaleRoot().GetScale().getX();
        var newX = this.mDefRef.mScaleX*adjustedScale;
        var newY = this.mDefRef.mScaleY*adjustedScale;
        var position = p.getPosition();
        p.setScale(newX, newY);
        p.setPosition(position.getX(), position.getY() + this.mDefRef.mYOffset);

    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeScrollArea'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeScrollArea'] || {}; $MODULE_REGISTRY['weEngine/WeScrollArea'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-23
 *  @file:      WeScrollArea.js
 *  @author:    Jon Guest
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var ScrollArea = require('weEngine/ScrollArea').ScrollArea;

exports.WeScrollArea = Core.MessageListener.subclass(
{
	classname: 'WeScrollArea',
	
    initialize : function(parent, controller_frame, asset_size, orientation)
    {
    	//NgLogD("WeScrollArea addListener ");
    	Core.UpdateEmitter.addListener(this, this.onUpdate);
		//The scroller
		this.mWidgetList = [];
		this.mGL2List = [];
		this.mAnimList = [];
		this.mNotifyChildrenOfMove = false;
		this.mLastPositionId = "";
		this.mScrollPosition = new Core.Point([0,0]);
		this.mFrame = new Core.Rect(controller_frame);
		this.mScrollArea = new ScrollArea(controller_frame, asset_size);
		this.mScrollArea.setDepth(0);
		this.mScrollArea.getContentNode().setPosition([0,0]);
		parent.addChild(this.mScrollArea);
		this.mScrollArea.setScrollPosition([1.0,0.5]);
		if (Exists(orientation))
		{
			if(orientation == "vertical")
			{
				this.mScrollArea.setScrollDirection(ScrollArea.ScrollDirection.Vertical);
			}
			else
			{
				this.mScrollArea.setScrollDirection(ScrollArea.ScrollDirection.Horizontal);
			}
		}
		//Core.UpdateEmitter.addListener(this, this.onUpdate);
		//var self=this;
		//this.mScrollArea.setUpdateListener( function(delta){ self.onUpdate(delta); });
    },
    destroy : function()
    {	
		if (this.mLastPositionId != "")
		{
			WeUiMgr.SetLastScrollPosition(this.mLastPositionId, this.mScrollArea.getScrollPosition());
		}
		this.mScrollArea.destroy();
		for (var i = 0; i < this.mWidgetList.length; i++)
		{
			if (Exists(this.mWidgetList[i].destroy))
			{
				this.mWidgetList[i].destroy();
			}
		}
		if(this.scroll_indicator)
		{
			this.scroll_indicator.destroy();
			this.scroll_indicator=null;
		}
		for (var i = 0; i < this.mGL2List.length; i++)
		{
			this.mGL2List[i].destroy(); 
		}
		delete this.mGL2List;
		
		for (var i = 0; i < this.mAnimList.length; i++)
		{
			this.mAnimList[i].destroy(); 
		}
		delete this.mAnimList;
		
		//NgLogD("------------!!!!!!!!------WeScrollArea done shutting down------!!!!!!!!-------------")
    },
    
    UpdateScrollIndicator: function()
    {
		if(this.scroll_indicator)
		{
			var scroll_position = this.mScrollArea.getScrollPosition();
			var maxX=0;
			var minX=this.mScrollArea.frame.getSize().getWidth() - this.mScrollArea._contentSize.getWidth();
			var progress=(scroll_position.getX()-minX)/ (maxX-minX);
			var progressNoClamp=progress;
			progress = Clamp(1.0-progress, 0.0, 1.0);
			
			var nCenterWidth=  -minX / this.scroll_indicator.xWidth;
			var scroller_center= this.scroll_indicator.xController.xChildren[1];
			var scroller_start= this.scroll_indicator.xController.xChildren[0];
			var scroller_end= this.scroll_indicator.xController.xChildren[2];
			var allWidth=scroller_center.GetWidth()+scroller_start.GetWidth()+scroller_end.GetWidth();
			if(nCenterWidth< 1)
			{
				this.scroll_indicator.GetGL2().setVisible(false);
			}
			else if( nCenterWidth>1 )
			{
				nCenterWidth= this.scroll_indicator.xWidth / nCenterWidth;
				if(nCenterWidth<allWidth)
				{
					nCenterWidth=allWidth;
				}
			}
			var scrool_start= this.scroll_indicator.xPosX - nCenterWidth*0.5;
			var scrool_end= this.scroll_indicator.xPosX-this.scroll_indicator.xWidth + nCenterWidth*0.5;

			scroller_center.SetWidthUsingScale(nCenterWidth);
			scroller_start.SetPosition( -nCenterWidth*0.5-scroller_start.GetWidth()*0.5, scroller_start.GetY());
			scroller_end.SetPosition( nCenterWidth*0.5+scroller_end.GetWidth()*0.5, scroller_end.GetY() );
			
			var scroll_indicatorX= scrool_start+ (scrool_end-scrool_start)*(1.0-progressNoClamp);
			this.scroll_indicator.GetGL2().setPosition(-scroll_indicatorX, this.scroll_indicator.xPosY);
		}    	
    },
    
	// Returns widget and x,y offset, does proper wrap-around for wheel-scroller
	getWidget : function(i)
	{
		var wheel = true;
		var horizontal = this.mScrollArea.getScrollDirection() == ScrollArea.ScrollDirection.Horizontal;
		if(wheel)
		{
			var length = 0;
			if(horizontal)
				length = this.mScrollArea.frame.getSize().getWidth() - this.mScrollArea._contentSize.getWidth();
			else
				length = this.mScrollArea.frame.getSize().getHeight() - this.mScrollArea._contentSize.getHeight();

			var n_items = this.mWidgetList.length;

			var idx = i % n_items;
			if(idx < 0)
				idx = length + idx;

			var widget = this.mWidgetList[idx];
			var offset = Math.floor(i / n_items)

			var x = 0;
			var y = 0;
			if(horizontal)
				x = offset * length;

			return [widget, x, y];
		}
		return [this.mWidgetList[i], 0, 0];
	},

	onUpdate : function()
	{	
		// iterate through the widgets in this control and turn them on/off based on if they're in the frame
		var count = this.mWidgetList.length;
		var scroll_position = this.mScrollArea.getScrollPosition();
		
		this.UpdateScrollIndicator();
		
		var notify_children = false;
		if (this.mNotifyChildrenOfMove)
		{
			// check for movement - if so, lets tell the child components
			if (this.mScrollPosition.getX() != scroll_position.getX() ||
				this.mScrollPosition.getY() != scroll_position.getY())
			{
				notify_children = true;
				this.mScrollPosition.setAll(scroll_position.getX(), scroll_position.getY());
			}
		}
		
		for (var i in this.mWidgetList)
		{
			var w = this.getWidget(i);
			var widget = w[0];
			var off_x = w[1];
			var off_y = w[2];

			var x = off_x + (widget.mX + scroll_position.getX()) - (widget.xWidth * 0.5);
			var y = off_y + (widget.mY + scroll_position.getY()) - (widget.xHeight * 0.5);
	
			var widgetRect = new Core.Rect(new Core.Point(x,y), new Core.Size(widget.xWidth, widget.xHeight));
			// check to see if our rectangles intersect
			if (widgetRect.getMinY() > this.mFrame.getMaxY() || widgetRect.getMaxY() < this.mFrame.getMinY() ||
			    widgetRect.getMinX() > this.mFrame.getMaxX() || widgetRect.getMaxX() < this.mFrame.getMinX())
			{
				// hide this widget
				if (Exists(widget.destroy))
				{
					NgLogD("WeScrollArea destroy  "+widget.created);
				    var placeholderWidget = {};
					placeholderWidget.xItem = widget.xItem;
					placeholderWidget.xItemDef = widget.xItemDef;
					placeholderWidget.xWidth = widget.xWidth;
					placeholderWidget.xHeight = widget.xHeight;
					placeholderWidget.mX = widget.mX;
					placeholderWidget.mY = widget.mY;
					placeholderWidget.created=false;
					this.mWidgetList[i] = placeholderWidget;
					widget.destroy();
				}
			}
			else
			{
				// show this widget - if its not already showing
				if (!Exists(widget.GetGL2))
				{
					NgLogD("WeScrollArea creating  "+widget.created);
					
					widget.xItemDef.pos_x = widget.mX;
					widget.xItemDef.pos_y = widget.mY;
					var tempWidget;
					if (Exists(this.widget_item_type) && this.widget_item_type == "gift_send_item" && Exists(WeGameStateMgr.mGiftUsers))
        			{
        			    var node = this.getContentNode();
   
                    	widget.xItemDef.images[2].args.gamertag = WeGameStateMgr.mGiftUsers[i];
                    	tempWidget = WeUiMgr.CreateGameWidget(widget.xItemDef, widget.xItem, this.getContentNode());
                
            	    }
            	    else if (Exists(this.widget_item_type) && this.widget_item_type == "share_send_item" && Exists(WeGameStateMgr.mSEGiftUsers))
        			{
        			    var node = this.getContentNode();
   
                    	widget.xItemDef.images[2].args.gamertag = WeGameStateMgr.mSEGiftUsers[i];
                    	tempWidget = WeUiMgr.CreateGameWidget(widget.xItemDef, widget.xItem, this.getContentNode());
            	    }
            	    else
            	    {
					    tempWidget = WeUiMgr.CreateGameWidget(widget.xItemDef, widget.xItem, this.getContentNode());
				    }
					tempWidget.xItem = widget.xItem;
					tempWidget.xItemDef = widget.xItemDef;
					tempWidget.xWidth = widget.xWidth;
					tempWidget.xHeight = widget.xHeight;
					tempWidget.created=true;
					widget = tempWidget;
					this.mWidgetList[i]=tempWidget;
					
					NgLogD("WeScrollArea create  "+this.mWidgetList[i].created);
				}

				// Push a notification down to any potential children that care...not very pretty...
				if (notify_children)
				{
	                if (Exists(widget.xCallbackList))
	                {
	                    for (var j = 0; j < widget.xCallbackList.length; j++)
	                    {
	                        if (Exists(widget.xCallbackList[j].Callback))
	                        {
	                            widget.xCallbackList[j].Callback();
	                        }
	                    }
	                }
				}
			}
		}
	},
	setPosition : function(pos)
	{	
		this.mScrollArea.getContentNode().setPosition(pos.getX(), pos.getY());
	},
	pushWidget : function(widget)
	{
		this.mWidgetList.push(widget);
	},
	pushGL2 : function(obj)
	{
		this.mGL2List.push(obj);
	},
	pushAnim : function(obj)
	{
	    this.mAnimList.push(obj);
	},
	getContentNode : function(item)
	{
		return this.mScrollArea.getContentNode();
	},
	setNotifyChildren : function(notify)
	{
		this.mNotifyChildrenOfMove = notify;
	},
	setSaveLastPositionId : function(identifier)
	{
		this.mLastPositionId = identifier;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeRealmScrollArea'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeRealmScrollArea'] || {}; $MODULE_REGISTRY['weEngine/WeRealmScrollArea'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-23
 *  @file:      WeRealmScrollArea.js
 *  @author:    Jon Guest
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var ScrollArea = require('weEngine/ScrollArea').ScrollArea;
var WeScrollArea = require('weEngine/WeScrollArea').WeScrollArea;

exports.WeRealmScrollArea = WeScrollArea.subclass(
{
	classname: 'WeRealmScrollArea',
	
	initialize : function($super, parent, controller_frame, asset_size, orientation, args)
	{
		$super(parent, controller_frame, asset_size, orientation);
		
		this.args=args;
		this.fadeDistance=30.0;
		this.sizeIncrese=30.0;
		if(this.args && this.args.fade_distance)
		{
			this.fadeDistance=this.args.fade_distance;
			this.sizeIncrese=this.args.size_increse;
		}
	},
	
	onUpdate : function($super)
	{	
	// iterate through the widgets in this control and turn them on/off based on if they're in the frame
		
		var scroll_position = this.mScrollArea.getScrollPosition();
		
		this.UpdateScrollIndicator();
		
		if(this.scroll_back)
		{
			try
			{
				var scroll_position = this.mScrollArea.getScrollPosition();
				var maxX=0;
				var minX=this.mScrollArea.frame.getSize().getWidth() - this.mScrollArea._contentSize.getWidth();
				if((maxX-minX)>0)
				{
					var progress=(scroll_position.getX()-minX)/ (maxX-minX);
					
					progress = Clamp(1.0-progress, 0.0, 1.0);
					
					//MOve to parameters
					var width=260/427;
					
					
					var uv=[ (1-width)*progress , 0, width, 1 ];
					this.scroll_back.SetUV(uv);
				}
				else
				{
					this.scroll_back.SetVisible(false);
				}
			}
			catch(e)
			{
				NgLogD("exception "+e);
			}
		}
		
		var notify_children = false;
		if (this.mNotifyChildrenOfMove)
		{
			// check for movement - if so, lets tell the child components
			if (this.mScrollPosition.getX() != scroll_position.getX() ||
				this.mScrollPosition.getY() != scroll_position.getY())
			{
				notify_children = true;
				this.mScrollPosition.setAll(scroll_position.getX(), scroll_position.getY());
			}
		}
		var count = this.mWidgetList.length;
		for (var i in this.mWidgetList)
		{
			var widget = this.mWidgetList[i];
			var x = (widget.mX + scroll_position.getX()) - (widget.xWidth * 0.5);
			var y = (widget.mY + scroll_position.getY()) - (widget.xHeight * 0.5);
			var widgetRect = new Core.Rect(new Core.Point(x,y), new Core.Size(widget.xWidth, widget.xHeight));
			// check to see if our rectangles intersect
			/*
			if (widgetRect.getMinY() > this.mFrame.getMaxY() || widgetRect.getMaxY() < this.mFrame.getMinY() ||
			    widgetRect.getMinX() > this.mFrame.getMaxX() || widgetRect.getMaxX() < this.mFrame.getMinX())
			{
				// hide this widget
				if (Exists(widget.destroy))
				{
				    var placeholderWidget = {};
					placeholderWidget.xItem = widget.xItem;
					placeholderWidget.xItemDef = widget.xItemDef;
					placeholderWidget.xWidth = widget.xWidth;
					placeholderWidget.xHeight = widget.xHeight;
					placeholderWidget.mX = widget.mX;
					placeholderWidget.mY = widget.mY;
					this.mWidgetList[i] = placeholderWidget;
					//widget.destroy();
				}
				
				if (Exists(widget.GetGL2) && widget.SetAlpha)
				{
					widget.SetAlpha(0.0);
				}
				else
				{
					NgLogD("no GetGL2 or SetAlpha");
					fullRecurseDump(widget, 4, 0);
				}
			}
			else
			*/
			{

				// show this widget - if its not already showing
				if (!widget.created)
				{
					widget.xItemDef.pos_x = widget.mX;
					widget.xItemDef.pos_y = widget.mY;

					var tempWidget = WeUiMgr.CreateGameWidget(widget.xItemDef, widget.xItem, this.getContentNode());
					tempWidget.xItem = widget.xItem;
					tempWidget.xItemDef = widget.xItemDef;
					tempWidget.xWidth = widget.xWidth;
					tempWidget.xHeight = widget.xHeight;
					tempWidget.created=true;
					widget = tempWidget;
					this.mWidgetList[i]=tempWidget;
				}
				
				if (Exists(widget.GetGL2) && widget.SetAlpha)
				{
					widget.SetAlpha(1.0);
				}
				else
				{
					//NgLogD("no GetGL2 or SetAlpha "+widget.SetAlpha);
					//fullRecurseDump(widget, 4, 0);
				}
				
				//alpha all Commponnents
				
				//if(widget.xChildren)
				{
					var fFadeDistance=this.fadeDistance;
					
					var widgetX=(widget.mX + scroll_position.getX()) ;

					//var widgetXMin=(widget.mX + scroll_position.getX()) - (widget.xWidth * 0.5);
					//var widgetXMax=(widget.mX + scroll_position.getX()) + (widget.xWidth * 0.5);
					/*
					if(this.mFrame.getMaxX()-fFadeDistance>widgetXMax)
					{
						widget.SetAlpha( (this.mFrame.getMaxX()-widgetXMax)/fFadeDistance );
					}
					else if(this.mFrame.getMinX()+fFadeDistance>widgetXMin)	
					{
						widget.SetAlpha( (widgetXMin-this.mFrame.getMinX())/fFadeDistance );
					}
					else
					{
						widget.SetAlpha(1.0);
					}
					*/
					if(widget.xChildren)
					{
						//NgLogD("widget.xChildren length "+widget.xChildren.length);
						for(var widgetItem in widget.xChildren)
						{
							var widgetItemReal= widget.xChildren[widgetItem];
							var widgetItemRealX=widgetItemReal.GetX();
							
					        var widgetItemRealWidth=0;
					        if(widgetItemReal.GetWidth)
					        {
					        	widgetItemRealWidth=widgetItemReal.GetWidth()*0.5;
					        }
							
							var widgetItemXMin=widgetX+widgetItemRealX-widgetItemRealWidth;
							var widgetItemXMax=widgetX+widgetItemRealX+widgetItemRealWidth;
							
							//NgLogD("this.mFrame.getMinX() "+this.mFrame.getMinX()+" widgetItemXMin "+widgetItemXMin);
							var alpha=1.0;
							var maxX=this.mFrame.getMaxX()+this.sizeIncrese;
							var minX=this.mFrame.getMinX()-this.sizeIncrese;
							
							if(maxX-fFadeDistance<widgetItemXMax)
							{
								alpha =  (maxX-widgetItemXMax)/fFadeDistance;
							}
							else if(minX+fFadeDistance>widgetItemXMin)	
							{
								alpha = (widgetItemXMin-minX)/fFadeDistance;
							}
							//NgLogD("alpha  "+alpha);
							widgetItemReal.SetAlpha(alpha);
							widgetItemReal.SetVisible(alpha>0.01);
						}
					}
				}
				

				// Push a notification down to any potential children that care...not very pretty...
				if (notify_children)
				{
	                if (Exists(widget.xCallbackList))
	                {
	                    for (var j = 0; j < widget.xCallbackList.length; j++)
	                    {
	                        if (Exists(widget.xCallbackList[j].Callback))
	                        {
	                            widget.xCallbackList[j].Callback();
	                        }
	                    }
	                }
				}
			}
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeProgressBar'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeProgressBar'] || {}; $MODULE_REGISTRY['weEngine/WeProgressBar'] = exports; /////////////////////////////////////////////////////////////////////////////
/// @file:      WeProgressBar.js
/// @author:    awong@ngmoco.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     Progess bar that when updated slides the amount closer to complete
//////////////////////////////////////////////////////////////////////////////

var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Content = require('weEngine/WeContent').Content;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var WeFramedSprite2D = require('weEngine/WeSprite2D').WeFramedSprite2D;


exports.WeProgressBar = Core.Class.subclass(   
{
	classname: 'WeProgressBar',
	
    /////////////////////////////////////////////////////////////////////////////
    /// @class: WeProgressBar
    initialize: function()
    {
        this.mLastCaller = null;
        this.mContainer = null;
        this.mBackground = null;

        this.mDecayRate = 0.8;
        this.mSnapRate = 0;
        this.mLastDelta = 0;
        this.mX = 0;
        this.mShouldHandleUpdate = false;
        this.mWasUpdated = false;
    
        this.mItemType = null;
        this.mDataSource = null;
        this.mDataType = null;
        this.mScrollType = null;
        this.mNumRows = null;
        this.mNumCols = null;

        this.mItemDefs = null; 
        this.mItems = null; 
        this.count = 0;
        this.mCreated=false;
    },

    Init : function( container )                      
    {
        var self = this;
        this.mContainer = container;
        if (container.source)
        {
            this.mObjSource = container.owner.xParent.owner.xArgs;
        }
        this.mItems = [];
    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: displays the item defs to the screen
    Display : function(halfY)
    {
    	if(this.mCreated)
    	{
    		return;
    	}
    	this.mCreated=true;
    	
    	var capsSizeUV=10/128;
    	var capSize=this.mContainer.owner.xHeight/2;
    	var height=this.mContainer.owner.xHeight;
    	
    	if(halfY)
    	{
    		var yPos=-this.mContainer.owner.xHeight*0.5;
    	}
    	else
    	{
    		var yPos=-this.mContainer.owner.xHeight;
    	}
    	
    	var item = new WeFramedSprite2D(Content.getImagePath(getAssets( "BtnGray" ))
    	, [capSize, height]
        ,[0-this.mContainer.owner.xWidth*0.5, yPos , 8]
    	,[0, 0, capsSizeUV, 1]
    	,this.mContainer);
    	this.mItems.push(item); 
    	var item =new WeFramedSprite2D(Content.getImagePath(getAssets( "BtnGray" ))
    	, [this.mContainer.owner.xWidth-capSize-capSize, height]
        ,[0-this.mContainer.owner.xWidth*0.5+capSize, yPos, 8]
    	,[capsSizeUV, 0, 1-capsSizeUV-capsSizeUV, 1]
    	,this.mContainer);
    	this.mItems.push(item); 
    	
    	var item =new WeFramedSprite2D(Content.getImagePath(getAssets( "BtnGray" ))
    	, [capSize, height]
        ,[this.mContainer.owner.xWidth*0.5-capSize, yPos, 8]
    	,[1-capsSizeUV, 0, capsSizeUV, 1]
    	,this.mContainer);
    	this.mItems.push(item); 
    	var capsSizeUV=7/128;
    	
    	var size=[capSize, height];
    	var uv=[0, 0, capsSizeUV, 1];
    	var item=new WeFramedSprite2D(Content.getImagePath(getAssets( "BtnBlue" ))
    	,size 
        ,[-this.mContainer.owner.xWidth*0.5, yPos, 9]
    	,uv
    	,this.mContainer);
    	
    	item.mSize=size;
    	item.mUV=uv;
    	item.mProgress=capSize/this.mContainer.owner.xWidth;
    	
    	this.mItems.push(item);  
    	
    	var size=[this.mContainer.owner.xWidth-capSize-capSize, height];
    	var uv=[capsSizeUV, 0, 1-capsSizeUV-capsSizeUV, 1];
    	var item=new WeFramedSprite2D(Content.getImagePath(getAssets( "BtnBlue" ))
    	, size
        ,[0-this.mContainer.owner.xWidth*0.5+capSize, yPos, 9]
    	,uv
    	,this.mContainer);
    	
    	item.mSize=size;
    	item.mUV=uv;
    	item.mProgress=(this.mContainer.owner.xWidth-capSize-capSize)/this.mContainer.owner.xWidth;
    	
    	this.mItems.push(item); 
    	
    	var size=[capSize, height];
    	var uv=[1-capsSizeUV, 0, capsSizeUV, 1];
    	var item=new WeFramedSprite2D(Content.getImagePath(getAssets( "BtnBlue" ))
    	, size
        ,[this.mContainer.owner.xWidth*0.5-capSize, yPos, 9]
    	,uv
    	,this.mContainer);
    	
    	item.mSize=size;
    	item.mUV=uv;
    	item.mProgress=capSize/this.mContainer.owner.xWidth;
    	
    	this.mItems.push(item);
    },

    /////////////////////////////////////////////////////////////////////////////
    /// @method: displays the item defs to the screen
    destroy : function()
    {
        var len = this.mItems.length;
        for(var idx = 0; idx < len; ++idx)
        {
            this.mItems[idx].destroy();
        }
        this.mItems = [];
        
        if (Exists(this.mCapSprite))
        {
            this.mCapSprite.destroy();
            delete this.mCapSprite;
        }
    },
    
    SetProgress: function(percent)
    {
    	var currentProgress=0.0;
    	var ended=false;
        if (this.mItems)
        {
        	for(var itemIndex in this.mItems)
            {   
                var item = this.mItems[itemIndex];
                if (item.mUV)
                {
                    currentProgress+=item.mProgress;
                
                    if(currentProgress>=percent)
                    {
                	
                    	if(ended)
                    	{
                    		item.GetGL2().setVisible(false);
                    	}
                    	else
                    	{
                    		var progressinItem= ( (percent-(currentProgress-item.mProgress))/item.mProgress );
                		
                    		item.mFrameData.size= [ item.mSize[0]*progressinItem,   item.mSize[1] ] ;
                		
                    		item.SetUV([item.mUV[0], 0 , item.mUV[2]* progressinItem , 1 ]);
                	
                    		item.GetGL2().setVisible(true);
                    		ended=true;
                    	}
                	
                    }
                    else
                    {
                    	item.mFrameData.size=item.mSize;
                    	item.SetUV([item.mUV[0], 0 , item.mUV[2] , 1 ]);
                    	item.GetGL2().setVisible(true);	
                    }   
                }
                
                          
            }
        }
    },

    OnControllerUpdate : function()
    {
    	if(this.mObjSource )//&& this.mObjSource.product)
    	{
    		var prod = this.mObjSource.product;
    		var percent = this.mObjSource.source.GetPercentRemaining(prod) * 0.01;
    		this.SetProgress(percent);
    	}
    }

});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/ScrollArea'] = function(){var exports = $MODULE_REGISTRY['weEngine/ScrollArea'] || {}; $MODULE_REGISTRY['weEngine/ScrollArea'] = exports; /*
 * ScrollArea.js
 *  This Node subclass manages a multi-touch aware momentum scrolling area with stretchy sides.
 *  
 * Momentum Scrolling
 *  When applying physical-like forces to UI elements, we can achieve the best feel by treating
 *  elements not as simulated physics objects, but as multi-mode models. While dragging, instead
 *  of applying forces and integrating (which produces lag), we'll manipulate the object in space
 *  directly; This will keep the drag responsive and snappy. Since we're not accumulating forces
 *  in a physical simulation, we approximate the absolute drag forces by averaging them with an
 *  exponential smoothing function. When we release a drag, we then apply the accumulated drag
 *  force to the UI element and use a constant friction factor to slow the movement over time.
 *
 * Stretchy Sides
 *  While a continuous function (for drag contribution to movement) would be ideal for stretchy
 *  sides, an approximate parametric function will get us most of the way while simplifying the
 *  implementation considerably. 
 *    While we're within the scroll bounds, we apply drag movements 1:1 to the scrolling node.
 *    While we're outside the scroll bounds, we'll scale our movements by a constant factor.
 *  For normal dragging this means we'll get responsive movement inside the bounds and degraded
 *  movement outside the bounds. Since the there's a physical limit to dragging a finger across
 *  a screen, our degraded movement will have a reasonable soft limit to its extent; This way we
 *  avoid the need for an asymptotic function. This parametric function also responds well to our
 *  momentum scrolling allowing for a natural bounce at the end without any recoil.
 */

var Core = require('NGCore/Client/Core').Core;
var GL2 = require('NGCore/Client/GL2').GL2;

//Momentum slowdown.
var SA_Friction = 0.9;

//Contribution of new drag forces.
var SA_SmoothingFactor = 0.3;

//Stretchy sides snap-back factor.
var SA_StretchDecay = 0.65;

//Stretchy degraded movement factor.
var SA_RangeFactor = 0.5;

exports.ScrollArea = GL2.Node.subclass(
{
	classname: 'ScrollArea',
	
	ScrollDirection:
	{ 
		Horizontal: 1,
		Vertical: 2,
		Both: 3
	},
	
	initialize: function(frame, contentSize)
	{
		//Setup events
		this.frame = new Core.Rect(frame);
		this.setPosition(this.frame.getOrigin());
		this._contentSize = new Core.Size(contentSize);
		this._content = new GL2.Node();
		this._content.setDepth(0);
		this.addChild(this._content);
		
		this._dragger = new DragListener(this);
		this._updateListener = null;
		
		var target = this._dragger.getTarget();
		
		target.setPosition(this.frame.getOrigin());
		target.setSize(contentSize);
		target.setDepth(0);
		this.addChild(target);
		
		//Setup momentum scrolling
		this._momentum = {
			x: 0,
			y: 0
		};
		
		this._scroll = this.ScrollDirection.Horizontal;
	},
	
	destroy: function()
	{
		this._updateListener=null;
		this._dragger.destroy();
		this._content.destroy();
	},

	getContentNode: function()
	{
		return this._content;
	},
	
	setScrollDirection: function(dir)
	{
		switch (dir)
		{
			case this.ScrollDirection.Horizontal:
			case this.ScrollDirection.Vertical:
			case this.ScrollDirection.Both:
				this._scroll = dir;
				break;
			default:
				NgLogD("Trying to set invalid scrollDirection:" + dir);
				break;
		}
	},
	
	getScrollDirection: function()
	{
		return this._scroll;
	},
	
	setUpdateListener: function(cb)
	{
		this._updateListener=cb;
	},
	
	setScrollPosition: function(vector)
	{
		vector = new Core.Vector(vector);
		if (vector.getX() === undefined || vector.getY() === undefined) return;
		
		var h_upper = 0;
		var h_lower = this.frame.getSize().getWidth() - this._contentSize.getWidth();
		if (h_lower > -1) h_lower = -1;
		
		var v_upper = 0;
		var v_lower = this.frame.getSize().getHeight() - this._contentSize.getHeight();
		if (v_lower > -1) v_lower = -1;
		
		var new_x = this._content.getPosition().getX();
		var new_y = this._content.getPosition().getY();
		
		if (this._scroll == this.ScrollDirection.Horizontal ||
			this._scroll == this.ScrollDirection.Both)
		{
			new_x = h_lower + (h_upper - h_lower) * vector.getX();
		}
		if (this._scroll == this.ScrollDirection.Vertical ||
			this._scroll == this.ScrollDirection.Both)
		{
			new_y = v_lower + (v_upper - v_lower) * vector.getY();
		}
		
		this._content.setPosition(new_x,new_y);
	},
	
	getScrollPosition: function()
	{
		return this._content.getPosition();
	},
	
	//This function calculates application of deltas over the range of positions.
	applyRange: function(position, delta, lower, upper)
	{
		if (delta === 0) return position;
		
		//Handle positive delta
		if (delta > 0) 
		{
			//If we're below our lower bound, only move by range factor.
			if ( position < lower) 
			{
				position += delta * SA_RangeFactor;
				//If we've moved into range, apply the delta into range and save the remainder.
				if (position >= lower) 
				{
					delta = (position - lower) / SA_RangeFactor;
					position = lower;
				}
				else 
				{
					return position;
				}
			}
			//If we're inside our bounds, apply the delta
			if (position < upper) 
			{
				//if the delta will place us out of range, apply it and save the remainder.
				if (position + delta > upper) 
				{
						delta -= (upper - position);
						position = upper;
						delta *= SA_RangeFactor;
				}
			}
			//We're out of range, so only apply by range factor.
			else
			{
				delta *= SA_RangeFactor;
			}
		}
		
		//Handle negative delta; same thing, just bounds reversed.
		else if (delta < 0) 
		{
			if (position > upper) 
			{
				position += delta * SA_RangeFactor;
				if (position <= upper) 
				{
					delta = (position - upper) / SA_RangeFactor;
					position = upper;
				}
				else 
				{
					return position;
				}
			}
			if (position > lower) 
			{
				if(position+delta <lower)
				{
					delta -= (lower - position);
					position = lower;
					delta *= SA_RangeFactor;
				}
			} 
			else 
			{
				delta *= SA_RangeFactor;
			}
		}
		return position + delta;
	},

	onUpdate: function(delta)
	{
		var hasTouch = this._dragger.hasTouch();
		
		//Our ranges are negative because we push the origin up/left from the start position.
		var h_upper = 0;
		var h_lower = this.frame.getSize().getWidth() - this._contentSize.getWidth();
		if (h_lower > -1) h_lower = -1;
		
		var v_upper = 0;
		var v_lower = this.frame.getSize().getHeight() - this._contentSize.getHeight();
		if (v_lower > -1) v_lower = -1;
		
		var new_x = this._content.getPosition().getX();
		var new_y = this._content.getPosition().getY();

		// This makes sure they can't forcibly game the scroller into allowing
		// them to scroll past a frame_width/2 PAST the edge of the content.
		var left_bound = (this.frame.getSize().getWidth() * 0.5);
		var right_bound = -(this._contentSize.getWidth() - left_bound);
		if  (new_x < right_bound || new_x > left_bound)
		{
			this._dragger.clearTouches();
			hasTouch = false;
		}
		// Same for vertical scrollers...		
		var top_bound = (this.frame.getSize().getHeight() * 0.5);
		var bottom_bound = -(this._contentSize.getHeight() - top_bound);
		if (new_y < bottom_bound || new_y > top_bound)
		{
			this._dragger.clearTouches();
			hasTouch = false;
		}		
		
		//if we're in bounds and we have no movement, don't bother updating
		if (delta.x == 0 && delta.y == 0)
		{
			if (this._momentum.x == 0 && this._momentum.y == 0)
				if (hasTouch ||
					new_x >= h_lower && new_x <= h_upper &&
					new_y >= v_lower && new_y <= h_upper)
				return;
		}
		
		//If we have touches accumulate momentum
		if (hasTouch)
		{
			//Use exponential smoothing to approximate the current momentum
			this._momentum.x = SA_SmoothingFactor * delta.x + (1 - SA_SmoothingFactor) * this._momentum.x;
			this._momentum.y = SA_SmoothingFactor * delta.y + (1 - SA_SmoothingFactor) * this._momentum.y;			
		}
		//Otherwise, consume the momentum.
		else
		{
			delta.x += this._momentum.x;
			delta.y += this._momentum.y;
			
			//Apply friction, stop if we're below a small threshold.
			this._momentum.x *= SA_Friction;
			this._momentum.y *= SA_Friction;
			if (this._momentum.x < 1 && this._momentum.x > -1) this._momentum.x = 0;
			if (this._momentum.y < 1 && this._momentum.y > -1) this._momentum.y = 0;
		}
		
		//Handle any deltas
		if (this._scroll == this.ScrollDirection.Horizontal ||
			this._scroll == this.ScrollDirection.Both)
		{
			new_x = this.applyRange(new_x, delta.x, h_lower, h_upper);
		}
		if (this._scroll == this.ScrollDirection.Vertical ||
			this._scroll == this.ScrollDirection.Both)
		{
			new_y = this.applyRange(new_y, delta.y, v_lower, v_upper);
		}

		//Without touches to anchor us, we should slide back into range.
		if ( !hasTouch)
		{
			if (new_x < h_lower)
			{
				new_x = h_lower - (h_lower - new_x) * SA_StretchDecay;
				if (h_lower - new_x < 1)
					new_x = h_lower;
			}
			else if (new_x > h_upper)
			{
				new_x = h_upper + (new_x - h_upper) * SA_StretchDecay;
				if (new_x - h_upper < 1)
					new_x = h_upper;
			}
			if (new_y < v_lower)
			{
				new_y = v_lower - (v_lower - new_y) * SA_StretchDecay;
				if (v_lower - new_y < 1)
					new_y = v_lower;
			}
			else if (new_y > h_upper)
			{
				new_y = v_upper + (new_y - v_upper) * SA_StretchDecay;
				if (new_y - v_upper < 1)
					new_y = v_upper;
			}
		}
		this._content.setPosition(new_x,new_y);
		
		if(this._updateListener)
		{
			this._updateListener(delta);
		}
	}
});

var DragListener = Core.MessageListener.subclass(
{
	classname: 'DragListener',
	
	initialize: function(node)
	{
		this._touches = [];
		this.scrollArea = node;
		this.lastStartTarget=null;
		this._target = new GL2.TouchTarget();
		var cTouchEmitter = this._target.getTouchEmitter();
		if(cTouchEmitter)
		{
			cTouchEmitter.addListener(this, this.onTouch);
		}
		Core.UpdateEmitter.addListener(this, this.onUpdate);
	},

	destroy: function()
	{
		this._target.destroy();
		Core.UpdateEmitter.removeListener(this);
	},

	getTarget: function()
	{
		return this._target;
	},

	onTouch: function(touch)
	{
		DebugTouch(touch, "DragListener onTouch()");
				
		var key = "k" + touch.getId();
	//*	FOR ORIENTATION
		var touchPosition = FixTouchPositionForOrientation( touch.getPosition() );

	//*/
		switch(touch.getAction())
		{
			case touch.Action.Start: 
				this._touches[key] = {
					x:touchPosition.getX(),
					y:touchPosition.getY(),
					dx:0,
					dy:0
				};
				//SCROOLL item hilight fix
				if(this.lastStartTarget )
				{
					var cTouchEmitter=this.lastStartTarget.getTouchEmitter();
					if(cTouchEmitter)
					{
						touch._setAction(touch.Action.End);
						cTouchEmitter.chain(touch);
						touch._setAction(touch.Action.Start);
					}
					this.lastStartTarget=null;
				}

				break;
			case touch.Action.End:
				//SCROOLL item hilight fix
				if(this.lastStartTarget  )
				{
					var cTouchEmitter=this.lastStartTarget.getTouchEmitter();
					if(cTouchEmitter)
					{
						cTouchEmitter.chain(touch);
					}
					this.lastStartTarget=null;

				}
				
				delete this._touches[key];
				break;
			
			case touch.Action.Move: 
				var delta = this._touches[key];
				var pos = touchPosition;
				if (delta === undefined || pos === undefined) break;
				
				delta.dx += pos.getX() - delta.x;
				delta.dy += pos.getY() - delta.y;
				delta.x = pos.getX();
				delta.y = pos.getY();
				if (pos.getX() >= gRawWidth-1)
				{   // fix WERULEMOBAGE-199
				    this.clearTouches();
				}
				break;
		}
		
		if ( WeUiMgr.GetActiveScreen() === "SocialMapScreen")
		{
            var targets = touch.getTouchTargets();
        }
        else
        {
            var targets = SortTouchTargets(touch);
        }
        
		for (var t=0; t < targets.length; t++)
        {
            var item = targets[t];
            if (item != this._target && 
                    item != WeGameStateMgr.mLot.mTargetTouch)
            {
            	var cTouchEmitter=item.getTouchEmitter();
            	if(cTouchEmitter)
            	{
	                if( cTouchEmitter.chain(touch) )
	                {
	                	//SCROOLL item hilight fix
	                	if(touch.getAction()==touch.Action.Start)
	                	{
	                		this.lastStartTarget=item;
	                	}
	                	return true;
	                }
            	}
            }
        }
	},
	
	onUpdate: function()
	{
		var count = 0;
		var delta = {
			x:0,
			y:0
		};
		
		//Since we're multitouch aware, we need to average the drag contribution.
		for (var key in this._touches)
		{
			var t = this._touches[key];
			if (t === undefined) continue;
			delta.x += t.dx;
			delta.y += t.dy;
			t.dx = t.dy = 0;
			++count;
		}
		if (count > 1) {
			delta.x /= count;
			delta.y /= count;
		}
		
		//Tell our scroll area to update.
		this.scrollArea.onUpdate(delta);
	},
	
	clearTouches: function()
	{
		for (var key in this._touches) 
		{
			delete this._touches[key];
		}
	},
	
	hasTouch: function()
	{
		for (var key in this._touches) return true;
		return false;
	}
	
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeLabel2D'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeLabel2D'] || {}; $MODULE_REGISTRY['weEngine/WeLabel2D'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-23
 *  @file:      WeLabel2D.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////

exports.WeLabel2D = Core.MessageListener.subclass(
{
	classname: "WeLabel2D",
	
    initialize : function(parent)
    {
        this.mTextGL2 = new GL2.Text();
        this.parent = parent || GL2.Root;
        this.parent.addChild(this.mTextGL2);
        this.updating = false;
    },

    destroy : function()
    {
        if (Exists(this.mTextGL2))
        {
            this.mTextGL2.destroy();
            delete this.mTextGL2;
            this.mTextGL2=null;
            if (this.updating)
            {
                Core.UpdateEmitter.removeListener(this);
                this.updating = false;
            }
        }
		else
		{
			NgLogD("ERROR: Trying to cleanup a non-existant text label");
		}
    },
    
    EnableUpdate : function(cb)
    {
        if (this.updating)
        {
            Core.UpdateEmitter.removeListener(this);
        }
        this.updating = true;
        Core.UpdateEmitter.addListener(this, cb);
    },

    GetGL2 : function()
    {
        return this.mTextGL2;
    },
    
    GetX: function()
    {
        return this.mTextGL2.getPosition().getX();
    },
    
    GetY: function()
    {
        return this.mTextGL2.getPosition().getY();
    },
    
    GetWidth: function()
    {
        return this.mTextGL2.getSize().getWidth();
    },
    
    GetHeight: function()
    {
        return this.mTextGL2.getSize().getHeight();
    },
    
    SetVisible: function(value)
    {
        if (Exists (this.mTextGL2))
        {
    	   this.mTextGL2.setVisible(value);
        }
    },

    SetRotation: function(value)
    {
        this.mTextGL2.setRotation(value);
    },

    GetRotation: function(value)
    {
        return this.mTextGL2.getRotation();
    },

    SetText: function(text)
    {
       if (this.mTextGL2 && (text === "" || text))
       {
           this.mTextGL2.setText(text);
       }
    },

    SetPosition: function(x, y)
    {
       if (this.mTextGL2)
       {
           this.mTextGL2.setPosition(x, y);
       }
    },
    
    GetVisible: function()
    {
    	return this.mTextGL2.getVisible();
    },
    
    SetAlpha: function(alpha)
    {
		if (!this.mTextGL2)
		{
			NgLogD("SetAlpha: mTextGL2 does not exist: " + this);
			return;
		}
        this.mTextGL2.setAlpha(alpha);
        if(alpha === 0)
        {
            this.mTextGL2.setVisible(false);
        }
        else if(!this.mTextGL2.getVisible())
        {
            this.mTextGL2.setVisible(true);
        }
    }
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeContentDownloader'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeContentDownloader'] || {}; $MODULE_REGISTRY['weEngine/WeContentDownloader'] = exports; //
//	class that handles all content downloading
//
var Storage = require('NGCore/Client/Storage').Storage;
var Core = require('NGCore/Client/Core').Core;
var Network = require('NGCore/Client/Network').Network;
var NGUI = require('NGCore/Client/UI').UI;

exports.WeContentDownloader = Core.Class.singleton(
{
		classname: "WeContentDownloader",
		contentLevelKey: 'contentLevel',
						
	    initialize : function() 
	    {
			this.mManifests = null;
			this.mContentLevel = -1;
			this.mTotal = {};
			this.mProgress = {};
			this.mLastContentLevel = 0;
			
			this.mManifestLevels = [];
			this.mManifestsInProgress = [];
			this.mManifestLevelInProgress = null;
			
			this.mDownloadedAll = false;
			this.mDownloadAll = false;
			this.mPercent = 0;
			this.mLoadingScreenWebviewProgress = 0;
			this.mShowLoadingText = true;
			this.mError = false;
	    },
	    
	    GetDownloadedAll : function()
	    {
	    	downloadedAll = this.mLastContentLevel == this.mContentLevel; 
	    	NgLogD("downloaded all: " + downloadedAll);
	    	return downloadedAll;
	    },
	    
	    SetContentLevel : function(manifestLevel)
	    {
	    	NgLogD("SetContentLevel: " + JSON.stringify(manifestLevel));
	    	var contentLevel = manifestLevel.level + manifestLevel.levels - 1;
	    	
	    	if (this.mContentLevel == contentLevel)
	    	{
	    		return;
	    	}
	    	
	    	NgLogD("setting content level to " + contentLevel);
	    	
	    	this.mContentLevel = contentLevel;
	    	
	    	Storage.KeyValueCache.local.setItem(this.contentLevelKey, contentLevel);
	    },
	    
	    GetContentLevel : function()
	    {
	    	return this.mContentLevel; 
	    },
	    
	    Setup : function(cb)
	    {
			Storage.KeyValueCache.local.getItem(this.contentLevelKey, function(err, data)
			{
				if (!err)
				{
					Storage.KeyValueCache.local.getItem('resetContentLevel', function(err, data)
					{
						if (err)
						{
							this.mContentLevel = 0;
							
							Storage.KeyValueCache.local.setItem('resetContentLevel', 1);
						}
						
						if (Exists(cb))
						{
							cb();
						}
						
					}.bind(this));
					
					this.mContentLevel = data;
				}
				else
				{
					Storage.KeyValueCache.local.setItem('resetContentLevel', 1);
					
					cb();
				}
				
			}.bind(this));
		},
		

		SetManifestsInfo : function(manifestsInfo)
		{
		    if (Core.Capabilities.getScreenPixelUnits() == 2 && gFixedWidth == 480 && gFixedHeight == 320)
            {
			    this.mManifests = manifestsInfo.manifests[GameSpecificVariables.GameResolution + "_retina"];
			}
			else
			{
			    this.mManifests = manifestsInfo.manifests[GameSpecificVariables.GameResolution];
			}
			
			var lastContentLevel = 0;
			
			for(var i in this.mManifests)
			{
				var manifest = this.mManifests[i];

				NgLogD("checking manifest level:" + manifest.level);
				
				if (manifest.level > lastContentLevel)
				{
					lastContentLevel = manifest.level; 
				}
			}
			
			this.mLastContentLevel = lastContentLevel;
			NgLogD("last manifest level: " + this.mLastContentLevel);
			
		},
		
		GetManifestsInfo  : function(cb)
		{
			if (Exists(this.mManifests))
			{
				cb(this.mManifests);
			}
			
			//	
	    	//	load assets manifests
	    	//
	    	NgLogD('WeContentDownloader::GetManifestsInfo: reading secondary manifests');
	    	
			var res = GameSpecificVariables.GameResolution;
			var filename = "./Configs/secondaryManifests.json";
            var fs = Storage.FileSystem;
	    	ReadFile(fs, filename, {'blocking': false}, function(err, data)
	    	{
	    		if (!err )
	            {
	    			this.SetManifestsInfo(JSON.parse(data));
	    	    }
	    		else
	    		{
	    			//
	    			//	cannot really continue
	    			//
	    			ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
	    		}
	    		
	    		cb(this.mManifests);
	    	}.bind(this));
		},
		
		GetManifestsForLevel : function(level, cb)
		{
			var download = this.GetDownloadAll();
			
			this.GetManifestsInfo(function(manifests)
			{
				var manifestsToDownload = [];
				
				manifests.forEach(function(item)
				{
					var needLevel = this.mContentLevel > level ? this.mContentLevel : level;
					  
					//
					//	get all manifests for level with number of items in each
					//
					var manifestsLevel = item.level + item.levels - 1;
					
					if (item.level <= needLevel)
					{
						var manifestLevel = {};
						manifestLevel.level = item.level;
						manifestLevel.levels = item.levels;
												
						if (download && manifestLevel.level < this.mContentLevel)
						{
							NgLogD("download: skipping " + JSON.stringify(item));
						}
						else
						{
							//
							//	select manifests we need 
							//
							var neededManifests = item.manifests.filter(function(manifest)
							{
								return manifest.indexOf('all') > 0 || manifest.indexOf(gTextureCompression) > 0;
							});
							
							manifestLevel.manifests = neededManifests;
							NgLogD("manifestLevel: " + JSON.stringify(manifestLevel));
							
							manifestsToDownload.push(manifestLevel);
						}
					}
				}.bind(this));
				
				cb(manifestsToDownload);
				
			}.bind(this));
			
		},
		
		GetDownloadPogress : function(size, name)
		{
			var total = 0;
			var downloaded = 0;
			
						
			this.mProgress[name] = size;
			
			for (name in this.mTotal)
			{
				total += this.mTotal[name];
			}
				
			for (name in this.mProgress)
			{
				downloaded += this.mProgress[name];
			}

			if (total == 0)
			{
				return 0;
			}
			
			percent = (downloaded / total * 100).toFixed(1);
			
			return percent;
		},
		
		UpdateDownloadSize : function(size, name)
		{
			this.mTotal[name] = size;
			
		},
		
		GetLoadingText : function()
		{
		    if (!this.mShowLoadingText)
		    {
		        return "";
		    }
			if (!gFirstBoot)
			{
				return "";
			}
			
			for (var i=0; i < gLoadingText.length; i++)
	        {
	            if (this.mPercent <= gLoadingText[i][0])
	            {
	                return gLoadingText[i][1];
	            }
	        }
		},
		
		GetStatusText : function()
		{
	        return "Loading Content";
		},
		
		DownloadManifest : function(name, level)
		{
			NgLogD("downloading manifest name: " + name + " level " + level);
			
			this.mTotal[name] = 0;
			this.mProgress[name] = 0;
			
			this.mManifestsInProgress.push(name);
			
			NgLogD("downloading " + name);
			var dl = new Network.DownloadManifest();
			
			dl.start(
				Core.Capabilities.getContentUrl(),
				"./", 
				name,
				function(cur, total)
				{
					//
					//	download progress
					//
					if (cur == 0)
					{
						this.UpdateDownloadSize(total, name);
					}

					this.UpdateStatusMessage(this.GetDownloadPogress(cur, name));
				}.bind(this),
					
				function(err, manifest)
				{
					if (err)
					{
						if (!this.mError && !this.mDownloadAll)
						{
							//
							// TODO: need to show error in a better way
							//
							NgLogD( "****** downloader failed with " + err );
							var alertDialog = new NGUI.AlertDialog();
			                alertDialog.setTitle(gErrors.DOWNLOAD_FAILURE.title);
			                alertDialog.setText(gErrors.DOWNLOAD_FAILURE.message);
			                alertDialog.setChoices(["OK"]);
			                alertDialog.show();
			                this.mError = true;
						}
					}
					else
					{
						//
						//	download complete
						//
						this.OnManifestDownloaded(name, level);
					}
					
				}.bind(this)); 
		},
		
		UpdateAllContent: function(cb)
		{
			//
			//	Download alll game content one manifest by one
			//
			this.mDownloadAll = true;
			this.UpdateContent(this.mLastContentLevel, cb);
		},
		
		GetNextManifestLevel : function()
		{
			this.mManifestLevelInProgress = this.mManifestLevels.shift();
			
			NgLogD("manifest level in progress: " + JSON.stringify(this.mManifestLevelInProgress));
			
			return this.mManifestLevelInProgress;
		},
		
		GetNextManifest : function()
		{
			return this.mManifestLevelInProgress.manifests.shift();
		},
		
		//	Download all content required up to level provided or level that was downloaded last
		//
		UpdateContent : function(level, cb)
		{
			
			this.mDownloadCompleteCallback = cb;
			
			NgLogD("content download:  level: " + level + " downloadAll: " + this.mDownloadAll + " contentLevel: " + this.mContentLevel);
						
			var self = this;
			
			this.GetManifestsForLevel(level, function(manifestsLevels)
			{
				this.mManifestLevels = manifestsLevels;
				
				NgLogD("going to download manifests levels: " + JSON.stringify(manifestsLevels));
				
				//
				//	start download manifests
				//
				if (this.mDownloadAll)
				{
					NgLogD("downloading all data");
					
					//
					//	start single download
					//
					this.GetNextManifestLevel();
					
					this.DownloadManifest(this.GetNextManifest(), self.mManifestLevelInProgress.level);
				}
				else
				{
					this.mManifestLevelInProgress = manifestsLevels[0];
                    
                    //
                    //      Download all manifests
                    //
                    manifestsLevels.forEach(function(manifestLevel)
                    {
                            if (manifestLevel.level > this.mManifestLevelInProgress.level)
                            {
                                    this.mManifestLevelInProgress = manifestLevel;
                            }

                            manifestLevel.manifests.forEach(function(manifest)
                            {
                                    this.DownloadManifest(manifest, manifestLevel.level);
                            }.bind(this));
                            
                    }.bind(this));

				}
			}.bind(this)); 
		},
		
		UpdateStatusMessage : function(percent)
		{
			this.mPercent = percent;
			
			gStatusMessage = this.GetStatusText() + "\nProgress: " + this.mPercent + " % ";

/*			The new progress window:
			0.  At 0% (when you first load) you see the traditional 1st-time screen with the guy saying "Welcome!..."
			1.  At 15%, change text.  Sample text "I will now show you the kingdoms of over Rulers.  What will you do, your majesty?"
			2.  At 30%, we will show a full-screen webview with another kingdom's screenshot.  Dynamic text stops here, but the loading % text & spinner stay until the end.
			3.  At 60%, show another kingdom.
			4.  At 90%, show another.
*/						
            var count = 0;
			if (Exists(NGWindow.document.additionalWebList))
            {
                count = NGWindow.document.additionalWebList.length;
            }
			
			for (var i=0; i < count; i++)
			{
			    if (this.mLoadingScreenWebviewProgress == i+2)
			    {
			         var wv = NGWindow.document.additionalWebList[i];
			         var alpha = wv.getAlpha();
                      if (alpha < 1)
                      {
                          alpha = alpha + gWebViewFadeSpeed;
                          NgLogD("UPDATE ALPHA " + alpha);
                      }
                      else
                      {
                          alpha = 1;
                      }
                      wv.setAlpha(alpha);
			    }
		    }
		    
            var webView = NGWindow.document.loadingWebView;
            if(webView)
			{
			    var i;
    			for ( i = 0; i < gLoadingScreenWebViewStages.length - 1; i++ ) /* 5 stages */
    			{
    				if ( this.mPercent >= gLoadingScreenWebViewStages[i] && this.mPercent < gLoadingScreenWebViewStages[i + 1] )
    				{
    					if( this.mLoadingScreenWebviewProgress < i ) /* have not yet entered this stage */
    		            {
    						this.mLoadingScreenWebviewProgress = i;
    						
    						var count = 0;
    						if (Exists(NGWindow.document.additionalWebList))
                            {
                                count = NGWindow.document.additionalWebList.length;
                            }
                			for (var j=0; j < count; j++)
                			{
                			    if (this.mLoadingScreenWebviewProgress == j+2)
                			    {
                			         var wv = NGWindow.document.additionalWebList[j];
                			         this.mShowLoadingText = false;
                			         NgLogD("webview loaded:" + wv.loaded);
                			         if (!wv.loaded)
                			         {
                			        	 wv.initialVisible = true;
                			         }
                			         else
                			         {
                			        	 wv.setVisible(true);
                			         }
                			         
            			         }
            			    }
    		            }				
    				}
    			}
			}
		},
		
		GetDownloadAll : function()
		{
			return this.mDownloadAll;
		},
		
		OnManifestRead : function()
		{
			if (this.mManifestLevelInProgress == null)
			{
				//
				//	bad callback
				//	
				return;
			}
			NgLogD("OnManifestDownloaded: manifests in progress: " + JSON.stringify(this.mManifestsInProgress));
			NgLogD("OnManifestDownloaded: manifests level in progress: " + JSON.stringify(this.mManifestLevelInProgress));

			var downloadComplete = false;
			
			if (this.GetDownloadAll())
			{
				//
				//	update content level and check if there are more manifests to download
				//
				if (this.mManifestLevelInProgress.manifests.length == 0 && this.mManifestsInProgress.length == 0)
				{
					this.SetContentLevel(this.mManifestLevelInProgress);
					
					//
					//	see if someone is waiting on download
					//
					if (Exists(this.mLevelDownloadCallback) && this.mContentLevel >= this.mWaitingLevel)
					{
						var cb = this.mLevelDownloadCallback;
						this.mLevelDownloadCallback = null;
						cb();
					}
					
					this.mManifestLevelInProgress = this.GetNextManifestLevel();
					
					NgLogD("Downloading next level:" + JSON.stringify(this.mManifestLevelInProgress));
					
					//
					//	last level downloaded
					//
					downloadComplete = !Exists(this.mManifestLevelInProgress);
				}

				if (!downloadComplete && this.mManifestLevelInProgress.manifests.length > 0)
				{
					//
					// Download next manifest
					//
					var level = this.mManifestLevelInProgress.level;
					this.DownloadManifest(this.GetNextManifest(), level);
				}
			}
			else
			{
				if (this.mManifestsInProgress.length == 0)
				{
					//
					//	update content level and call callback 
					//
					this.SetContentLevel(this.mManifestLevelInProgress);
					
					this.mManifestLevelInProgress = null;
					
					downloadComplete = true;
				}
			}
			
			if (downloadComplete)
			{
				NgLogD("downloaded all manifests. ");
				
				this.UpdateStatusMessage(100);

				this.mTotal = {};
				this.mProgress = {};
				
				if (Exists(this.mDownloadCompleteCallback))
				{
					this.mDownloadCompleteCallback();
					this.mDownloadCompleteCallback = null;
				}
			}
		},
		
		OnManifestDownloaded : function(manifest, level)
		{
			if (this.mManifestLevelInProgress == null)
			{
				//
				//	bad callback
				//	
				return;
			}
			
			var index = this.mManifestsInProgress.indexOf(manifest);
			
			if (index != -1)
			{	
				NgLogD("downloaded " + manifest);
				this.mManifestsInProgress.splice(index, 1);
				ReadImagesManifest(manifest, level);
			}
		},
		
		
		SetWaitLevelDownloadCallback : function(cb, level)
		{
			this.mLevelDownloadCallback = cb;
			this.mWaitingLevel = level;
		},
		
		IsDownloading : function()
		{
			return Exists(this.mManifestLevelInProgress);
		},
		
		//
		//	Have content for level?
		//
		HaveContent : function(level)
		{
			NgLogD("HaveContent: content level "  + this.mContentLevel + " level " + level);
			return this.mContentLevel >= level;
		}
	});
; return exports;};
$MODULE_FACTORY_REGISTRY['Code/WeBuilding'] = function(){var exports = $MODULE_REGISTRY['Code/WeBuilding'] || {}; $MODULE_REGISTRY['Code/WeBuilding'] = exports;  //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-21
 *  @file:      WeBuilding.js
 *  @author:    Chris Jimison
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Require Block
var Core = require('NGCore/Client/Core').Core;
var Social = require('NGCore/Client/Social').Social;
var Content = require('weEngine/WeContent').Content;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var WeBuildingBubble = require('weEngine/WeBuildingBubble').WeBuildingBubble;
var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var WeEffectsMgr = require('weEngine/WeEffects').WeEffectsMgr;
var WeFlyOff = require('weEngine/WeFlyOff').WeFlyOff;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;
var WeBuildingBase = require('weEngine/WeBuildingBase').WeBuildingBase;
var WeCoinsCrowns = require('weEngine/WeCoinsCrowns').WeCoinsCrowns;
//////////////////////////////////////////////////////////////////////////////
/**
 * Class : _WeBuilding
 * @brief: Defines the basics of what a "Building" is
 */
exports.WeBuilding = WeBuildingBase.subclass({
	classname : "WeBuilding",
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: Init
	 * The building for use in the game
	 * @param {Enity} enity Game Enity this building is really a wrapper for
	 * @param {ProtoEntity} protoEntity The proto entity associated with this building
	 * @param {ProtoVisual} protoVisual The proto visual associated with this building
	 * @param {protoVisualDecal} protoVisualDecal The proto entity visual decal 
	 *                                            associated with this building
	 * @param {bool} addToGrid should the building be added to the game grid
	 * @param {bool} isShell object that doesn't really do anything but look pretty
	 */
	initialize : function(entity, protoEntity, protoVisual, protoVisualDecal, addToGrid, isShell)
	{
		this.mSize = new Vec2D();
		this.mAnchor = new Vec2D();
		this.mState = BuildingState.None;

		//Don't touch it is for internal class use :)
		this.mAddedToGrid = false;
		this.mbTouched = false;
		this.canProcess = true;
		this.canProcessZap = true;
		this.canSendJob = true;

		// this.mBRect = null;

		this.mVillagers = [];
		this.updating = false;
		if (!Exists(isShell))
		{
			isShell = false;
		}

		this.mEntity = entity;
		this.mProtoEntity = protoEntity;

		if (Exists(protoVisual))
		{
			this.mProtoVisual = protoVisual;
		}

		if (Exists(protoVisualDecal))
		{
			this.mProtoVisualDecal = protoVisualDecal;
		}

		if (!isShell)
		{
			var products = weProtoDb.getInstance().getProtoProducesForEntity(entity.proto_entity_id);
			this.InitProducts(products);
		}

		var results = this.InitSprites(addToGrid);

		if (results)
		{
			if (!isShell)
			{
				// Special case gift cart init
				if (this.IsGiftCart())
					this.mEntity.work_type = 'gift_cart';

				if (this.IsHarvestAll())
					this.mEntity.work_type = 'harvest_all';
				
				this.InitProductsFromId(entity.proto_entity_id);

				// Enable updates for buildings, but NOT decals
				if (!this.IsStateSet(BuildingState.Decal))
				{
					this.toggleUpdatable();
				}

				this.mSelectSound = protoEntity.sound_select;
			} else
			{
				this.InitShell();
			}
		} else if (isShell)
		{
			this.InitShell();
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: SetupSprites
	 * Init the sprite data in the game.
	 * @param {bool} addToGameWorld Should the building be added to the game world
	 */
	InitSprites : function(addToGameWorld)
	{
		var protoEntity = this.GetProtoEntity();
		var protoVisual = this.GetProtoVisual();
		var protoVisualDecal = this.GetProtoVisualDecal();

		var lod = gLOD;
		if (protoEntity.entity_type != "BuildingCityHall" && !this.IsGiftCart())
		{
			this.SetState(BuildingState.Movable);
		}
		if (protoVisual)
		{
			this.mSprite = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), protoVisual, lod, this.mEntity.flipped, 1);
			this.UpdateSpritePosition(false);
			this.mSprite.name = this.mProtoVisual.header_tag;
			this.mSprite.primary = true;
			this.mSprite.mOwner = this;
		}

		// Setup this guys game size
		if (protoEntity && Exists(protoEntity.obstruction_size_x) && Exists(protoEntity.obstruction_size_y))
		{
			if(protoEntity.obstruction_size_x === 0 &&
			protoEntity.obstruction_size_y === 0) 
			{
				if(this.mSprite)
				{
					this.SetSizeFromSprite(this.mSprite);
				}	
			}
			else
			{
				this.mSize.x = protoEntity.obstruction_size_x;
				this.mSize.y = protoEntity.obstruction_size_y;
			}
		} else if (this.mSprite)
		{
			this.SetSizeFromSprite(this.mSprite);
		} else
		{
			this.mSize.x = 0;
			this.mSize.y = 0;
		}

		var isDecal = this.CountDecalState();
		//NgLogD("********* isDecal = " + isDecal);

		if (protoVisualDecal)
		{

			this.mDecal = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), protoVisualDecal, lod, this.mEntity.flipped, 0.4);

			this.UpdateDecalPosition(isDecal);

			if (this.mSize.x === 0)
			{
				this.SetSizeFromSprite(this.mDecal);
			}
			this.mDecal.name = protoVisualDecal.header_tag;
			this.mDecal.mOwner = this;
			this.mDecal.primary = false;
		}

		var self = this;
		this.mAnchor.x = this.mEntity.location_x;
		this.mAnchor.y = this.mEntity.location_y;
		
		if (this.mDecal)
		{
		    this.mDecal.mOwner = this;
			this.mDecal.Enable("Touch", function(touch)
			{
				return self.OnNativeTouch(touch);
			});
		} 
		
		if (this.mSprite)
		{
		    this.mSprite.mOwner = this;
			this.mSprite.Enable("Touch", function(touch)
			{
				return self.OnNativeTouch(touch);
			});
		}

		var wasAdded = false;
		if (addToGameWorld)
		{
			var ignoreBounds = true;
			if (this.IsGiftCart())
			{
			    wasAdded = this.AddToGridIgnoreOnlyBounds(WeGameStateMgr.GetGameLotGrid());
			}
			else
			{
			    wasAdded = this.AddToGrid(WeGameStateMgr.GetGameLotGrid(), ignoreBounds);
		    }

			if (!wasAdded)
			{
				wasAdded = this.AddToGridClosest(WeGameStateMgr.GetGameLotGrid(), this.mAnchor);
				if(wasAdded)
				{
					WeGameStateMgr.GetGameLotGrid().AddToDirtyList(this);
				}
			}
			if (!wasAdded)
			{
				if (this.mSprite)
				{
					this.mSprite.destroy();
				}
				if (this.mDecal)
				{
					this.mDecal.destroy();
				}
			}
		}

		return wasAdded;
	},

	CountDecalState : function()
	{
	    this.UnsetState(BuildingState.Decal);
		if ((this.mProtoEntity.decal_z_order && this.mProtoEntity.decal_z_order !== 0))
		//if (this.mSize.x === 0 || this.mSize.y === 0)
		{
			this.SetState(BuildingState.Decal);
			return true;
		} else if (this.mProtoEntity.proto_name == "Gift Cart")
		{
			// --- Making giftcart back to a building
			// this.SetState(BuildingState.Decal);
			// return true;
		} else if (this.mProtoEntity && Exists(this.mProtoEntity.obstruction_size_x) && Exists(this.mProtoEntity.obstruction_size_y)
		    && this.mProtoEntity.obstruction_size_x === 0 && this.mProtoEntity.obstruction_size_y === 0)
	    {
	        this.SetState(BuildingState.Decal);
	        return true;
	    }
		var isDecal = !Exists(this.mSprite);
		if(isDecal)
			this.SetState(BuildingState.Decal);
		return isDecal;
	},

	////////////////////////////////////////////////////////////////////////////////
	//// Method: UnloadSprites
	//// Unloads any assets attached to this building
	UnloadSprites : function()
	{
		if (Exists(this.mDecal))
		{
			this.mDecal.destroy();
			delete this.mDecal;
			this.mDecal = null;
		}

		if (Exists(this.mSprite))
		{
			this.mSprite.destroy();
			delete this.mSprite;
			this.mSprite = null;
		}
		this.CloseJobBubble();
	},

	InitShell : function()
	{
		// Set the shell properties for this guy
		var color = 111 / 255;
		this.SetColor(color, color, color, 1);
		this.SetGameState(BuildingState.Shell);
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: InitProducts
	 * Sets up the products that this building can produces
	 * @param {ProtoProduct} product the proto product attached to this building
	 */
	InitProducts : function(products)
	{

		//
		//	invalidate job state
		//
		this.mJob = null;
		
		if (Exists(products) && products.length > 0)
		{
			// Cache off the needed vars 
			this.mProtoProducts = products;
			this.mProtoJobProducts = [];
			this.mProtoProductsInLevel = [];

			var productsLen = products.length;
			for ( var idx = 0; idx < productsLen; ++idx)
			{
				if (null !== products[idx].proto_event_id)
				{
					this.mProtoJobProducts.push(products[idx]);
				} else
				{
					if (products[idx].level <= WeGameStateMgr.GetGameLotInfo().mLevel)
					{
						this.mProtoProductsInLevel.push(products[idx]);
					}
				}
			}
			if (products.length > 0)
			{
				this.SetState(BuildingState.Product);
			}
			if (this.mProtoJobProducts.length > 0)
			{
				this.SetState(BuildingState.JobProduct);
			}
			if (this.mProtoProductsInLevel.length == 1) //HACK - THIS VAR SHOULD BE DELETED
			{
				if (this.mEntity.proto_entity_id != 4 && this.mEntity.proto_entity_id != 753 && this.mEntity.proto_entity_id != WeEventGame.mEventProducingBuildingIdList) //HACK - furthermore make sure its NOT a farm
				{
					// don't set auto-produce for event entities like the orchid planter box
					var configs = weProtoConfigs.getInstance().map;
					if (configs.EventParticipationEntityIds != undefined)
					{
						var eventIDstring = configs.EventParticipationEntityIds.toString();
						var eventIDs = eventIDstring.split("|");
						var numEventIDs = eventIDs.length;
						for (var i = 0; i < numEventIDs; ++i)
						{
							if (this.mEntity.proto_entity_id == parseInt(eventIDs[i]))
							{
								NgLogD("event entity id " + this.mEntity.proto_entity_id + " set to not auto-produce");
								return;
							}
						}
					}
					
					if (WeEventGame.isEventProducingID(this.mEntity.proto_entity_id))
					{
						NgLogD("game event entity id " + this.mEntity.proto_entity_id + " set to not auto-produce");
						return;
					}
					
					this.SetState(BuildingState.AutoProducing);
				}
			}
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : DoGrowing
	 * Update the get building state for a "growing" tick.
	 */
	DoGrowing : function()
	{
		this.SetGameState(BuildingState.Busy);
		// Check how far along this guy is and update it with the correct display
		var percentage = this.CompletionPercentage();
		var prod = null;
		var protoEntity = this.GetProtoEntity();

		if (this.IsStateSet(BuildingState.AutoProducing))
		{
			prod = this.GetJobProductByProducingProtoEntityId(protoEntity.id);
			if (prod)
			{
				if (percentage == 1.0)
				{ // done
					this.SetGameState(BuildingState.Ready);
					this.OpenJobBubble();
			//		this.AttractPest();
				} else if (percentage == -1.0)
				{ // spoiled
					this.SetSpoiled();
				}
			} else
			{
				if (this.HasWorkStarted())
				{
					date = this.GetActualWorkStartedDate();
					var job = this.ActiveJob();
					prod = weProtoDb.getInstance().getProtoProduceId(this.mEntity.current_product_id);
                    if (Exists (prod))
                    {
					    complete = WeTime.GetGameDate();
					    complete.setTime(prod.produce_duration * 1000 + date.getTime());
					    now = WeTime.GetGameDate();
					    if (complete <= now)
					    {
						    this.SetGameState(BuildingState.Ready);
						    this.OpenJobBubble();
					    } else if (job && WeGameStateMgr.GetGameLotInfo().IsJobSpoiled(job))
					    {
					    	this.SetGameState(BuildingState.Spoiled);
						    this.OpenJobBubble();
					    }
                    }
				}
			}
		} else
		{
			prod = this.GetProductFromId(this.mEntity.current_product_id);
			if (prod)
			{
				var anim = weProtoDb.getInstance().getProtoEntityAnimationById(prod.proto_animation_id);
				if (Exists(anim))
				{
					if (percentage == -1.0)
					{
						this.SetSpoiled();
					} else if (percentage == 1.0)
					{
						// Set the almost done image
						this.SetMainSpriteTo(anim.header_tag, 1);
						this.SetGameState(BuildingState.Ready);

						if (WeGameStateMgr.IsCurrentUser())
						{
							this.OpenJobBubble();
						}
					} else if (percentage >= 0.66)
					{
						// Set the over half way done image
						this.SetMainSpriteTo(anim.header_tag, 0);
					} else if (percentage >= 0.33)
					/*	
					{
						this.SetMainSpriteTo(this.GetProduceAnimation(), 1);
					} else
					{
						this.SetMainSpriteTo(this.GetProduceAnimation(), 0);
					}
					*/
					{
						// Get Produce state
						var animBuilding = weProtoDb.getInstance().getProtoAnimationsForProtoVisualIdState(this.mProtoEntity.primary_proto_visual_id, "Produce");
						if (animBuilding)
						{
							this.SetMainSpriteTo(animBuilding.header_tag, 0);
						} else
						{
							this.SetMainSpriteTo(anim.header_tag, 0);
						}
					} else
					{
						// Get Idle state
						var animBuilding = weProtoDb.getInstance().getProtoAnimationsForProtoVisualIdState(this.mProtoEntity.primary_proto_visual_id, "Produce");
						if (animBuilding)
						{
							this.SetMainSpriteTo(animBuilding.header_tag, 0);
						} else
						{
							this.SetMainSpriteTo(anim.header_tag, 0);
						}
					}
				} else
				{
					if (percentage == 1.0)
					{ // done
						this.SetGameState(BuildingState.Ready);
						if (WeGameStateMgr.IsCurrentUser())
						{
							this.OpenJobBubble();
						}
					} else if (percentage == -1.0)
					{ // spoiled
						this.SetSpoiled();
					}
				}
			}
		}
	},
	
	GetProduceAnimation : function()
	{
		if(this.mEntity.proto_entity_id == 4)
		{
			return 'SPR_farm_base_produce';
		}
		else if( this.mEntity.proto_entity_id == 753 )
	   {
		   return 'SPR_mcfarm_base_produce';
	   }
	   return 'SPR_farm_base_produce';
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: GetBuildingUiLoadArgs
	 * @param {Object} args gets the location of the item
	 * @return {Object}
	 */
	SetupBuildingUI : function(args)
	{
		args.source = this;
		args.pos_x = 0;
		args.pos_y = 0;

		var itemDef = WeUiMgr.GetItemDef(args.itemType);
		var widget = WeUiMgr.CreateGameWidget(itemDef, args, WeRenderDevice.GetGameUiRoot());

		// this prioritizes progress bar items over job bubble items
		var incZ = 1;
		if (args.itemType == "job_bubble")
		{
			incZ = 0.5;
			//NgLogD("Trying to show job bubble...");
		}

		// March down the widget heirarchy and base all of the Z values off of this base sprites Z
		var cSprite = this.GetMainSprite();
		if (cSprite)
		{
			args.pos_x = this.GetBuildingBubbleX();
			args.pos_y = this.GetBuildingBubbleY();
			if(args.itemType == 'action_bubble')
				args.pos_y -= 32;
			widget.setPosition(args.pos_x, args.pos_y, 0);
		}
		

		return widget;
	},

	////////////////////////////////////////////////////////////////////////////////
	///**
	// * Method : OnSpoiled
	// * This building is now in a "Spoiled" game state.  This should only really
	// * be set for things that have a time limit to how long their product can
	// * be ready for. "Farms" for werule is a good example.
	// */
	SetSpoiled : function()
	{
		if (this.IsDecoration())
		{
			return false;
		}

		this.SetGameState(BuildingState.Spoiled);

		if (this.IsStateSet(BuildingState.AutoProducing))
		{
			return;
		}

		if (WeGameStateMgr.IsCurrentUser())
		{
			this.OpenJobBubble();
		}
		
		var animBuilding = weProtoDb.getInstance().getProtoAnimationsForProtoVisualIdState(this.mProtoEntity.primary_proto_visual_id, "Produce");

		// Check if the graphics are valid, else leave it alone
		if (animBuilding)
		{
			this.SetMainSpriteTo(animBuilding.header_tag, 2);
		}
		
		//this.SetMainSpriteTo(this.GetProduceAnimation(), 2);
	},

	ActiveJob : function()
	{ // TODO: make this more efficient

		if (Exists(this.mJob))
		{
			if (this.mJob == 'none')
			{
				return null;
			}
			
			return this.mJob;
		}
				
		var lot = WeGameStateMgr.GetGameLotInfo();
		var active_jobs = lot.active_jobs;
		var len = active_jobs.length;
		for ( var idx = 0; idx < len; ++idx)
		{
			var job = active_jobs[idx];
			if (job.entity_id == this.mEntity.id)
			{
				
				if ((job.state == "RequestSent") || (job.state == "Working"  && this.mEntity.current_product_id == job.product_id))
				{
					this.mJob = job;
					return job;
				}
			}
		}
		
		this.mJob = 'none';

		return null;

	},

	GetBuildingJob : function()
	{ 
		return this.ActiveJob();
	},

	
	IsDecoration : function()
	{
		var proto_entity = weProtoDb.getInstance().getProtoEntityById(this.mEntity.proto_entity_id);
		
		if (Exists(proto_entity) && proto_entity.entity_type == 'Decoration')
		{
			return true;
		}
		
		return false;
	},
	
	
	
	ShouldHaveOwnerJobBubble : function()
	{
		
			
		if (!this.HasWorkStarted() || !this.IsStateSet(BuildingState.AutoProducing)
        		    || this.IsStateSet(BuildingState.Collecting))
        {
            return false;
        }

		var job =  this.ActiveJob();
		
		var date = this.GetActualWorkStartedDate();

		var prod = weProtoDb.getInstance().getProtoProduceId(this.mEntity.current_product_id);
		if (!Exists(prod))
		{
			NgLogD("Missing produce for id "+this.mEntity.current_product_id);
		    return false;
		}
		
		
				
		var complete = WeTime.GetGameDate();
		complete.setTime(prod.produce_duration * 1000 + date.getTime());
		now = WeTime.GetGameDate();
		
				
		if (complete <= now)
		{
			return true;
		} else if (job && job.state == "RequestSent")
		{
			return true;
			
		} else if (job && WeGameStateMgr.GetGameLotInfo().IsJobSpoiled(job))
		{
			return true;
		}

		return false;
	},

	ShouldHaveFriendJobBubble : function()
	{
		var job = this.ActiveJob();
		
		if (this.IsStateSet(BuildingState.JobProduct) && this.HasAvailableJobs() && (this.mEntity.current_product_id != this.mProtoJobProducts[0].id))
		{
			// Available for a social job 
			return true;
		} 
		else if (job && this.GetProtoJobProducts() != null && !WeGameStateMgr.GetGameLotInfo().IsJobSpoiled(job))
		{
			return true;
		} 
		else if (Exists(this.mJobPlaced))
		{
			return true;
		}

		return false;
	},
	
	
	//////////////////////////////////////////////////////////////////////////////
	// Method:  Flip
	// Flips the building 
	Flip : function()
	{
		var hadBubble = Exists(this.mBubble);

		var oldR = this.GetColor().getRed();
		var oldG = this.GetColor().getGreen();
		var oldB = this.GetColor().getBlue();

		this.UnloadSprites();
		this.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());
		this.mEntity.flipped = !this.mEntity.flipped;
		this.InitSprites(false);
		this.SetColor(oldR, oldG, oldB, 1);

		if (this.AddToGridClosest(WeGameStateMgr.GetGameLotGrid(), this.mAnchor))
		{
			WeGameStateMgr.GetGameLotGrid().AddToDirtyList(this);
		} else
		{
			this.UnloadSprites();
			this.InitSprites();
		}

		//HACK for farms
		if (!this.IsStateSet(BuildingState.Shell))
		{
			var sheet = this.mCurrentSprite;
			var frame = this.mCurrentFrame;
			if (sheet && sheet !== "")
			{
				this.mCurrentSprite = "";
				this.mCurrentFrame = -1;

				this.SetMainSpriteTo(sheet, frame);
			}
		}

		if (Exists(this.mActionBubble))
		{
			this.mActionBubble.Trigger('force_close');
		}

		if (hadBubble)
		{
			this.CloseJobBubble();
			this.OpenJobBubble();
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : DoConstruction
	 * Tell the building to continue on with it's construction effort
	 */
	DoConstruction : function()
	{
		// Check to see if we are done
		if (this.IsConstructionDone())
		{
			// Lets re-init this guy
			this.UpdateEntity(this.mEntity);
			this.SetColor(1, 1, 1, 1);
			this.RemoveBuilder();

			// create villager?
			this.RemoveVillagers();
			this.CreateVillagers();
			return;
		}

		// Keep building
		if (!Exists(this.mAgentBuilder))
		{
			this.CreateBuilder();
		}
	},

	CreateBuilder : function()
	{
		// id should be read from config
		var protoEntity = weProtoDb.getInstance().getProtoEntityById(126);
		var protoVisual = weProtoDb.getInstance().getProtoVisualById(protoEntity.primary_proto_visual_id);

		this.mAgentBuilder = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), protoVisual, 0, false, 1);

		this.mAgentBuilder.PushGamePosition([ this.mEntity.location_x, this.mEntity.location_y, 80 ], [ 0, 0, this.mProtoVisual.z_order_vertical_offset ]);
		this.mAgentBuilder.SetAnimationByName("HelpBuild");

	},

	//////////////////////////////////////////////////////////////////////////////
	// Method: UpdatePosition
	// @param: Array[x, y, z];
	PositionUpdated : function()
	{

		this.mEntity.location_x = this.mAnchor.x;
		this.mEntity.location_y = this.mAnchor.y;

		var isDecal = this.CountDecalState();

		if (this.mSprite)
		{
			this.UpdateSpritePosition(isDecal);
		}
		if (this.mDecal)
		{
			// Z  = 0.5
			this.UpdateDecalPosition(isDecal);
		}

		// this.SetBRectPosition(this.mAnchor);

		if (Exists(this.mActionBubble))
		{
			this.mActionBubble.Trigger('force_close');
		}

		if (Exists(this.mBubble))
		{
			this.CloseJobBubble();
			this.OpenJobBubble();
		}

		if (Exists(this.mAgentBuilder))
		{
			// stop the building dude
			this.RemoveBuilder();
			this.CreateBuilder();
		}

		//WeGameStateMgr.SetGlobalGameWidget(null);

	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnObjStateAssetRequested
	 * Callback made by the UI screen system to request the correct asset based
	 * on the state of the game.  This is how the game messages back to the
	 * ui system for assets to display based on the general screen "state"
	 * @return{String} name of the asset to display
	 */
	OnObjStateAssetRequested : function()
	{
		var asset = "";
		var len = 0;
		var idx = 0;
		var protoEntity = this.GetProtoEntity();
		var protoProducts = this.GetProtoProducts();
		var job;

		if (this.IsGiftCart())
		{
			asset = getAssets( "icon_gifting" );
		}

		else if (this.IsHarvestAll())
		{
			asset = getAssets( "job_scryingpool" );
		}

		// Check to see if we are currently 'Constructing' the building
		else if (this.IsStateSet(BuildingState.Constructing))
		{
			// $TODO get this asset from the screen DEF, not the code
			asset = getAssets( "icon_hammer" );
		} else if (this.IsStateSet(BuildingState.AutoProducing))
		{
			if (WeGameStateMgr.IsCurrentUser())
			{
				job = this.ActiveJob();
				var prod = this.GetProductFromId(this.mEntity.current_product_id);
				if (job && job.state == "RequestSent")
				{
					// $TODO: plus user image. 
					asset = ".User_" + job.request_name;
				} else if (job && WeGameStateMgr.GetGameLotInfo().IsJobSpoiled(job))
				{
					asset = getAssets( "resIcon_spoil" );
				} else if (prod && this.CalculateProducedAmount() === prod.produce_cap)
				{ // done
					if (job && Exists(prod.icon_png))
					{
						asset = prod.icon_png;
					} else
					{
						// $TODO: Get this asset from the screen DEF file

						if (Exists(prod.icon_png))
						{
							asset = prod.icon_png;
						} else
						{
							asset = getAssets( "resIcon_gold" );
						}

					}
				}
			} else
			{
				job = this.ActiveJob();
				if (this.HasAvailableJobs())
				{
					// $TODO get this asset from the screen DEF file
					asset = getAssets( "resIcon_open4biz" );
				} else if (job && job.state == "RequestSent")
				{
					// $TODO: plus user image. 
					asset = ".User_" + job.request_name;
				} else if (job && WeGameStateMgr.GetGameLotInfo().IsJobSpoiled(job))
				{
					asset = getAssets( "resIcon_spoil" );
				} else if (Exists(this.mJobPlaced))
				{
					asset = ".User_" + gUsernameSelf;
				}

			}
		} else
		{
			// $TODO get this asset from the screen DEF file
			asset = getAssets( "resIcon_spoil" );
			if (this.IsStateSet(BuildingState.Available))
			{
				// $TODO get this asset from the screen DEF file
				if (WeEventGame.isEventProducingID(this.mEntity.proto_entity_id))
				{
					asset = getAssets("resIcon_seedbag");
				}
				else if (protoEntity.idle_icon_png)
				{
					asset = protoEntity.idle_icon_png;
				}
				else
				{
					asset = getAssets( "resIcon_seedbag" );
				}
			} else if (this.IsStateSet(BuildingState.Ready))
			{
				len = protoProducts.length;
				for (idx = 0; idx < len; ++idx)
				{
					if (this.mEntity.current_product_id == protoProducts[idx].id)
					{
					    if (Exists(protoProducts[idx].icon_png))
					    {
						    asset = protoProducts[idx].icon_png;
					    }
						break;
					}
				}
			}
		}
		asset = this.FixPngExtension(asset);
		if (asset === ".png")
		{
			//DebugPrintCallstack();
		}

		return asset;
	},

	//////////////////////////////////////////////////////////////////////////////
	/*
	 * Method:  OnProduceTouch
	 * Handle touches on producing buildings
	 */
	OnProduceTouch : function()
	{
		
		
		var self = this;
		var prod = this.GetProductFromId(this.mEntity.current_product_id);
		gCurrentProducingBuilding=this.mEntity.proto_entity_id;
		var widget = null;
		// Setup the UI args 
		var args = this.GetUILocationArgs();
		args.source = this;
		args.product = prod;
		var bubble = null;

		if (this.IsStateSet(BuildingState.Available))
		{
			args.itemType = "harvest_selection";
			var def = WeUiMgr.GetItemDef(args.itemType);
            def.labels[0].text = this.mProtoEntity.product_choice_text;
//            NgLogD("############  ProtoEntity dump #########");
//            fullRecurseDump(this.mProtoEntity,2,"###");
//            NgLogD("############  ProtoEntity dump end #########");
			widget = WeUiMgr.CreateGameWidget(def, args);
			widget.setPosition(0, 0, 6);
			WeGameStateMgr.SetGlobalGameWidget(widget);
		} else if (this.IsStateSet(BuildingState.Spoiled))
		{
			// Create the Job bubble
			bubble = this.CreateCollectionBubble(getAssets( "resIcon_spoil" ), "Cleaning...", prod);

			// When the bubble closes set us back to available
			bubble.On('close', function()
			{
				self.needFlyOff = false;
				self.OnRequest(bubble.xRequest, 'OnHarvest', null);
				self.SetAvailable();
			});

			// Send off the request
			WeProtocol.harvest(this.mEntity.id, function(request)
			{
				bubble.xRequest = request;
				bubble.Trigger('done');
			});

            this.mSpoiled = true;
		} else if (this.IsStateSet(BuildingState.Ready))
		{
			if(!gHarvestAllActive)
			{
				// Create the Job bubble
				bubble = this.CreateCollectionBubble(prod.icon_png, "Harvesting...", prod);

				// When the bubble closes set us back to available
				bubble.On('close', function()
				{
					
					self.OnRequest(bubble.xRequest, 'OnHarvest', null);
					
				});

				// Send off the request
				WeProtocol.harvest(this.mEntity.id, function(request)
				{
					bubble.xRequest = request;
					bubble.Trigger('done');
				});
			}
		} else if (this.IsStateSet(BuildingState.Busy))
		{
			args.itemType = "harvest_status";
			if (null !== prod)
			{
				args.obj_state_image = prod.icon_png;
				args.obj_state_text = prod.producing_text;
				args.obj_state_boost = prod.boost_cost;

				var defBusy = WeUiMgr.GetItemDef(args.itemType);
				var gameWidget = WeUiMgr.CreateGameWidget(defBusy, args);
				gameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5, 6);

				gameWidget.EnableUpdate(function(delta)
				{
					var remaining = self.GetPercentRemaining(prod);
					if (remaining >= 100)
					{
						WeGameStateMgr.SetGlobalGameWidget(null);
					}
				});

				gameWidget.Name = function()
				{
					return "OnProduceTouch";
				};

				WeGameStateMgr.SetGlobalGameWidget(gameWidget);
			}
		}
				
		
		
		
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method:  SetUILocation
	 * Sets the object place in the correct location relative to the game object
	 * @return {Object}  an object that will have the pos_x and pos_y
	 * values set of it
	 */
	GetUILocationArgs : function(args)
	{
		if (!Exists(args))
		{
			args = {};
		}
		args.pos_x = gRawWidth * 0.5;
		args.pos_y = gRawHeight * 0.5;
		return args;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnItemSelected
	 * The callback that the user has selected an item to produce. This must be
	 * set up to the server for verification
	 * @param {ProtoEntity} ent ref of the requested item to create
	 */
	OnItemSelected : function(ent)
	{
		if (ent.product.level <= WeGameStateMgr.GetGameLotInfo().mLevel)
		{
			this.CloseJobBubble();
			WeGameStateMgr.SetGlobalGameWidget(null);
			var self = this;

            if (WeEventGame.isEventProducingID(this.mEntity.proto_entity_id))
            {
                var bubble = this.CreateCollectionBubble(ent.product.icon_png, "Enchanting " + ent.product.proto_name + "...", ent.product);
            }
            else
            {
			    // Bring up the Planting UI
			    var bubble = this.CreateCollectionBubble(ent.product.icon_png, "Planting " + ent.product.proto_name + "...", ent.product);
            }
			// When the bubble closes set us back to available
			this.mActionBubble.On('close', function()
			{
				self.OnRequest(bubble.xRequest, 'OnPlantCrop');
			});

			// Send off the request
			WeProtocol.produce(this.mEntity.id, ent.product.id, function(request)
			{
				bubble.xRequest = request;
				bubble.Trigger('done');
			});
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: CreateCollectionBubble
	 * This is really just a convence wrapper for creating the building bubbles
	 * and should not be used except for inside the WeBuilding code
	 * @param{String} image name of the image asset to display
	 * @param{String} text to display in the action bubble
	 * @param{ProtoProto} prod that can be querried for info
	 */
	CreateCollectionBubble : function(image, text, prod, time)
	{
		var args = {};
		args.source = this;
		args.itemType = "action_bubble";
		args.obj_state_image = image;
		args.obj_state_text = text;
		args.obj_state_time_remaining_percent = "0%";
		args.product = prod;
		this.CreateActionBubble(args, time);
		this.SetGameState(BuildingState.Collecting);
		// add bubble to collection bubbles list
		WeGameStateMgr.mCollectionBubbleList.push(this.mActionBubble);
		NgLogD("Collection bubbles: "+WeGameStateMgr.mCollectionBubbleList.length);
		return this.mActionBubble;
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: CreateCollectionBubble
	 * This is really just a convence wrapper for creating the building bubbles
	 * and should not be used except for inside the WeBuilding code
	 * @param{String} image name of the image asset to display
	 * @param{String} text to display in the action bubble
	 * @param{ProtoProto} prod that can be querried for info
	 */
	CreateActionBubble : function(args, time)
	{
		var self = this;

		// Construct the Widget object
		var widget = this.SetupBuildingUI(args);

		// If there is already an action bubble up, get rid of it
		if (Exists(this.mActionBubble))
		{
			this.mActionBubble.Trigger('force_close');
		}

		// Create the new bubble wrapper
		var bubble = new WeBuildingBubble(widget, true);
		this.mActionBubble = bubble;

		/** 
		 * The action bubble is now ready
		 */
		bubble.On('ready', function()
		{
			bubble.xStart = true;
			bubble.mTimer = new SimpleTimer(bubble.xTime * 1000);
			bubble.xCompleted = false;
			bubble.xPercent = 0;
			self.CloseJobBubble();
		});

		/** 
		 * The Action bubble is now updating
		 */
		bubble.On('update', function()
		{
			var now = WeTime.GetGameDate();
			if (bubble.xCompleted && bubble.xPercent >= 100)
			{
				bubble.xPercent = 100;
				bubble.Trigger('internal_close');
			} else
			{
				//if (bubble.xCompleted) NgLogD("Bubble done, but at "+bubble.xPercent+" percent...");	
				bubble.mTimer.Update();
				bubble.xPercent = bubble.mTimer.GetPercents();
			}
		});

		// External source as triggered that the action bubble is done
		bubble.On('done', function()
		{
			bubble.xCompleted = true;
		});

		// Source as triggered that the action bubble should close
		bubble.On('internal_close', function()
		{
			// remove bubble from collection bubbles list
			var list = WeGameStateMgr.mCollectionBubbleList;
			for (var j in list)
			{
				if (list[j] === bubble)
				{
					list.splice(j,1);
					break;
				}
			}
			// perform delayed (message) handler
			if (Exists(bubble.notify) && Exists(bubble.notifyArgs))
				bubble.notify(bubble.notifyArgs);
			
			bubble.Trigger('close');
			var hasProducts = self.IsStateSet(BuildingState.Product);
			var isAutoProducts = self.IsStateSet(BuildingState.AutoProducing);
			if (hasProducts && !isAutoProducts && !self.IsStateSet(BuildingState.Busy))
			{
				self.OpenJobBubble();
			}

			if (widget !== null)
			{
				if (Exists(widget))
				{
					widget.destroy();
				}
				delete self.mActionBubble;
				self.mActionBubble = null;
				widget = null;
			}
		});

		bubble.On('force_close', function()
		{
			// Ugly fix - near release (WeHope (tm))
			if (args.obj_state_text == "Placing...")
			{
				//Don't allow placing objects to be force closed...
				//this call is already headed to the server and we pretty much
				//need to NOT allow the object to be killed by the local client
				//NgLogD("Cancelling force close on a placing object");
				return;
			}

			// remove bubble from collection bubbles list
			var list = WeGameStateMgr.mCollectionBubbleList;
			for (var j in list)
			{
				if (list[j] === bubble)
				{
					list.splice(j,1);
					break;
				}
			}

			if (widget !== null)
			{
				if (Exists(widget))
				{
					widget.destroy();
				}
				delete self.mActionBubble;
				self.mActionBubble = null;
				widget = null;
			}
		});

		if(isFinite(time))
			bubble.xTime = time;
		else
			bubble.xTime = gGlobalHarvestTime; // tested from WeRule $TODO Make this a tunable!

		bubble.Trigger('ready');
	},

	OnAutoProduceTouchOwerBuilding : function()
	{
		var self = this;
		var job = this.GetBuildingJob();
		var itemDef = null;
		var gameWidget = null;

		var args = {};
		args.source = this;
		args.pos_x = gRawWidth / 2;
		args.pos_y = gRawHeight / 2;

		if (this.mWaitingRespons)
		{
			return;
		}

		if (job && WeGameStateMgr.GetGameLotInfo().IsJobSpoiled(job))
		{
			//NgLogD("@@@@@ Job is spoiled");
			if (job.state === "RequestSent")
			{
				this.mWaitingRespons = true;
				WeProtocol.hireReply(job, false, function(request)
				{
					self.OnRequest(request, 'OnProcessJob', 'job');
					self.RemoveJobHack(request, job);
					this.mWaitingRespons = false;
				});
			} else
			{
				NgLogD("cancel spoiled job");
				
				// Create the Job bubble
				bubble = this.CreateCollectionBubble(getAssets( "resIcon_spoil" ), "Cleaning...",this.GetProductFromId(this.mEntity.current_product_id));

				// When the bubble closes set us back to available
				bubble.On('close', function()
				{
					self.needFlyOff = false;
					self.OnRequest(bubble.xRequest, 'OnHarvest', null);
				});
				
				// Send off the request
				WeProtocol.harvest(this.mEntity.id, function(request)
				{
					bubble.xRequest = request;
					bubble.Trigger('done');
				});

			}
			
		} else if (job && job.state == "RequestSent" && this.canProcess)
		{
			//NgLogD("@@@@@ Job request was sent");
			this.canProcessZap = true;
			// show job request

			var prod = weProtoDb.getInstance().getProtoProduceId(job.product_id);
			if (prod === null)
			{
				NgLogD("ERROR: OnAutoProduceTouchOwerBuilding bad job");
				objDump(job, 4);
				return;
			}

			args.OnYes = function(args)
			{
				WeGameStateMgr.mTouchAllowed = false;
				self.canProcess = false;
				var bubble = self.CreateCollectionBubble(prod.icon_png, "Accepting...", prod);

				bubble.On('close', function()
				{
					WeGameStateMgr.mTouchAllowed = true;
					self.OnRequest(bubble.xRequest, 'OnProcessJob', 'job');
				});

				WeGameStateMgr.SetGlobalGameWidget(null);

				WeProtocol.hireReply(args.job, true, function(request)
				{
					bubble.xRequest = request;
					bubble.Trigger('done');
				});

			};

			args.OnNo = function(args)
			{
				WeGameStateMgr.mTouchAllowed = false;
				self.canProcess = false;
				var bubble = self.CreateCollectionBubble(prod.icon_png, "Rejecting...", prod);
				bubble.On('close', function()
				{
					WeGameStateMgr.mTouchAllowed = true;
					self.OnRequest(bubble.xRequest, 'OnProcessJob', 'job');
					self.RemoveJobHack(bubble.xRequest, bubble.job);
				});

				WeProtocol.hireReply(args.job, false, function(request)
				{
					bubble.xRequest = request;
					bubble.job = args.job;
					bubble.Trigger('done');
				});
				WeGameStateMgr.SetGlobalGameWidget(null);
			};

			var event = weProtoDb.getInstance().getProtoEventId(prod.proto_event_id);
			args.popup_label = "Job Request";
			args.popup_text = "Accept Job?";
			args.game_label_5 = "New " + this.mProtoEntity.proto_name + " Order!";
			args.game_label_4 = prod.produce_cap;
			args.game_label_3 = job.request_name;
			args.game_label_2 = prod.proto_name;
			args.game_asset_1 = prod.icon_png;
			args.game_label_6 = " ";
			var event = weProtoDb.getInstance().getProtoEventId(prod.proto_event_id);
			if (event)
			{
				args.game_label_6 = event.name;
			}

			args.job = job;
			itemDef = WeUiMgr.GetItemDef("accept_order");
			gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
			gameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5, 6);
			WeGameStateMgr.SetGlobalGameWidget(gameWidget);
		} else if (job && job.state == "Working" && this.canProcessZap)
		{
			//NgLogD("@@@@@ Job is working");
			this.canProcess = true;
			prod = this.GetJobProductByProducingProtoEntityId(this.mProtoEntity.id);
			remaining = self.GetPercentRemaining(prod);
			if (remaining < 100 && this.canSendJob)
			{
				args = {};
				args.OnYes = function(args)
				{
					self.OnUseMojo(prod);
					WeGameStateMgr.SetGlobalGameWidget(null);
				};

				args.OnNo = function(args)
				{
					WeGameStateMgr.SetGlobalGameWidget(null);
				};

				args.source = this;
				args.product = prod;
				args.building = self;
				itemDef = WeUiMgr.GetItemDef("job_status");

				args.obj_state_image = prod.icon_png;
				args.obj_state_text = prod.producing_text + " for \n" + job.request_name;
				args.obj_state_boost = prod.boost_cost;

				gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
				gameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5, 6);
				self = this;
				gameWidget.EnableUpdate(function()
				{
					var remaining = self.GetPercentRemaining(prod);
					if (remaining >= 100)
					{
						WeGameStateMgr.SetGlobalGameWidget(null);
					}
				});

				gameWidget.Name = function()
				{
					return "OnAutoProduceTouchOwerBuilding";
				};

				this.toggleUpdatable();
				WeGameStateMgr.SetGlobalGameWidget(gameWidget);

			} else if (this.canSendJob)
			{
				this.canSendJob = false;
				this.CloseJobBubble();
				// Create the Job bubble
				bubble = this.CreateCollectionBubble(prod.icon_png, prod.harvesting_text, prod);

				// When the bubble closes set us back to available
				bubble.On('close', function()
				{
					self.needFlyOff = true;
					self.OnRequest(bubble.xRequest, 'OnProcessJob', 'job');
					self.canSendJob = true;
				});

				// Set the work_started_at state 
				this.mEntity.work_started_at = null;
				// Send off the request
				WeProtocol.completeJob(this.ActiveJob(), function(request)
				{
					bubble.xRequest = request;
					bubble.Trigger('done');
				});
			}
		} else
		{
			if (!this.IsStateSet(BuildingState.Collecting))
			{
				//NgLogD("@@@@@ Building NOT collecting");
				prod = this.GetProductFromId(this.mEntity.current_product_id);
				remaining = self.GetPercentRemaining(prod);
				if(prod)
				{
					if (remaining < 100)
					{
						//NgLogD("@@@@@ Job/ produce is not finished");
						var cSprite = this.GetMainSprite();
						var cProtoVisual = this.GetMainProtoVisual();

						args.pos_x = self.GetBuildingBubbleX();
						args.pos_y = self.GetBuildingBubbleY(); //+offset; 

						args.itemType = "auto_producing_status";
						args.product = prod;
						// Ok this is a player building so open up the progress menu
						args.obj_state_text = prod.producing_text;
						args.obj_state_time_remaining_full = this.GetTimeRemaining(prod) + " Remaining";
						args.obj_state_time_remaining_percent = "" + remaining + "%";

						itemDef = WeUiMgr.GetItemDef("auto_producing_status");
						gameWidget = WeUiMgr.CreateGameWidget(itemDef, args, WeRenderDevice.GetGameUiRoot());

						args.pos_x = self.GetBuildingBubbleX();
						args.pos_y = self.GetBuildingBubbleY(); //+offset; 

						gameWidget.setPosition(args.pos_x, args.pos_y, cSprite.GetDepth() + 1);

						var statusBubble = new WeBuildingBubble(gameWidget, true);
						WeGameStateMgr.SetGlobalGameWidget(statusBubble);
					} else
					{
						if(!gHarvestAllActive)
						{
							//NgLogD("@@@@@ Job/ produce is finished");
							this.CloseJobBubble();
							WeEffectsMgr.PlaySoundEffect("money_coindrop.mp3");
							// Create the Job bubble
							var resIcon = getAssets( "resIcon_gold" );
							
							if (WeCoinsCrowns.isCoinImage(resIcon))
								resIcon = WeCoinsCrowns.getCoinsOrCrowns(resIcon);
							
							var collectionBubble = this.CreateCollectionBubble(resIcon , prod.harvesting_text, prod);

							// When the bubble closes set us back to available
							collectionBubble.On('close', function()
							{
								self.needFlyOff = true;
								//NgLogD("Closing bubble and letting the building to process server response");
								self.OnRequest(collectionBubble.xRequest, 'OnHarvest', null);
								self.SetState(BuildingState.AutoProducing);
								self.InitItem_Produce();	// put the building into the auto-producing cycle again
							});

							// Send off the request
							WeProtocol.harvest(self.mEntity.id, function(request)
							{
								self.prepareBubbleForClosing (collectionBubble, request);
								//NgLogD("##### Bubble that got back harvest response: ");
								//objDump(bubble);
								//NgLogD("##### END");
								//NgLogD("@@@@@ Completed: "+bubble.xCompleted+" @@@@@");
								//bubble.xRequest = request;
								//bubble.Trigger('done');
							});
						}
					}
				}
			}
			//else NgLogD("@@@@@ Building is collecting");
		}
	},

	OnAutoProduceTouchFriendBuilding : function()
	{
		if (this.IsStateSet(BuildingState.Collecting) || WeGameStateMgr.GetIsSocialJobPlaced())
		{
			return;
		}

		var self = this;
		var args = {};
		args.source = this;
		args.pos_x = gRawWidth / 2;
		args.pos_y = gRawHeight / 2;

		var prod = this.mProtoJobProducts[0];

		args.itemType = "place_order";
		args.game_label_1 = prod.proto_name;
		var event = weProtoDb.getInstance().getProtoEventId(prod.proto_event_id);
		args.game_label_2 = event.name;
		args.game_label_3 = "" + event.reward_gold;
		args.game_label_4 = "" + event.reward_xp;

		args.game_asset_1 = prod.icon_png;
		var def = WeUiMgr.GetItemDef("place_order");
		var widget = WeUiMgr.CreateGameWidget(def, args);
		widget.setPosition(args.pos_x, args.pos_y, 6);
		WeGameStateMgr.SetGlobalGameWidget(widget);
	},

	RemoveBuilder : function()
	{
		if (Exists(this.mAgentBuilder))
		{
			// stop the building dude
			this.mAgentBuilder.destroy();
			delete this.mAgentBuilder;
			this.mAgentBuilder = null;
		}
	},

	IsHarvestable : function()
	{
		if(this.IsStateSet(BuildingState.Ready))
			return true;

		if(this.IsStateSet(BuildingState.AutoProducing) || WeEventGame.isEventProducingID(this.mEntity.proto_entity_id))
		{
			var prod = this.GetProductFromId(this.mEntity.current_product_id);
			if (prod)
			{
				var remaining = this.GetPercentRemaining(prod);
				if(remaining >= 100)
					return true;
			}
		}

		return false;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : OnConstructingTouch
	 * The user touch a building that is under construction
	 * @param {Object} controller
	 * @param {Object} args
	 */
	OnConstructingTouch : function()
	{
		var self = this;
		var args = {};
		args.itemType = "job_status";

		prod = this.GetProductFromId(this.mEntity.current_product_id);

		args.product = prod;

		args.source = this;
		args.obj_state_image = getAssets( "icon_hammer" );
		args.obj_state_text = "Constructing...";
		args.obj_state_boost = this.mProtoEntity.boost_cost;

		var defBusy = WeUiMgr.GetItemDef(args.itemType);
		var gameWidget = WeUiMgr.CreateGameWidget(defBusy, args);
		gameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5, 6);

		gameWidget.EnableUpdate(function()
		{
			var remaining = self.GetPercentRemaining(null);
			if (remaining >= 100)
			{
				WeGameStateMgr.SetGlobalGameWidget(null);
			}
		});

		gameWidget.Name = function()
		{
			return "OnConstructionTouch";
		};
		this.toggleUpdatable();
		WeGameStateMgr.SetGlobalGameWidget(gameWidget);

		// Play the construction sound
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.ConstructionShort);
	},

	HasAvailableJobs : function()
	{
		return (!this.IsStateSet(BuildingState.Constructing) && (this.GetProtoEntity().entity_type == "Building") && this.GetProtoJobProducts() !== null && !this.ActiveJob()
		&& WeGameStateMgr.GetGameLotInfo().HasAvailableJobs());
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: OnHarvest
	 * This building needs to be have the harvest action applied to it.
	 * NOTE:  This is a callback made after the server has confirmed that the 
	 * lot has been harvested
	 * @param {Enitity} ent new server copy of the entity
	 */
	OnHarvest : function(obj)
	{
		var cb = function()
		{
			if (cb.ent)
			{
				WeGameStateMgr.GetGameLotInfo().UpdateInfo(cb.ent.kingdom.kingdom);
				WeEffectsMgr.PlaySoundEffect(cb.obj.mProtoEntity.sound_gather);
				cb.obj.UpdateEntity(cb.ent);
				cb.obj.SetAvailable();
				
			} else if (cb.job)
			{
				WeGameStateMgr.GetGameLotInfo().UpdateJobInfo(cb.job);
				cb.obj.UpdateEntity(cb.ent);
				WeEffectsMgr.PlaySoundEffect(cb.obj.mProtoEntity.sound_gather);
			}
		};
		
		cb.obj = this;
		
		if (obj === null || (Exists(obj.entity) && !Exists(obj.entity.kingdom)))
		{
			return;
		}

		cb.ent = obj.entity;
		cb.job = obj.job;
	
        if(!Exists(this.mSpoiled) || !this.mSpoiled)
        {
		    if ((Exists(obj.entity) && Exists(obj.entity.kingdom)))
		    {
			    this.needFlyOff = true;
		    }
		
		    var prod = this.GetProductFromId(this.mEntity.current_product_id);
		    if (prod && this.needFlyOff)
		    {
			    WeEffectsMgr.PlaySoundEffect("money_coindrop.mp3");
			    var offset = 0;
			    if (prod.xp_reward > 0)
			    {
				    this.CreateResourceFlyOff(prod.xp_reward, "xp", 0);
				    offset += gFlyOffOffset;
			    }

			    if (prod.produce_cap > 0)
			    {
				    this.CreateResourceFlyOff(prod.produce_cap, "coin", offset);
			    }
            }
		}


    
		if (WeEventGame.isEventProducingID(this.mEntity.proto_entity_id))
		{   // we only create the set of items when none on screen
		    // this prevents the same active items from appearing after another harvest.
		    var cSprite = this.GetMainSprite();
		    WeEventGame.createDropsFromActiveItems(cSprite.GetX(), cSprite.GetY());
		}
		

		this.OnFlushSprite(cb);
        this.mSpoiled = false;
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: OnFlushSprite
	 * @param {Function} to call once the old sprite has been removed
	 */
	OnFlushSprite : function(cb)
	{
		//NgLogD("OnFlushSprite start");
		if (!Exists(this.mSprite))
		{
			return;
		}

		this.mCurrentSprite = "";
		this.mCurrentFrame = -1;
		if (Exists(this.mSprite))
		{
			this.mSprite.destroy();
			this.mSprite = null;
		}

		if (Exists(cb))
		{
			cb();
		}

		var protoVisual = this.GetProtoVisual();

		this.mSprite = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), protoVisual, 0, this.mEntity.flipped, 1);
		this.mSprite.name = this.mProtoVisual.header_tag;
		this.mSprite.primary = true;
		this.mSprite.mOwner = this;

		var self = this;
		if (!this.mDecal)
		{
		    this.mSprite.mOwner = this;
			this.mSprite.Enable("Touch", function(touch)
			{
				return self.OnNativeTouch(touch);
			});
		}

		this.PositionUpdated();
		//NgLogD("OnFlushSprite end");
	},

	DeleteSecondarySprite : function()
	{
		if (Exists(this.mSecondarySprite))
		{
			this.mSecondarySprite.destroy();
			delete this.mSecondarySprite;
			this.mSecondarySprite = null;
		}
	},

	CreateResourceFlyOff : function(amount, type, offset)
	{
		var sprite = getAssets( "resIcon_gold" );
		if (WeCoinsCrowns.isCoinImage(sprite))
			sprite = WeCoinsCrowns.getCoinsOrCrowns(sprite);
		if (type == "xp")
		{
			sprite = getAssets( "resIcon_XP" );
		} else if (type == "happy")
		{
			sprite = getAssets( "resIcon_happy" );
		}

		var cSprite = this.GetMainSprite();
		var flyOff = new WeFlyOff(WeRenderDevice.GetGameUiRoot(), cSprite.GetX(), cSprite.GetY() + offset, type, amount, sprite);
	},

	GetBuildingBubbleY : function()
	{
		//var cProtoVisual = this.GetMainProtoVisual();
		//var offset = cProtoVisual.offset_y;

		//return this.GetMainSprite().GetY() - this.GetMainSprite().GetHeight() * 0.5 - offset;
		
		return this.GetMainSprite().GetY() - this.GetMainSprite().GetHeight() * 0.5 - 25;
	},

	GetBuildingBubbleX : function()
	{
		var cProtoVisual = this.GetMainProtoVisual();

		//-((cProtoVisual.offset_x + cSprite.GetHeight() * WeRenderDevice.GetScaleRoot().GetScale().getX())  + 
		//        gameWidget.xHeight * 0.5);
		if (this.mEntity.flipped)
		{
			return this.GetMainSprite().GetX() - cProtoVisual.offset_x;
		}
		return this.GetMainSprite().GetX() + cProtoVisual.offset_x;
	},

	//////////////////////////////////////////////////////////////////////////////
	// Method: OpenLotActionMenu
	// Open the Lot action UI on the screen
	OpenLotActionMenu : function()
	{
		if (!this.IsStateSet(BuildingState.Shell) && WeGameStateMgr.GetActiveObject() !== this)
		{
			return;
		}

		var self = this;

		// Let create a UI widget
		var args = {};
		var isBuyOp = this.IsStateSet(BuildingState.Shell);
		var shouldOpen = false;
		if (isBuyOp)
		{
			shouldOpen = true;
			// Add the Buy button
			args.OnBuy = function(theArgs)
			{
				self.CloseLotActionMenu();
				// Add your cancel logic here
				// Currently the UI widget does not have a cancel button but I think we will add it soon

				// JOY.. you just bought a new building.  Let the game know
				var bubble = self.CreateCollectionBubble(getAssets( "icon_hammer "), "Placing...", null);
				WeGameStateMgr.GetGameLotInfo().ConstructObjectFromShell(bubble, self, self.eventFlag);
			};

			args.OnCancel = function(theArgs)
			{
				// Add your cancel logic here
				// Currently the UI widget does not have a cancel button but I think we will add it soon
				// Loose the shell object
				WeGameStateMgr.SetActiveObject(null);
				WeGameStateMgr.SetPendingObject(null);

			};
		} else if (!this.IsStateSet(BuildingState.Constructing))
		{
			shouldOpen = true;
			args.OnSell = function(theArgs)
			{
				self.CloseLotActionMenu();
				// do you accept logic here
				var newArgs = {};
				newArgs.OnYes = function(theNewArgs)
				{
					WeGameStateMgr.SetGlobalGameWidget(null);
					self.OnSell();
				};

				newArgs.OnNo = function(theNewArgs)
				{
				};
				newArgs.popup_label = "Sell Item";
				newArgs.popup_text = "Are you sure you want to sell this " + self.mProtoEntity.proto_name + "?";

				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
				newArgs.xGameWidget = newGameWidget;
				newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
			};

			args.OnStash = function(theArgs)
			{
				self.CloseLotActionMenu();
				var newArgs = {};
				newArgs.OnYes = function(theNewArgs)
				{
					WeGameStateMgr.SetGlobalGameWidget(null);
					self.OnStash();
				};

				newArgs.OnNo = function(theNewArgs)
				{
				};
				newArgs.popup_label = "Stash Item";
				newArgs.popup_text = "Are you sure you want to stash this " + self.mProtoEntity.proto_name + "?";

				var itemDef = WeUiMgr.GetItemDef("popup_box");
				var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
				newArgs.xGameWidget = newGameWidget;
				newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
			};

		}
		if (this.CanFlip())
		{
			shouldOpen = true;
			args.OnFlip = function(theArgs)
			{
				
				self.CloseLotActionMenu();
				self.Flip();
				self.OpenLotActionMenu();
			};
		} else
		{
			args.OnFlipAlpha = 0.5;
			shouldOpen = true;
			args.OnFlip = function(theArgs)
			{
				//self.OpenLotActionMenu();
			};
		}

		args.OnShutdown = function()
		{
		};

		if (!shouldOpen)
		{
			return;
		}

		// Lets get the screen location of the object
		var screenPos = WorldToScreenPos(this.mAnchor);
		var screenInfo = WeRenderDevice.GetScreenInfo();
		// Are to the left of the item
		var isLeft = screenInfo.mWidth * 0.5 >= screenPos.x;

		// Are we on the top half or the lower half of the screen
		var isUpper = screenInfo.mHeight * 0.5 >= screenPos.y;

		var itemDef;
		var type = '';
		if (isBuyOp)
		{
			type = '_buy';
		} else
		{
			type = '_move';
		}
		var sFullType;
		if (isUpper)
		{
			sFullType = "BuildBuyAction_Lower" + type;
		} else
		{
			sFullType = "BuildBuyAction_Upper" + type;
		}
		itemDef = WeUiMgr.GetItemDef(sFullType);

		if (this.mLotActionMenu)
		{
			if (this.mLotActionMenu.msFullType == sFullType)
			{
				this.OpenLotActionMenuSetPosition(this.mLotActionMenu, isUpper, screenPos);
				return;
			}

			this.CloseLotActionMenu();
		}

		var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args, WeUiMgr.GetScreen().GetNode());
		args.xGameWidget = gameWidget;
		
		//fullRecurseDumpNodes(WeUiMgr.GetScreen().GetNode(), 0, 3);

		gameWidget.msFullType = sFullType;

		var cAnimation = new NumberAnimation(0.5, 0.0, 1.0);
		gameWidget.setAlpha(0.0);
		cAnimation.SetNumber = function(value)
		{
			gameWidget.setAlpha(value);
		};
		cAnimation.OnStop = function(value)
		{
		};

		this.OpenLotActionMenuSetPosition(gameWidget, isUpper, screenPos);

		var cWidgetPositionUpdater = null;
		if (this.IsStateSet(BuildingState.Shell))
		{
			cWidgetPositionUpdater = new WidgetPositionUpdater(this);
		}

		this.mLotActionMenu = gameWidget;

		gameWidget.Olddestroy = gameWidget.destroy;
		gameWidget.destroy = function()
		{
			if (self.mLotActionMenu)
			{
				if (cWidgetPositionUpdater)
				{
					cWidgetPositionUpdater.Stop();
					delete cWidgetPositionUpdater;
				}
				cAnimation.Stop();
				this.Olddestroy();
				self.mLotActionMenu = null;
				WeGameStateMgr.mGlobalGameWidget = null;
			}
		};
		WeGameStateMgr.SetGlobalGameWidget(gameWidget);
	},

	LostFocus : function()
	{
		if (this.IsStateSet(BuildingState.Shell))
		{
			this.OpenLotActionMenu();
		} else
		{
			this.CloseLotActionMenu();
		}
	},

	GhostRemoved : function()
	{
		if (this.IsStateSet(BuildingState.Shell))
		{
			this.OpenLotActionMenu();
		}
	},

	onCameraUpdated : function()
	{
		this.OpenLotActionMenu();
	},

	CloseLotActionMenu : function()
	{
		if (this.mLotActionMenu)
		{
			this.mLotActionMenu.destroy();
			this.mLotActionMenu = null;
		}
	},

	OpenLotActionMenuSetPosition : function(gameWidget, isUpper, screenPos)
	{
		var posY = 0;
		var offsetX = 0;
		// Caculate the Y offset needed
		if (isUpper)
		{
			posY = gameWidget.xHeight * 1.0;
		} else
		{
			var cSprite = this.GetMainSprite();
			var cProtoVisual = this.GetMainProtoVisual();
			//posY = -((cProtoVisual.offset_y + cSprite.GetHeight() * WeRenderDevice.GetScaleRoot().GetScale().getX()) + gameWidget.xHeight * 0.5);
			posY = -(( cSprite.GetHeight() * WeRenderDevice.GetScaleRoot().GetScale().getX()) + gameWidget.xHeight * 0.5);
		}
		posY += screenPos.y;

		if (posY < gameWidget.xHeight * 0.5)
		{
			posY = gameWidget.xHeight * 0.5;
		} else if (posY > (gRawHeight - gameWidget.xHeight * 0.5))
		{
			posY = (gRawHeight - gameWidget.xHeight * 0.5);
		}

		var posX = screenPos.x;
		// Check if we are to the left or right of the screen   
		if ((screenPos.x - gameWidget.xWidth * 0.5) < 0)
		{
			posX = gameWidget.xWidth * 0.5;
		} else if ((screenPos.x + gameWidget.xWidth * 0.5) > gRawWidth)
		{
			posX = gRawWidth - gameWidget.xWidth * 0.5;
		}

		gameWidget.setPosition(posX, posY, 9.0);
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnSell
	 * The user has requested that this instance of the building be sold.
	 * NOTE: The server has yet to confirm this action.  This is a callback from
	 * the UI
	 * @param {Entity} ent new values for the entity
	 */
	OnSell : function()
	{
		var self = this;
		// This building needs to be sold
		var data = {};
		data.entities = [];

		var dataSet = {};
		dataSet.flipped = this.mEntity.flipped;
		dataSet.id = this.mEntity.id;
		dataSet.proto_entity_id = this.mProtoEntity.id;
		dataSet.sell = 'true';
		dataSet.location_x = this.mEntity.location_x;
		dataSet.location_y = this.mEntity.location_y;
		data.entities.push(dataSet);

		var kingdomId = WeGameStateMgr.GetCurrentKingdomId();

		WeProtocol.updateBuildingPositions(kingdomId, data, function(request)
		{
			// lets do the actual sell
			if (request.readyState == 4)
			{
				if (Exists(request.responseText) && 0 !== request.responseText.length)
				{
					//NgLogD("Looks like the item was sold");
					var obj = JSON.parse(request.responseText);
					if (obj.kingdom)
					{
						WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.kingdom);
					}

					// note: no xp fly off for selling
					if (self.mProtoEntity.gold_sell_value > 0)
					{
						self.CreateResourceFlyOff(self.mProtoEntity.gold_sell_value, "coin", 0);
					}

					self.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());
					
					// remove the sold entity (the entity id only should appear once)
					WeGameStateMgr.RemoveEntityWithId(self.mEntity.id);
					
					if (Exists(self))
					{
						self.destroy();
					}
					
					WeEffectsMgr.PlaySoundEffect("money_cashregister.mp3");
				} else
				{
					NgLogD("WeProtocol.updateBuildingPositions Hmmm....:" + request.responseText);
					WeUiMgr.ShowNetworkErrorPopUp();
				}
			} else if (request.readyState === 0)
			{
				ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
			}
		});
	}
});

var WidgetPositionUpdater = Core.MessageListener.subclass({
	initialize : function(object)
	{
		this.object = object;
		Core.UpdateEmitter.addListener(this, this.onUpdate);
	},

	classname : 'WidgetPositionUpdater',

	onUpdate : function()
	{
		this.object.OpenLotActionMenu();
	},

	Stop : function()
	{
		if (this.object)
		{
			this.object = null;
			Core.UpdateEmitter.removeListener(this);
		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeCharacter'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeCharacter'] || {}; $MODULE_REGISTRY['weEngine/WeCharacter'] = exports; //////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-03
 *  @file:      WeCharacter.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by NGMOCO:) LLC
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;
var WeEffectsMgr = require('weEngine/WeEffects').WeEffectsMgr;
var WeBuildingBubble = require('weEngine/WeBuildingBubble').WeBuildingBubble;

var Node = { Complete : 0, Process : 1, Failed : 2 }; 

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : WhileParentExists
 * @brief: $DESCRIPTION
 */
var WhileParentExists = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
        this.mChildren = [];
		this.mPestWidget = null;
    },
    PreProcess : function(source)
    {
        var results = Node.Complete;
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior WhileParentExists : Preprocess");
        }

        this.mHasPreProcessedChild = false;

        return results;
    },

    Process : function(source)
    {
        var results = Node.Process;
        
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior WhileParentExists : Process");
        }

        if(this.mChildren.length > 0)
        {
            if(!this.mHasPreProcessedChild)
            {
                this.mChildren[0].PreProcess(source);
                this.mHasPreProcessedChild = true;
            }
            
            var childResults = this.mChildren[0].Process(source);
            if(childResults != Node.Process)
            {
                childResults = this.mChildren[0].PostProcess(source);
            }
        }

        return results;
    },

    PostProcess : function(source)
    {
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior WhileParentExists : PostProcess");
        }

        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : Sequence
 * @brief: $DESCRIPTION
 */
var Sequence = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
        this.mChildren = [];
    },
    PreProcess : function(source)
    {
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior Sequence : Process");
        }

        this.mCurIdx = 0;
        this.mCurPreProcess = true;
        
        return Node.Complete;
    },

    Process : function(source)
    {
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior Sequence : Process");
        }
        
        var results = Node.Process;
        if(this.mCurPreProcess)
        {
            results = this.mChildren[this.mCurIdx].PreProcess(source);
            if(results != Node.Complete && source.mDebugBehavior)
            {
                NgLogD("Behavior Sequence : Process: Child PreProcess failed");
            }
            this.mCurPreProcess = false;
        }
        
        results = this.mChildren[this.mCurIdx].Process(source);

        if(results != Node.Process)
        {
            this.mChildren[this.mCurIdx].PostProcess(source);
            ++this.mCurIdx;
            this.mCurPreProcess = true;

            if(this.mCurIdx >= this.mChildren.length)
            {
                results = Node.Complete;
            }
            else
            {
                results = Node.Process;
            }
        }

        return results;
    },

    PostProcess : function(source)
    {
        delete this.mCurIdx;
        delete this.mCurPreProcess;
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : HasTapEvent
 * @brief: $DESCRIPTION
 */
var HasTapEvent = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
        this.mChildren = [];
    },
    PreProcess : function(source)
    {
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior HasTapEvent : PreProcess");
        }

        this.mPreProcess = [true, true];
    },
    Process : function(source)
    {
        var results = Node.Process;
        var childResults = Node.Complete;

        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior HasTapEvent : Process");
        }
        
        var idx = 0;
        if(source.mTapEvent)
        {
            idx = 1;
        }

        if(this.mPreProcess[idx])
        {
            childResults = this.mChildren[idx].PreProcess(source);
            if(childResults != Node.Complete && source.mDebugBehavior)
            {
                NgLogD("**** Behavior HasTapEvent Error on child preprocess");
            }
            this.mPreProcess[idx] = false;
        }
        
        childResults = this.mChildren[idx].Process(source);
        if(childResults == Node.Complete)
        {
            childResults = this.mChildren[idx].PostProcess(source);
            this.mPreProcess[idx] = true;
        }

        return results;
    },

    PostProcess : function(source)
    {
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : HasPath
 * @brief: $DESCRIPTION
 */
var HasPath = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
        this.mChildren = [];
    },
    
    PreProcess : function(source)
    {
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior HasPath : PreProcess");
        }

        this.mPreProcess = [true, true];
        return Node.Complete;
    },

    Process : function(source)
    {
        var childResults = Node.Complete;

        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior HasPath : Process");
        }
        
        var idx = 0;
        if(source.mPath)
        {
            idx = 1;
        }
        
        if(this.mPreProcess[idx])
        {
            childResults = this.mChildren[idx].PreProcess(source);
            if(childResults != Node.Complete && source.mDebugBehavior)
            {
                NgLogD("**** Behavior HasPath Error on child preprocess");
            }
            this.mPreProcess[idx] = false;
        }
        
        childResults = this.mChildren[idx].Process(source);
        if(childResults == Node.Complete)
        {
            childResults = this.mChildren[idx].PostProcess(source);
            this.mPreProcess[idx] = true;
        }

        return Node.Process;
    },

    PostProcess : function(source)
    {
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : GetPath
 * @brief: $DESCRIPTION
 */
var GetPath = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
        this.mPath = null;
    },

    PreProcess : function(source)
    {
        if(source.mDebugBehavior)
        {
            NgLogD("**** Behavior HasPath : PreProcess");
        }

        this.mPreProcess = [true, true];
        return Node.Complete;
    },

    Process : function(source)
    {
        var results = Node.Process;
        if(this.mPath && this.mPath.length > 1)
        {
            source.mPath = this.mPath;
            results = Node.Complete;
        }
        else
        {
            // First we need to get a random location for this guys
            var dest = WeGameStateMgr.GetGameLotGrid().FindValidLocation();
            source.Sleep();
            var self = this; 
            WeSimulator.OnRequestPath(source, dest, function(path)
            {
            	/*
            	if(path== null || path.length <=1)
            	{
            			NgLogD("You seem to be lost, son...");
            	}
            	*/
                self.mPath = path;
                source.Wake();
                
                if(path)
                {
                    source.mPathFailedCount = 0;
                }
                else
                {
                    ++source.mPathFailedCount;
                    if(source.mPathFailedCount >= 5)
                    {
                        source.mAnchor = WeGameStateMgr.GetGameLotGrid().FindValidLocation();
                    }
                }
            });
        }

        return results;
    },

    PostProcess : function(source)
    {
        this.mPath = null;
        return Node.Complete;
    }
});

var RandomPath = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
        this.mPath = null;
    },

    PreProcess : function(source)
    {
        this.mPreProcess = [true, true];
        return Node.Complete;
    },

    Process : function(source)
    {
        var results = Node.Process;
        if(this.mPath && this.mPath.length > 1)
        {
            source.mPath = this.mPath;
            results = Node.Complete;
        }
        else
        {
			this.mPath = [source.mAnchor];
			for(var i = 0; i < 100; ++i)
				this.mPath.push(WeGameStateMgr.GetGameLotGrid().RandomLocation());
        }

        return results;
    },

    PostProcess : function(source)
    {
        this.mPath = null;
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : FollowPath
 * @brief: $DESCRIPTION
 */
var FollowPath = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
		this.speed = 1200; // 1 seconds to get though a grid loc
		if(Exists(args) && Exists(args.speed))
			this.speed = args.speed;
    },

    PreProcess : function(source)
    {
    	
        source.mPathIdx = 0;
        source.mLastPathUpdate = Core.Time.getRealTime();
        source.mT = 0;
        return Node.Complete;
    },

    Process : function(source)
    {
        var results = Node.Complete;
        
        var endIdx = source.mPath.length - 1;
        if(endIdx != source.mPathIdx)
        {
            results = Node.Process;
                
            // Now we need to move the guy along the path a bit
            var now = Core.Time.getRealTime();

            // how much time has elapsed
            var delta = now - source.mLastPathUpdate;

			var p0 = source.mPath[source.mPathIdx];
			var p1 = source.mPath[source.mPathIdx+1];

			var distance = WeMath.Distance2D(p0, p1);

	        var rate = this.speed;  
			if(Exists(source.mProtoEntity) && Exists(source.mProtoEntity.movement_speed))
				rate = 1000 * distance / source.mProtoEntity.movement_speed;
            
            // if we were paused (user tapped the character) during the movement
            // set the correct animation and skip one frame
            if (source.mPaused)
            {
                source.mPaused = false;
                delta = 0;
                source.SelectWalkAnim(p0, p1);
            }

            if(source.mT === 0)
            {
                source.SelectWalkAnim(p0, p1);
                source.mT = distance;
            }
            
            var frameSpeed = delta / rate;
            source.mT -= distance * frameSpeed;
            if(source.mT <= 0)
            {
                // we have moved beyond the point so just snap us
                source.SetGamePosition(p1);
                ++source.mPathIdx;
                source.mT = 0;
            }
            else
            {
            	//WeMath.Lerp(source.mAnchor, p0, p1, source.mT);
                var newPosition = new Vec2D();
                newPosition.x = source.mAnchor.x + (p1.x - p0.x) * frameSpeed;
                newPosition.y = source.mAnchor.y + (p1.y - p0.y) * frameSpeed;
                source.SetGamePosition(newPosition);
            }

            source.mLastPathUpdate = now;
        }
        else
        {
            if(Exists(source.mPest))
            {
			    source.PlayAnimation('IdleVariation1');
		    }
            results = Node.Complete;
        }
        return results;
    },

    PostProcess : function(source)
    {
        //source.mPath = null;
        //source.mT = 0;
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : PlaySound
 * @brief: $DESCRIPTION
 */
var PlaySound = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
    },

    PreProcess : function(source)
    {
        return Node.Complete;
    },

    Process : function(source)
    {
		if(Exists(source.mProtoEntity))
        	WeEffectsMgr.PlaySoundEffect(source.mProtoEntity.sound_select);
        return Node.Complete;
    },

    PostProcess : function(source)
    {
        return Node.Complete;
    }
});

var TouchPest = Core.Class.subclass(
{
    initialize: function(args)
    {
    },

    PreProcess : function(source)
    {
        return Node.Complete;
    },

    Process : function(source)
    {
		if(Exists(source.mPest))
			WePests.onTouch(source.mPest);
		source.mTapEvent = false;
		source.Wake();
        return Node.Complete;
    },

    PostProcess : function(source)
    {
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : PlayAttention
 * @brief: $DESCRIPTION
 */
var PlayAttention = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
    
    },

    PreProcess : function(source)
    {
        return Node.Complete;
    },

    Process : function(source)
    {
        //source.mSprite.SetAnimationByName('AttentionSouthEast');
		source.mSprite.SetAnimationByName('IdleVariation1');
        return Node.Complete;
    },

    PostProcess : function(source)
    {
        return Node.Complete;
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : Wait
 * @brief: $DESCRIPTION
 */
var Wait = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
		// Set time to animation length
        //this.mTime = args.time; 
        this.mComplete = false;
    },
    
    PreProcess : function(source)
    {
        source.mTapEvent = false; 
        source.mWaitComplete = false;
        source.mPaused = true;

		this.mTime = source.mSprite.mSpriteGL2.getAnimation().getTotalDuration();
         
        WeSimulator.OnTimer(this.mTime, function()
        {
            source.mWaitComplete = true;
            source.Wake();
        });
        
        return Node.Complete;
    },

    Process : function(source)
    {
        var results = Node.Process;
        if(!source.mWaitComplete)
        {
            source.Sleep();
        }
        else
        {
            results = Node.Complete;
        }
        return results;
    },

    PostProcess : function(source)
    {
        delete source.mWaitComplete;
        return Node.Complete; 
    }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : IdleRandom
 * @brief: $DESCRIPTION
 */
var IdleRandom = Core.Class.subclass(
{
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(args)
    {
    
    },

    PreProcess : function(source)
    {
        source.mIdleRandomTime = Core.Time.getRealTime();
        source.mIdleRandomTime=(source.mIdleRandomTime + 1000 * (Math.floor((8-1)*Math.random()) + 2));
        source.PlayAnimation('IdleVariation1');
        return Node.Complete;
    },

    Process : function(source)
    {
        var results = Node.Process;
        var now = Core.Time.getRealTime();
        if(now > source.mIdleRandomTime)
        {
            results = Node.Complete;
        }
        return results;
    },

    PostProcess : function(source)
    {
        // From Path
        delete source.mPath;
        delete source.mT;
        delete source.mPathIdx;
        delete source.mLastPathUpdate;

        // From IdleRandomTime
        delete source.mIdleRandomTime;

        return Node.Complete;
    }
});


var StdBehavior =
{
    name : "WhileParentExists",
    children :
    [
        {
            name : "HasTapEvent",
            children :
            [
                // No the agent does not have a tap event
                {
                    name : "HasPath",
                    children :
                    [
                        // No the agent does not have a path so request one
                        {
                            name : "Sequence",
                            children :
                            [
                                {
                                    name : "GetPath"
                                },
                                {
                                    name : "IdleRandom"
                                }
                            ]
                        },
                        // Yes, do the sequence of ops
                        {
                            name : "Sequence",
                            children :
                            [
                                {
                                    name : "FollowPath"
                                },
                                {
                                    name : "IdleRandom"
                                }
                            ]
                        }
                    ]
                },
                // Yes the agent has a tap event
                {
                    name : "Sequence",
                    children :
                    [
                        {
                            name : "PlaySound"
                        },
                        {
                            name : "PlayAttention"
                        },
                        {
                            name : "Wait",
                            args :
                            {
                                // wait 5 seconds between the touch and continuing
                                time : 5
                            }
                        }
                    ]
                }
            ]
        }
    ]
};

var Lod0Behavior =
{
    name : "WhileParentExists",
    children : []
};

var PestWalkBehavior =
{
    name : "WhileParentExists",
    children :
    [
        {
            name : "HasTapEvent",
            children :
            [
				{
				    name : "HasPath",
                    children :
                    [
                        // No the agent does not have a path so request one
                        {
                            name : "Sequence",
                            children :
                            [
                                {
                                    name : "GetPath"
                                }
                            ]
                        },
                        // Yes, do the sequence of ops
                        {
                            name : "Sequence",
                            children :
                            [
                                {
                                    name : "FollowPath",
                                    args :
                                    {
                                        speed : 2000
                                    }
                                },
                                {
                                    name : "GetPath"
                                }
                            ]
                        }
                    ]
				},	
                {
                    name : "TouchPest"
                }
            ]
        }
    ]
};

var PestBehavior =
{
    name : "WhileParentExists",
    children :
    [
        {
            name : "HasTapEvent",
            children :
            [
                // No the agent does not have a tap event
                {
                    name : "HasPath",
                    children :
                    [
                        // No the agent does not have a path so request one
                        {
                            name : "Sequence",
                            children :
                            [
                                {
                                    name : "RandomPath"
                                }
                            ]
                        },
                        // Yes, do the sequence of ops
                        {
                            name : "Sequence",
                            children :
                            [
                                {
                                    name : "FollowPath",
                                    args :
                                    {
                                        speed : 2000
                                    }
                                },
                                {
                                    name : "GetPath"
                                }
                            ]
                        }
                    ]
                },
                // Yes the agent has a tap event
                {
                    name : "TouchPest"
                }
            ]
        }
    ]

};

//////////////////////////////////////////////////////////////////////////////
/**
 * Class : WeCharacter
 * @brief: $DESCRIPTION
 */
exports.WeCharacter = Core.Class.subclass(
{
	classname: "WeCharacter",
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: initialize
     * 
     */ 
    initialize: function(is_pest, is_walking, protoEntity)
    {
        this.mProtoEntity = protoEntity;
        this.mProtoVisual = null;
        this.mProtoVisualDecal = null;
        this.mParent = null;
        this.mTapEvent = false;
       
        this.mHasInit = false;
        // Construct an instance of the standard behavior
		if(is_pest)
		{
			this.mBehavior = this.ConstructBehaviorNode(is_walking?PestWalkBehavior:PestBehavior);
		}
		else
		{
			if(gLOD == 0)
        		this.mBehavior = this.ConstructBehaviorNode(Lod0Behavior);
			else
        		this.mBehavior = this.ConstructBehaviorNode(StdBehavior);
		}
        
        this.mSize = new Vec2D();
        this.mAnchor = new Vec2D();
        this.mPathFailedCount = 0;
        this.mPaused = false;
    },

    ConstructBehaviorNode : function(nodeDef)
    {
        var node;
        // There has to be a better way of doing this....
        switch(nodeDef.name)
        {
            case "WhileParentExists":
                node = new WhileParentExists(nodeDef.args);
                break;

            case "Sequence":
                node = new Sequence(nodeDef.args);
                break;

            case "HasTapEvent":
                node = new HasTapEvent(nodeDef.args);
                break;

            case "HasPath":
                node = new HasPath(nodeDef.args);
                break;

            case "GetPath":
                node = new GetPath(nodeDef.args);
                break;

			case "RandomPath":
				node = new RandomPath(nodeDef.args);
				break;

            case "FollowPath":
                node = new FollowPath(nodeDef.args);
                break;

            case "DoAnimation":
                node = new DoAnimation(nodeDef.args);
                break;

            case "PlaySound":
                node = new PlaySound(nodeDef.args);
                break;

			case "TouchPest":
				node = new TouchPest(nodeDef.args);
				break;

            case "PlayAttention":
                node = new PlayAttention(nodeDef.args);
                break;
            
            case "Wait":
                node = new Wait(nodeDef.args);
                break;
            
            case "IdleRandom":
                node = new IdleRandom(nodeDef.args);
                break;

            default:
                break;
        }
        
        if(nodeDef.children)
        {
            var len = nodeDef.children.length;
            for(var idx = 0; idx < len; ++idx)
            {
                node.mChildren.push(this.ConstructBehaviorNode(nodeDef.children[idx]));  
            }
        }

        return node;
    },

    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: Init
     */
    Setup : function (protoEntity, protoVisual, protoVisualDecal, parentBuilding)
    {
        this.mProtoEntity = protoEntity;
        this.mProtoVisual = protoVisual;
        this.mProtoVisualDecal = protoVisualDecal;
        
        this.SetupSprites();

        this.mParent = parentBuilding;
        
        // We need to get some update action!!!
        //this.toggleUpdatable();
        this.mSleep = false;
        this.Wake();
       
        this.SetGamePosition(WeGameStateMgr.GetGameLotGrid().FindValidLocation());
        return true;
    },

	GetPestBubbleImage : function()
	{
		if ( !this.mPest )
		{
			return "";
		}
		var bubble_header_tag = WePests.getPestBubbleHeaderTag( this.mPest );
		if ( !bubble_header_tag )
		{
			return "";
		}
		
		if ( bubble_header_tag.indexOf("SPR_events_") !== -1 )
		{
			bubble_header_tag = bubble_header_tag.substring(11);
		}
		return bubble_header_tag + ".png";
	},
	
	CreatePestBubble : function()
	{
		this.DeletePestBubble();

		var self = this;
		var args = {};

		
		// SetupPestBubbleUI
		args.source = this;
		args.pos_x = this.mAnchor.x;
		args.pos_y = this.mAnchor.y;
		args.item_type = "pest_bubble";

		var itemDef = WeUiMgr.GetItemDef(args.item_type);
		// Create the Widget 
		var widget = WeUiMgr.CreateGameWidget(itemDef, args, WeRenderDevice.GetGameUiRoot());

		if ( !itemDef || !widget )
		{
			NgLogD("CreatePestBubble: widget can not be created");
			return;
		}
		// this prioritizes progress bar items over job bubble items
		var incZ = 1;

		// March down the widget heirarchy and base all of the Z values off of this base sprites Z
		var cSprite = this.mSprite;
		if (cSprite)
		{
			widget.setPosition(args.pos_x, args.pos_y, 0);
		}
		
		// Create the new bubble wrapper
		var bubble = new WeBuildingBubble(widget, true);
		this.mBubble = bubble;	// set bubble
		this.mPestWidget = widget;

		// Source as triggered that the action bubble should close
		bubble.On('internal_close', function()
		{
			bubble.Trigger('close');
			if (Exists(widget))
			{
				widget.destroy();
			}
			delete self.mBubble;
			self.mBubble = null;
		});
	},

	GetPestBubbleYbaseline : function()
	{
		if (this.mSprite)
			return this.mSprite.GetY() - this.mSprite.GetHeight();
		else
			return 0;
	},

	DeletePestBubble : function()
	{
		if (Exists(this.mBubble))
		{
			this.mBubble.Trigger('internal_close');
		}
	},
	
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Method: SetupSprites
     */
    SetupSprites : function()
    {
    	//TODO move to better place
    	//wecity
    	//this.mLOD = 1;
        this.mLOD = gLOD;
		/*if(Exists(this.mProtoEntity))
		{
			var isLOD3 = this.mProtoEntity.proto_name.indexOf("Dragon") != -1; 
			if(isLOD3 || Exists(this.mPest))
				this.mLOD = 3;
		}*/
    
        this.mSprite = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), this.mProtoVisual, this.mLOD, false, 1);

        // Setup this guys game size
        this.mSize.x = Math.floor((this.mSprite.mWidth / cTileSizeWidth) + 0.5);
        this.mSize.y = Math.floor((this.mSprite.mHeight / cTileSizeWidth) + 0.5);
        
        this.mSprite.PushGamePosition(  [this.mAnchor.x, this.mAnchor.y, 80],
                                        [   this.mProtoVisual.offset_x,
                                            this.mProtoVisual.offset_y,
                                            this.mProtoVisual.z_order_vertical_offset ]);
        this.mSprite.name = this.mProtoVisual.header_tag;
        this.mSprite.primary = true;

        var self = this;

        this.mSprite.Enable("UpdateEmitter", function(delta){self.onUpdate();});
        //PushGamePosition sets Z acording game position
        //this.mSprite.SetDepth(90);
 
       // this.PlayAnimation("IdleVariation1");

	 	var enableTouch = true;
        if(Exists(gTunables.optimizations))
        {
            enableTouch = gTunables.optimizations.character_touch; 
        }

        if(enableTouch)
        {
        	if (this.mSprite.mAnimations.length > 0 && this.mLOD > 0)
        	{
        		this.mSprite.Enable("Touch", function(touch){ return self.onNativeTouch(touch); });
        	}
        }

		if (Exists(this.mPest))
		{
			this.CreatePestBubble();
		}
    },

    PlayAnimation : function(spriteName)
    {
    	//NgLogD("PlayAnimation: "+spriteName);
    	//NgLogD("mAnim: "+this.mAnim);
    	if(spriteName)
    	{
		   if((this.mAnim === undefined || this.mAnim != spriteName) && this.mSprite)
	        {
	            this.mAnim = spriteName;
	            this.mSprite.SetAnimationByName(this.mAnim);
	        }
    	}
    	else
    	{
            if(this && this.mSprite && this.mAnim)
            {
                this.mSprite.SetAnimationByName(this.mAnim);
            }   		
    	}
    },

    SelectWalkAnim : function(start, end)
    {
        var anim = 'MoveSouth';
        if(start.x == end.x && start.y < end.y)
        {
            anim = 'MoveNorthWest';
        }
        else if(start.x == end.x && start.y > end.y)
        {
            anim = 'MoveSouthEast';
        }
        else if(start.x > end.x && start.y == end.y)
        {
            anim = 'MoveSouthWest';
        } 
        else if(start.x < end.x && start.y == end.y)
        {
            anim = 'MoveNorthEast';
        }
        else if(start.x < end.x && start.y < end.y)
        {
            anim = 'MoveNorth';
        }
        else if(start.x > end.x && start.y < end.y)
        {
            anim = 'MoveWest';
        }
        else if(start.x < end.x && start.y > end.y)
        {
            anim = 'MoveEast';
        }
        
        this.PlayAnimation(anim);
     
    },

    SetGamePosition : function(anchor)
    {
        try
        {
            this.mAnchor.x = anchor.x;
            this.mAnchor.y = anchor.y;
            if(this.mSprite)
            {
                this.mSprite.PushGamePosition(  [this.mAnchor.x, this.mAnchor.y, 80],
                                                [   this.mProtoVisual.offset_x,
                                                    this.mProtoVisual.offset_y,
                                                    this.mProtoVisual.z_order_vertical_offset ]);

                // this.mSprite.SetDepth(90);
            }
			if(this.mPest && this.mBubble)
			{
				var args = {};
				args.x = this.mSprite.GetX();
				args.y = this.GetPestBubbleYbaseline() - (this.mPestWidget ? this.mPestWidget.xHeight : 15)/* the height of the widget*/ - 10 /*additional offset */;
				this.mBubble.setPosition( args );
			}
        }
        catch(ex)
        {
            NgLogD("Exception .. " + ex);
        }
    },

    destroy : function ()
    {
		this.DeletePestBubble();
        this.UnloadSprites();
        WeSimulator.RemovePathForCharacter(this);
    },
     
    UnloadSprites : function ()
    {
        if(Exists(this.mSprite))
        {
            this.mSprite.destroy();
            delete this.mSprite; 
        }
	},

    Wake : function ()
    {
        if(this.mSleep)
        {
            //this.mSprite.toggleUpdatable();
            this.mSleep = false;
        }
       // this.PlayAnimation();
    },

    Sleep : function ()
    {
        if(!this.mSleep)
        {
            //this.mSprite.toggleUpdatable();
            this.mSleep = true;
        }
    },

    onNativeTouch : function( touch )
    {
        if(touch.getAction()  == touch.Action.Start)
        {
            this.mTouchId = touch.getId(); 
            this.mTouchTime = Core.Time.getFrameTime();
        }
        else if(touch.getAction()  == touch.Action.End && this.mTouchId == touch.getId())
        {
            var delta = Core.Time.getFrameTime() - this.mTouchTime;
            if(delta < 400)
            {
                this.mTapEvent = true;
				this.PlayAnimation('IdleVariation1');
				if(Exists(this.mProtoEntity))
               		WeEffectsMgr.PlaySoundEffect(this.mProtoEntity.sound_select);
            }
        }
        
        return false;
    },

    ProcessLOD : function()
    {
        this.mLOD = gLOD;
        return;
        /*
        var point = new Vec2D(this.mAnchor.x, this.mAnchor.y);
        
        var screenPointLower = WorldToScreenPos(point);
        point.x = this.mAnchor.x + this.mSize.x;
        point.y = this.mAnchor.y + this.mSize.y;

        var screenPointUpper = WorldToScreenPos(point);
        
        point.x = this.mAnchor.x + this.mSize.x;
        point.y = this.mAnchor.y;
        var screenPointLeft = WorldToScreenPos(point);
        
        point.x = this.mAnchor.x;
        point.y = this.mAnchor.y + this.mSize.y;
        var screenPointRight = WorldToScreenPos(point);
       
        if(screenPointLower.y > gRawHeight ||
           screenPointUpper.y < 0 ||
           screenPointLeft.x < 0 ||
           screenPointRight.x > gRawWidth) 
        {
            this.UnloadSprites();
            this.mLOD = -1;
        }
        else
        {
            // Calculate the LOD based on the camera zoom
            var lod = 0;

            if(lod !== this.mLOD)
            {
                this.UnloadSprites();
                this.SetupSprites();
                if(this.mAnim)
                {
                    this.PlayAnimation(this.mAnim);
                }
                
                this.mLOD = lod;
            }
        }
        */
    },

    onUpdate : function()
    {
        if(!this.mSleep)
        {
            this.ProcessLOD();
            if(!this.mHasInit)
            {
                this.mBehavior.PreProcess(this);
                this.mHasInit = true;
            }

            this.mBehavior.Process(this);
        }
    }
});



; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeBuildingBubble'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeBuildingBubble'] || {}; $MODULE_REGISTRY['weEngine/WeBuildingBubble'] = exports; //////////////////////////////////////////////////////////////////////////////
/** @data:      2010-11-04
 *  @file:      WeBuildingBubble.js
 *  @author:    Chris Jimison
 *  Website:    http://www.ngmoco.com
 *  Copyright:  2010, by NGMOCO :)
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */

var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
//////////////////////////////////////////////////////////////////////////////
/** 
 * Class: WeBuildingBubble
 * @param {Widget} widget that the Bubble encapsulates
 * @param {Boolean} updatable should the bubble get an update tick?
 */
 
 
var _WeBuildingBubble = Core.MessageListener.subclass(
{
	classname: "WeBuildingBubble",
    initialize: function(widget, updatable)
    {
        var self = this;
        if(!Exists(updatable))
        {
            updatable = false;
        }
        
        if (Exists(widget.hide_idle))
        {
            this.hide_idle = widget.hide_idle;
        }
        else
        {
            this.hide_idle = false;
        }
        
        if(updatable)
        {
            widget.EnableUpdate(function()
            {
                self.Trigger('internal_update');
                self.Trigger('update');
            });

        }
         
        if(WeGameStateMgr.IsLotObjectsMovable())
        {
            widget.setAlpha(0); 
        }
        this.mSource = null;
        this.mCB = [];
        
        /**
         * This is a default destroy method.  If you need to do more then
         * then provide you own method but be SURE to shutdown the widget
         */
        this.On('shutdown', function()
        {
            if (Exists(widget))
            {
                widget.destroy();
            } 
        });

        this.On('setAlpha', function(alpha)
        {
            widget.setAlpha(alpha); 
        });

        this.On('internal_update', function()
        {
            // Do internal stuff
            // Basically we are doing an inverse scaling here
             var adjustedScale = 1 / WeRenderDevice.GetScaleRoot().GetScale().getX();
           
			if (self.mSource && self.mSource.GetMainSprite())
            {
                // widget.setScale(adjustedScale*widget.getScale(), adjustedScale*widget.getScale());
                var pos_y = (self.mSource.GetBuildingBubbleY() - widget.xHeight * 0.5 - ((adjustedScale-gTunables.camera_zoom_min)*26));
                widget.setPosition(widget.GetX(), pos_y);
            }
            else
            {
                 widget.setScale(adjustedScale, adjustedScale);
            }
        });

        this.On('setScale', function(scale)
        {
			widget.setScale(scale);
        });

        this.On('setPosition', function(args)
        {
			widget.setPosition(args.x, args.y);
        });

    },

    setScale : function(flag)
    {
        this.Trigger('setScale', flag);
    },

    setPosition : function(args)
    {
        this.Trigger('setPosition', args);
    },
   
    setAlpha : function(flag)
    {
        this.Trigger('setAlpha', flag);
    },

	SetVisible : function(visible) 
	{
		if(visible)
			this.Trigger('setAlpha', 1);
		else
			this.Trigger('setAlpha', 0);
	},

    //////////////////////////////////////////////////////////////////////////////
    /** 
     * Method: On 
     * @param {String} name
     * @return {Function} callback callback function for when the action triggers 
     */
    On : function(name, callback)
    {
        this.mCB[name] = callback;
    },

    //////////////////////////////////////////////////////////////////////////////
    /** 
     * Method: Trigger 
     * @param {String} name of the event that should fire
     * @return {Object} args an object that should be passed into callback.
     *                  $TODO this should really use the parameters object instead
     */
    Trigger : function(name, args)
    {
        if(Exists(this.mCB[name]))
        {
            if(undefined === args)
            {
                this.mCB[name]();
            }
            else
            {
                this.mCB[name](args);
            }
        }
    },

    Update : function()
    {

    },
    //////////////////////////////////////////////////////////////////////////////
    /** 
     * Method: Shutdown
     * Because we want to replace a a WeBuildingBubble with the "global widget"
     * in a few places we need a shutdown method.  All this does is triggers the
     * shutdown event
     */
    destroy : function()
    {
        this.Trigger('shutdown');
    }
});

exports.WeBuildingBubble = _WeBuildingBubble;
    
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeFlyOff'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeFlyOff'] || {}; $MODULE_REGISTRY['weEngine/WeFlyOff'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeFlyOff.js
/// @author:    awong@ngmoco.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     
///
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var GL2 = require('NGCore/Client/GL2').GL2;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var MessageListener = require('NGCore/Client/Core/MessageListener').MessageListener;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var Content = require('weEngine/WeContent').Content;

// ////////////////////////////////////////////////////////////////////////////
// Class WeFlyOff
var gFlyOffVelY = -1;
var gSpriteNumberFrameWidth = 16;
var gSpriteNumberFrameHeight = 24;
var gNumberSheetWidth = 256;
var gNumberSheetHeight = 32;
var gFlyOffNumberOffsetFromRes = 30;
var gFlyOffTime = 3000;
var gNumberFontSpacing = 17;

exports.WeFlyOff = Core.MessageListener.subclass(
{
	classname : "WeFlyOff",

	initialize : function(screen, x, y, type, amount, sprite) {
		this.mAmount = 0;
		this.mCanvas = null;
		this.mImage = null;
		this.mEndTime = null;
		this.mIsUpdatable = true;
		this.mSpriteNumbers = [];
        

		this.mAmount = amount;
		this.mNodeGL2 = new GL2.Node();
		this.parent = screen;
		this.parent.addChild(this.mNodeGL2);

		this.mImage = new WeSprite2D(Content.getImagePath(sprite), [ 40, 40 ], [ 0, 0 ],
				this.mNodeGL2, [ 0.5, 0.5 ]);

		this.mNodeGL2.setPosition(x, y);
		this.mNodeGL2.setDepth(10);
		this.mEndTime = Core.Time.getFrameTime() + gFlyOffTime;

		var numString = amount + "";
		var len = numString.length;

		this.mSpriteNumbers = [];
        this.mAnimList = [];
		for ( var idx = 0; idx < len; idx++) {
			var index = parseInt(numString.charAt(numString.length - 1
					- idx)) + 2;
			var sheetW = gNumberSheetWidth;
			var sheetH = gNumberSheetHeight;
			var srcx = (gSpriteNumberFrameWidth * index) / sheetW;
			var srcy = 0 / sheetH;
			var w = gSpriteNumberFrameWidth;
			var h = gSpriteNumberFrameHeight;

			this.mAnimFrame = new GL2.Animation();
			this.mAnimFrame.pushFrame(new GL2.Animation.Frame(
					Content.getImagePath(GameSpecificVariables.WeSprite2D.FPSImages),
					100, [ 21, 30 ], [ 0.5, 0.5 ],
					[ srcx, srcy, w / sheetW, h / sheetH ]));
                    
            this.mAnimList.push(this.mAnimFrame);
			var sprite = new GL2.Sprite();
			sprite.setAnimation(this.mAnimFrame, 0);
			sprite.setPosition(0 - gNumberFontSpacing * idx
					- gFlyOffNumberOffsetFromRes, 3);
			this.mSpriteNumbers.push(sprite);
			this.mNodeGL2.addChild(sprite);
		}

		this.updating = true;
		Core.UpdateEmitter.addListener(this, this.OnUpdate);
	},

	destroy : function() {
		if (Exists(this.mNodeGL2)) {
			this.mNodeGL2.destroy();
			delete this.mNodeGL2;
		}

		this.mImage.destroy();

		var len = this.mSpriteNumbers.length;
		for ( var idx = 0; idx < len; idx++) {
			if (null !== this.mSpriteNumbers[idx]) {
				// this.removeChild(this.mSpriteNumbers[idx]);
				// this.mSpriteNumbers[idx].unregister();
				this.mSpriteNumbers[idx].destroy();
				this.mSpriteNumbers[idx] = null;
			}
		}

		this.mSpriteNumbers = [];
		
		var len = this.mAnimList.length;
		for ( var idx = 0; idx < len; idx++) {
			if (null !== this.mAnimList[idx]) {
				// this.removeChild(this.mSpriteNumbers[idx]);
				// this.mSpriteNumbers[idx].unregister();
				this.mAnimList[idx].destroy();
				this.mAnimList[idx] = null;
			}
		}
		this.mAnimList = [];
		
		if (this.updating) {
			Core.UpdateEmitter.removeListener(this);
			this.updating = false;
		}
	},

	OnUpdate : function(delta) {
		var tick = Core.Time.getFrameTime();
		if (tick > this.mEndTime) {
			this.destroy();
		} else {
			var position = this.mNodeGL2.getPosition();
			this.mNodeGL2.setPosition(position.getX(), position.getY()
					+ gFlyOffVelY);

		}
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeBuildingBase'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeBuildingBase'] || {}; $MODULE_REGISTRY['weEngine/WeBuildingBase'] = exports; var GL2 = require('NGCore/Client/GL2').GL2;
var Core = require('NGCore/Client/Core').Core;
var Audio = require('NGCore/Client/Audio').Audio;
var Storage = require('NGCore/Client/Storage').Storage;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var WeAnimatedSprite2D = require('weEngine/WeSprite2D').WeAnimatedSprite2D;
var WeBuildingBubble = require('weEngine/WeBuildingBubble').WeBuildingBubble;
var WeCoinsCrowns = require('weEngine/WeCoinsCrowns').WeCoinsCrowns;

exports.WeBuildingBase = Core.MessageListener.subclass(
{
	classname : 'WeBuildingBase',
	
	////////////////////////////////////////////////////////////////////////////////
	//// Method: Shutdown
	//// Shuts down the Building and unloads all it's assets
	destroy : function()
	{
		this.CloseLotActionMenu();
		// Remove ourself from the map
		if (!this.mDisableRemoveObstruction)
		{
			this.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());
		}

		this.CloseJobBubble();
		if (Exists(this.mActionBubble))
		{
			this.mActionBubble.Trigger('force_close');
		}
		this.UnloadSprites();

		WeGameStateMgr.SetGlobalGameWidget(null);

		this.RemoveVillagers();

		this.RemoveBuilder();

		if (this.updating)
		{
			Core.UpdateEmitter.removeListener(this);
			this.updating = false;
		}
	},

	AddToGridClosest : function(cLotGrid, requestedPosition)
	{
		if (this.mAddedToGrid)
		{
			NgLogD("AddToGridClosest Hey you do not removed object before adding");
		}
		var bAdded = cLotGrid.AddObstructionClosest(this,
				requestedPosition);
		if (bAdded)
		{
			this.mAddedToGrid = true;
		}
		return bAdded;
	},

	AddToGridClosestFirst : function(cLotGrid, requestedPosition)
	{
		if (this.mAddedToGrid)
		{
			NgLogD("AddToGridClosest Hey you do not removed object before adding");
		}
		var bAdded = cLotGrid.AddObstructionClosest(this,
				requestedPosition, true);
		if (bAdded)
		{
			this.mAddedToGrid = true;
		} else
		{
			bAdded = cLotGrid.AddObstructionClosest(this,
					requestedPosition);
			if (bAdded)
			{
				this.mAddedToGrid = true;
			}
		}
		return bAdded;
	},
	
	AddToGridIgnoreOnlyBounds : function(cLotGrid)
	{
		if (this.mAddedToGrid)
		{
			NgLogD("AddToGrid Hey you do not removed object before adding");
		}
		var bAdded = cLotGrid.AddObstructionIgnoreOnlyBounds(this);
		if (bAdded)
		{
			this.mAddedToGrid = true;
		}
		return bAdded;
	},

	AddToGrid : function(cLotGrid, ignoreBounds)
	{
		if (this.mAddedToGrid)
		{
			NgLogD("AddToGrid Hey you do not removed object before adding");
		}
		var bAdded = cLotGrid.AddObstruction(this, ignoreBounds);
		if (bAdded)
		{
			this.mAddedToGrid = true;
		}
		return bAdded;
	},

	RemoveFromGrid : function(cLotGrid)
	{
		if (this.mAddedToGrid)
		{
			if (cLotGrid.RemoveObstruction(this))
			{
				this.mAddedToGrid = false;
				return true;
			}
			NgLogD("Something wrong cannot remove object");
			return false;
		}
		NgLogD("Heyy man you trayng to remove not added object");
		return false;
	},

	/**
	 *
	 */
	MoveToPositionOnGrid : function(cLotGrid, requestedPosition)
	{
		// First lets check if this position is in bounds
		cLotGrid.MovePositionToBounds(this, requestedPosition);

		var cOldPosition = this.mAnchor;

		this.RemoveFromGrid(cLotGrid);

		this.mAnchor = requestedPosition;
		var results = this.AddToGrid(cLotGrid);
		if (results)
		{
			this.PositionUpdated();
			cLotGrid.AddToDirtyList(this);
		} else
		{
			// Failed to add the guy at the position so put him back
			this.mAnchor = cOldPosition;
			var resultsTmp = this.AddToGrid(cLotGrid);
			if (!resultsTmp)
			{
				NgLogD("MoveToPositionOnGrid cant add back to ols position");
			}
		}
		return results;
	},

	GetStartX : function()
	{
		return this.mAnchor.x;
	},

	GetStartY : function()
	{
		return this.mAnchor.y;
	},

	GetEndX : function()
	{
		return this.mAnchor.x + this.GetSizeX();
	},

	GetEndY : function()
	{
		return this.mAnchor.y + this.GetSizeY();
	},

	// return fliped x size
	GetSizeX : function()
	{
		if (this.IsFlipped())
		{
			return this.mSize.y;
		}
		return this.mSize.x;
	},

	// return fliped y size
	GetSizeY : function()
	{
		if (this.IsFlipped())
		{
			return this.mSize.x;
		}
		return this.mSize.y;
	},

	// return fliped y size
	GetSize : function()
	{
		if (this.IsFlipped())
		{
			return new Vec2D(this.mSize.y, this.mSize.x);
		}
		return new Vec2D(this.mSize.x, this.mSize.y);
	},

	SetSizeFromSprite : function(cSprite)
	{
		//this.mSize.x= Math.ceil((cSprite.GetWidth() / cTileSizeWidth) );
		//this.mSize.y= Math.ceil((cSprite.GetHeight() / cTileSizeWidth) );
		this.mSize.x = Math
				.floor((cSprite.GetWidth() / cTileSizeWidth) + 0.5);
		this.mSize.y = this.mSize.x;
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: SetState
	 * @param {BuildingState} state the game state you want to set
	 */
	SetState : function(state)
	{
		this.mState = this.mState | state;
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: UnsetState
	 * @param {BuildingState} state the game state you want to unset
	 */
	UnsetState : function(state)
	{
		this.mState = this.mState & ~state;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: IsStateSet
	 * @return {bool} is the request state set
	 */
	IsStateSet : function(state)
	{
		return ((this.mState & state) !== 0);
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: IsConstructionDone
	 * Helper function to check if the construction of this building is done
	 * @return {Boolean} is the work done
	 */
	IsConstructionDone : function()
	{
		if (!this.HasWorkStarted())
		{
			//NgLogD("IsConstructionDone? no, work not started");
			return false;
		}

		var buildStart = this.GetWorkStartedDate();
		var completion = WeTime.GetGameDate();
		completion.setTime(this.mProtoEntity.build_time * 1000
				+ buildStart.getTime());
		var now = WeTime.GetGameDate();

		return now >= completion;
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: SetGameState
	 * @param {BuildingState} the game state is a range of bits that are mutual
	 * exclusive.  So it is assumed that if you set on, the others will be flipped
	 * to off
	 */
	SetGameState : function(state)
	{
		this.mState = ((this.mState & ~(BuildingState.Available))
				& (~(BuildingState.Busy)) & (~(BuildingState.Ready))
				& (~(BuildingState.Spoiled))
				& (~(BuildingState.Constructing))
				& (~(BuildingState.Collecting)) & (~(BuildingState.Shell)))
				| state;
	},

	toggleUpdatable : function()
	{
		if (this.updating === false)
		{
			this.updating = true;
			Core.UpdateEmitter.addListener(this, this.OnUpdate);
		}
	},

	DisableTouch : function()
	{
		//NgLogD(">>> Touch <<< WeBuildingBase DisableTouch()");
		
		if (this.mDecal && this.mDecal.GetGL2())
		{
			this.mDecal.GetGL2().setTouchable(false);
		} 
		
		if (this.mSprite && this.mSprite.GetGL2())
		{
			this.mSprite.GetGL2().setTouchable(false);
		}
	},

	EnableTouch : function()
	{
		//NgLogD(">>> Touch <<< WeBuildingBase EnableTouch()");

		if (this.mDecal && this.mDecal.GetGL2())
		{
			this.mDecal.GetGL2().setTouchable(true);
		} 
		
		if (this.mSprite && this.mSprite.GetGL2())
		{
			this.mSprite.GetGL2().setTouchable(true);
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	// Method:  IsFlipped
	// Check to see if this entity is in the "Flipped" state
	// @return boolean has the object been "Flipped"
	IsFlipped : function()
	{
		return this.mEntity.flipped;
	},

	//////////////////////////////////////////////////////////////////////////////
	// Method:  IsFlipped
	// Check to see if this entity is in the "Flipped" state
	// @return boolean has the object been "Flipped"
	CanFlip : function()
	{
		return this.mProtoEntity.can_flip;
	},

	//////////////////////////////////////////////////////////////////////////////
	// Method:  CanMove
	// Check to see if this is in fact a "movable" object in the game world
	// @return boolean has the object can be moved
	CanMove : function()
	{
		return this.IsStateSet(BuildingState.Movable);
	},

	//////////////////////////////////////////////////////////////////////////////
	// Method:  IsDecal
	// Is this object a decal or if it is not a decal
	// @return boolean as to if this a decal object or not default is false
	IsDecal : function()
	{
		return this.IsStateSet(BuildingState.Decal);
	},

	AddVillager : function(villager)
	{
		this.mVillagers.push(villager);
	},

	RemoveVillagers : function()
	{
		if (this.mVillagers)
		{
			// clear villagers
			for (var i in this.mVillagers)
			{
			    var obj = this.mVillagers[i];
			    obj.destroy();
			}
		}
        this.mVillagers = [];
	},
	
	CreateVillagers : function()
	{
		var db = weProtoDb.getInstance();
		var protoEntity = this.GetProtoEntity();
		var children = db.getProtoEntityChildren(protoEntity);

		if (children.length > 0)
		{
			var childLength = children.length;
			for ( var idx = 0; idx < childLength; idx++)
			{
				id = children[idx].proto_entity.id;
				var type = children[idx].proto_entity.type;

				var childProtoEntity = db.getProtoEntityById(id);
				var childProtoVisual = db
						.getProtoVisualById(childProtoEntity.primary_proto_visual_id);

				if (childProtoEntity.entity_type == "Villager")
				{
					if (childProtoVisual)
					{
						WeGameStateMgr
								.GetGameLotInfo()
								.CreateCharacter(this, childProtoEntity);
					} else
					{
						NgLogD("ERROR no ProtoVisual for "
								+ childProtoEntity.proto_name
								+ " protovisual id "
								+ childProtoEntity.primary_proto_visual_id);
					}
				}
			}
		}
	},

	////////////////////////////////////////////////////////////////////////////////
	//// Method: UnloadSprites
	//// Unloads any assets attached to this building
	UnloadSprites : function()
	{
		if (Exists(this.mDecal))
		{
			this.mDecal.destroy();
			delete this.mDecal;
			this.mDecal = null;
		}

		if (Exists(this.mSprite))
		{
			this.mSprite.destroy();
			delete this.mSprite;
			this.mSprite = null;
		}

		this.DeleteSecondarySprite();

		this.CloseJobBubble();
	},

	InitShell : function()
	{
		// Set the shell properties for this guy
		var color = 111 / 255;
		this.SetColor(color, color, color, 1);
		this.SetGameState(BuildingState.Shell);
	},

	SetColor : function(r, g, b, a)
	{
		if (this.mSprite)
		{
			this.mSprite.SetColor(r, g, b, a);
		}
		if (this.mDecal)
		{
			this.mDecal.SetColor(r, g, b, a);
		}
	},

	GetColor : function()
	{
		if (this.mSprite)
		{
			return this.mSprite.GetColor();
		}
		if (this.mDecal)
		{
			return this.mDecal.GetColor();
		}
		NgLogD("GetColor no sprite no decal problem");
		return undefined;
	},

	FixPngExtension : function(filename)
	{
		if (filename && filename.indexOf('.') < 0)
		{
			return filename + ".png"
		}
		return filename;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : GetProductFromId
	 * @param {Integer} id of the Product we want from this building
	 * @return {ProtoProduct} that maps to the id
	 */
	GetProductFromId : function(id)
	{
		var products = this.GetProtoProducts();
		//NgLogD("Products for this building: ");
		//objDump(products[0]);
		var len = products.length;
		for ( var idx = 0; idx < len; ++idx)
		{
			if (products[idx].id == id)
			{
				return products[idx];
			}
		}
		return null;
	},

	GetActualWorkStartedDate : function()
	{
		var startDate = this.GetWorkStartedDate();

		if (this.IsStateSet(BuildingState.AutoProducing)
				&& this.mEntity.work_type === "Build")
		{
			startDate.setTime(startDate.getTime()
					+ (this.mProtoEntity.build_time * 1000));
		}

		return startDate;
	},

	GetWorkStartedDate : function()
	{
		return ConvertToDate(this.mEntity.work_started_at);
	},



	GetConstructionTime : function()
	{
		var buildStart = this.GetWorkStartedDate();
		var completion = WeTime.GetGameDate();
		completion.setTime(this.mProtoEntity.build_time * 1000
				+ buildStart.getTime());
		var now = WeTime.GetGameDate();

		return WeTime.ConvertToNiceTime(completion - now);

	},

	OnRequest : function(request, handle, type)
	{
		if (type === undefined)
		{
			type = 'entity';
		}

		if (request && request.readyState == 4)
		{
			if (Exists(request.responseText)
					&& request.responseText.length)
			{
				try
				{
					var obj = JSON.parse(request.responseText);
					if (obj)
					{
						obj.statusCode = request.respHeaders.status;
					} else
					{
						// NgLogD("[RCDEBUG] Object is undefined in OnRequest. Responsetext: " + request.responseText);
					}
					if (type === null)
					{
						this[handle](obj);
					} else
					{
						this[handle](obj[type]);
					}
				} catch (ex)
				{
					NgLogException(ex);
					NgLogD("WeBuilding.prototype.OnRequest - Could not parse.  Response = "
							+ ex);
					NgLogD("statusText:" + request.statusText);
					NgLogD("responseText:" + request.responseText);
					//Storage.FileSystem.writeFile('./server-error', request.responseText);
					WeUiMgr.ShowNetworkErrorPopUp();
				}
			} else
			{
				NgLogD("Invalid Server Response");
				WeUiMgr.ShowNetworkErrorPopUp();
			}
		} else if (request && request.readyState === 0)
		{
            NgLogD("WeBuilding.prototype.OnRequest: Ready state === 0");
			WeUiMgr.ShowNetworkErrorPopUp();
		}
		else if (request)
		{
			NgLogD("Request with readyState = "+ request.readyState);
		}
		else
		{	
			NgLogD("OnRequest called with no request provided!");
		}
	},
	
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: GetProtoEntity
	 * We are currently caching off the protoentity but the memory overhead of this
	 * maybe too much.  As such we should use this method so we remove the cached
	 * copy if not needed.
	 * @return {ProtoEntity} attached to this building
	 */
	GetProtoEntity : function()
	{
		if (Exists(this.mProtoEntity))
		{
			return this.mProtoEntity;
		}

		return null;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: GetProtoVisual
	 * We are currently caching off the protoentity but the memory overhead of this
	 * maybe too much.  As such we should use this method so we remove the cached
	 * copy if not needed.
	 * @return {ProtoVisual} attached to this building
	 */
	GetProtoVisual : function()
	{
		if (Exists(this.mProtoVisual))
		{
			return this.mProtoVisual;
		}

		return null;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: GetProtoVisualDecal
	 * We are currently caching off the protoentityvisualdecal but the memory overhead 
	 * of this maybe too much.  As such we should use this method so we remove the cached
	 * copy if not needed.
	 * @return {ProtoVisualDecal} attached to this building
	 */
	GetProtoVisualDecal : function()
	{
		if (Exists(this.mProtoVisualDecal))
		{
			return this.mProtoVisualDecal;
		}

		return null;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: GetProtoProducts
	 * We are currently caching off the protoproducts but the memory overhead 
	 * of this maybe too much.  As such we should use this method so we remove the cached
	 * copy if not needed.
	 * @return {ProtoProducts} attached to this building
	 */
	GetProtoProducts : function()
	{
		if (!Exists(this.mProtoProducts))
		{
			this.mProtoProducts = [];
		}

		return this.mProtoProducts;
	},

	GetAllProtoProducts : function()
	{
		if (!Exists(this.mAllProtoProducts))
		{
			this.mAllProtoProducts = [];
		}

		return this.mAllProtoProducts;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: GetProtoJobProducts
	 * We are currently caching off the protoproducts but the memory overhead 
	 * of this maybe too much.  As such we should use this method so we remove the cached
	 * copy if not needed.
	 *
	 * A ProtoJobProduct is the Social jobs that the building can produce
	 * @return {ProtoProducts} job products attached to this building
	 */
	GetProtoJobProducts : function()
	{
		if (!Exists(this.mProtoJobProducts))
		{
			this.mProtoJobProducts = [];
		}

		return this.mProtoJobProducts;
	},

	IsTouchInObstruction : function(touch)
	{
	    
	    var configs = weProtoConfigs.getInstance().map;
		if (configs.EventParticipationEntityIds != undefined)
		{
			var eventIDstring = configs.EventParticipationEntityIds.toString();
			var eventIDs = eventIDstring.split("|");
			var numEventIDs = eventIDs.length;
			for (var i = 0; i < numEventIDs; ++i)
			{
				if (this.mEntity.proto_entity_id == parseInt(eventIDs[i]))
				{
				    return true;
				}
			}
		}
		
		if (this.IsDecal())
		{
			return WeGameStateMgr.GetGameLotGrid().TouchOnObstruction(
					this, touch);
		}
		return true;
	},
	
	// ultra hack for job removal
	RemoveJobHack : function(request, job)
	{
		if (Exists(request) && request.readyState == 4 && Exists(request.responseText))
		{
			if (job)
			{
				var lot = WeGameStateMgr.GetGameLotInfo();
				var active_jobs = lot.active_jobs;
				var len = active_jobs.length;
				for ( var idx = 0; idx < len; ++idx)
				{
					var job = active_jobs[idx];
					if (active_jobs[idx].id === job.id)
					{
						active_jobs.splice(idx, 1);
						break;
					}
				}
			}

			// recalculate and go through
			WeGameStateMgr.GetGameLotInfo().UpdateJobBubbles();

			this.UpdateEntity(this.mEntity);
		}
	},

	IsGiftCart : function()
	{
		var id = gConfigs['GiftingCartEntityId'];
		if (Exists(id))
		{
			//NgLogD("@@@@@ Gifting cart entity id: "+id);
			//NgLogD("@@@@@ Current entity id :"+this.mEntity.proto_entity_id);
/*			
			var giftCartEntity = weProtoDb.getInstance().getProtoEntityById(id);
			if (!Exists(giftCartEntity))
			{
				NgLogD("No gifting cart entity in protodb!");
			}
			else
			{
				//NgLogD("ENTITY: ");
				//objDump (giftCartEntity);
				var giftCartVisual = weProtoDb.getInstance().getProtoVisualById(giftCartEntity.primary_proto_visual_id);
				if (!Exists(giftCartVisual))
				{
					NgLogD("No gifting cart visual in protodb!");
				}
				else
				{
					//NgLogD("VISUAL: ");
					//objDump (giftCartVisual);
				}
			}
*/			
			return this.mEntity.proto_entity_id == id;
		}
		else	// fallback to hardcoded value
		{
			return this.mEntity.proto_entity_id == 663;
		}
		
		
	},

	IsHarvestAll : function()
	{
		var configs = weProtoConfigs.getInstance().map;
		var id = configs['HarvestAllEntityId'];
		return this.mEntity.proto_entity_id == id;
	},

	InitItem_gift_cart : function()
	{
		// Create bubble
		this.OpenJobBubble();
	},

	InitItem_harvest_all : function()
	{
		gHarvestAll = this;
		if(WeGameStateMgr.IsAnyHarvestable())
			this.OpenJobBubble();
	},

	UpdateSpritePosition : function(isDecal)
	{
		var protoVisual = this.GetProtoVisual();

		this.mSprite.mLayer = isDecal ? 0 : 1;

		if (this.mEntity.flipped)
		{
			this.mSprite.PushGamePosition([ this.mEntity.location_x, this.mEntity.location_y, 1.0 ], [ -protoVisual.offset_x, protoVisual.offset_y, protoVisual.z_order_vertical_offset ], false,
			isDecal);
		} else
		{
			this.mSprite.PushGamePosition([ this.mEntity.location_x, this.mEntity.location_y, 1.0 ], [ protoVisual.offset_x, protoVisual.offset_y, protoVisual.z_order_vertical_offset ], false,
			isDecal);
		}
	},

	UpdateDecalPosition : function(isDecal)
	{
		var protoVisualDecal = this.GetProtoVisualDecal();

		this.mDecal.mLayer = isDecal ? 0 : 1;

		if (this.mEntity.flipped)
		{
			this.mDecal.PushGamePosition([ this.mEntity.location_x, this.mEntity.location_y, 0.5 ],
			[ -protoVisualDecal.offset_x, protoVisualDecal.offset_y, protoVisualDecal.z_order_vertical_offset ], false, isDecal);
		} else
		{
			this.mDecal.PushGamePosition([ this.mEntity.location_x, this.mEntity.location_y, 0.5 ], [ protoVisualDecal.offset_x, protoVisualDecal.offset_y, protoVisualDecal.z_order_vertical_offset ],
			false, isDecal);
		}
		if (this.mSprite)
		{
			this.mDecal.SetDepth(this.mSprite.GetDepth() - 0.01);
		}
	},

	GetMainSprite : function()
	{
		if (this.mSprite)
		{
			return this.mSprite;
		} else if (this.mDecal)
		{
			return this.mDecal;
		}

		NgLogD("WARNING: GetMainSprite: no visual representation for building!");

		var cProtoVisual = this.GetMainProtoVisual();
		if (cProtoVisual)
		{
			NgLogD("proto visual name" + cProtoVisual.header_tag);
		} else
		{
			NgLogD("WARNING: GetMainSprite: no proto visual found!");
		}
		return null;
	},

	GetMainProtoVisual : function()
	{
		if (this.mSprite)
		{
			return this.GetProtoVisual();
		} else if (this.mDecal)
		{
			return this.GetProtoVisualDecal();
		}
		return null;
	},
	
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: InitItem_Build
	 * The building is of type "Build".  If the building has completed construction
	 * then it needs to start autoproducing and/or working on its socal job.  If
	 * it is not completed construction, apply a color tint it 
	 */
	InitItem_Build : function()
	{
		this.SetState(BuildingState.Build);

		// 1) Check if this guy is in a fully built state
		if (!this.IsConstructionDone())
		{
			// The building is in the build state
			this.SetGameState(BuildingState.Constructing);
			// Set the decal colors on this guy
			var colorValue = 111 / 255;
			this.SetColor(colorValue, colorValue, colorValue, 1);

			this.OpenJobBubble();
		} else if (this.IsStateSet(BuildingState.Product))
		{
			// Look, I know this guy is a "Build" item but since it has
			// completed builing it needs some "produce" properities
			this.InitItem_Produce();
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: ChangeProtoEntity
	 * Building entity changed, init the new building functionality
	 * @return {ProtoEntity} attached to this building
	 */
	ChangeProtoEntity : function(newProtoEntity)
	{
		// Check if the new entity is not already set
		if (this.mProtoEntity)
		{
			if (this.mProtoEntity.proto_entity_id == newProtoEntity.proto_entity_id)
			{
				return;
			}
		}

		// remove the obstruction
		WeGameStateMgr.GetGameLotGrid().RemoveObstruction(this);

		// Set new prot entity
		this.mProtoEntity = weProtoDb.getInstance().getProtoEntityById(newProtoEntity.proto_entity_id);

		if (this.mProtoEntity.primary_proto_visual_id)
		{
			// Set new entity id
			this.mEntity.proto_entity_id = this.mProtoEntity.id;

			// Get the proto visuals
			var protoVisual = weProtoDb.getInstance().getProtoVisualById(this.mProtoEntity.primary_proto_visual_id);
			var protoVisualDecal = weProtoDb.getInstance().getProtoVisualById(this.mProtoEntity.decal_proto_visual_id);

			// Validate proto visuals
			if (Exists(protoVisual))
			{
				this.mProtoVisual = protoVisual;
			}

			if (Exists(protoVisualDecal))
			{
				this.mProtoVisualDecal = protoVisualDecal;
			}

			if (Exists(this.mDecal))
			{
				this.mDecal.destroy();
				delete this.mDecal;
				this.mDecal = null;
			}

			if (Exists(this.mSprite))
			{
				this.mSprite.destroy();
				delete this.mSprite;
				this.mSprite = null;
			}

			// Create new sprites
			this.InitSprites(true);
		}
	},

	prepareBubbleForClosing : function (bubble, request)
	{
		//NgLogD("@@@@@ Completed: "+this.mActionBubble.xCompleted+" @@@@@");
		bubble.xRequest = request;
		bubble.Trigger('done');			
	},

	OpenGiftingView : function()
	{
		//WeProtocol.getGifts(WeProtocol.getGiftsCallback);
		//WeProtocol.getGiftUsers(WeProtocol.getGiftUsersCallback);

		WeUiMgr.ShowLoading(true);
		NgLogD("Gifting starts here!");
		new Timer(0.3, function()
		{
			//NgLogD("Timer ended!");
			WeUiMgr.TransitionScreenTo("GiftingScreen");
		});
	},
	
	LockCamera : function()
	{
		return (WeGameStateMgr.IsLotObjectsMovable() || this.IsStateSet(BuildingState.Shell)) && this.mbTouched;
	},

	OnNativeTouch : function(touch)
	{
		DebugTouch(touch, "WeBuildingBase OnNativeTouch()");
		
		//WeGameStateMgr.GetGameLotGrid().DebugDumpMapInfo();
		
		if ( WeUiMgr.GetActiveScreen() === "SocialMapScreen")
		{
            return false;
        }
        
		if (!WeGameStateMgr.mTouchAllowed)
		{
			return false;
		}
		
		// If you can't move then you are the castle (unless you are gift cart)
		// $TODO there should really be a "touchable" state
		if (!this.IsStateSet(BuildingState.Movable)  && !this.IsGiftCart())
		{
			return false;
		}
		
		var self = this;
		var touchAction = touch.getAction();
		var touchPosition = touch.getPosition();
		this.mLastTouchAction = touchAction;
		// Is the building in a movable state?
		if (this.IsStateSet(BuildingState.Movable) && (WeGameStateMgr.IsLotObjectsMovable() || this.IsStateSet(BuildingState.Shell)))
		{			
			var activeObj = WeGameStateMgr.GetActiveObject();
			// Check if this touch belongs to this object
			if ( (activeObj != null && activeObj != this) )
        	{
				return false;
			}

			//Super Hack for camera 2 point touch
			if( Core.Capabilities.getPlatformOS() === "Android")
			{
    			if (touch.getId() != 1 || WeCamera.getTouchCount() === 2)
    			{
    				this.mTouchId = -1;
    				this.mbTouched = false;
    				if (WeGameStateMgr.GetActiveObject() === this || WeGameStateMgr.GetActiveObject() !== null)
    				{
    					WeGameStateMgr.SetActiveObject(null);
    				}
    				return false;
    			}
			}
						
			var touchTime = Core.Time.getFrameTime();
			var delta = touchTime - (Exists(this.mLastTouchTime) ? this.mLastTouchTime : 0);
			
			if (touchAction == touch.Action.Start && !this.IsStateSet(BuildingState.Constructing))
			{ // we touched a shell building, set it as the active object
				WeGameStateMgr.SetActiveObject(this);
				this.mTouchId = touch.getId();
				this.mbTouched = true;
				this.mFirsTouchPos = touchPosition;
			} 
			else if (touchAction == touch.Action.Move)
			{ // we let weground handle the movement of activeobj building
				this.mbTouched = true;
			}
			else if (touchAction == touch.Action.End && (touch.getId() == this.mTouchId) && delta < 500 && null !== WeGameStateMgr.GetActiveObject() && !this.IsStateSet(BuildingState.Constructing))
			{
				if (this.mbTouched)
				{
					if (!this.IsStateSet(BuildingState.Shell))
					{
						this.SetColor(1, 1, 1, 1);
						if( this.mFirsTouchPos && 
								Math.abs(this.mFirsTouchPos.getX() - touchPosition.getX()) < WeUiMgr.GetTouchLeeway() &&
                                Math.abs(this.mFirsTouchPos.getY() - touchPosition.getY()) < WeUiMgr.GetTouchLeeway())
						{
							this.OpenLotActionMenu();
						}
					}
					else
					{
						this.OpenLotActionMenu();
					}
					this.mbTouched = false;
					return true;
				}
				return true;
			}
			
			if(touchAction == touch.Action.End)
			{
				this.mFirsTouchPos=null;
				if (this.IsStateSet(BuildingState.Shell))
				{
					this.OpenLotActionMenu();
				}
			}
			this.mLastTouchTime = touchTime;
			return false;
		} else if (touchAction == touch.Action.Move && touch.getId() == this.mTouchId)
		{
			return false;
		} else if (touchAction == touch.Action.Start)
		{
			//if (!this.IsTouchInObstruction(touch))
			if (this.IsDecal())
			{
				return false;
			}
			this.mLastTouchTime = Core.Time.getFrameTime();
			this.mLastTouchLoc = touch.getPosition();
			this.mTouchId = touch.getId();
			return true;
		} else if (touchAction == touch.Action.End && touch.getId() == this.mTouchId && Exists(this.mLastTouchLoc))
		{
			if (WeGameStateMgr.GetActiveObject())
			{
				WeGameStateMgr.SetActiveObject(null);
			}
			var time = Core.Time.getFrameTime();
			var dist = WeMath.Distance2D(new Vec2D(this.mLastTouchLoc.getX(), this.mLastTouchLoc.getY()), new Vec2D(touchPosition.getX(), touchPosition.getY()));
			if(time - this.mLastTouchTime < Globals.BuildingTapTime && dist < Globals.BuildingTapDistance)
			{
				if (this.IsGiftCart())
				{
					//NgLogD("### Gift cart touched!");
					this.OnGiftCartTouch();
				}
				else if (this.IsHarvestAll())
				{
					this.OnHarvestAllTouch();	
				}
				else if (WeGameStateMgr.IsCurrentUser())
				{
					if (this.IsStateSet(BuildingState.Constructing))
					{
						this.OnConstructingTouch();
					} else if (this.IsStateSet(BuildingState.AutoProducing))
					{
						WeEffectsMgr.PlaySoundEffect(this.mProtoEntity.sound_select);
						this.OnAutoProduceTouch();
					} else
					{
						WeEffectsMgr.PlaySoundEffect(this.mProtoEntity.sound_select);
						this.OnProduceTouch();
					}
				} else
				{
					if (this.IsStateSet(BuildingState.Constructing))
					{
						// Play the construction sound
						WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.ConstructionShort);
					} else
					{
						var jobProducts = this.GetProtoJobProducts();
						if (this.IsStateSet(BuildingState.AutoProducing) && Exists(jobProducts) && Exists(jobProducts[0]) && (this.mEntity.current_product_id != jobProducts[0].id))
						{
							WeEffectsMgr.PlaySoundEffect(this.mProtoEntity.sound_select);
							this.OnAutoProduceTouch();
						}
					}
				}

				this.mTouchId = -1;
				if (this.IsDecal())
				{
				    return false;
				}
				return true;
			}
		}
		return false;
	},

	IsTouched : function()
	{
		return this.mbTouched;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: InitItem_Produce
	 * Sets up the building item with the properities of a produce building (a.k.a farms)
	 */
	InitItem_Produce : function()
	{
		this.SetState(BuildingState.Produce);
		if (this.IsStateSet(BuildingState.AutoProducing))
		{
			if (WeGameStateMgr.IsCurrentUser())
			{
				if (this.HasWorkStarted())
				{
					if (this.ShouldHaveOwnerJobBubble())
					{
						this.OpenJobBubble();
					} else
					{
						this.DoGrowing();
					}
				}
			} else
			{
				if (this.ShouldHaveFriendJobBubble())
				{
					this.OpenJobBubble();
				}
			}
		} else
		{
			if (this.mEntity.current_product_id)
			{
				var date = this.GetWorkStartedDate();
				var prod = weProtoDb.getInstance().getProtoProduceId(this.mEntity.current_product_id);
				if (prod)
				{
					var spoil = WeTime.GetGameDate();
					var nMiliSecTillEnd = (prod.produce_duration + prod.spoilage_duration) * 1000;
					spoil.setTime(nMiliSecTillEnd + date.getTime());
					var currentDate = WeTime.GetGameDate();
					if (spoil < currentDate)
					{
						// NgLogD("[RCDEBUG] Setting spoiled (date) ("+this.mProtoEntity.proto_name+")");
						this.SetSpoiled();
					} else
					{
						this.DoGrowing();
					}
					//var nMiliSecTillEnd= (prod.produce_duration + prod.spoilage_duration) * 1000;
					//IsTimerFinished(ConvertToDate(this.mEntity.work_started_at),  nMiliSecTillEnd )
				} else
				{
					NgLogD("How did this happen.  Please contact an Engineer!");
				}
			} else
			{
				var products = weProtoDb.getInstance().getProtoProducesForEntity(this.mProtoEntity.id);
				if (products && products.length > 0)
				{
					this.SetAvailable();
				}
			}
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : OnAvailable
	 * This building is "Available" for work.  If this is a "farm" type object
	 * and the current user is the owner then the job bubble will open. Else if
	 * this is not a the current user and the owner is not the logged in user and
	 * no social job has been placed then the "open for business" actions are
	 * done.  The image selection logic will be done via screen callbacks when
	 * the ui has been constructed
	 */
	SetAvailable : function()
	{
		var protoEntity = this.GetProtoEntity();
		if (protoEntity.entity_type === "BuildingCityHall")
		{
			return;
		}

		this.SetGameState(BuildingState.Available);
		if (WeGameStateMgr.IsCurrentUser())
		{
			this.OpenJobBubble();
		}
	},
	
	SetBubble : function(bubble)
	{
		if(!WeGameStateMgr.mLotInfo.IsBubblesShowing())
		{
			bubble.Trigger('setAlpha', 0);
		}
		this.mBubble=bubble;
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: OpenJobBubble
	 * Opens the job bubble over this game item
	 */
	OpenJobBubble : function()
	{
		// Fix the bubble from opening just after converting into a business building
		if (this.justChangedToBusiness === true)
		{
			this.justChangedToBusiness = false;
			return;
		}

		if (gHarvestAll && this.IsHarvestAll() && !WeGameStateMgr.IsCurrentUser())
		{
			return;
		}
		   
		if (!this.IsStateSet(BuildingState.Shell) && !this.IsStateSet(BuildingState.Constructing))
		{
			// Close down any existsing bubbles 
			this.CloseJobBubble();

			var self = this;
			var args = {};
			args.itemType = "job_bubble";

			// Create the Widget 
			var widget = this.SetupBuildingUI(args);

			// Create the new bubble wrapper
			var bubble = new WeBuildingBubble(widget, true);
			this.SetBubble(bubble);
			this.mBubble.mSource = this;
			// Source as triggered that the action bubble should close
			bubble.On('internal_close', function()
			{
				bubble.Trigger('close');

				if (Exists(widget))
				{
					widget.destroy();
				}
				delete self.mBubble;
				self.mBubble = null;
			});

			// Open scrying pool bubble
			if(gHarvestAll && !this.IsHarvestAll()) {
				if(this.IsStateSet(BuildingState.Ready) || this.IsStateSet(BuildingState.AutoProducing)) {
					gHarvestAll.OpenJobBubble();
				}	
			}
			
			if (this.OnObjStateAssetRequested() === "")
			{   // HACK: there was no asset inside bubble for some WEIRD reason so we should just close bubble.
			    // bubbles always have something in them right?
			    this.CloseJobBubble();
			}
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: CloseJobBubble
	 * Close the job bubble on this game item
	 */
	CloseJobBubble : function()
	{
		if (Exists(this.mBubble))
		{
			this.mBubble.Trigger('internal_close');
		}

		// Close harvest all bubble if neccessary
		if(gHarvestAll && !this.IsHarvestAll()) {
			if(!WeGameStateMgr.IsAnyHarvestable())
				gHarvestAll.CloseJobBubble();
		}
	},


	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: onUpdate
	 * Update tick to do the growing action on times that are currently "Busy"
	 */
	OnUpdate : function(delta)
	{
	    if (WeGameStateMgr.mSuspended)
	    {
	        return;
	    }
	    
		if (this.IsStateSet(BuildingState.Busy))
		{
			this.DoGrowing();
		} else if (this.IsStateSet(BuildingState.Constructing))
		{
			this.DoConstruction();
		} else if (this.IsStateSet(BuildingState.Ready))
		{
			var percentage = this.CompletionPercentage();
			if (percentage == -1.0)
			{
				this.SetSpoiled();
			}
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: HasWorkStart
	 * Utility method for check if the building has work that has started.
	 * Important for producing objects (such as farms)
	 * @return {Boolean} has work started
	 */
	HasWorkStarted : function()
	{
		return (Exists(this.mEntity.work_started_at) && this.mEntity.work_started_at != "null" && this.mEntity.work_started_at != "<null>");
	},

	OnGiftCartTouch : function(touch)
	{
		//NgLogD("#### Trying to process gift cart touch!");
		// If we're in redesign mode, do nothing
		if (WeUiMgr.mActiveScreen === "RedesignScreen")
			return;

		// Only from level 10
        if (gCurGameLotInfo.mLevel < 10)
        {
		    var args = {};
		    args.OnOk = function(args)
		    {
			    WeGameStateMgr.SetGlobalGameWidget(null);
		    };
		    args.popup_label = "I'm sorry...";
            if (WeGameStateMgr.IsCurrentUser())
            {
		        args.popup_text = "You need to reach level 10 to open your free gifts. You're almost there. Complete goals to level up faster!";
            }
            else
            {
                args.popup_text = "You need to reach level 10 to send free gifts to friends. You're almost there. Complete goals to level up faster!";
            }
		    var itemDef = WeUiMgr.GetItemDef("popup_box");
		    var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
		    newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
		    WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
		    return;
        }

		// Gift cart touch handling - still to improve
		if (WeGameStateMgr.IsCurrentUser() && !WeGameStateMgr.mGiftingOpen)
		{
			WeGameStateMgr.mGiftingOpen = true;
            WeProtocol.getGiftUsers(function(){});
			this.OpenGiftingView();
		}
		else if (!WeGameStateMgr.IsCurrentUser())
		{
			WeProtocol.sendGiftToCurrentUser();
		}
		return false;
	},

	OnHarvestAllTouch : function() 
	{
		if(!WeGameStateMgr.IsCurrentUser())
			return;

		var buildings = WeGameStateMgr.GetHarvestable();
		if(buildings.length == 0)
			return true;

		var configs = weProtoConfigs.getInstance().map;
		var entityId = configs['HarvestAllEntityId'];
		var cost = configs['HarvestAllCost'];
		var timeMultiplier = configs['HarvestAllProgressTimeMultiplier'];
		if(timeMultiplier == undefined)
			timeMultiplier = 0.05;
		var harvestTime = gGlobalHarvestTime + timeMultiplier * buildings.length;

		var args = {};
		
		if (cost <= WeGameStateMgr.GetGameLotInfo().mana)
		{
		    args.OnYes = function(args)
    		{
				gHarvestAllActive = true;
    			var bubble = this.CreateCollectionBubble(getAssets("job_scryingpool"),
    				"Harvesting...", null, harvestTime);
    			bubble.On('close', function()
    			{
    				var sender = bubble.xSender;
    				var buildings = bubble.xBuildings;
    				var request = bubble.xRequest;
    				var obj;
    				try
    				{
    					obj = JSON.parse(request.responseText);
    				}
    				catch(ex)
    				{
    					NgLogD("Unable to parse harvestAll response");
    					WeUiMgr.ShowNetworkErrorPopup();
    				}

    				if(Exists(obj))
    				{
    					for(var i in obj.kingdom.entities)
    					{
    						var ent = obj.kingdom.entities[i];
    						for(var j in buildings)
    						{
    							var building = buildings[j];
    							if(building.mEntity.id == ent.id)
    							{
    								var oldFlyOff = building.needFlyOff;
    								building.needFlyOff = false;
    								building.OnHarvest(ent);
    								building.needFlyOff = oldFlyOff;

    								if(building.IsStateSet(BuildingState.Ready))
    									building.SetAvailable();

    								if(building.IsStateSet(BuildingState.AutoProducing)) {
    									building.CloseJobBubble();
    									building.UpdateEntity(ent);
    								}
    							}
    						}
    					}

    					var lot = WeGameStateMgr.GetGameLotInfo();
    					var offset = 0;
    					if(obj.kingdom.xp_flyoff > 0)
    					{
    						lot.xp += obj.kingdom.xp_flyoff;
    						sender.CreateResourceFlyOff(obj.kingdom.xp_flyoff, "xp", 0);
    						offset = gFlyOffOffset;
    					}	
    					if(obj.kingdom.gold_flyoff > 0)
    					{
    						lot.gold += obj.kingdom.gold_flyoff;
    						sender.CreateResourceFlyOff(obj.kingdom.gold_flyoff, "coin", offset);
    					}	
    					lot.mana -= cost;
    					sender.CloseJobBubble();
						gHarvestAllActive = false;
    				}
    			});

    			WeProtocol.harvestAll(buildings, function(request) 
    			{
    				bubble.xRequest = request;
    				bubble.xBuildings = buildings;
    				bubble.xSender = this;
    				bubble.Trigger('done');
    			}.bind(this));
			
    			WeGameStateMgr.SetGlobalGameWidget(null);
    		}.bind(this);

    		args.OnNo = function(args)
    		{
    			WeGameStateMgr.SetGlobalGameWidget(null);
    		};
    		
    		args.popup_label = "Harvest All?";
    		args.popup_text = "Do you want to do " + buildings.length + " harvests for "; 
    		args.popup_text += cost + " mojo?";
        }
        else
        {
            args.OnOk = function(args)
              {
                  WeGameStateMgr.SetGlobalGameWidget(null);
              };
              
              args.popup_label = "Sorry";
      		args.popup_text = "It costs " + cost + " mojo to harvest all, and you only have " + WeGameStateMgr.GetGameLotInfo().mana + "."; 
        }
		

		var itemDef = WeUiMgr.GetItemDef("popup_box");
		var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
		newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

		WeGameStateMgr.SetGlobalGameWidget(newGameWidget);

		return true;
	},
	
	//////////////////////////////////////////////////////////////////////////////
	/** 
	 * Method: SetMainSpriteTo
	 * @param {"String"} name of the sprite sheet to create
	 * @param {Integer} fame number to set this sprite to
	 * Set the main sprite to the following asset.  This was written to be used by the
	 * game to replace the "keep" structure
	 */
	SetMainSpriteTo : function(sheet, frame)
	{
		if (this.mCurrentSprite === sheet && this.mCurrentFrame === frame)
		{
			return;
		}

		if (Exists(this.mSprite))
		{
			this.mSprite.destroy();
			delete this.mSprite;
			this.mSprite = null;
		}

		var protoVisual = this.GetProtoVisual();
		// I don't really care what was on this guy .. just harvest him out.
		this.mSprite = new WeAnimatedSprite2D(WeRenderDevice.GetGameRoot(), sheet, gLOD, this.mEntity.flipped, 1);

		this.UpdateSpritePosition(this.CountDecalState());

		this.mSprite.name = this.mProtoVisual.header_tag;
		this.mSprite.primary = true;
		this.mSprite.mOwner = this;

		if (frame >= this.mSprite.mAnimations.length)
		{
			NgLogD("******** WeBuilding : Frame " + frame + " not found in " + this.mProtoVisual.header_tag);
			frame = this.mSprite.mAnimations.length - 1;
		}

		this.mSprite.GetGL2().setAnimation(this.mSprite.mAnimations[frame], 0);
		var self = this;
		if (this.mDecal)
		{
		    this.mDecal.mOwner = this;
			this.mDecal.Enable("Touch", function(touch)
			{
				return self.OnNativeTouch(touch);
			});
		} 
		
		if (this.mSprite)
		{
		    this.mSprite.mOwner = this;
			this.mSprite.Enable("Touch", function(touch)
			{
				return self.OnNativeTouch(touch);
			});
		}

		this.toggleUpdatable();

		this.mCurrentSprite = sheet;
		this.mCurrentFrame = frame;
	},
	
	OnStash : function()
	{
		var self = this;
		var data = {};
		data.entities = [];

		var dataSet = {};
		dataSet.flipped = this.mEntity.flipped;
		dataSet.id = this.mEntity.id;
		dataSet.proto_entity_id = this.mProtoEntity.id;
		dataSet.stash = 'true';
		dataSet.location_x = this.mEntity.location_x;
		dataSet.location_y = this.mEntity.location_y;
		data.entities.push(dataSet);

		var kingdomId = WeGameStateMgr.GetCurrentKingdomId();

		WeProtocol.updateBuildingPositions(kingdomId, data, function(request)
		{
			if (request.readyState == 4)
			{
				if (Exists(request.responseText) && 0 !== request.responseText.length)
				{
					var obj = JSON.parse(request.responseText);
					if (obj.kingdom)
						WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.kingdom);

					// remove the stashed entity (the entity id only should appear once)
					WeGameStateMgr.RemoveEntityWithId(self.mEntity.id);

					self.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());

					if (Exists(self))
						self.destroy();

					WeProtocol.getStash();
				} else
				{
                    NgLogD("Error: WeProtocol.updateBuildingPositions");
					WeUiMgr.ShowNetworkErrorPopUp();
				}
			} else if (request.readyState === 0)
			{
				ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
			}
		});
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnPlantCrop
	 * Called when the server has confirmed that we have "planted" the crop
	 * @param {Entity} ent new values for the entity
	 */
	OnPlantCrop : function(ent)
	{
		if (ent)
		{
			WeGameStateMgr.GetGameLotInfo().UpdateInfo(ent.kingdom.kingdom);
			this.UpdateEntity(ent);

			this.CloseJobBubble();
			this.DoGrowing();
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnUseMojo
	 * The user has requested to use mojo is some way
	 * @param {ProtoProduct} prod that needs to be boosted
	 */
	OnUseMojo : function(prod)
	{
		var self = this;
		var boostCost = 0;

		//NgLogD("@@@@ Bring it on!");
		self.canProcessZap = false;

		if (this.IsStateSet(BuildingState.Constructing))
		{
			boostCost = Math.max(this.mProtoEntity.boost_cost, 1);
		} else if (Exists(prod))
		{
			boostCost = prod.boost_cost;
		}

		if (WeGameStateMgr.GetGameLotInfo().mana < boostCost)
		{
			self.canProcessZap = true;
			// not enough mana
			var newArgs = {};
			newArgs.OnYes = function(theNewArgs)
			{
				WeUiMgr.TransitionScreenTo("BuyMojoScreen");
			};

			newArgs.OnNo = function(theNewArgs)
			{

			};
			newArgs.popup_label = "Oops!";
			newArgs.popup_text = "You don't have enough " + GameSpecificVariables.Texts.mojoTextU + ". Get more?";

			var itemDef = WeUiMgr.GetItemDef("popup_box");
			var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
			newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);

			WeGameStateMgr.SetGlobalGameWidget(newGameWidget);
			return;
		}

		NgLogD("*********** Prod = " + prod);

		// Create the Job bubble
		//var bubble = this.CreateCollectionBubble(GameSpecificVariables.Textures.Small_Mojo, "Using " + GameSpecificVariables.Texts.mojoTextU + "...", prod);
 		var small_mojo = GameSpecificVariables.Textures.Small_Mojo;
 		if (WeCoinsCrowns.isCoinImage(small_mojo))
			small_mojo = WeCoinsCrowns.getCoinsOrCrowns(small_mojo);
 		
 		var bubble = this.CreateCollectionBubble(small_mojo, "Using " + GameSpecificVariables.Texts.mojoTextU + "...", prod);
 		
		// When the bubble closes set us back to available
		bubble.On('close', function()
		{
			//NgLogD("@@@@ Take it off...")
			self.canProcessZap = true;
			self.OnRequest(bubble.xRequest, 'OnProcessMojo', null);
		});

		// Send off the request
		WeProtocol.useMana(self.mEntity.id, boostCost, function(request)
		{
			bubble.xRequest = request;
			bubble.Trigger('done');
		});

		WeGameStateMgr.SetGlobalGameWidget(null);
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.Mojo);
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnProcessMojo
	 * The callback for when the json request has been parsed
	 * @param {JSON} obj parsed json object
	 */
	OnProcessMojo : function(obj)
	{
		if (obj && obj.entity)
		{
			WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.entity.kingdom.kingdom);
			var job = this.ActiveJob();
			if (job)
			{
				this.CloseJobBubble();
				//NgLogD("ON PROCESS " + job.state);
				this.UpdateEntity(obj.entity);
				this.OpenJobBubble();
			} else
			{
				this.OnBoostBuilding(obj.entity);
			}
		}

	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: UpdateEntity
	 * Updates the entity object and updates any building state due to the new
	 * entity values
	 * @Param {Entity} The new intity values
	 */
	UpdateEntity : function(ent)
	{
		NgLogD("updating entity: " + JSON.stringify(ent));
		
		if (Exists(ent))
		{
			CopyProtoEntity(ent, this.mEntity);

			this.mState = BuildingState.None;
			this.CountDecalState();
			var protoEntity = this.GetProtoEntity();
			if (protoEntity.entity_type != "BuildingCityHall" && !this.IsGiftCart())
			{
				this.SetState(BuildingState.Movable);
			}

			// Now lets re-init this guy
			this.InitProductsFromId(ent.proto_entity_id);
			
			this.RemoveBuilder();

			// Update scrying pool
			if(gHarvestAll) {
				if(!WeGameStateMgr.IsAnyHarvestable())
					gHarvestAll.CloseJobBubble();
			}

			this.AttractPest();
		}	
	},

	AttractPest : function()
	{
		var db = weProtoDb.getInstance();
		var prod = db.getProtoProduceId(this.mEntity.current_product_id);
		if (!Exists(prod))
		{
		    return;
		}
		
		var percentage = this.CompletionPercentage();
		var attracts_pest = false;
		if(percentage >= 1.0)
		{
			var pests = db.proto_pests;
			
			NgLogD("**************** AttractPest **************");
			
			for(var i in pests)
			{
				var pest = pests[i].proto_pest;
				var triggers = pest.spawn_trigger_ids.split('|');
				for(var j in triggers)
				{
					if(parseInt(triggers[j]) == prod.id)
					{
						attracts_pest = true;
						break;
					}
				}
				if(attracts_pest)
					break;
			}
		}

		if(attracts_pest)
			WeProtocol.getPests(WeGameStateMgr.GetCurrentKingdomId());
	},

	InitProductsFromId : function(proto_entity_id)
	{
		var products = weProtoDb.getInstance().getProtoProducesForEntity(proto_entity_id);
		this.InitProducts(products);
		var func = 'InitItem_' + this.mEntity.work_type;
		if (Exists(this[func]))
		{
			this[func]();
		} else
		{
			NgLogD("WeBuilding unknown building type: " + this.mEntity.work_type);
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: OnBoostBuilding
	 * The callback that the user has request to "boost" their crop or building via
	 * using mojo.  This call should be made when the server has signed off on our
	 * request to use the mojo
	 * @param {ProtoEntity} ent new values of this proto entity 
	 */
	OnBoostBuilding : function(ent)
	{

		WeGameStateMgr.GetGameLotInfo().UpdateInfo(ent.kingdom.kingdom);
		this.UpdateEntity(ent);

		if (this.xBoostPercent)
		{
			delete this.xBoostPercent;
		}

		this.SetColor(1, 1, 1, 1);

		this.RemoveBuilder();
		this.RemoveVillagers();
		this.CreateVillagers();

		WeEffectsMgr.PlaySoundEffect(this.mProtoEntity.sound_build_complete);

		this.CloseJobBubble();
	},

	OnProcessJob : function(job)
	{
		//NgLogD("ON PROCESS JOB: " + job);
		if (Exists(job))
		{
			WeGameStateMgr.GetGameLotInfo().UpdateJobInfo(job);
			this.CloseJobBubble();

			// I need to update all affected entities
			WeGameStateMgr.GetGameLotInfo().UpdateEntities(job.affected_entities);

			if (job.request_kingdom && job.request_kingdom.kingdom && job.request_kingdom.kingdom.id === WeGameStateMgr.GetCurrentKingdomId())
			{
				WeGameStateMgr.GetGameLotInfo().UpdateInfo(job.request_kingdom.kingdom);
			}

			if (job.friend_kingdom && job.friend_kingdom.kingdom && job.friend_kingdom.kingdom.id === WeGameStateMgr.GetCurrentKingdomId())
			{
				WeGameStateMgr.GetGameLotInfo().UpdateInfo(job.friend_kingdom.kingdom);
			}

			var prod = this.GetJobProductByProducingProtoEntityId(this.mProtoEntity.id);
					// this.GetProductFromId(this.mEntity.current_product_id);
			if (prod && this.needFlyOff)
			{
				var offset = 0;
				if (prod.xp_reward > 0)
				{
					this.CreateResourceFlyOff(prod.xp_reward, "xp", 0);
					offset += gFlyOffOffset;
				}

				if (prod.produce_cap > 0)
				{
					this.CreateResourceFlyOff(prod.produce_cap, "coin", offset);
				}
			}

		} else
		{
			NgLogD("Error - null or undefined job");
		}

		// recalculate and go through
		WeGameStateMgr.GetGameLotInfo().UpdateJobBubbles();

	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method:  GetPercentRemaining
	 * Accessor to the % to completion
	 * 
	 * $TODO how is this different then CompletePercente?
	 *
	 * @param {ProtoProduct} prod that the building is currently working on
	 * @return {float} percent to completion
	 */
	GetPercentRemaining : function(prod)
	{
		var completion = null;
		var date = null;
		var delta = null;
		var percent = 0;

		if (this.IsHarvestAll())
		{
			if (Exists(this.mActionBubble))
				percent = this.mActionBubble.xPercent;
			else 
				percent = 0;
		}
		if (this.IsStateSet(BuildingState.Constructing))
		{
			date = this.GetWorkStartedDate();
			completion = WeTime.GetGameDate();
			completion.setTime(this.mProtoEntity.build_time * 1000 + date.getTime());

			delta = (WeTime.GetGameTime() - date.getTime()) / (completion.getTime() - date.getTime());
			percent = Math.floor(delta * 100.0);
		} else if (prod)
		{
			if (this.IsStateSet(BuildingState.Collecting))
			{
				// Is this what you wanted?
				if (Exists(this.mActionBubble))
					percent = this.mActionBubble.xPercent;
			} else if (this.HasWorkStarted())
			{
				if (Exists(this.mActionBubble))
				{
                    percent = this.mActionBubble.xPercent;
				} else
				{
					var startDate = this.GetActualWorkStartedDate();

					completion = WeTime.GetGameDate();
					completion.setTime(prod.produce_duration * 1000 + startDate.getTime());
					delta = (WeTime.GetGameTime() - startDate.getTime()) / (completion.getTime() - startDate.getTime());
					percent = Math.floor(delta * 100.0);

					percent = Clamp(percent, 0, 100);
				}
			}
		} else
		{
			if (this.xBoostPercent)
			{
				this.xBoostPercent = this.xBoostPercent < 100 ? (this.xBoostPercent + 1) : 100;
				percent = this.xBoostPercent;
			} else
			{
				this.xBoostPercent = 1;
			}
		}
		return percent;
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method: CompletionPercentage
	 * Gets a the percent complete this building is for it's ProtoProduct
	 * @return float percent complete from 0.0 - 1.0
	 */
	CompletionPercentage : function()
	{
		// ERROR case.  I don't think this should ever be set but who knows :P
		if (!this.HasWorkStarted())
		{
			NgLogD("ERROR CompletionPercentage HasWorkStarted");
			return -1.0;
		}

		var buildStart;
		var completion;
		var now;
		if (!this.IsStateSet(BuildingState.Produce))
		{
			// We are still building the object so this should
			// be a direct calculation based on the time created
			// vs the time completed
			buildStart = this.GetWorkStartedDate().getTime();
			completion = buildStart + this.mProtoEntity.build_time * 1000;
			now = WeTime.GetGameDate().getTime();
			var delta = completion - now;
			var per = delta / (this.mProtoEntity.build_time * 1000);
			if (per <= Number.MIN_VALUE)
			{
				per = 0;
			}
			return 1.0 - per;
		} else
		{
			buildStart = this.GetWorkStartedDate().getTime();

			if (this.IsStateSet(BuildingState.AutoProducing) && this.mEntity.work_type === "Build")
			{
				buildStart += (this.mProtoEntity.build_time * 1000);
			}

			// Check if the build state is also set.  If then we need to add the amount of "build time"
			// to the results.
			if (this.IsStateSet(BuildingState.Build))
			{
				buildStart += this.mProtoEntity.build_time * 1000;
			}
			var prod = weProtoDb.getInstance().getProtoProduceId(this.mEntity.current_product_id);
			if (Exists(prod))
			{
				// Time to complete
				completion = buildStart + prod.produce_duration * 1000;

				// Time to spoil
				var spoil = completion + prod.spoilage_duration * 1000;

				// Now
				now = WeTime.GetGameDate().getTime();

				// Check the state
				if (now >= spoil)
				{
					// The cheese is old and moldy
					return -1.0;
				} else if (now >= completion)
				{
					// It is Ready
					return 1.0;
				} else
				{
					return (now - buildStart) / (completion - buildStart);
				}
			} else
			{
				return 0;
			}
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method:  GetTimeRemaining
	 * accessor to the amount of time left until this "thing" is done
	 * @param {ProtoProduct} prod that the building is currently working on
	 * @return {String} in the following format "X h Y m Z s"
	 */
	GetTimeRemaining : function(prod)
	{
		var time = "";

		if (this.IsStateSet(BuildingState.Constructing))
		{
			time = this.GetConstructionTime();
		} else if (prod)
		{
			var producedProgress = (this.CalculateProducedAmount() / prod.produce_cap);
			var timeLeft = (1 - producedProgress) * prod.produce_duration;

			var delta = timeLeft * 1000;

			time = WeTime.ConvertToNiceTime(delta);

		}

		return time;
	},

	CalculateProducedAmount : function(pr)
	{
		//ST: added possibility to acquire prod from caller
		//    shouldn't this be default behaviour anyway?

		var prod = pr;
		if (!prod)
		{
			prod = this.GetProductFromId(this.mEntity.current_product_id);
		}
		if (!prod)
		{
			NgLogD("No product for id "+this.mEntity.current_product_id+"!");
		}
		if (prod.produce_duration === 0)
		{
			return prod.produce_cap;
		}

		var startTime = this.GetActualWorkStartedDate().getTime();

		var gametime = WeTime.GetGameTime();
		var since = (gametime - startTime) / 1000;

		return Math.min((since / (prod.produce_duration)) * prod.produce_cap, prod.produce_cap);
	},

	//////////////////////////////////////////////////////////////////////////////
	// Method:  Handle touches on the AutoProducing 
	OnAutoProduceTouch : function()
	{
		if (WeGameStateMgr.IsCurrentUser())
		{
			this.OnAutoProduceTouchOwerBuilding();
		} else if (this.HasAvailableJobs())
		{
			this.OnAutoProduceTouchFriendBuilding();
		}
	},

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : GetJobProductByProducingProtoEntityId
	 * @param {Integer} id of the Job Product we want
	 * @return {ProtoProduct} job product we want from our list
	 */
	GetJobProductByProducingProtoEntityId : function(id)
	{
		var jobProducts = this.GetProtoJobProducts();
		var len = jobProducts.length;
		for ( var idx = 0; idx < len; ++idx)
		{
			if (jobProducts[idx].producing_proto_entity_id == id)
			{
				return jobProducts[idx];
			}
		}
		return null;
	},


	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Method : OnSocialJobRequest
	 * @param {Object} args struct that defines which social job has been requested
	 */
	OnSocialJobRequest : function(args)
	{
		if (this.IsStateSet(BuildingState.Collecting) || WeGameStateMgr.GetIsSocialJobPlaced())
		{
			return;
		}

		// Request for your social job here
		var self = this;
		var prod = this.GetJobProductByProducingProtoEntityId(this.mProtoEntity.id);
		var kId = WeGameStateMgr.GetCurrentKingdomId();

		var bubble = self.CreateCollectionBubble(prod.icon_png, "Ordering...", prod);
		bubble.On('close', function()
		{
			self.OnRequest(bubble.xRequest, 'OnProcessJob', 'job');
		});

		WeProtocol.hireFriend(prod, kId, this.mEntity.id, null, function(request)
		{
			bubble.xRequest = request;
			bubble.Trigger('done');
		});

		WeGameStateMgr.SetGlobalGameWidget(null);
		WeGameStateMgr.SetIsSocialJobPlaced(true);
		
		this.mJobPlaced = true;
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.JobOrder);
	},
	
	IsInSelectionHotspot : function(position, diamondSelection, applyScale)
	{
	    if (diamondSelection == false)
	    {   
	        return true;
	    }
	    
	    // var gameLoc = ScreenToWorldPos([position.getX(), position.getY()]);
	    //         
	    //          var gameLoc = ScreenToWorldPos([touch.getPosition().getX(), touch.getPosition().getY()]);
	    //             gameLoc.floor();
            
        var scale = WeRenderDevice.GetScaleRoot().GetScale().getX();

           var sceenCenterX = ((position.getX() )) * (scale) - 
                                  WeCamera.transRoot.getPosition().getX() ;
         var sceenCenterY = ((position.getY())) * (scale)- 
                                  WeCamera.transRoot.getPosition().getY();
           sceenCenterY = -sceenCenterY;
           
         var gameLoc = new Vec2D(sceenCenterX, sceenCenterY);
           
                               
	    var rect;
	   
	    // if (this.mDecal && this.mDecal.GetGL2())
	    //                        {
	    //                            rect = new Core.Rect(this.mDecal.GetX() - this.mDecal.GetWidth() * this.GetStartX() * scale, 
	    //                                       this.mDecal.GetY() - this.mDecal.GetHeight() * this.GetStartY() * scale, 
	    //                                       this.mDecal.GetWidth() * this.GetStartX() * scale,
	    //                                       this.mDecal.GetHeight() * scale);
	    //                        }
	    //                        else
	    //                        {
	    //                            rect = new Core.Rect(this.mSprite.GetX() - this.mSprite.GetWidth() * this.GetStartX() * scale, 
	    //                                       this.mSprite.GetY() - this.mSprite.GetHeight() * this.GetStartY() * scale, 
	    //                                       this.mSprite.GetWidth() * this.GetStartX() * scale,
	    //                                       this.mSprite.GetHeight() * scale);
	    //                        }
	    rect = new Core.Rect(this.mSprite.GetX()-this.mSprite.GetWidth() * 0.5 * scale, 
	                             this.mSprite.GetY()+this.mSprite.GetHeight() * scale, 
	                             this.mSprite.GetWidth()  * scale,
	                             this.mSprite.GetHeight() * scale);
	        NgLogD("** Sprite  " + this.mSprite.GetX() + " " + this.mSprite.GetY());
	        NgLogD("** ANCHOR  " + this.GetStartX() + " " + this.GetStartY());
	        NgLogD("** TOUCH  " + gameLoc);
	        NgLogD("** RECT  " + rect.getOrigin().getX() + " " + rect.getOrigin().getY() + " " + rect.getSize().getWidth() + " " + rect.getSize().getHeight());
	        var diamondHeight = (rect.getSize().getWidth() / cTileSizeWidth) * cTileSizeHeight * 0.5;
	        NgLogD("DIAMOND HEIGHT " + diamondHeight);
            if (gameLoc.y > (rect.getOrigin().getY() + diamondHeight))
            {
                var bottomOfTopDiamond = (rect.getSize().getHeight() - diamondHeight);
                if (gameLoc.y < (rect.getOrigin().getY() + bottomOfTopDiamond))
                {
                    NgLogD("*** BOTTOM");
                    return true;
                }
                else
                {
                    if (diamondSelection)
                    {    // do triangle
                        var trianglePointA = WeMath.AddVec2D(new Vec2D(rect.getOrigin().getX(), rect.getOrigin().getY()),  new Vec2D(0 , bottomOfTopDiamond));
                        var trianglePointB = WeMath.AddVec2D(new Vec2D(rect.getOrigin().getX(), rect.getOrigin().getY()),  new Vec2D(rect.getSize().getWidth() , bottomOfTopDiamond));
                        var trianglePointC = WeMath.AddVec2D(new Vec2D(rect.getOrigin().getX(), rect.getOrigin().getY()),  new Vec2D(rect.getSize().getWidth()*0.5 , bottomOfTopDiamond+diamondHeight));
                        
                        var temp = IsPointInTriangle(gameLoc, trianglePointA, trianglePointB, trianglePointC);
                        NgLogD("*** TRIANGLE TEST1 " + temp);
                        return temp;
                    }
                    else
                    {
                        return true;
                    }
                }
            }
            else
    	    {    // do triangle
    	        
    	        
    	        
    	        var trianglePointA = WeMath.AddVec2D(new Vec2D(rect.getOrigin().getX(), rect.getOrigin().getY()), new Vec2D(0 , diamondHeight));
                var trianglePointB = WeMath.AddVec2D(new Vec2D(rect.getOrigin().getX(), rect.getOrigin().getY()),  new Vec2D(rect.getSize().getWidth() , diamondHeight));
                var trianglePointC = WeMath.AddVec2D(new Vec2D(rect.getOrigin().getX(), rect.getOrigin().getY()),  new Vec2D(rect.getSize().getWidth() *0.5 , 0));
                
                
                var temp = IsPointInTriangle(gameLoc, trianglePointA, trianglePointB, trianglePointC);
                NgLogD("*** TRIANGLE TEST2 " + temp);
                return temp;
    	    }
	
	
	    
	    return false;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeSimulator'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeSimulator'] || {}; $MODULE_REGISTRY['weEngine/WeSimulator'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeSimulator
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:
///
//////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var WeCloudManager = require('weEngine/WeCloudMgr').WeCloudManager;
var WeScaleAnimSyncronizer = require('weEngine/WeAnimController').WeScaleAnimSyncronizer;

var _WeSimulator = Core.MessageListener.subclass(
{
	classname: "WeSimulator",
	
    initialize : function()
    {
        this.mPathRequests = [];
        this.mTimerObjects = [];
        this.mPathRate = 10;
    },
    
    destroy : function()
    { 
    },

    onUpdate : function()
    {
        this.ProcessPathRequests();
        this.ProcessTimerRequests();
        if (!DeviceIsLowMemory())
        {
            WeCloudManager.Update();
        }
        WeScaleAnimSyncronizer.Update();
        WeCamera.OnUpdate();
    },

    Setup : function()
    { 
        Core.UpdateEmitter.addListener(this, this.onUpdate);
    },

    OnRequestPath : function(character, dest, cb)
    {
        this.mPathRequests.push({agent : character, goal : dest, response : cb});
    },

    RemovePathForCharacter : function(character)
    {
        var len = this.mPathRequests.length;
        for(var idx = 0; idx < len; ++idx)
        {
            var request = this.mPathRequests[idx];
            if (request.agent == character)
            {
                this.mPathRequests.splice(idx, 1);
                return;
            }
        }
    },

    ProcessPathRequests : function()
    {
        // slice off the first element in the list
        if(this.mPathRequests.length > 0)
        {
            if(this.mPathRate === 0)
            {
                var request = this.mPathRequests[0];
                var path = WeGameStateMgr.GetGameLotGrid().FindPath(request.agent.mAnchor, request.goal);

                request.response(path);
                this.mPathRequests.shift();
                this.mPathRate = 10;
            }
            else
            {
                --this.mPathRate;
            }
        }
    },

    ProcessTimerRequests : function()
    {
        var now = new Date();
        var deadIdx = [];
        var len = this.mTimerObjects.length;
        for(var idx = 0; idx < len; ++idx)
        {
            if(now >= this.mTimerObjects[idx].time)
            {
                this.mTimerObjects[idx].response();
                deadIdx.push(idx);
            }
        }
        len = deadIdx.length;
        for(var i = 0; i < len; ++i)
        {
            this.mTimerObjects.splice(deadIdx[i], 1);
        }
    },

    OnTimer : function(time, cb)
    {
        var date = new Date();
        date.setTime(date.getTime() + time);

        this.mTimerObjects.push({ time : date, response : cb });
    }
});

exports.WeSimulator = new _WeSimulator();
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeSplashManager'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeSplashManager'] || {}; $MODULE_REGISTRY['weEngine/WeSplashManager'] = exports; //////////////////////////////////////////////////////////////////////////////
/// @file:      WeSplashScreens
/// @author:    jguest@ngmoco.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:
///
//////////////////////////////////////////////////////////////////////////////
var WeSprite2D = require('weEngine/WeSprite2D').WeSprite2D;
var Content = require('weEngine/WeContent').Content;

// Failsafe - in case the bootup json fails.
var gSplashScreens = 
[
	{
        name		: "ngmoco_splash",
		rotation	: 0,
		duration	: 1000,
        asset		: "ngmoco_bump_android_800x480.png"
	},
	{
        name		: "newtoy_splash",
		rotation	: -90,
		duration	: 1000,
        asset		: "newtoy_splash.png"
	}
];


exports.WeSplashManager = Core.MessageListener.subclass(
{
	classname: 'WeSplashManager',
	
	SplashState :
	{
		Null	: -1,
		LoadSplash : 0,
		Showing : 1,
		Done : 2
	},
	
	mSplashScreens: null,
	
    initialize : function()
    {
		this.mCurrentScreenIndex = 0;
		this.mTimer = 0;

		this.mNextState = this.SplashState.Null;
		this.mState = this.SplashState.Null;
		
		this.mNode = new GL2.Node();
		GL2.Root.addChild(this.mNode);
		
		this.mSprite = null;
		this.mSpriteList = [];
    },

	destroy : function()
	{
		// clean up the splash screen
		for (var i=0; i < this.mSpriteList.length; i++)
		{
		    this.mSpriteList[i].destroy();
		    delete this.mSpriteList[i];
		}
		
		// remove the update listener
		Core.UpdateEmitter.removeListener(this);	
		
		// remove the node we used...
		GL2.Root.removeChild(this.mNode);
		this.mNode.destroy();
	},

	startSequence: function(cb)
	{
		this.mSplashScreens=gSplashScreens;
        // Load the game from the flat file
        var fs = Storage.FileSystem;
		var self = this;
		ReadFile(fs, "./Configs/bootup.json", {'blocking': false}, function(err, data)
        {
            if (!err )
            {
                try
                {
                    var obj = JSON.parse(data);

					// Can't use GameSpecificVariables.GameResolution yet
					var target = "splash_screens_" + gRawWidth + "x" + gRawHeight;
					self.mSplashScreens = obj[target];
					if(self.mSplashScreens == undefined)
					{
						self.setState(self.SplashState.Done);
					}
					else
					{
						self.setState(self.SplashState.LoadSplash);
					}
               	}
				catch(e)
				{
					NgLogD("------------------------------------");
					NgLogD("---- Error reading bootup.json -----");
					NgLogD("------------------------------------");
				    WeUiMgr.ShowNetworkErrorPopUp();
				}
			}
			else
			{
				NgLogD("************************************");
				NgLogD("---- Error reading bootup.json: -----");
				NgLogD(err);
				NgLogD("************************************");
			}
		});

		this.mCallback = cb;
		this.mWidth = gRawWidth;
		this.mHeight = gRawHeight;
		this.mLastTickTime = Core.Time.getRealTime();
		Core.UpdateEmitter.addListener(this, this.onUpdate);
	},


	setState : function(state)
	{
		this.mNextState = state;
		this.mState = this.SplashState.Null;
	},
	
    //////////////////////////////////////////////////////////////////////////////
    // method: onUpdate
    onUpdate : function()
    {
		var tick = Core.Time.getRealTime();
		var deltaTime = tick - this.mLastTickTime;
		this.mLastTickTime = tick;
		
		var init = false;
		if (this.mNextState != this.SplashState.Null && this.mNextState != this.mState)
		{
			init = true;
			this.mState = this.mNextState;
			this.mNextState = this.SplashState.Null;
		}

		switch(this.mState)
		{
		case this.SplashState.Null:
			break;
		case this.SplashState.LoadSplash:
		    this.mTimer = 0;
			this.loadScreen(this.mCurrentScreenIndex);
			this.setState(this.SplashState.Showing);
			break;
		case this.SplashState.Showing:		
			// Track how long this splash has been on the screen
			this.mTimer += deltaTime;
			
			// Done displaying? Head to the next splash screen
			if (this.mTimer > this.mSplashScreens[this.mCurrentScreenIndex].duration)
			{
				this.mCurrentScreenIndex++;
				var newState = this.mCurrentScreenIndex < this.mSplashScreens.length ? this.SplashState.LoadSplash : this.SplashState.Done;
				this.setState(newState);
			}
			break;
		case this.SplashState.Done:
			if (init)
			{
				this.mCallback(); //this will actually end up destroying this object, a little strange...
			}
			break;
    	}
	},

	loadScreen : function(index)
	{
		var screenDef = this.mSplashScreens[this.mCurrentScreenIndex];

		var asset = Content.getImagePath(screenDef.asset);
		var rotation = screenDef.rotation;
		this.mSprite = new GL2.Sprite();
		this.mSprite.setDepth(110);
		
		var w = this.mWidth;
		var h = this.mHeight;
		if (rotation == -90)
		{
			w = this.mHeight;
			h = this.mWidth;
		}
		
		this.mSprite.setImage(asset, [w, h], [0.5, 0.5]);
		this.mSprite.setPosition(this.mWidth/2, this.mHeight/2);
		this.mSprite.setRotation(rotation);
		this.mNode.addChild(this.mSprite);
        this.mSpriteList.push(this.mSprite);
        
		//return; // DO AWAY WITH SOUND!
		if(screenDef.sound) {
			NgLogD('=== Playing ' + screenDef.sound);
			try
			{
				WeEffectsMgr.PlaySoundEffect(Content.getAudioPath(screenDef.sound));
			}
			catch(ex)
			{
				NgLogD("EXCEPTION "+ex);
			}
		}	
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeGoals'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeGoals'] || {}; $MODULE_REGISTRY['weEngine/WeGoals'] = exports; /////////////////
// Description
//
/////////////////

/////////////////
// Require block



///////////////////////
// GoalTask - task item
var GoalTask = Core.Class.subclass(
{
	classname: 'GoalTask',
	
	initialize: function (obj, goal_id)
	{
		if (!Exists(obj))
		{
			//NgLogD("Error while creating a task!");
			return;
		}
		
		this.goal_id 			= goal_id;
		this.user_id 			= obj.user_id;
		this.proto_task_id 		= obj.proto_task_id;
		
		if (!Exists(obj.display_count))
			this.current_count 	= obj.current_count;
		else
			this.current_count 	= obj.display_count;
			
		this.time_started 		= obj.time_started;
		this.time_completed 	= obj.time_completed;
		
		this.is_newly_completed = obj.is_newly_completed;
		
		this.proto_task = weProtoDb.getInstance().getProtoGoalTaskById(this.proto_task_id);				
	},

	taskFromProto: function (protoTask, user_id)
	{
		this.user_id 			= user_id;
		this.proto_task_id 		= protoTask.proto_id;
		this.current_count 		= protoTask.count;
		
		var date = new Date();
		this.time_started 		= ConvertToWeDate(date);
		this.time_completed 	= ConvertToWeDate(date);
		
		this.is_newly_completed = false;
		
		this.proto_task = protoTask;
		return this;			
	}
	
});


///////////////////
// Goal - goal item
var Goal = Core.Class.subclass(
{
	classname: 'Goal',
	
	initialize: function (obj)
	{
		//objDump(obj);
		if (!Exists(obj))
		{
			NgLogD("Error while creating a goal!");
			return;
		}
		
		this.id 				= obj.id;
		this.user_id 			= obj.user_id;
		this.proto_goal_id 		= obj.proto_goal_id;
		this.completed_count 	= obj.completed_count;
		this.active 			= obj.active;
		
		this.time_started 		= obj.time_started;
		this.time_completed 	= obj.time_completed;
		
		this.is_newly_unlocked 	= obj.is_newly_unlocked;
		this.is_newly_completed = obj.is_newly_completed;
		this.is_newly_expired 	= obj.is_newly_expired;
		this.expired_boost_cost = obj.expired_boost_cost;
		
		this.proto_goal = weProtoDb.getInstance().getProtoGoalById(this.proto_goal_id);
		
		if (this.is_newly_unlocked)
			this.still_new = true;
		else this.still_new = false;
		
		this.tasks = [];
		var tasks = obj.tasks;
		for (var i in tasks)
		{
			var task_desc = tasks[i].user_goal_task;
			if (!Exists(task_desc)) continue;
			
			var task = new GoalTask(task_desc, this.id);
			this.tasks.push(task);
		}	
		
		if (tasks.length <= 0 && this.completed_count > 0)
		{ // this goal is converted from tutorial objective
			var protoTasks = weProtoDb.getInstance().getProtoGoalTasksByProtoGoalId(this.proto_goal_id);
			for (var i in protoTasks)
			{
				task = new GoalTask();
				task.taskFromProto(protoTasks[i], this.user_id);
				this.tasks.push(task);
			}			
		}
/*		
		NgLogD("@@@@@ Proto tasks for a GOAL with id "+this.proto_goal_id);
		for (var i in this.tasks)
		{
			objDump(this.tasks[i].proto_task);
		}
*/			
	},
	
	getTasks: function ()
	{
		return this.tasks;
	},

	isEventGoal: function ()
	{
		return (this.proto_goal && this.proto_goal.goal_type == "event");
	},

	shouldUseEventGoalView: function ()
	{
		return (this.proto_goal && this.proto_goal.goal_view_type == "event");
	},

	print: function ()
	{
		NgLogD("I'm a goal!");	
	}
	
});

/////////////////
// WeGoals

var WeGoals = Core.Class.subclass(
{
	classname: 'WeGoals',
	
	initialize: function ()
	{
		this.goals = [];
		this.activeGoals = [];
		this.completedGoals = [];
		
		this.popups = [];
		this.animateGoalbook = false;
		this.currentGoal = null;	// current non-event goal for detailed viewing
		this.goalToShowDetail = null;	// goal for detailed list view or the event detail view
		this.showEventGoal = false;
		this.enabled = true;		// global switch
	},

	/* reload the current page of the goal book */
	reloadList: function ()
	{
		var img = WeUiMgr.GetImageFactory().FindImageOfName("goals_active_tab");
		if (Exists(img) && Exists(img.view))
		{
			WeUiMgr.GetImageFactory().setGoalToShowDetailAndGetGoalDetailView("goals_detail");	
			NgLogD("reloadList: Reloading "+img.view);
			var view = img.view;
			var name = WeUiMgr.GetJSONDef()[view].composite[0].name;
			WeUiMgr.GetCompositeFactory().RebuildComposite(name, view);
		}
	},

/* Eye candy */	
	doCompleteTask: function (goal, task)
	{
		// animated toast, sound and animated goalbook
		var goalName = goal.proto_goal.goal_name;
		var taskName = task.proto_task.description + " completed!";
		WeUiMgr.ShowTaskToast(goalName, taskName);
		
		if ( !goal.isEventGoal() )
		{
			this.currentGoal = goal;
		//	inspect("######### doCompleteTask: this.currentGoal", WeGoals.currentGoal.tasks, 4);
			this.reloadList();
		}
		else	// switch the tab to the event goal
		{
			this.showEventGoal = true;
		}
		if (!Exists(WeUiMgr.GetImageFactory().FindImageOfName("goals_active_tab")))
		{
			this.animateGoalbook = true;
		}
        // Bring this effect to the front.
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalTaskComplete);
	},
	
	doUnlockGoal: function (goal)
	{
		// popup, sound and animated goalbook
		var args = goal;
		var itemDef = WeUiMgr.GetItemDef("goal_unlocked");
		gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
		gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);   
		
		if (goal && goal.proto_goal)
		{
			if ( !goal.isEventGoal() )
			{
		    	this.currentGoal = goal;
			}
			else	// switch the tab to the event goal
			{
				this.showEventGoal = true;
			}
			if (!Exists(WeUiMgr.GetImageFactory().FindImageOfName("goals_active_tab")))
			{
				this.animateGoalbook = true;
			}
			WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalUnlocked);
		}
		return gameWidget;
	},
	
	doCompleteGoal: function (goal)
	{	
		// popup and sound
		var args = goal;
		
        if (Exists(gConfigs.EventMainGoalsProtoIds))
        {
            var ids = String(gConfigs.EventMainGoalsProtoIds).split("|");
            if (Exists(ids))
            {
                var lastEventGoal = ids[ids.length-1];
                if (parseInt(lastEventGoal) === parseInt(goal.proto_goal.proto_id) && gConfigs.MobageEventMainGoalsCompletedURL && gConfigs.MobageEventMainGoalsCompletedURL.length > 0)
                {
                    WeGameStateMgr.mInterstitialURL = gConfigs.MobageEventMainGoalsCompletedURL;
                    WeUiMgr.TransitionScreenTo("EventStatus");

                    this.reloadList();
                    // Do away with this background music.
                    Audio.Music.setVolume(0.0);
                    // Bring this effect to the front.
                    WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalComplete);
                    return null;
                }
            }
        }
        if(Exists(goal.proto_goal.completion_webview))
        {
            gameWidget = WeUiMgr.CreateFullScreenWebView(goal.proto_goal.completion_webview);
        }
        else
        {
            var itemDef = WeUiMgr.GetItemDef("goal_complete");
            gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
            gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
        }

		if ( !goal.isEventGoal() )
		{
			this.currentGoal = goal;
			this.reloadList();
		}
		else
		{
			this.showEventGoal = true;
		}
        // Do away with this background music.
        Audio.Music.setVolume(0.0);
        // Bring this effect to the front.
		WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.GoalComplete);

		return gameWidget;
	},
	
/* Add goal to lists */
	setGoal: function (goal)
	{
		var list = this.goals;
		var len  = list.length;
		for (var i=0; i<len; i++)
		{
			if (list[i].id == goal.id)
			{	// reset goal information
				list[i] = goal;
				break;
			}
		} // new goal
		if (i == len)
			list.push(goal);
		
		// Active goals
		list = this.activeGoals;
		len  = list.length;
		for (var i=0; i<len; i++)
		{
			if (list[i].id == goal.id)
			{
				list.splice(i,1);
				i--; len--;
			}
			else if (goal.active && Exists(goal.proto_goal) && Exists(list[i].proto_goal)
					&& (goal.is_newly_unlocked && !list[i].is_newly_unlocked
 					|| (goal.proto_goal.priority > list[i].proto_goal.priority
 						&& (goal.is_newly_unlocked || !list[i].is_newly_unlocked))
 				))
			{
				list.splice(i, 0, goal);
				break;
			}				
		}
		if (i == len && goal.active /*&& Exists(goal.proto_goal)*/ && goal.proto_goal && !(goal.isEventGoal())) 	// active goals do not include event goals
 			list.push(goal);
		// Completed goals
		list = this.completedGoals;
		len = list.length;
		for (var i=0; i<len; i++)
		{
			if (list[i].id == goal.id)
			{
				list.splice(i,1);
				i--; len--;
			}
			else if (!goal.active && Exists(goal.time_completed) && Exists(list[i].time_completed)
					&& ConvertToDate(goal.time_completed) >= ConvertToDate(list[i].time_completed))
			{
				list.splice(i, 0, goal);
				break;				
			}
		}
		if (i == len && !goal.active /*&& Exists(goal.proto_goal)*/)
 			list.push(goal);
	},	

	getGoalByProtoGoalId: function(protoGoalId)
	{
		if (!Exists(this.goals))
		{
			return null;
		}
		for(var i in this.goals)
		{
			if(Exists(this.goals[i]) && Exists(this.goals[i].proto_goal) && this.goals[i].proto_goal.proto_id == protoGoalId) 
			{
				return this.goals[i];
			}
		
		}
		return null;
	},
	
	isEventOn: function()
	{
		return (Exists(gConfigs.CurrentEventName) && String(gConfigs.CurrentEventName).toLowerCase() != "false");		
	},

	/* check if a given goal is one of the current event's goals */
	isGoalCurrentEventGoal: function(goal)
	{
		if (!goal || !goal.proto_goal || !this.isEventOn() || !gConfigs.EventMainGoalsProtoIds)
		{
			return false;
		}
		var ids = String(gConfigs.EventMainGoalsProtoIds).split("|");
		for(var i = 0; i < ids.length; i++)
		{
			if(String(goal.proto_goal.proto_id) == String(ids[i]))
			{
				return true;
			}
		}
		return false;
	},
	
	/* get the current event goal as we progress */
	getCurrentEventGoal: function( )
	{
		if (!this.isEventOn())
		{
			return null;
		}
		if(!Exists(gConfigs.MainEventGoalProtoId))
		{
		    if (!Exists(gConfigs.EventMainGoalsProtoIds))
		    {
		        return null;
		    }
		    
			var ids = String(gConfigs.EventMainGoalsProtoIds).split("|");
		}
		else
			var ids = [gConfigs.MainEventGoalProtoId];

		// the correct logic is to return the earliest active event goal in the ids or (if all completed) return the last event goal
		var goal = null;
		for(var i in ids)
		{
			goal = this.getGoalByProtoGoalId(ids[i]);
			if(goal && goal.active)
			{
				return goal;	// the 1st active event goal
			}
		}
		return goal;	// the last completed event goal or null
	},

	/* get the required level to unlock the 1st event goal */
	getRequiredLevelToUnlockEventGoal: function()
	{
		if (!this.isEventOn() || !Exists(gConfigs.EventMainGoalsProtoIds) || gConfigs.EventMainGoalsProtoIds === "")
		{
			return 0;	// no valid data
		}
		
		var ids = String(gConfigs.EventMainGoalsProtoIds).split("|");
		if (ids.length < 1)
		{
			return 0;	//invalid data
		}
		eventFirstProtoGoal = weProtoDb.getInstance().getProtoGoalById( parseInt( ids[0] ) );

		if ( !eventFirstProtoGoal || !(eventFirstProtoGoal.required_level) )
		{
			return 0;
		}
		
		return eventFirstProtoGoal.required_level;
	},

/* Response handler */	
	handleGoals: function (goals)
	{		
		//NgLogD(">>> GOALS:");
	//	var ids = "";
	//	for (var i in goals)
	//		ids += goals[i].user_goal.proto_goal_id.toString()+" ";
		//NgLogD(ids);		
		//NgLogD("<<<");
		
		if (!Exists(goals) || !this.enabled)
			return;
			
		for (var i in goals)
		{
			var goal_desc = goals[i].user_goal;
			if (!Exists(goal_desc)) continue;
			
			var goal = new Goal(goal_desc);
			this.setGoal (goal);
			
			var tasks = goal.getTasks();
			for (var j in tasks)
			{
				//NgLogD ("Goal "+goal.proto_goal_id+" status: just completed - "+goal.is_newly_completed+", "
				//		+"\njust unlocked - "+goal.is_newly_unlocked+", "
				//		+"task just completed: "+tasks[j].is_newly_completed);
				if (tasks[j].is_newly_completed
					&& !(goal.is_newly_completed || goal.is_newly_unlocked))
				{
					this.doCompleteTask(goal, tasks[j]);
					//NgLogD("Task complete!");
				}
				//HACK for mojo-completed tasks
				else if (Exists (tasks[j].proto_task)
						 && tasks[j].current_count >= tasks[j].proto_task.count
						 && !(goal.is_newly_completed || goal.is_newly_unlocked) && !goal.isEventGoal() )
				{
					this.currentGoal = goal;
					this.reloadList();
					//NgLogD("Task (kind of) complete!");
				}
					
			}
			
			if (goal.is_newly_unlocked)
			{
				//this.doUnlockGoal(goal);
				var obj = {};
				obj.handle = this.doUnlockGoal.bind(this);
				obj.args = goal;
				WeGameStateMgr.SetPopupWidget(obj);
				//NgLogD("Goal unlocked!");
			}
			else if (goal.is_newly_completed)
			{
				//this.doCompleteGoal(goal);
				var obj = {};
				obj.handle = this.doCompleteGoal.bind(this);
				if (obj.handle)
				{
			    	obj.args = goal;
    				WeGameStateMgr.SetPopupWidget(obj);
				}
				//NgLogD("Goal complete!");
			}
			
			if ( !this.currentGoal && goal.active)	// if there is no current goal yet, always set the currentGoal as the 1st handled active goal
			{
				this.currentGoal = goal;
			}
		}
		
		//NgLogD("All goals: "+this.goals.length);
		//NgLogD("Active: "+this.activeGoals.length);
		//NgLogD("Completed: "+this.completedGoals.length);		
	}
	
});

exports.WeGoals = new WeGoals();
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WePests'] = function(){var exports = $MODULE_REGISTRY['weEngine/WePests'] || {}; $MODULE_REGISTRY['weEngine/WePests'] = exports; var Core = require('NGCore/Client/Core').Core;

var g_bWePestsScreenShown=false;

var WePests = Core.Class.subclass(
{
	classname: 'WePests',

	initialize: function()
	{
		this.mResultPest = null;
		this.animationRunning = false;
		this.mBuildings = [];
	},

	setAnimationRunning: function(running)
	{
		this.animationRunning = running;
	},

	isAnimationRunning: function()
	{
		return this.animationRunning;
	},
	
	isParticipating : function()
	{
		if(!Exists(gConfigs.EventParticipationEntityIds))
			return false;

		var ids = gConfigs.EventParticipationEntityIds;
		if(ids == parseInt(ids))
			var participate_ids = [ids];
		else
			var participate_ids = gConfigs.EventParticipationEntityIds.split('|');

		var lot = WeGameStateMgr.mLotInfo.mKingdomObjects;
		for(var i in lot)
		{
			var ent = lot[i];
			for(var j in participate_ids)
			{
				if(ent.mEntity.id === participate_ids[j]) {
					return true;
				}	
			}
		}
		return false;
	},

	hasPests : function()
	{
		if(Exists(this.mHasPests))
			return this.mHasPests;
		return false;
	},

	killAllPests : function()
	{
		if(this.mBuildings && this.mBuildings.length >= 1)
		{
			for (var i=0; i < this.mBuildings.length; i++)
			{
				if (this.mBuildings[i])
				{
			    	this.mBuildings[i].RemoveVillagers();
				}
			}
			this.mHasPests = false;
		}
		this.mBuildings = [];
		for(var i in this.mPests)
		{
			this.mPests[i].destroy();
		}
		this.mPests = [];
	},
	
	removePestWithId : function(pest_id)
	{
		for(var i in this.mPests)
		{
			if (this.mPests[i].mPest.id == pest_id)
			{
				this.mPests[i].destroy();
				this.mPests.splice(i,1);
				break;
			}
		}
	},

	isPestExistWithId : function(pest_id)
	{
		for(var i in this.mPests)
		{
			if (this.mPests[i].mPest.id == pest_id)
			{
				return true;
			}
		}
		return false;	//not found
	},

	updateAllPests : function(pests)
	{
	},

	getPestBubbleHeaderTag : function(pest)
	{
		var	db = weProtoDb.getInstance();
		var proto = db.mapIdToPest[pest.proto_id];
		NgLogD("getPestBubbleHeaderTag: " + pest.proto_id + " " + proto.float_bubble_header_tag);
		return proto.float_bubble_header_tag;
	},

	spawnPest : function(building, pest)
	{
		if (this.isPestExistWithId(pest.id))
		{
			return;	// already existed do not need to add
		}

		if(!Exists(this.mPests))
			this.mPests = [];

		var	db = weProtoDb.getInstance();
		var proto = db.mapIdToPest[pest.proto_id];
	
		// Spawn pest character
		var is_walking = (proto.movement_type == 'walking');
		var character = new WeCharacter(true, is_walking);
		character.mPest = pest;
        if (Exists(proto.proto_visual_id))
        {
        	visual = weProtoDb.getInstance().getProtoVisualById(proto.proto_visual_id);
		    character.Setup(null, visual, null);
        }
        else
        {
            character.Setup(null, null, null);
        }
		if(building) 
		{
			building.AddVillager(character);
			if (this.mBuildings.indexOf(building) == -1)
			{
				this.mBuildings.push(building);
			}
		}
		else
			this.mPests.push(character);

	},
	
	onTouch : function(pest)
	{
		if ( !WeGameStateMgr.IsCurrentUser() || WeUiMgr.mActiveScreen === "RedesignScreen" )
		{	// tap your friend's pest or you are in the design mode
			return;
		}
		var	db = weProtoDb.getInstance();
		var proto = db.mapIdToPest[pest.proto_id];
		var params = {
			"proto_name" : proto.proto_name,
			"large_image_png" : proto.large_image_png,
			"pest_id" : pest.id
			
		};
        WeUiMgr.ShowCaptureSelectionScreen(proto, params);

	},
	
	// Response handlers

	handlePests : function(pests)
	{
		NgLogD("HandlePests: " + JSON.stringify(pests));
		this.killAllPests();

		this.mHasPests = false;
		for(var i in pests)
		{
			var pest = pests[i].user_pest;

			// Find entity which spawned this
			var building = null;
			if(Exists(pest.spawned_by_id))
			{
				var lot = WeGameStateMgr.mLotInfo.mKingdomObjects;
				for(var j in lot)
				{
					var ent = lot[j];
					if(ent.mEntity.id === pest.spawned_by_id)
					{
						building = ent;
						break;
					}
				}
			}		
			if(pest.state === "active" && pest.is_visible && WeGameStateMgr.GetRealmName() == 'main')
			{
				this.mHasPests = true;
				this.spawnPest(building, pest);
			}
			else
			{
				this.removePestWithId(pest.id);	// precausious fix: in case this message includes this pest twice
			}
		}
	//	if(!this.isParticipating()&& !g_bWePestsScreenShown)
	//	{
		//	g_bWePestsScreenShown=true;
		//	WeUiMgr.TransitionScreenTo("EventScreen");
	//	}
	},

	handleCatch : function(pests, pest_id, users)
	{
		// Respawn pests
		this.handlePests(pests);
		
		// Find the right pest
		var pest = null;
		if(Exists(pests))
		{
			for(var i in pests) 
			{
				if(pests[i].user_pest.id === pest_id)
				{
					pest = pests[i].user_pest;
					break;
				}
			}
		}
		
		this.mResultPest = pest;
		this.mSendUsers = users;
		
		//NgLogD("################### handleCatch");
		this.handleCatchSuccessOrFail();
		return true;
	},
	
	handleCatchSuccessOrFail : function()
	{
		var pest = this.mResultPest;
		if ( !pest || this.isAnimationRunning() || WeUiMgr.GetActiveScreen() === "EventStatus")
		{
			return;
		}
		//NgLogD("################### handleCatchSuccessOrFail");

		// Figure out if capture was successful
		if( pest.state === "missed")
		{
			WeUiMgr.ShowCaptureFailScreen(pest);
		}
		else if( pest.state == "captured")
		{
			WeUiMgr.ShowCaptureShareScreen(this.mSendUsers,pest);
		}
		this.mResultPest = null;
	}
});

exports.WePests = new WePests();
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix'] = exports; //
//  Mobclix.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

/**
 * Classes and objects contained by the Mobclix package. Please note the  
 * Mobclix Advertising service is a local offering, subject to change.
 * @name Mobclix
 * @namespace
 * @description
 */

exports.Mobclix = {
	AdView: require('NGCore/Client/Mobclix/AdView').AdView,

	/**
	 * AdView class for the 320x50 unit.
	 * @name Mobclix#AdView_320x50
	 * @see Mobclix.AdView_320x50
	 * @see Mobclix.AdView
	 */
	AdView_320x50: require('NGCore/Client/Mobclix/AdView').AdView_320x50,

	/**
	 * AdView class for the 300x250 unit.
	 * @name Mobclix#AdView_300x250
	 * @see Mobclix.AdView_300x250
	 * @see Mobclix.AdView
	 */
	AdView_300x250: require('NGCore/Client/Mobclix/AdView').AdView_300x250,

	/**
	 * AdView class for the FullScreen unit.
	 * @name Mobclix#AdView_FullScreen
	 * @see Mobclix.AdView_FullScreen
	 * @see Mobclix.FullScreenAdView
	 */
	AdView_FullScreen: require('NGCore/Client/Mobclix/FullScreenAdView').AdView_FullScreen,
	
	/**
	 * Start up the Mobclix SDK, this must be called prior to requesting ads.
	 * @name Mobclix#startWithApplicationId
	 * @function
	 * @param	{String}	applicationId	The Mobclix Application ID for your app
	 */
	startWithApplicationId: function(applicationId) {
		require('NGCore/Client/Mobclix/Core/Controller').Controller.startWithApplicationId(applicationId);
	}
};
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeTransaction'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeTransaction'] || {}; $MODULE_REGISTRY['weEngine/WeTransaction'] = exports; var Bank           = require('NGCore/Client/Social/US/Service/Bank').Bank;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;


var WeTransaction = exports.WeTransaction = Core.MessageListener.singleton (
{
	initialize: function()
	{
	},
	
	resumeTransactions: function()
	{
		Bank.Debit.getPendingTransactions(function(error, transactions) {
			if(error)
			{
				NgLogD("resumeTransactions getPendingTransactions error: "+error.description);
			}
			else
			{
				for(var i in transactions)
				{
					Bank.Debit.getTransaction(transactions[i],
					function(error, transaction)
					{
						if(error)
						{
							NgLogD("resumeTransactions getTransaction error: "+error.description);
						}
						else
						{
							//????????????????????????????????????????????????
							//???????????? some hack, that works??????????????
							//????????????????????????????????????????????????
							transaction = transaction.transaction;
							
							if (!Exists(transaction))
							{
								return;
							}
							
							if(transaction.state != 'OPEN')
							{
								Bank.Debit.openTransaction(transaction.id,
								function(error, transaction)
								{
									if (error)
									{
										NgLogD("resumeTransactions openTransaction error: "+error.description);
									}
									else if(transaction)
									{
										WeTransaction.addMojoWithTransaction(transaction);
									}
								});
							}
							else
							{
								WeTransaction.addMojoWithTransaction(transaction);
							}
						}
					});
				}
			}
		});
	},
	
	buyIAPBuildingItemId: function(itemId, cb){
	    var transaction = {};
		transaction.item = {"id" : itemId};
		transaction.quantity = "1";
		NgLogD("WTFFFFFFF buyIAPBuildingItemId " + itemId);
		objDumpMembers(transaction.item, 4);
		Bank.Debit.createTransaction([transaction], "Buying item...",
		function(error, transaction)
		{
			if(!transaction)
			{
				objDumpMembers(error, 4);
				cb(error);
			}
			else
			{
				objDumpMembers(transaction, 4);
				Bank.Debit.openTransaction(transaction.id,
				function(error, transaction)
				{
					cb(error);
					if(!transaction)
					{
						Bank.Debit.closeTransaction( transaction.id, function(error, transaction){} );
						objDumpMembers(error, 4);
					}
					else
					{
						WeTransaction.completeItemTransaction(transaction);
					}
				});
			}
		});
    },
    
    completeItemTransaction: function(transaction)
	{
		WeProtocol.createTransaction ( WeGameStateMgr.GetCurrentKingdomId(), transaction,
		function(request)
		{
			//objDumpMembers(request, 4);
			NgLogD("createTransaction response request.responseText"+request.responseText);
			
			var obj = JSON.parse(request.responseText);
			if ((typeof obj.tryagain != 'undefined') && obj.tryagain) 
			{
				return;
			}
            WeGameStateMgr.SetGlobalGameWidget(null);
            WeProtocol.getStash();
			if (obj && obj.kingdom && obj.kingdom.kingdom )
			{
				WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.kingdom.kingdom);
				
				var text = WeTransaction.succsessText(transaction);
				WeTransaction.displayWidgetWithText("Thank You!", text);
				
				Bank.Debit.closeTransaction( transaction.id, 
				function(error, transaction)
				{
					if(transaction)
					{
						//objDumpMembers(transaction, 4);
					}
					else
					{
						//objDumpMembers(error, 4);
					}
				});
			}
			else
			{
				NgLogD("MTX ERROR " + request);
				WeTransaction.displayWidgetWithText("Store Error", "Please try again later");
				WeTransaction.cancelTransactionWithId(transaction.id);
			}
		});
	},
    
	buyMojoWithItemId: function(itemId, cb){
		var transaction = {};
		transaction.item = {"id" : itemId};
		transaction.quantity = "1";
//		NgLogD("WTFFFFFFF buyMojoWithItemId");
//		objDumpMembers(transaction.item, 4);
		Bank.Debit.createTransaction([transaction], "Buying mojo...",
		function(error, transaction)
		{
			if(!transaction)
			{
				//objDumpMembers(error, 4);
				cb(error);
			}
			else
			{
				//objDumpMembers(transaction, 4);
				Bank.Debit.openTransaction(transaction.id,
				function(error, transaction)
				{
					cb(error);
					if(!transaction)
					{
						Bank.Debit.closeTransaction( transaction.id, function(error, transaction){} );
						//objDumpMembers(error, 4);
					}
					else
					{
						WeTransaction.addMojoWithTransaction(transaction);
					}
				});
			}
		});
	},
	
	addMojoWithTransaction: function(transaction)
	{
		WeProtocol.createTransaction ( WeGameStateMgr.GetCurrentKingdomId(), transaction,
		function(request)
		{
			//objDumpMembers(request, 4);
			NgLogD("createTransaction response request.responseText"+request.responseText);
			
			var obj = JSON.parse(request.responseText);
			if ((typeof obj.tryagain != 'undefined') && obj.tryagain) 
			{
				return;
			}

			if (obj && obj.kingdom && obj.kingdom.kingdom )
			{
				WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.kingdom.kingdom);
				
				var text = WeTransaction.succsessText(transaction);
				WeTransaction.displayWidgetWithText("Thank You!", text);
				
				Bank.Debit.closeTransaction( transaction.id, 
				function(error, transaction)
				{
					if(transaction)
					{
						//objDumpMembers(transaction, 4);
					}
					else
					{
						//objDumpMembers(error, 4);
					}
				});
			}
			else
			{
				NgLogD("MTX ERROR " + request);
				WeTransaction.displayWidgetWithText("Store Error", "Please try again later");
				WeTransaction.cancelTransactionWithId(transaction.id);
			}
		});
	},
	
	cancelTransactionWithId : function(transactionId)
	{
		Bank.Debit.cancelTransaction( transactionId,
		function(error, transaction)
		{
			if(transaction)
			{
				objDumpMembers(transaction, 4);
			}
			else
			{
				objDumpMembers(error, 4);
			}
			
			Bank.Debit.closeTransaction( transaction.id, 
			function(error, transaction)
			{
				if(transaction)
				{
					//objDumpMembers(transaction, 4);
				}
				else
				{
					//objDumpMembers(error, 4);
				}
			});
		});
    },
	
	displayWidgetWithText: function(title, text) {
		var gameWidget;
		var theArgs = {};
		var itemDef;
		
		theArgs.OnOk = function(objArgs)
		{
			WeGameStateMgr.SetGlobalGameWidget(null);
		};
		
		theArgs.popup_label = title; 
		theArgs.popup_text = text;
		
		itemDef = WeUiMgr.GetItemDef("popup_box");
        itemDef.images[0].tag = "empty_touch";
		
		gameWidget = WeUiMgr.CreateGameWidget(itemDef, theArgs);
		gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
	},

	succsessText: function(transaction)
	{
		var text = "";
		
		var item   = transaction.item;
		var itemId = item.sku;
		var i      = "debit:".length;
		itemId     = itemId.substring(i);
		
		NgLogD("itemId : |"+itemId+"|");
		
	//	var storeList = WeUiMgr.GetCompositeFactory().OnHandleTag_build_mojo_store_list_in_build_menu();
	    var storeList = WeUiMgr.mIAPData;
		for (var k in storeList)
		{
			if(storeList[k].product_identifier == itemId)
			{
			    if (storeList[k].entity > 0)
			    {
			         text = "The " + storeList[k].name + " has been successfully purchased! Tap the item again to place it in your kingdom.";
			    }
			    else
			    {
				    text = "You got " + storeList[k].mojo + " "+GameSpecificVariables.Texts.mojoTextU+"!";
			    }
				return text;
			}
		}
		return text;
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['weEngine/WeConfiguration'] = function(){var exports = $MODULE_REGISTRY['weEngine/WeConfiguration'] || {}; $MODULE_REGISTRY['weEngine/WeConfiguration'] = exports; //
//	class that encapsulates all settings read from configuration.json
//
var Storage = require('NGCore/Client/Storage').Storage;

exports.WeConfiguration = Core.Class.singleton(
		{
			initialize : function() 
		    {
				this.mConfiguration = null;
		    },
		    
		    Load : function(cb)
		    {
		        var fs = Storage.FileSystem;
		    	ReadFile(fs, "./configuration.json", {'blocking': false}, function(err, data)
		    		{
			            if (!err )
		                {
			            	configuration = JSON.parse(data);
			            	WeConfiguration.mConfiguration = configuration; 
			            	
	                    	cb(configuration);
		                }
		                else
		                {
		                	NgLogD("**Error: Failed read the configuration.json file");
		                }
			    	}
		    	);
		    },
		    
		    Get: function(name)
		    {
		    	if (this.mConfiguration)
		    	{
		    		return mConfiguration[name];
		    	}
		    	
		    	
		    	NgLogD("**Error: key does not exist in configuration" + name);
		    	
		    	return null;
		    }
		    
		}
);; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/AdView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/AdView'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/AdView'] = exports; //
//  Mobclix.AdView.Base.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var AdViewInternal = require('NGCore/Client/Mobclix/AdViewInternal').AdViewInternal;

var AdView = exports.AdView = AdViewInternal.subclass(
/** @lends Mobclix.AdView.prototype */
{
	__className: "Mobclix.AdView",
	_subsequent: false,
	
	/**
	 * @class 
	 * This class should not be instantiated directly, instead use one of the following subclasses:
	 * <ul>
	 * <li>{@link Mobclix.AdView_320x50}</li>
	 * <li>{@link Mobclix.AdView_300x250}</li>
	 * </ul>
     *<br>
     * Mobclix.AdViews are resized automatically for screen density. Please
     * do not override the width and height of the AdView.<br>
     * Thus, when positioning a Mobclix.AdView, do not override the AdView's
     * frame's width and height accidentally. Positioning of the AdView
     * should be done in the following manner:<br><br>
     * var adViewFrame = adView.getFrame();<br>
     * adViewFrame[0] = x;<br>
     * adViewFrame[1] = y;<br>
     * adView.setFrame(adViewFrame);<br>
     *
	 * @constructs The default constructor.
	 * @public
	 */
	initialize: function($super) {
		$super();
	},

	/**
	 * Requests a new ad from the server
	 * If ad refreshes are paused, this will also call resumeAdAutoRefresh
	 *
	 * This should only be called when you want to manually refresh an ad.
	 * @public
	 */
	getAd: function() {
		this._subsequent = false;
		AdViewInternal.prototype.getAd.apply(this, arguments);
	},
	
	/**
	 * Pauses the autorefresh of ads
	 *
	 * This should be called in viewWillDisappear
	 * @public
	 */
	pauseAdAutoRefresh: function() {
		this.cancelScheduledGetAd();
	},

	/**
	 *	Resumes the autorefresh of ads
	 *
	 * This should be called in viewDidAppear
	 * @public
	 */
	resumeAdAutoRefresh: function() {
		if(!this._subsequent) {
			this.getAd();
		} else {
			this.scheduleNextGetAd();	
		}
	},

	/**
	 * Cancels any ads currently load and calls pauseAdRefresh
	 *
	 * This should be called in viewDidUnload/dealloc
	 * @public
	 */
	cancelAd: function() {
		this._cancelAd();
	}
});

/**
 * @class
 * Use this class to create an ad view for the 320x50 unit.
 * @name Mobclix.AdView_320x50
 * @extends Mobclix.AdView
 * @public
 */
exports.AdView_320x50 = AdView.subclass({
	_size: {
		width: 320,
		height: 50
	}
});

/**
 * @class
 * Use this class to create an ad view for the 300x250 unit.
 * @name Mobclix.AdView_300x250
 * @extends Mobclix.AdView
 * @public
 */
exports.AdView_300x250 = AdView.subclass({
	_size: {
		width: 300,
		height: 250
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/FullScreenAdView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/FullScreenAdView'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/FullScreenAdView'] = exports; //
//  Mobclix.FullScreenAdView.Base.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var AdViewInternal = require('NGCore/Client/Mobclix/AdViewInternal').AdViewInternal;

var FullScreenAdView = exports.FullScreenAdView = AdViewInternal.subclass(
/** @lends Mobclix.FullScreenAdView.prototype */
{
	__className: "Mobclix.FullScreenAdView",
	_subsequent: false,
	_canRequestNextAd: true,
    
	/**
	 * @class 
	 * This class should not be instantiated directly, instead use one of the following subclasses:
	 * <ul>
	 * <li>{@link Mobclix.AdView_FullScreen}</li>
	 * </ul>
     * <br>
     * This view does not need to be added to the view hierarchy. The
     * requested fullscreen ad will automatically be attached.
     * The easiest implementation of the FullScreenAdView can be done in
     * the following manner:<br><br>
     * var fullScreenAdView = new Mobclix.AdView_FullScreen();<br>
     * fullScreenAdView.requestAndDisplayAd();<br>
     *
	 * @constructs The default constructor.
	 * @public
	 */
	initialize: function($super) {
		$super();
	},

	/**
	 * Requests a new ad from the server. This ad will preload, but will not
     * display until displayAd is called.
     *
	 * @public
	 */
	requestAd: function() {
        if (!this._canRequestNextAd)
            return;
        this._canRequestNextAd = false;
		this._subsequent = false;
        this.prefetchAd();
	},


    /**
	 * Displays a requested ad. If no ad has been previously requested, this
     * method will not do anything.
     *
	 * @public
	 */
	displayAd: function() {
		AdViewInternal.prototype.displayAd.apply(this, arguments);
	},
    
    /**
	 * Requests and displays a requested ad as soon as it is finished
     * loading.
     *
	 * @public
	 */
	requestAndDisplayAd: function() {
        if (!this._canRequestNextAd)
            return;
        this._canRequestNextAd = false;
        this.getAd();
	},
    
    /**
	 * Returns if the FullScreenAdView has an ad prepared for display.
     *
     * @return	{bool}	If true, the FullScreenAdView is ready to display an
     * ad via the displayAd method.
	 * @public
	 */
    hasAd: function() {
        return this._hasPrefetchedAd;
    },

	/**
	 * Cancels any ads currently load and calls pauseAdRefresh
	 *
	 * This should be called in viewDidUnload/dealloc
	 * @public
	 */
	cancelAd: function() {
		this._cancelAd();
	},
});

/**
 * @class
 * Use this class to create a full screen adview.
 * @name Mobclix.AdView_FullScreen
 * @extends Mobclix.FullScreenAdView
 * @public
 */
exports.AdView_FullScreen = FullScreenAdView.subclass({
	_size: {
		width: 999,
		height: 999
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/Controller'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Controller'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Controller'] = exports; //
//  Mobclix.Core.Controller.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Device = require('NGCore/Client/Device').Device;
var Storage = require('NGCore/Client/Storage').Storage;
var Session = require('NGCore/Client/Mobclix/Core/Session').Session;
var SessionTracking = require('NGCore/Client/Mobclix/Core/SessionTracking').SessionTracking;
var Config = require('NGCore/Client/Mobclix/Core/Config').Config;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var ProxyListener = Core.MessageListener.subclass({
	onUpdate: function() {}
});

exports.Controller = Core.Class.singleton({
	applicationId: null,
    userAgent: null,
	networkEmitter: null,
	proxyListener: null,
	_isAppActive: true,
	sessionTracking: null,
	inModal: false,
	emitter: null,
	_hasBeenStarted: false,
	
	initialize: function() {
		this.proxyListener = new ProxyListener();
		var self = this;
		
		this.emitter = new Core.MessageEmitter();
		
		Device.NetworkEmitter.addListener(this.proxyListener, function() { });
		Device.LifecycleEmitter.addListener(this.proxyListener, function(event) {
			if(event == Device.LifecycleEmitter.Event.Suspend) {
				self.willGoInactive();
			} else if(event == Device.LifecycleEmitter.Event.Resume) {
				self.didBecomeActive();
			} else if(event == Device.LifecycleEmitter.Event.Terminate) {
				self.willTerminate();
			}
		});
	},
	
	hasBeenStarted: function() {
		return this._hasBeenStarted;
	},
	
	startWithApplicationId: function(id) {
		$mc.log("Starting with app id: " + id);

		var oldAppId = this.applicationId;
		var self = this;
		this.applicationId = id;

		if(!oldAppId || oldAppId != id) {
			Session.renewIdentifier();
			
			if(this.sessionTracking) this.sessionTracking.destroy();
			this.sessionTracking = new SessionTracking(this);
		}
		
		this._hasBeenStarted = true;
		
		Config.updateConfiguration(this);
		setTimeout(function() {
			self.emitter.emit(self);
		}, 1);
	},
	
	addListener: function(listener, func) {
		this.emitter.addListener(listener, func);
	},
	
	removeListener: function(listener) {
		this.emitter.removeListener(listener);
	},

	willTerminate: function() {
		this._isAppActive = false;
		if(this.sessionTracking) this.sessionTracking.willTerminate();
		$mc.log("App Lifecycle: willTerminate");
	},
	
	didBecomeActive: function() {
		this._isAppActive = true;
		if(this.sessionTracking) this.sessionTracking.didBecomeActive();
		$mc.log("App Lifecycle: didBecomeActive");
	},
	
	willGoInactive: function() {
		this._isAppActive = false;
		if(this.sessionTracking) this.sessionTracking.willGoInactive();
		$mc.log("App Lifecycle: willGoInactive");
	},
	
	isApplicationActive: function() {
		return this._isAppActive;
	},
	
	isAndroid: function() {
		return Core.Capabilities.getPlatformOS().match(/android/i);
	},
	
	isIOS: function() {
		return Core.Capabilities.getPlatformOS().match(/iphone|ipad|ios|ipod/i);
	},
	
	isIPad: function() {
		return Core.Capabilities.getPlatformOS().match(/ipad/i);
	},
		
	getNetworkState: function() {
		return "wifi";
		
		// This is broken
		switch (Device.NetworkEmitter.getLastStatus()) {
			case Device.NetworkEmitter.Status.Cellular:
				return "wifi";
			case Device.NetworkEmitter.Status.Wifi:
				return "carrier";
			default:
				return "none";
		}
	},
	
	getLocation: function() {
		if(Device.LocationEmitter.getListenerCount() > 0) {
			var lastLocation = Device.LocationEmitter.getLastLocation();
			if(lastLocation && lastLocation.position) {
				return lastLocation.position.getX() + "," + lastLocation.position.getY();
			}
		}

		return null;
	},
	
	getApplicationId: function() {
		return this.applicationId;
	},
    
    setUserAgent: function(ua, fromCache) {
        if (this.userAgent == null && fromCache) {
            $mc.log("Loading user agent from cache: ", ua);
            this.userAgent = ua;
            return;
        } else if (this.userAgent == null ||
                ua != this.userAgent) {
            $mc.log("Saving new user agent to cache: ", ua);
            this.userAgent = ua;
            var kv = new Storage.KeyValue();
            kv.registerForKey("mobclix");
            kv.setItem("userAgent", ua, function(param1, value, key) {
                kv.destroy();
            });
            return;
        }
        $mc.log("Ignoring matching user agent: ", ua);
    },
    
    getUserAgent: function(ua) {
        return this.userAgent;
    },
	
	destroy: function() {
		this.applicationId = null;
		if(this.sessionTracking) this.sessionTracking.destroy();
		this.sessionTracking = null;
		Device.NetworkEmitter.removeListener(this.proxyListener);
		this.emitter = null;
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/AdViewInternal'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/AdViewInternal'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/AdViewInternal'] = exports; //
//  Mobclix.AdViewInternal.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var UI = require('NGCore/Client/UI').UI;
var MMView = require('NGCore/Client/Mobclix/Core/MMView').MMView;

var Config = require('NGCore/Client/Mobclix/Core/Config').Config;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;
var Controller = require('NGCore/Client/Mobclix/Core/Controller').Controller;
var HTTPRequest = require('NGCore/Client/Mobclix/Core/HTTPRequest').HTTPRequest;
var MMArray = require('NGCore/Client/Mobclix/Core/MMArray').MMArray;

var Browser = require('NGCore/Client/Mobclix/Browser').Browser;

var Creative = require('NGCore/Client/Mobclix/Creative').Creative;

var WebCreativeView = require('NGCore/Client/Mobclix/CreativeView/Web').Web;
var FullScreenCreativeView = require('NGCore/Client/Mobclix/CreativeView/FullScreen').FullScreen;

var Social = require('NGCore/Client/Social').Social;

var FullScreenAdSize = exports.FullScreenAdSize = {
	width: 999,
	height: 999
};

var AdViewInternal = exports.AdViewInternal = MMView.subclass(
/** @lends Mobclix.AdViewInternal.prototype */
{
	__className: "Mobclix.AdViewInternal",

	/**
	 * Enumeration for error codes.
	 * @name Mobclix.AdView.Error
	 * @namespace
	 * @public
	 */
	Error: {
		/** 
		 * Unknown error occured
		 * @name Mobclix.AdView.Error#Unknown
		 */
		Unknown: 0,

		/** 
		 * There was an error on the Mobclix Server
		 * @name Mobclix.AdView.Error#ServerError
		 */
		ServerError: -500,
		
		/** 
		 * Ads are currently unavailable
		 * @name Mobclix.AdView.Error#ServerError
		 */
		Unavailable: -503,

		/** 
		 * Connection error occured
		 * @name Mobclix.AdView.Error#Connection
		 */
		Connection: -7777777,

		/** 
		 * An ad was requested without calling {@link Mobclix#startWithApplicationId}
		 * @name Mobclix.AdView.Error#NotStarted
		 */
		NotStarted: -8888888,
		
		/** 
		 * The requested unit side has been remotely disabled
		 * @name Mobclix.AdView.Error#Disabled
		 */
		Disabled: -9999999
	},
	
	_listener: null,
	_ordinalNumber: 0,
	_inTestMode: false,
	_size: {
		width: 320,
		height: 50
	},
	
	_shouldGetAdAfterConfig: false,
	_autoDisplayNextAdRequest: false,
	_hasPrefetchedAd: false,
	_wasPaused: false,
	_pausedSelf: false,
	_isLoading: false,
	_refreshTimeout: null,
	_shouldAutoplay: false,
	_lastAutoplayTime: 0,
	_hasFinishedStarting: false,
	_shouldGetAdAfterFinishedStarting: false,
	_originOfRegistration: null,
    _distributionName: null,
    
	/**
	 * @class AdViewInternal 
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @private
	 */
	initialize: function($super) {
		$super();
		var self = this;
        
        this._setAdSpace();
        
		this.setFrame([0, 0, $mc.dip(this._size.width), $mc.dip(this._size.height)]);
		this._listener = new Core.MessageListener();
		Config.addListener(this._listener, function() { self._configUpdated(); });
		Controller.addListener(this._listener, function() { self._finishStarting(); });
		var creatives = new MMArray();
		this.currentCreatives = creatives;
		creatives.release();
		
		if(Controller.hasBeenStarted()) {
			this._finishStarting();
		}
	},
	
    _setAdSpace: function() {
        var self = this;
        try {
            var session = Social.US.Session.getCurrentSession();
            var user = session.user();
            user.getOriginOfRegistration(function(error, originOfRegistration) {
                if(!originOfRegistration) {
                    var errorCode = error.errorCode;
                    var errorDesc = error.description;
                } else {
                    self._originOfRegistration = originOfRegistration.replace(/[aeiou_-]/g,"");
                }
            });
            
        } catch(e) {
            $mc.log("Error getting the OoR.", e);
        }
        try {
            var dist = Core.Capabilities.getDistributionName();
            this._distributionName = dist.replace(/[aeiou_-]/g,"");
        } catch(e) {
            $mc.log("Error getting the Distribution Name.", e);
        }
    },
    
	/**
	 * Called after {@link Mobclix.Config} is finished updating.
	 * @private
	 */
	_configUpdated: function() {
		$mc.log("config finished updating");
		if(this._shouldGetAdAfterConfig) {
			this._shouldGetAdAfterConfig = false;
			this.getAd();
		}
	},
	
	_finishStarting: function() {
		if(this._hasFinishedStarting) return;
		this._hasFinishedStarting = true;
	
		if(this._shouldGetAdAfterFinishedStarting) {
			this._shouldGetAdAfterFinishedStarting = false;
			this.getAd();
		}
	},
	
	_handleMobclixNotStarting: function() {
		if(this._hasFinishedStarting) return;
		this._shouldGetAdAfterFinishedStarting = false;

		this.failWithError(this.Error.NotStarted, "No application id found.  Please be sure to start Mobclix prior to requesting ads.");
	},
	
	// ====
	// Autorefreshing methods
	// ====
	
	/**
	 * Clears the refresh timeout
	 * @private
	 */
	clearRefreshTimeout: function() {
		if(this._refreshTimeout) {
			clearTimeout(this._refreshTimeout);
			this._refreshTimeout = null;
		}
	},
	
	/**
	 * Schedule the next get ad
	 * @private
	 */
	scheduleNextGetAd: function() {
		this._wasPaused = false;
		this._pausedSelf = false;
		var refreshTime = this._getRefreshTime();
		$mc.log("scheduleNextGetAd:", refreshTime);

		if(refreshTime > 0) {
			var self = this;
			this.clearRefreshTimeout();
			this._refreshTimeout = setTimeout(function() { $mc.log("Requesting ad!"); self.getAd(); }, refreshTime);
		}
	},
	
	/**
	 * Schedule the next get ad from an internal error
	 * This behaves identical to {@link Mobclix.AdViewInternal#scheduleNextGetAd} except it doesn't change internal state variables
	 * @private
	 */
	scheduleNextGetAdFromError: function() {
		$mc.log("scheduleNextGetAdFromError");
		var refreshTime = this._getRefreshTime();
		if(refreshTime > 0) {
			var self = this;
			this.clearRefreshTimeout();
			this._refreshTimeout = setTimeout(function() { self.getAd(); }, refreshTime);
		}
	},
	
	/**
	 * Cancel any scheduled get ads
	 * @private
	 */
	cancelScheduledGetAd: function() {
		$mc.log("cancelScheduledGetAd");
		this._wasPaused = true;
		this._pausedSelf = false;
		clearTimeout(this._refreshTimeout);
	},

	/**
	 * Returns the refresh time in milliseconds
	 * @private
	 */
	_getRefreshTime: function() {
		var refreshTime = 0;
		
		try {
			refreshTime = parseInt(this.refreshTime, 10);
		} catch(e) {
			refreshTime = 0;
		}

		if(refreshTime == 0 || isNaN(refreshTime)) {
			return Config.refreshInteveralForAdUnit(this._size) * 1000;
		} else {
			return refreshTime * 1000;
		}
	},
	
	/**
	 * Determines whether next ad should be scheduled
	 * @private
	 */
	shouldScheduleGetAd: function() {
        if (this._size.width == 999)
            return false;
		return !this._wasPaused || this._pausedSelf;
	},

	// ====
	// Request Lifecycle
	// ====

	/**
	 * Requests a new ad from the server
	 * If ad refreshes are paused, this will also call resumeAdAutoRefresh
	 *
	 * This should only be called when you want to manually refresh an ad.
	 * @private
	 */
	getAd: function() {
		this._getAd(null, true);
	},
	
	/**
	 * Request an ad to be displayed in the future
	 * A subsequent call to {@link Mobclix.AdViewInternal#displayAd} must be called when the ad is
	 * displayed to fire off any events that need to be triggered when displayed.
	 * @private
	 */
	prefetchAd: function() {
		if(this._hasPrefetchedAd) return;
		
		this.cancelScheduledGetAd();
		this._wasPaused = false;
		this._getAd(null, false);
	},
	
	/**
	 * Internal called from other methods such as {@link #getAd} and {@link #prefetchAd}
	 * 
	 * Requests an ad from the servers (if possible)
	 * @param	{object}	params	Additional parameters to pass back to the server, this must be a single dimensional key-value object
	 * @param 	{bool}		shouldAutoDisplay	Flag to indicate whether or not this request should display itself when it's finished
	 * @private
	 */
	_getAd: function(params, shouldAutoDisplay) {
		var self = this;
		
		// If we have an ad prefetched, we should display it, not get another ad
		if(this.hasPrefetchedAd) {
			this.displayAd();
			return;
		}

		// Set autodisplay toggle
		this._autoDisplayNextAdRequest = shouldAutoDisplay;
		
		// We can't request ads until Mobclix has finished starting
		if(!this._hasFinishedStarting) {
			$mc.log("Mobclix hasn't been started yet..");
			this._shouldGetAdAfterFinishedStarting = true;
			setTimeout(function() {
				self._handleMobclixNotStarting();
			}, 10000);
			return;
		}

		// If config is updating, we wait
		if(Config.isUpdating()) {
			$mc.log("RC Updating blocked adview..");
			this._shouldGetAdAfterConfig = true;
			return;
		}
		
		// If we're already waiting, we wait
		if(this._isLoading) {
			this.scheduleNextGetAdFromError();
			return;
		}
		
		// If we've already taken over the screen, we wait
		if(Controller.inModal) {
			this.scheduleNextGetAdFromError();
			return;
		}

		// If we're disabled, we don't load
		if(!Config.isAdUnitEnabled(this._size)) {
			$mc.log("Ad unit is not enabled..");
			this.failWithError(this.Error.Disabled, "This ad unit size has been remotely disabled in the developer dashboard.");
			return;
		}
		
		// Build parameters
		params = params || {};
		params = typeof params == 'object' ? params : {};

		// Determine autoplay
		this._shouldAutoplay = Config.isAutoPlayEnabled(this._size);
		if(typeof this.canAutoplay == 'function') {
			this._shouldAutoplay = this.canAutoplay(this) ? true : false;
		}
		
		// Determine RMRUI
		var richMediaRequiresUserInteraction = Config.richMediaRequiresUserInteraction(this._size);
		if(typeof this.richMediaRequiresUserInteraction == 'function') {
			richMediaRequiresUserInteraction = this.richMediaRequiresUserInteraction(this) ? true : false;
		}

		// Set ordinal
		var ordinalNumber;
		if(this._size == FullScreenAdSize) {
			ordinalNumber = __fullscreenOrdinalNumber++;
		} else {
			ordinalNumber = this._ordinalNumber++;
		}
		
		// Cancel any scheduled ads
		var wasWasPaused = this._wasPaused;
		this.cancelScheduledGetAd();

		if(!wasWasPaused && this._getRefreshTime() > 0) {
			// cancelScheduledGetAd sets wasPaused to TRUE and pausedSelf to FALSE
			this._pausedSelf = true;
		}

		// ---------------------------
		// Ad Feed ID Parameters
		// ---------------------------

		// Application ID
		params.i = Controller.getApplicationId();

		// Platform Name
		params.p = Controller.isAndroid() ? 'android' : (Controller.isIPad() ? 'ipad' : 'iphone');

		// Unit Size
		if(this._size.width == 999) {
			params.s = "fullscreen";
		} else {
			params.s = this._size.width + "x" + this._size.height;
		}

		// ---------------------------
		// Ad View State ID Parameters
		// ---------------------------

		// Should Autoplay
		params.ap = this._shouldAutoplay;

		// Rich Media requires user interaction
		params.rm = richMediaRequiresUserInteraction;

		// Ordinal Number
		params.o = ordinalNumber;

		// Ad Space
		var adSpace = "";
        if (this._originOfRegistration != null) {
            adSpace += this._originOfRegistration;
        }
        
        if (this._distributionName != null) {
            adSpace += this._distributionName;
        }
        
        this.adSpaceName = adSpace;
		if(adSpace && adSpace.length > 0) {
			if(adSpace.length > 32) {
				adSpace = adSpace.substr(0,32);
			}

			params.as = adSpace;
		}

		// Test Mode (Only if enabled)
		if(this._inTestMode) params.t = 1;

		// ---------------------------
		// Hardware Environment
		// ---------------------------

		// UDID
		params.u = Core.Capabilities.getUniqueId();

		// Connection Type
		params.ct = Controller.getNetworkState();

		// Device Model
		params.dm = Core.Capabilities.getDeviceName();

		// Hardware Device Model
		params.hwdm = Core.Capabilities.getPlatformHW();

        // User Agent
        if (Controller.getUserAgent() != null)
            params.ua = Controller.getUserAgent();

		// ---------------------------
		// Software Environment
		// ---------------------------	

		// Application Version
		// params.av = "1.0"; // TODO

		// SDK Version
		params.v = Config.getVersion();

		// OS Version
		params.sv = Core.Capabilities.getPlatformOSVersion();
		
		// Runtime
		params.rt = 'mobage';
		params.rtv = Core.Capabilities.getSDKVersion();
		

		// ---------------------------
		// Location
		// ---------------------------

		var location = null;
		if((location = Controller.getLocation())) {
			queryString.ll = location;
			location = null;
		}

		// ---------------------------
		// Additional Parameters
		// These would be passed in from a previous request that failed
		// ---------------------------

		if(typeof this.requestKeywords == 'function') {
			params.k = this.requestKeywords(this);
			if(!params.k) delete(params.k);
			else params.k = params.k.toString();
		}
		
		if(typeof this.requestQuery == 'function') {
			params.q = this.requestQuery(this);
			if(!params.q) delete(params.q);
			else params.q = params.q.toString();
		}
		
		// Set the request ad url if the delegate responds
		if(typeof this.requestAdUrl == 'function') {
			params.adurl = this.requestAdUrl(this);
			if(!params.adurl) delete(params.adurl);
			else params.adurl = params.adurl.toString();
		}

		var request = new HTTPRequest;
		request.start({
			url: Config.getAdvertisingURL(),
			data: params,
			type: "get",
            userAgent: Controller.getUserAgent(),
			success: function(request, response) {
				if(request.getStatusCode() == 200) {
					self.adRequestFinished(request, response);
				} else {
					self.requestFailed(request, null);
				}
			},
			error: function(request, error) {
				self.requestFailed(request, error);
			}
		});
		request.release();
	},
	
	/**
	 * Handles an ad request that suceeded with a status code of 200
	 * Attempts to parse the response for creatives and load an ad,
	 * If failed to load, it will {@link Mobclix.AdViewInternal#requestFailed}
	 * 
	 * @see Mobclix.AdViewInternal#requestFailed
	 * @see Mobclix.AdViewInternal#loadAd
	 * @private
	 */
	adRequestFinished: function(request, response) {
		this._isLoading = false;
		
		$mc.log("Request finished, response: " + request.getResponseText());

		var newCreatives = new MMArray();
		try {
			for(var index in response.creatives) {
				try {
					var creative = Creative.Create({creative: response.creatives[index]});
					newCreatives.push(creative);
					creative.release();
				} catch(e2) {
					$mc.log("Error while building creative model: ", e);
				}
			}
		} catch(e) {
			$mc.log("Error while building creative models: ", e);
		}
		
		$mc.log("setting currentcreatives");
		
		this.currentCreatives = newCreatives;

		$mc.log("release newcreatives");
		newCreatives.release();

		if(!this.currentCreatives || this.currentCreatives.length < 1) {
			this.requestFailed(request, "Failed to parse creative");
		} else {
			this.loadCreative(this.currentCreatives.get(0));
		}
	},
	
	/**
	 * Handles a failed ad request
	 * @see Mobclix.AdViewInternal#failWithError
	 * @private
	 */
	requestFailed: function(request, error) {
		$mc.log("Request failed -- error: ", error, "status code: ", request.request.status);

		if(request.request.status == 500) {
			this.failWithError(this.Error.Server, error);
		} else if(request.request.status == 0) {
			this.failWithError(this.Error.Connection, error);
		} else {
			this.failWithError(this.Error.Unknown, error);
		}
        
        if (this._size.width == 999) {
            this._canRequestNextAd = true;
        }
	},
	
	// ====
	// Creative Display Lifecycle
	// ====
	
	/**
	 * Loads the provided creative into the related CreativeView Type
	 * @param	{Object}	creative	Creative model to be loaded, must be an instance of {@link Mobclix.Creative.Base}
	 * @private
	 */
	loadCreative: function(creative) {
		$mc.log("Loading creative: " + creative);
		this.currentCreative = creative;
		
        if(this._size.width == 999) {
            $mc.log("Creating FullScreen Creative View");
            var creativeView = new FullScreenCreativeView();
            this.nextCreativeView = creativeView;
            creativeView.release();
            
            this.nextCreativeView.adView = this;
            this.nextCreativeView.loadWithCreative(this.currentCreative);
        } else {
            var creativeView = new WebCreativeView();
            this.nextCreativeView = creativeView;
            creativeView.release();
            
            var x = 0;
            
            var frame = this.getBounds();
            frame[0] = frame[2] * -2;
            frame[1] = frame[3] * -2;
            
            this.nextCreativeView.setFrame(frame);
            this.nextCreativeView.adView = this;
            this.addChild(this.nextCreativeView);
            this.nextCreativeView.loadWithCreative(this.currentCreative);
        }
	},

	/**
	 * Callback for instances of {@link Mobclix.Creative.Base} to indicate they're finished loading and ready to be displayed
	 * 
	 * @param	{object}	creativeView	Instance of {@link Mobclix.CreativeView.Base}
	 * @param	{object}	creative		Instance of {@link Mobclix.Creative.Base}
	 * @return	{bool}	If false, the creativeView/creative is no longer the current creative being loaded and should immediately halt it's lifecycle
	 * @private
	 */
	creativeViewFinishedLoading: function(creativeView, creative) {
		if(creative != this.currentCreative) {
			$mc.log("Creative load finished, but wasn't current creative: ", creative);
			creativeView.removeFromParent();
			return false;
		}

		// Notify the delegate
		this._wasPaused = false;
		if(typeof this.onFinishLoad == 'function') {
			this.onFinishLoad(this);
		}

		// Auto display ad
		if(this._autoDisplayNextAdRequest)
            this.displayAd();
        else
			this._hasPrefetchedAd = true;
		
		// Schedule the next ad
		if(this.shouldScheduleGetAd()) this.scheduleNextGetAd();

		return true;
	},

	/**
	 * Callback for instances of {@link Mobclix.Creative.Base} to indicate they've failed to load
	 * 
	 * @param	{object}	creativeView	Instance of {@link Mobclix.CreativeView.Base}
	 * @param	{object}	creative		Instance of {@link Mobclix.Creative.Base}
	 * @param	{object}	error	Underlying error
	 * @return	{boolean}	Flag indicating whether or not the provided creativeView/creative is still the current creative being loaded
	 * @private
	 */
	creativeViewFailedToLoad: function(creativeView, creative, error) {
        $mc.log("creativeViewFailedToLoad: ", creativeView);
        $mc.log("creativeViewFailedToLoad: ", creative);
        $mc.log("creativeViewFailedToLoad: ", error);
		var returnValue = true;
		
		if(creative != this.currentCreative) {
			$mc.log("Creative load failed, but wasn't current creative: ", creative);
			returnValue = false;
		} else {
			this.nextCreativeView = null;

			var creativeIndex = this.currentCreatives.indexOf(creative);

			if(creativeIndex + 1 < this.currentCreatives.length) {
				this.loadCreative(this.currentCreatives.get(creativeIndex + 1));
				returnValue = false;
			} else {
				if(creative.requestParameters && creative.requestParameters.length > 0) {
					this._getAd(creative.requestParameters, this._autoDisplayNextAdRequest);
					returnValue = false;
				} else {
					this.failWithError(this.Error.Unknown, error);
					returnValue = true;
				}
			}
		}

		creativeView.removeFromParent(); // We remove at the end, because it deallocs on remove
		return returnValue;
	},
	
	/**
	 * Displays the next creative view and triggers any actions/events asssociated with it
	 * @private
	 */
	displayAd: function() {
        if (this.nextCreativeView == null)
            return;
    
		var creativeView = this.nextCreativeView;
		var self = this;
        
        // Remove any old creative views, but leave current creative views
        $mc.each(this.getChildren(), function(view) {
            if(view == creativeView) return;
            $mc.log("Removing: " + view);
            self.queueReusableCreativeView(view);
            view.removeFromParent();
        });
    
        // Add new creativeview if it's not already in the stack.
        // This shouldn't ever happen, but we better be sure.
        if(!creativeView.getParent() || creativeView.getParent() != this) {
            this.addChild(creativeView);
        }
            

        if (this._size.width == 999) {
            creativeView.display();
            
            if(typeof this.onPresentAd == 'function') {
                this.onPresentAd(this);
            }
                
            // Update current reference
            this.currentCreativeView = creativeView;
        } else {
            
            // Place a temporary view over the view, or else the first ad on
            // Android won't load.
            if (Controller.isAndroid()) {
                var tempView = new MMView();
                this.addChild(tempView);
                tempView.removeFromParent();
            }

            // Bring view on screen
            creativeView.setFrame(this.getBounds());

            // Update current reference
            this.currentCreativeView = creativeView;

            // Autoplay if asked to
            var action = this.currentCreative.getAction();
            if(action && action.shouldAutoplay() && this._shouldAutoplay) {
                this._lastAutoplayTime = new Date();
                this.openActionURL(self.currentCreative, action.getUrl());
            }
        
        }

        // Notify tracking URLs
        try { this.currentCreative.getEvents().triggerEvent("show"); } catch(e) { }
        this.currentCreativeView.creativeHasBeenDisplayed();
            
		this.nextCreativeView = null;
		this._hasPrefetchedAd = false;
		this._shouldAutoplay = false;
	},
	
	/**
	 * Attempts to queue a resueable creative view
	 * @param	{object}	creativeView	Instance of {@link Mobclix.CreativeView.Base}
	 * @private
	 */
	queueReusableCreativeView: function(creativeView) {
		// TODO
	},
	
	/**
	 * Handles errors when loading an ad and notifies any listeners
	 * @private
	 */
	failWithError: function(code, error) {
		this._isLoading = false;

		if(typeof this.onFailedToLoad == 'function') {
			this.onFailedToLoad(this, code, error);
		}

		if(this.shouldScheduleGetAd()) this.scheduleNextGetAd();
	},
	
	// ====
	// Actions
	// ====

	/**
	 * Determines whether or not a creative can touch through
	 * 
	 * @param	{object}	creative		Instance of {@link Mobclix.Creative.Base}
	 * 
	 * @return	{boolean}	Whether or not the creative can touch through
	 * @private
	 */
	shouldTouchThrough: function(creative) {
		return !Controller.inModal;
	},

	/**
	 * Tells the ad view a creative will touch through
	 * Any touch through events will be fired at this point
	 * 
	 * @param	{object}	creative		Instance of {@link Mobclix.Creative.Base}
	 * @private
	 */
	willTouchThrough: function(creative) {
		Controller.inModal = true;
		this.cancelScheduledGetAd();

		if(typeof this.onWillTouchThrough == 'function') {
			this.onWillTouchThrough(this);
		}
	},
	
	/**
	 * Tells the ad view a creative did touch through
	 * Any did touch through events will be fired at this point
	 * 
	 * @param	{object}	creative		Instance of {@link Mobclix.Creative.Base}
	 * @private
	 */
	didTouchThrough: function(creative) {
		Controller.inModal = false;

		if(typeof this.onDidTouchThrough == 'function') {
			this.onDidTouchThrough(this);
		}

		if(this.shouldScheduleGetAd()) this.scheduleNextGetAd();
	},
	
	/**
	 * Convenience method to handle opening a full screen action URL.
	 * This method will automatically handle any events
	 * that need to be triggered when handling full screen takeovers
	 * 
	 * @param	{object}	creative		Instance of {@link Mobclix.Creative.Base}
	 * @param	{string}	url		Action URL to open in a full screen browser
	 * 
	 * @return	{boolean}	Whether or not the action url was able to open
	 * @private
	 */
	openActionURL: function(creative, url) {
		if(!this.shouldTouchThrough()) {
			$mc.log("Already in modal, can't open url");
			return false;
		}

		var self = this;
		
		this.willTouchThrough();
		$mc.log("Opening action URL:", url);
		
		var browserType = null;
		
		try {
			browserType = creative.getBrowserType();
		} catch (e) {
			browserType = Browser.Type.Toolbar;
		}
		
		var browser = new Browser(browserType);
		browser.onDidFinish = function() {
			self.didTouchThrough(creative);
		};
		
		browser.loadUrl(url);
		browser.presentViewController(true);
		browser.release();
		browser = null;
	},
	
	// ====
	// Memory Management
	// ====
	
	/** @private */
	destroy: function($super) {
		Config.removeListener(this._listener);
		this._listener.destroy();
		
		this.currentCreatives = null;
		this.currentCreative = null;
		this.nextCreativeView = null;
		this.adSpaceName = null;
		this._size = null;
		
		$mc.log(" ---- ADVIEW DESTROY ---- ");
		$super();
	}
});

// Properties
(function() {
	AdViewInternal.addProperty('currentCreatives', true);
	AdViewInternal.addProperty('currentCreative', true);
	AdViewInternal.addProperty('nextCreativeView', true);
	AdViewInternal.addProperty('adSpaceName', false);
	AdViewInternal.addProperty('requestAdUrl', false);
	AdViewInternal.addProperty('refreshTime', false, 0);
})();

// MobclixAdView Events
(function() {
	/**
	 * @name Mobclix.AdView#setOnFinishLoad
	 * @description Set a function to call when the <code>finishLoad</code> event occurs.
	 * @param {Function} eventCallback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.AdView#getOnFinishLoad
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getOnFinishLoad
	 * @description Retrieve the function to call when the <code>finishLoad</code> event occurs.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setOnFinishLoad
	 * @function
	 */
    /**
	 * @name Mobclix.FullScreenAdView#setOnFinishLoad
	 * @description Set a function to call when the <code>finishLoad</code> event occurs.
	 * @param {Function} eventCallback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.FullScreenAdView#getOnFinishLoad
	 * @function
	 */
	/**
	 * @name Mobclix.FullScreenAdView#getOnFinishLoad
	 * @description Retrieve the function to call when the <code>finishLoad</code> event occurs.
	 * @return {Function} The current callback function.
	 * @see Mobclix.FullScreenAdView#setOnFinishLoad
	 * @function
	 */
	AdViewInternal.addProperty('onFinishLoad', false);

	/**
	 * @name Mobclix.AdView#setOnFailedToLoad
	 * @description Set a function to call when the <code>failedToLoad</code> event occurs.
	 * @param {Function} eventCallback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView, code, error)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * The <code>code</code> parameter is the error code matching {@link Mobclix.AdView#Error}.
	 * The <code>error</code> parameter is a string describing the error.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.AdView#getOnFailedToLoad
	 * @function
	 */

	/**
	 * @name Mobclix.AdView#getOnFailedToLoad
	 * @description Retrieve the function to call when the <code>failedToLoad</code> event occurs.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setOnFailedToLoad
	 * @function
	 */
    
    	/**
	 * @name Mobclix.FullScreenAdView#setOnFailedToLoad
	 * @description Set a function to call when the <code>failedToLoad</code> event occurs.
	 * @param {Function} eventCallback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView, code, error)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * The <code>code</code> parameter is the error code matching {@link Mobclix.AdView#Error}.
	 * The <code>error</code> parameter is a string describing the error.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.FullScreenAdView#getOnFailedToLoad
	 * @function
	 */

	/**
	 * @name Mobclix.FullScreenAdView#getOnFailedToLoad
	 * @description Retrieve the function to call when the <code>failedToLoad</code> event occurs.
	 * @return {Function} The current callback function.
	 * @see Mobclix.FullScreenAdView#setOnFailedToLoad
	 * @function
	 */
	AdViewInternal.addProperty('onFailedToLoad', false);

	/**
	 * @name Mobclix.AdView#setOnCanAutoplay
	 * @description Set a function for the ad view to call to determine if an ad can autoplay.
	 * This will override the default setting used on the developer dashboard.
	 * <br /><br />
	 * Autoplay ads are similar to interstitial ads and will automatically
	 * open a website, video, or any other kind of modal action supported by the SDK.
	 * <br /><br />
	 * If this method isn't implemented, the settings provided on the Dashboard are used.
	 * @param {Function} callback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * This function most return boolean value indicating whether or not ads can autoplay.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.AdView#getOnCanAutoplay
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getOnCanAutoplay
	 * @description Retrieve the function to call when the ad view needs to determine if it can autoplay ads.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setOnCanAutoplay
	 * @function
	 */
	AdViewInternal.addProperty('onCanAutoplay', false);


	/**
	 * @name Mobclix.AdView#setOnWillTouchThrough
	 * @description Set a function for the ad view to call when the user touches through.  When this happens, the ad view will take over the screen experience, so in the case of a game it should be paused.
	 * @param {Function} callback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * This function most return boolean value indicating whether or not ads can autoplay.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.AdView#getOnWillTouchThrough
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getOnWillTouchThrough
	 * @description Retrieve the function to call when the user touches through.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setOnWillTouchThrough
	 * @function
	 */
	AdViewInternal.addProperty('onWillTouchThrough', false);

	/**
	 * @name Mobclix.AdView#setOnDidTouchThrough
	 * @description Set a function for the ad view to call when the user touch through is finished.  When this happens, the ad view is no longer taking over the screen experience, so in the case of a game, game play can be resumed.
	 * @param {Function} callback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * This function most return boolean value indicating whether or not ads can autoplay.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.AdView#getOnDidTouchThrough
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getOnDidTouchThrough
	 * @description Retrieve the function to call when the user touches through.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setOnDidTouchThrough
	 * @function
	 */
	AdViewInternal.addProperty('onDidTouchThrough', false);

	/**
	 * @name Mobclix.FullScreenAdView#setOnPresentAd
	 * @description Set a function to call when the <code>presentAd</code> event occurs.
	 * @param {Function} eventCallback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.FullScreenAdView#getOnPresentAd
	 * @function
	 */

	/**
	 * @name Mobclix.FullScreenAdView#getOnPresentAd
	 * @description Retrieve the function to call when the <code>presentAd</code> event occurs.
	 * @return {Function} The current callback function.
	 * @see Mobclix.FullScreenAdView#setOnPresentAd
	 * @function
	 */
	AdViewInternal.addProperty('onPresentAd', false);
    
    /**
	 * @name Mobclix.FullScreenAdView#setOnDismissAd
	 * @description Set a function to call when the <code>dismissAd</code> event occurs.
	 * @param {Function} eventCallback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * <br><br><b>Note:</b> This event is disabled if the value of this parameter is not a function.<br>
	 * @see Mobclix.FullScreenAdView#getOnDismissAd
	 * @function
	 */

	/**
	 * @name Mobclix.FullScreenAdView#getOnDismissAd
	 * @description Retrieve the function to call when the <code>dismissAd</code> event occurs.
	 * @return {Function} The current callback function.
	 * @see Mobclix.FullScreenAdView#setOnDismissAd
	 * @function
	 */
	AdViewInternal.addProperty('onDismissAd', false);

	/**
	 * @name Mobclix.AdView#setRichMediaRequiresUserInteraction
	 * @description Set a function for the ad view to call when determining if rich media requires user interaction:<br />
	 * Rich Media features include access to the following:<br />
	 * <ul>
	 *	<li>LED Flash</li>
	 *	<li>Vibrate</li>
	 *	<li>Sound</li>
	 * </ul>
	 * To allow these features to work automatically, this callback should return false.
	 * <br /></br />
	 * Applications that vibrate or play sound, should return true.
	 * <br /></br />
	 * If this callback isn't implemented, the settings provided on the Dashboard are used.
	 * @param {Function} callback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * This function most return boolean value indicating whether or not ads can autoplay.
	 * @see Mobclix.AdView#getRichMediaRequiresUserInteraction
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getRichMediaRequiresUserInteraction
	 * @description Retrieve the function to call when determining if rich media requires user interaction.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setRichMediaRequiresUserInteraction
	 * @function
	 */
	AdViewInternal.addProperty('richMediaRequiresUserInteraction', false);
	
	/**
	 * @name Mobclix.AdView#setRequestKeywords
	 * @description Set a function for the ad view to call to get the request keywords.
	 * @param {Function} callback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * This function most return boolean value indicating whether or not ads can autoplay.
	 * @see Mobclix.AdView#getRequestKeywords
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getRequestKeywords
	 * @description Retrieve the function to call to get the request keywords.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setRequestKeywords
	 * @function
	 */
	AdViewInternal.addProperty('requestKeywords', false);
	
	/**
	 * @name Mobclix.AdView#setRequestQuery
	 * @description Set a function for the ad view to call to get the request query.
	 * @param {Function} callback The new callback function, the signature for the callback is equivalent
	 * to:<br><br>
	 * <pre>function(adView)</pre><br>
	 * The <code>adView</code> parameter is the instance of the MobclixAdView that loaded.
	 * This function most return boolean value indicating whether or not ads can autoplay.
	 * @see Mobclix.AdView#getRequestQuery
	 * @function
	 */
	/**
	 * @name Mobclix.AdView#getRequestQuery
	 * @description Retrieve the function to call to get the request query.
	 * @return {Function} The current callback function.
	 * @see Mobclix.AdView#setRequestQuery
	 * @function
	 */
	AdViewInternal.addProperty('requestQuery', false);
})();

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/MMView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMView'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMView'] = exports; //
//  Mobclix.Core.MMView.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var UI = require('NGCore/Client/UI').UI;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

/**
 * @class MMView is a memory managed subclass of UI.View that brings in all methods supplied by {@link Mobclix.Core.MMClass}
 * @name Mobclix.Core.MMView
 * @extends UI.View
 * @private
 */
var mmViewMethods = exports.MMViewMethods = 
/** @lends Mobclix.Core.MMView.prototype */
{
	__className: "MMView",

	/**
	 * Adds the child node from it's view hierarchy and retains it
	 * @private
	 * @function
	 */
	addChild: function($super, childNode, index) {
		$super(childNode, index);
		try { childNode.retain(); } catch(e) { }
	},

	/**
	 * Removes the child node from it's view hierarchy and releases it
	 * @private
	 * @function
	 */
	removeChild: function($super, childNode) {
		$super(childNode);
		try { childNode.release(); } catch(e) { }
	},

	/**
	 * Gets the current bounds of the view
	 * @function
	 * @return	{object}	Bounds of the object
	 * @private
	 */
	getBounds: function() {
		var frame = this.getFrame();
        var bounds = [frame[0], frame[1], frame[2], frame[3]];
		bounds[0] = 0;
		bounds[1] = 0;
		return bounds;
	}
};

var MMView = exports.MMView = UI.View.subclass($mc.extend(require('NGCore/Client/Mobclix/Core/MMClass').Memory, mmViewMethods));
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/Config'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Config'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Config'] = exports; //
//  Mobclix.Core.Config.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Network = require('NGCore/Client/Network').Network;
var Storage = require('NGCore/Client/Storage').Storage;
var KeyValueCache = require('NGCore/Client/Storage/KeyValue').KeyValueCache;

var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;
// var Controller = require('./Controller').Controller;
var HTTPRequest = require('NGCore/Client/Mobclix/Core/HTTPRequest').HTTPRequest;

exports.Config = Core.Class.singleton({
	version: "0.99",
	
	configURL: "http://data.mobclix.com/post/config",
	advertisingURL: "http://ads.mobclix.com/",
	
	config: {},
	emitter: null,
	_isUpdating: false,
	_hasConfigFailed: false,
	_idleTimeoutInterval: 0.0,
	
	initialize: function() {
		this.emitter = new Core.MessageEmitter();
	},
	
	updateConfiguration: function(controller) {
		if(this.isUpdating()) return;
		else this._setUpdating(true);

		this._updateConfiguration(controller);
	},
	
	_updateConfiguration: function(controller) {
		var sessionTracking = controller.sessionTracking;
		
		if(controller.getNetworkState() == "none") {
			$mc.log("network state none");
			this.isUpdating(false);
			sessionTracking.offlineSessionCount++;
			sessionTracking.saveSessionTrackingData();
			this._hasConfigFailed = true;
			this.emitter.emit(this);
			return;
		}

		var self = this;

		// Load cached first
		try {
			Storage.FileSystem.readFile("MobclixConfig-" + controller.applicationId, false, function(error, value) {
				try {
					value = eval("("+value+")");
				} catch(e) { }

				if(value && typeof value == 'object' && value.length > 0) {
					self.config = value;
				}
			});
            
            var kv = new Storage.KeyValue();
            kv.registerForKey("mobclix");
            kv.getItem("userAgent", function(param1, value, key) {
                controller.setUserAgent(value, true);
                kv.destroy();
            });
		} catch(e) { }

		// Request fresh config
		var queryString = {
			a: controller.applicationId,
			p: controller.isAndroid() ? 'android' : (controller.isIPad() ? 'ipad' : 'iphone'),
			m: this.version,
			// v: "1.0", // TODO
			d: Core.Capabilities.getUniqueId(),
			dm: Core.Capabilities.getDeviceName(),
			// dv: "", // TODO
			hwdm: Core.Capabilities.getPlatformHW(),
			g: controller.getNetworkState(),
			off: sessionTracking.offlineSessionCount,
			st: sessionTracking.lastSessionLength,
			it: sessionTracking.idleSessionTime,
			rt: 'mobage',
			rtv: Core.Capabilities.getSDKVersion()
		};

		$mc.log("sessionTracking.offlineSessionCount:", sessionTracking.offlineSessionCount);
		$mc.log("sessionTracking.lastSessionLength:", sessionTracking.lastSessionLength);
		$mc.log("sessionTracking.idleSessionTime:", sessionTracking.idleSessionTime);
		
		// Location
		var location = null;
		if((location = controller.getLocation())) {
			queryString.ll = location;
			location = null;
		}
		
		var newKey = controller.applicationId + "-new";
		KeyValueCache.local.getItem(newKey, function(error, value) {
			// Determine if new
			if((error && error.length > 0) || value !== "false") {
				$mc.log("Detected new user");
				queryString['new'] = true;
				KeyValueCache.local.setItem(newKey, "false");
			}

			// Start request
			var request = new HTTPRequest;
			request.start({
				url: self.getConfigURL(),
				data: queryString,
				type: "get",
				success: function(request, response) {
					if(request.getStatusCode() == 200) {
						if(typeof response == 'string') {
							// Temp fix until the headers are updated on remote config
							response = eval("("+response+")");
						}

						self.finishedUpdating(response, controller);
					} else {
						self.failedToUpdate("Unknown error", controller);
					}
				},
				error: function(request, error) {
					self.failedToUpdate(error, controller);
				}
			});
			request.release();
		}, true);
	},
	
	finishedUpdating: function(response, controller) {
		this._setUpdating(false);
		this._hasConfigFailed = false;
		this.config = typeof response == 'object' ? response : {};
		controller.sessionTracking.idleSessionTime = 0;
		controller.sessionTracking.lastSessionLength = 0;
		controller.sessionTracking.offlineSessionCount = 0;
		controller.sessionTracking.saveSessionTrackingData();
		
		try {
			Storage.FileSystem.writeFile("MobclixConfig-" + controller.applicationId, JSON.stringify(this.config));
		} catch(e) { }
		
		this.emitter.emit(this);
	},
	
	failedToUpdate: function(error, controller) {
		$mc.log("Config Request failed, error: ", error);
		this._hasConfigFailed = true;
		this._setUpdating(false);
		controller.sessionTracking.offlineSessionCount++;
		controller.sessionTracking.saveSessionTrackingData();
		this.emitter.emit(this);
	},
	
	hasConfigFailed: function() {
		return this._hasConfigFailed;
	},
	
	addListener: function(listener, func) {
		this.emitter.addListener(listener, func);
	},
	
	removeListener: function(listener) {
		this.emitter.removeListener(listener);
	},
	
	getVersion: function() {
		return this.version;
	},
	
	_setUpdating: function(b) {
		this._isUpdating = b;
	},
	
	isUpdating: function() {
		return this._isUpdating;
	},
	
	getIdleTimeoutInterval: function() {
		try {
			return this.config.idle_timeout || this._idleTimeoutInterval;
		} catch (e) {
			return this._idleTimeoutInterval;
		}
	},
	
	getConfigURL: function() {
		try {
			return this.config.urls.config || this.configURL;
		} catch (e) {
			return this.configURL;
		}
	},
	
	getAdvertisingURL: function() {
		try {
			return this.config.urls.ads || this.advertisingURL;
		} catch (e) {
			return this.advertisingURL;
		}
	},
	
	getAnalyticsURL: function() {
		try {
			return this.config.urls.analytics || this.analyticsURL;
		} catch (e) {
			return this.analyticsURL;
		}
	},
	
	getNativeURLs: function() {
		var nativeURLs = null;
		
		try {
			nativeURLs = this.config.native_urls;
			if(!nativeURLs instanceof Array) {
				nativeURLs = null;
			}
		} catch(e) {
			nativeURLs = null;
		}
		
		if(!nativeURLs || nativeURLs.length == 0) {
			nativeURLs = [
							"itunes.apple.com",
							"phobos.apple.com",
							"maps.google.com",
							"youtube.com",
							"mailto:"
						];
		}
		
		return nativeURLs;
	},
	
	isAdUnitEnabled: function(size) {
		var props = this._propertiesForAdUnit(size);
		return $mc.parseBool(props.autoplay_interval) || true;
	},
	
	isAutoPlayEnabled: function(size) {
		var props = this._propertiesForAdUnit(size);
		return $mc.parseBool(props.autoplay) || false;
	},
	
	richMediaRequiresUserInteraction: function(size) {
		var props = this._propertiesForAdUnit(size);
		return $mc.parseBool(props.rm_require_user) || true;
	},
	
	refreshInteveralForAdUnit: function(size) {
		var props = this._propertiesForAdUnit(size);
		return parseInt(props.autoplay_interval, 10) || 30;
	},
	
	autoplayTimeoutInteveralForAdUnit: function(size) {
		var props = this._propertiesForAdUnit(size);
		return parseInt(props.autoplay_interval, 10) || size.height == 250 ? 0 : 120;
	},
	
	_propertiesForAdUnit: function(size) {
		var props = null;
		
		if(size.width == 999) {
			size = "fullscreen";
		} else {
			size = size.width  + "x" + size.height;
		}

		try {
			if(this.config.ad_units) $mc.each(this.config.ad_units, function(unit, key) {
				if(unit.size == size) {
					props = unit;
					return false;
				}
			});
		} catch(e) { }

		return props || {};
	},
	
	destroy: function() {
		this.version = null;
		this.configURL = null;
		this.advertisingURL = null;
		this.analyticsURL = null;
		this.config = null;
		this.emitter = null;
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/Utils'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Utils'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Utils'] = exports; //
//  Mobclix.Core.Utils.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;

exports.Utils = Core.Class.singleton(
/** @lends Mobclix.Core.Utils.prototype */
{
	/**
	 * @class Utils is a singleton class with a collection of static utility methods to help with development.
	 * @constructs The default constructor.
	 * @private
	 */
	initialize: function() {
		
	},
	
	/**
	 * Gets device indpenedent pixel
	 * @param	{number} pixel	Pixel to conver to DIP
	 * @return	{number} pixel converted to dip
	 * @private
	 */
	$dip: function(pixel) {
		return Math.round(pixel * Core.Capabilities.getScreenUnits());
	},
	
	/**
	 * Add a property to a class so it can be called the following ways:
	 * @example
	 * <code>(function() {
	 * Foo.addProperty('bar', true);
	 * })();
	 *
	 * // Instances of Foo can now access the bar property the following ways:
	 * obj.bar = value;
	 * obj.setBar(value);
	 * var barVal = obj.bar;
	 * var barVal = obj.getBar();</code>
	 * 
	 * 
	 * @param	{class}	target		Target class to this property to
	 * @param	{string}	propName	Name of the property to add to the class
	 * @param	{boolean}	shouldRetain	Whether or not this property should be retained when set (and released when unset)
	 * @param	{mixed}	defaultValue	Default value of this property
	 * @private
	 * @function
	 * @static
	 */
	$addProperty: function(target, propName, shouldRetain, defaultValue) {
		if(!propName) return;
		var self = this;
		
		shouldRetain = shouldRetain || false;

		var instVarName = '__' + propName;
		var caseAdjusted = propName.charAt(0).toUpperCase() + propName.substr(1);

		target.prototype[instVarName] = defaultValue || null;
		
		if(typeof target.prototype['get'+caseAdjusted] != 'function') {
			target.prototype['get'+caseAdjusted] = function() {
				return this[instVarName];
			};
		}

		if(typeof target.prototype['set'+caseAdjusted] != 'function') {
			target.prototype['set'+caseAdjusted] = function(newValue) {
				this[instVarName] = newValue;
			};
		}

		target.prototype.__defineSetter__(propName, function(newValue) {
			if(this[instVarName] && shouldRetain) {
				if(shouldRetain) {
					try {
						this[instVarName].release();
					} catch(e) {
						self.log("Error releasing ", target[instVarName], e);
					} finally {
						this[instVarName] = defaultValue;
					}
				}
			}
			
			this[instVarName] = newValue;
			if(shouldRetain && newValue) {
				try {
					newValue.retain();
				} catch(e) {
					self.log("Error retaining ", newValue, e);
				}
			}
		});
		
		target.prototype.__defineGetter__(propName, function() {
			return this[instVarName];
		});
	},
	
	/**
	 * Logs to console
	 */
	$log: function() {
		arguments[0] = "MobclixSDK: " + arguments[0];
		console.log.apply(console.log, arguments);
	},
	
	/**
	 * Primative stack trace tool
	 */
	$trace: function() {
		var stack = arguments.callee;
		
		this.log("+ Starting Trace");

		while(stack) {
			this.log("|", stack.toString().split('\n')[0].replace(/\{\s?/, ""));
			stack = stack.caller;
		}
		
		this.log("+ Finished Trace");
	},
	
	/**
	 * Quickly enumerate an object or array
	 * 
	 * @param	{mixed}	object	Object or array to enumerate through
	 * @param	{function}	callback	Calback function that will be run on each element in the object.  Should conform to <code>function(value, key)</code>
	 * @private
	 * @function
	 * @static
	 */
	$each: function(object, callback) {
		if(!object) {
			this.log("Passed null object.. ");
			this.trace();
		}
		
		if(typeof object == 'array' || (typeof object.length == 'number' && typeof object[0] != 'undefined')) {
			for(var index = 0; index < object.length; index++) {
				if(callback(object[index], index) === false) break;
			}
		} else if(typeof object == 'object' && (typeof object.length != 'number' || object.length > 0)) {
			for(var key in object) {
				if(callback(object[key], key) === false) break;
			}
		}
	},
	
	/**
	 * Extend classes with functions and variables from another object
	 * 
	 * @param	{mixed}	target	base target to extend
	 * @param	{object}	objects,...	subsequent objects to apply to the base target
	 * @return	{mixed}	target extended with new functions/params
	 */
	$extend: function() {
		self = this;
		
		// Make sure we have a target
		if(arguments.length == 0) return {};

		// Get the tag
		var target = arguments[0];

		// Ensure we have an extendable target
		if(typeof target != 'object' && typeof target != 'function') {
			target = {};
		}

		for(var i = 1; i < arguments.length; i++) {
			// Get the object
			var object = arguments[i];

			// Ensure we have an object we can extend with, otherwise, bail.
			if(typeof object != 'object') {
				return target;
			}

			// Loop through object and bring eerything into the target scope
			for(var key in object) {
				var value = object[key];

				// Ignore undefined values
				if(typeof value == 'undefined') continue;

				// Handle null
				else if(value == null) {
					if(typeof target == 'function') target.prototype[key] = null;
					else target[key] = null;
				}

				// Handle objects recursively
				else if(typeof value == 'object') {
					if(typeof target == 'function') {
						target.prototype[key] = self.extend(target.prototype[key], value);
					} else {
						target[key] = self.extend(target[key], value);
					}
				}

				// For the rest, just do a straight assign
				else {
					if(typeof target == 'function') target.prototype[key] = value;
					else target[key] = value;
				}
			}
		}

		// Pass it back
		return target;
	},
	
	/**
	 * Get the bounds of a provided view
	 * 
	 * @param	{UI.View}	view	Instance of <code>UI.View</code> to get the bounds of
	 * @private
	 * @function
	 * @static
	 * @return	Bounds of the view
	 */
	$bounds: function(view) {
		var frame = view.getFrame();
		frame[0] = 0;
		frame[1] = 0;
		return frame;
	},
	
	/**
	 * Get the boolean value of a string
	 * 
	 * @param	{string}	str
	 * @private
	 * @function
	 * @static
	 * @return	Boolean
	 */
	$parseBool: function(str) {
		if(typeof str == 'undefined') return false;
		
		if(typeof str == 'boolean') {
			return str;
		}
		
		try {
			str = str.toString().substr(0, 1);
			if(str == "t" || str == "y" || str == "1") {
				return true;
			} else {
				return false;
			}
		} catch(e) {
			return false;
		}
	},
	
	/**
	 * Get the double value of a string
	 * 
	 * @param	{string}	str
	 * @private
	 * @function
	 * @static
	 * @return	Double
	 */
	$parseDouble: function(str) {
		if(typeof str == 'double' || typeof str == 'undefined') {
			return str;
		}
		
		if(str == null) return str;
		
		return str + 0.0;
	},
	
	/**
	 * Get the SHA1 value of a string
	 * 
	 * @param	{string}	msg
	 * @private
	 * @function
	 * @static
	 * @return	SHA1 String
	 */
	$sha1: function(msg) {
		/**
		*
		*  Secure Hash Algorithm (SHA1)
		*  http://www.webtoolkit.info/
		*
		**/

		function rotate_left(n,s) {
			var t4 = ( n<<s ) | (n>>>(32-s));
			return t4;
		};

		function lsb_hex(val) {
			var str="";
			var i;
			var vh;
			var vl;

			for( i=0; i<=6; i+=2 ) {
				vh = (val>>>(i*4+4))&0x0f;
				vl = (val>>>(i*4))&0x0f;
				str += vh.toString(16) + vl.toString(16);
			}
			return str;
		};

		function cvt_hex(val) {
			var str="";
			var i;
			var v;

			for( i=7; i>=0; i-- ) {
				v = (val>>>(i*4))&0x0f;
				str += v.toString(16);
			}
			return str;
		};


		function Utf8Encode(string) {
			string = string.replace(/\r\n/g,"\n");
			var utftext = "";

			for (var n = 0; n < string.length; n++) {

				var c = string.charCodeAt(n);

				if (c < 128) {
					utftext += String.fromCharCode(c);
				}
				else if((c > 127) && (c < 2048)) {
					utftext += String.fromCharCode((c >> 6) | 192);
					utftext += String.fromCharCode((c & 63) | 128);
				}
				else {
					utftext += String.fromCharCode((c >> 12) | 224);
					utftext += String.fromCharCode(((c >> 6) & 63) | 128);
					utftext += String.fromCharCode((c & 63) | 128);
				}

			}

			return utftext;
		};

		var blockstart;
		var i, j;
		var W = new Array(80);
		var H0 = 0x67452301;
		var H1 = 0xEFCDAB89;
		var H2 = 0x98BADCFE;
		var H3 = 0x10325476;
		var H4 = 0xC3D2E1F0;
		var A, B, C, D, E;
		var temp;

		msg = Utf8Encode(msg);

		var msg_len = msg.length;

		var word_array = new Array();
		for( i=0; i<msg_len-3; i+=4 ) {
			j = msg.charCodeAt(i)<<24 | msg.charCodeAt(i+1)<<16 |
			msg.charCodeAt(i+2)<<8 | msg.charCodeAt(i+3);
			word_array.push( j );
		}

		switch( msg_len % 4 ) {
			case 0:
				i = 0x080000000;
			break;
			case 1:
				i = msg.charCodeAt(msg_len-1)<<24 | 0x0800000;
			break;

			case 2:
				i = msg.charCodeAt(msg_len-2)<<24 | msg.charCodeAt(msg_len-1)<<16 | 0x08000;
			break;

			case 3:
				i = msg.charCodeAt(msg_len-3)<<24 | msg.charCodeAt(msg_len-2)<<16 | msg.charCodeAt(msg_len-1)<<8	| 0x80;
			break;
		}

		word_array.push( i );

		while( (word_array.length % 16) != 14 ) word_array.push( 0 );

		word_array.push( msg_len>>>29 );
		word_array.push( (msg_len<<3)&0x0ffffffff );


		for ( blockstart=0; blockstart<word_array.length; blockstart+=16 ) {

			for( i=0; i<16; i++ ) W[i] = word_array[blockstart+i];
			for( i=16; i<=79; i++ ) W[i] = rotate_left(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);

			A = H0;
			B = H1;
			C = H2;
			D = H3;
			E = H4;

			for( i= 0; i<=19; i++ ) {
				temp = (rotate_left(A,5) + ((B&C) | (~B&D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
				E = D;
				D = C;
				C = rotate_left(B,30);
				B = A;
				A = temp;
			}

			for( i=20; i<=39; i++ ) {
				temp = (rotate_left(A,5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
				E = D;
				D = C;
				C = rotate_left(B,30);
				B = A;
				A = temp;
			}

			for( i=40; i<=59; i++ ) {
				temp = (rotate_left(A,5) + ((B&C) | (B&D) | (C&D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
				E = D;
				D = C;
				C = rotate_left(B,30);
				B = A;
				A = temp;
			}

			for( i=60; i<=79; i++ ) {
				temp = (rotate_left(A,5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
				E = D;
				D = C;
				C = rotate_left(B,30);
				B = A;
				A = temp;
			}

			H0 = (H0 + A) & 0x0ffffffff;
			H1 = (H1 + B) & 0x0ffffffff;
			H2 = (H2 + C) & 0x0ffffffff;
			H3 = (H3 + D) & 0x0ffffffff;
			H4 = (H4 + E) & 0x0ffffffff;

		}

		var temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);

		return temp.toLowerCase();
	},


	/**
	 * Base64 decode
	 * http://www.webtoolkit.info/
	 * 
	 * @param	{string}	input	base64 encoded string
	 * @function
	 * @static
	 * @private
	 * @return	{string} base64 decoded string
	 **/
	$base64Decode: function(input) {
		var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		
		var utf8_decode = function(utftext) {
			var string = "";
			var i = 0;
			var c = c1 = c2 = 0;

			while ( i < utftext.length ) {

				c = utftext.charCodeAt(i);

				if (c < 128) {
					string += String.fromCharCode(c);
					i++;
				}
				else if((c > 191) && (c < 224)) {
					c2 = utftext.charCodeAt(i+1);
					string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
					i += 2;
				}
				else {
					c2 = utftext.charCodeAt(i+1);
					c3 = utftext.charCodeAt(i+2);
					string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
					i += 3;
				}

			}

			return string;
		};
		
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = keyStr.indexOf(input.charAt(i++));
			enc2 = keyStr.indexOf(input.charAt(i++));
			enc3 = keyStr.indexOf(input.charAt(i++));
			enc4 = keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		return utf8_decode(output);
	}

});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/HTTPRequest'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/HTTPRequest'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/HTTPRequest'] = exports; //
//  Mobclix.Core.HTTPRequest.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var MMClass = require('NGCore/Client/Mobclix/Core/MMClass').MMClass;
var Network = require('NGCore/Client/Network').Network;
var Utils = require('NGCore/Client/Mobclix/Core/Utils').Utils;

exports.HTTPRequest = MMClass.subclass({
	__className: "HTTPRequest",

	success: false,
	loading: false,
	error: false,
	response: null,
	statusCode: 0,
	request: null,
	
	initialize: function() {
		try {
			this.request = new Network.XHR();
		} catch (e) {
			this.request = null;
		}
	},
	
	getStatusCode: function() {
		return this.statusCode;
	},
	
	getResponse: function() {
		return this.response;
	},
	
	getResponseText: function() {
		return this.request.responseText;
	},
	
	wasSuccessful: function() {
		return this.success;
	},
	
	getError: function() {
		return this.error;
	},

	start: function(options) {
		// If we don't have an ajax object, bail out
		if(!this.request) {
			this.error = true;
			if(options.error) options.error(this);
			return false;
		}
		
		// Cleanup options
		if(typeof options != "object") {
			options = {url: options};
		}
		
		// Setup some defaults
		options.type = options.type || "GET";
		options.timeout = options.timeout || 120;
		options.data = options.data || "";
		options.async = options.async || true;
		
		
		// Build data
		if(typeof options.data == "object") {
			var params = options.data;
			options.data = "";

			for(var key in params) {
				options.data += "&" + escape(key) + "=" + escape(params[key]);
			}
			
			if(options.data.length > 0) {
				options.data = options.data.substring(1, options.length);
			}
		} else if(options != null && typeof options != 'undefined') {
			options.data = options.data.toString();
		} else {
			options.data = "";
		}
        
		// Setup state change handler
		var self = this;
		self.retain();

		this.request.onreadystatechange = function() {
			// Check if we're done loading
			if(self.request.readyState != 4) return;
			self.loading = false;
			
			// Store status code
			self.statusCode = self.request.status;

			// See if it's a valid response
			if((self.statusCode >= 200 && self.statusCode < 300) || (!options.async && self.statusCode == 0)) {
				self.success = true;

				if(self.request.getResponseHeader("Content-type").indexOf("json") >= 0 || self.request.getResponseHeader("Content-type").indexOf("javascript") >= 0) {
					try {
						resp = eval("("+self.request.responseText+")");
					} catch (e) {
						resp = null;
					}
					
					if(resp == null || typeof resp == 'undefined') {
						resp = self.request.responseText;
					}
				} else {
					resp = self.request.responseText;
				}
				
				if(options.success) options.success(self, resp);
			} else if(self.request.responseXML) {
				resp = self.request.responseXML;
			} else {
				self.error = true;
				if(options.error) options.error(self, self.statusCode);
			}
			
			self.release();
		};
		
		// Start the request
		if(options.type.toLowerCase() == "get") {
			var url = options.url + (options.url.indexOf("?") >= 0 ? "&" : "?") + options.data;
			this.request.open("GET", url, options.async);

            if (options.userAgent != null)
                this.request.setRequestHeader("User-Agent", options.userAgent);
			this.request.send(null);
		} else {
			this.request.open(options.type, options.url, options.async);
			this.request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
			this.request.setRequestHeader("Content-length", options.data.length);
            if (options.userAgent != null)
                this.request.setRequestHeader("User-Agent", options.userAgent);
			this.request.send(options.data);
		}
		
		this.loading = true;
	},
	
	destroy: function($super) {
		// if(this.request) this.request.destroy(); // Network.XHR doesn't have a .destroy() -- what?
		this.request = null;
		this.response = null;
		
		$super();
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/MMArray'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMArray'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMArray'] = exports; //
//  Mobclix.Core.MMArray.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var MMClass = require('NGCore/Client/Mobclix/Core/MMClass').MMClass;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var MMArray = exports.MMArray = MMClass.subclass({
	__className: "MMArray",
	___array: null,
	length: 0,
	
	initialize: function($super) {
		$super();
		this.___array = new Array();
	},
	
	get: function(index) {
		return this.___array[index];
	},
	
	set: function(index, element) {
		if(this.___array[index]) {
			try { this.___array[index].release(); } catch (e) { }
		}
		
		this.___array[index] = element;
		try { this.___array[index].retain(); } catch(e) { }
		
		this.length = this.___array.length;
	},
	
	remove: function(index) {
		var element = this.___array[index];
		this.___array = this.___array.slice(0, index).join(this.___array.slice(index+1));
		try { element.release(); } catch (e) { }
		this.length = this.___array.length;
	},
	
	push: function() {
		for(var i = 0; i < arguments.length; i++) {
			var element = arguments[i];
			$mc.log("Adding " + element.__description()  + " to " + this.__description());
			this.___array.push(element);
			try { element.retain(); } catch(e) {}
		}
		this.length = this.___array.length;
	},
	
	pop: function() {
		var element = this.___array.pop();
		try { element.release(); } catch(e) { }
		this.length = this.___array.length;
		return element;
	},
	
	valueOf: function() {
		return this.___array.valueOf();
	},
	
	toString: function() {
		return this.___array.toString();
	},
	
	reverse: function() {
		this.___array.reverse();
	},
	
	indexOf: function(element) {
		for(var i = 0; i < this.___array.length; i++) {
			if(element == this.___array[i]) {
				return i;
			}
		}
		
		return -1;
	},
	
	each: function(callback) {
		for(var i = 0; i < this.___array.length; i++) {
			if(callback(this.___array[i], i) === false) break;
		}
	},
	
	destroy: function($super) {
		var self = this;
		this.each(function(element) {
			$mc.log("Removing " + element.__description()  + " from " + self.__description());
			try { element.release(); } catch(e) { }
		});
		
		this.length = this.___array.length;
		this.___array = null;

		$super();
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Browser'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Browser'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Browser'] = exports; //
//  Mobclix.Browser.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Device = require('NGCore/Client/Device').Device;
var UI = require('NGCore/Client/UI').UI;
var ViewController = require('NGCore/Client/Mobclix/ViewController').ViewController;
var Controller = require('NGCore/Client/Mobclix/Core/Controller').Controller;
var MMView = require('NGCore/Client/Mobclix/Core/MMView').MMView;
var MMWebView = require('NGCore/Client/Mobclix/Core/MMWebView').MMWebView;
var Config = require('NGCore/Client/Mobclix/Core/Config').Config;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var ProxyListener = Core.MessageListener.subclass({
	onUpdate: function() {}
});

var Browser = exports.Browser = ViewController.subclass(
/** @lends Mobclix.Browser.prototype */
{
	__className: "Mobclix.Browser",
	webView: null,
	onDidFinish: null,
    browserType: null,
	topBar: null,
	bottomBar: null,
	bottomBorders: [null, null],
	prevArrow: null,
	nextArrow: null,
	doneButton: null,
	proxyListener: null,
    keyListener: null,
	
    // Null unless this is a fullscreen ad
    creativeView: null,
    
	Type: {
		Toolbar: 1,
		Navigation: 2,
		Full: 3,
		Minimal: 4
	},
	
	initialize: function($super, browserType, creativeView) {
		$super();
		
		var self = this;
		var types = this.Type;
        this.creativeView = creativeView;

        // Register register to close browser when app loses focus if not a fullscreen ad.
        if (creativeView == null) {
            this.proxyListener = new ProxyListener();
            Device.LifecycleEmitter.addListener(this.proxyListener, function(event) {
                if(event == Device.LifecycleEmitter.Event.Suspend) {
                    if(self.isPresented()) {
                        self.dismissViewController();
                    }
                }
            });
        }
        
        this.keyListener = new ProxyListener();
        Device.KeyEmitter.addListener(this.keyListener, function(event) {
            if(event.code === Device.KeyEmitter.Keycode.back) {
                if(self.isPresented()) {
                    self.dismissViewController();
                    return true;
                }
            }
        }, 0xffffffff);

		var browserType = browserType || this.Type.Toolbar;
		this.browserType = browserType;
        
		// Web View
		this.webView = new MMWebView();
		this.addChild(this.webView);
		
		// Bottom Bar
		(function() {
			if(browserType != types.Toolbar && browserType != types.Navigation && browserType != types.Full) return;
			
			self.bottomBar = new MMView();
			self.bottomBar.setGradient({
				gradient: [ "ffb0bccd 0.0", "ff879ab3 0.5", "ff8094ae 0.5", "ff6d83a1 1.0" ]
			});
			self.addChild(self.bottomBar);
			
			self.doneButton = new UI.Button({
				'text': 'Close',
				'textColor': 'ff',
				'textShadow': "8000 1.0 {0,1}",
				'textSize': 13,
				'textFont': UI.FontStyle.Bold,
				'textGravity': UI.ViewGeometry.Gravity.Center,
				'frame': [0, 0, 60, 30]
			});
			
			var corners = $mc.dip(4);
			corners = [corners, corners, corners, corners].join(' ');
			
			self.doneButton.setNormalGradient({
				corners: corners,
				outerLine: "ff2952b8 1",
				gradient: [ "ff7b9eea 0.0", "ff376fe0 0.5", "ff2260dd 0.5", "ff2463de 1.0" ]
			});
			self.doneButton.setHighlightedGradient({
				corners: corners,
				outerLine: "ff1b2c4e 1",
				gradient: [ "ff7d88a5 0.0", "ff3a4e77 0.5", "ff253c6a 0.5", "ff273e6d 1.0" ]
			});
			
			self.doneButton.setOnClick(function() {
				self.dismissViewController(true);
			});

			self.bottomBar.addChild(self.doneButton);

			var arrowProps = {
				'text': '◀',
				'textColor': 'ff',
				'textShadow': "8000 1.0 {0,1}",
				'textSize': 16,
				'textFont': UI.FontStyle.Bold,
				'textGravity': UI.ViewGeometry.Gravity.Center
			};
			
			if(Controller.isAndroid()) {
				arrowProps.textSize = 32;
			}
			
			self.prevArrow = new UI.Button(arrowProps);
			self.prevArrow.setOnClick(function() { self.webView.goBack(); });
			self.prevArrow.setTextColor('ffa8d4ff', UI.State.Pressed);
			self.bottomBar.addChild(self.prevArrow);

			arrowProps.text = '▶';
			self.nextArrow = new UI.Button(arrowProps);
			self.nextArrow.setTextColor('ffa8d4ff', UI.State.Pressed);
			self.nextArrow.setOnClick(function() { self.webView.goForward(); });
			self.bottomBar.addChild(self.nextArrow);
			
			self.bottomBorders[0] = new MMView();
			self.bottomBorders[0].setBackgroundColor('ff2d3034');
			self.bottomBar.addChild(self.bottomBorders[0]);
			
			self.bottomBorders[1] = new MMView();
			self.bottomBorders[1].setBackgroundColor('ffd8dee6');
			self.bottomBar.addChild(self.bottomBorders[1]);
			
			self.loadingIndicator = new UI.Spinner({
				'frame': [0, 0, 30, 30]
			});
			self.bottomBar.addChild(self.loadingIndicator);
			
			// Setup WebView listenres to control the bar items
            // Only for non-fullscreen creatives. Fullscreen listeners are set below.
            if (self.creativeView == null) {
                self.webView.setOnPageevent(function(event) {
                    self.updateArrows();
                });

                self.webView.setOnStartload(function(event) {
                    self.updateArrows();
                    self.loadingIndicator.setVisible(true);
                });

                self.webView.setOnPageload(function(event) {
                    self.updateArrows();
                    self.loadingIndicator.setVisible(false);
                });

                self.webView.setOnError(function(event) {
                    self.updateArrows();
                    self.loadingIndicator.setVisible(false);
                });

                self.webView.setOnLoad(function(event) {
                    self.updateArrows();
                });
            }
		})();

		// Widget close
		(function() {
			if(browserType != types.Minimal) return;

			var cornerSize = $mc.dip(14);
			var backFontSize = 18;
		
			if(Controller.isAndroid()) {
				backFontSize = 20;
			}

			var back = new UI.Button({
				'text': '✖',
				'textColor': 'ff',
				'textSize': backFontSize,
				'textFont': UI.FontStyle.Bold,
				'textGravity': UI.ViewGeometry.Gravity.Center,
				'textInsets': [1, 0, 0, 1],
				'frame': [$mc.dip(10), $mc.dip(10), $mc.dip(32), $mc.dip(32)]
			});

			back.setGradient({
				corners: [cornerSize, cornerSize, cornerSize, cornerSize].join(' '),
				outerLine: "ff 2",
				gradient: [ "00 0.0", "00 1.0" ]
			}, UI.State.Normal);
		
			back.setGradient({
				corners: [cornerSize, cornerSize, cornerSize, cornerSize].join(' '),
				outerLine: "ff 2",
				gradient: [ "00 0.0", "00 1.0" ]
			}, UI.State.Pressed);
		
			back.onclick = function() {
				self.dismissViewController(true);
			};
		
			self.addChild(back);
		})();
        
        if (creativeView != null) {
            this.webView.setOnPageevent(function(event) {
                self.onPageEvent(event);
            });
            
            this.webView.setOnStartload(function(event) {
                self.onStartLoad(event);
            });

            this.webView.setOnShouldload(function(event) {
                return self.onShouldLoad(event);
            });

            this.webView.setOnPageload(function(event) {
                self.onPageLoad(event);
            });
            
            this.webView.setOnError(function(event) {
                self.onError(event);
            });
        }
	},
	
    updateArrows: function() {
        var canGoForward = this.webView.canGoForward();
        this.nextArrow.setAlpha(canGoForward ? 1.0 : 0.6);
        this.nextArrow.setState(canGoForward ? UI.State.Normal : UI.State.Disabled);

        var canGoBack = this.webView.canGoBack();
        this.prevArrow.setAlpha(canGoBack ? 1.0 : 0.6);
        this.prevArrow.setState(canGoBack ? UI.State.Normal : UI.State.Disabled);
    },
    
	viewWillAppear: function($super, animated) {
		$super(animated);
		this.layoutSubviews();
	},
	
	setFrame: function() {
		UI.View.prototype.setFrame.apply(this, arguments);
		this.layoutSubviews();
	},
	
	layoutSubviews: function() {
		var bounds = this.getBounds();
		var webViewFrame = this.getBounds();
		
		if(this.bottomBar) {
			var barHeight = $mc.dip(44);
			this.bottomBar.setFrame(0, bounds[3] - barHeight, bounds[2], barHeight);
			webViewFrame[3] -= barHeight;

			var loadingFrame = [0,0,25,25];
			loadingFrame[0] = Math.floor((bounds[2] - loadingFrame[2]) / 2);
			loadingFrame[1] = Math.floor((barHeight - loadingFrame[3]) / 2);
			this.loadingIndicator.setFrame(loadingFrame);
		
			var donePadding = $mc.dip(6);
			
			var doneFrame = this.doneButton.getFrame();
			doneFrame[2] = $mc.dip(54);
			doneFrame[3] = $mc.dip(29);
			doneFrame[0] = bounds[2] - doneFrame[2] - donePadding;
			doneFrame[1] = Math.floor((barHeight - doneFrame[3]) / 2);
			this.doneButton.setFrame(doneFrame);
			
			var doneOuterWidth = doneFrame[2] + $mc.dip(6);
			
			var arrowFrame = [0,0,0,0];
			arrowFrame[0] = doneOuterWidth;
			arrowFrame[1] = 0;
			arrowFrame[2] = Math.floor((bounds[2] - (doneOuterWidth * 2)) / 3);
			arrowFrame[3] = barHeight;
			this.prevArrow.setFrame(arrowFrame);

			arrowFrame[0] = bounds[2] - arrowFrame[2] - doneOuterWidth;
			this.nextArrow.setFrame(arrowFrame);
			
			var borderFrame = [0, 0, bounds[2], $mc.dip(1)];
			this.bottomBorders[0].setFrame(borderFrame);
			
			borderFrame[1] = $mc.dip(1);
			this.bottomBorders[1].setFrame(borderFrame);
		}
		
		this.webView.setFrame(webViewFrame);
	},
	
	dismissViewController: function($super, animated) {
		if(typeof this.onDidFinish == 'function') {
			this.onDidFinish();
		}
		$super(animated);
	},
	
	loadUrl: function(url) {
		this.webView.loadUrl(url);
	},
    
    loadWithCreative: function(cacheLocation) {
		this.webView.loadDocument(cacheLocation);
	},
	
    getParameterByName: function(url, name, d) {
		name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
		var regexS = "[\\?&]"+name+"=([^&#]*)";
		var regex = new RegExp( regexS );
		var results = regex.exec( url );
		if( results == null )
			return d;
		else
			return decodeURIComponent(results[1].replace(/\+/g, " "));
	},
    
    onShouldLoad: function(event) {
        if (this.creativeView.loaded && !this.creativeView.touched) {
            try {
                this.creativeView.adView.currentCreative.getEvents().triggerEvent("touch");
            } catch(e) { }
        }
        this.creativeView.touched = true;
		return true;
	},
	
	onPageEvent: function(event) {
		$mc.log("WebView webgame Page Event: ", JSON.stringify(event));
        var method = event.eventStream.split("?")[0];
        if (method == "setUserAgent") {
            var userAgent = this.getParameterByName(event.eventStream, "ua") || null;
            Controller.setUserAgent(userAgent);
        }
        if(this.browserType == this.Type.Toolbar || this.browserType == this.Type.Navigation || this.browserType == this.Type.Full)
            this.updateArrows();
	},

	onStartLoad: function(event) {
		$mc.log("WebView webgame Page Start Load: ", JSON.stringify(event));
        if(this.browserType == this.Type.Toolbar || this.browserType == this.Type.Navigation || this.browserType == this.Type.Full) {
            this.updateArrows();
            this.loadingIndicator.setVisible(true);
        }
	},

	onPageLoad: function(event) {
		$mc.log("WebView webgame Page Load: ", JSON.stringify(event));
		if (!this.creativeView.loaded) {
			this.creativeView.loaded = true;
			this.creativeView.adView.creativeViewFinishedLoading(this.creativeView, this.creativeView.currentCreative);
            try {
                this.webView.invoke("var uaUrl = \"ngcore://setUserAgent?ua=\" + escape(navigator.userAgent); window.location=uaUrl;");
            } catch (err) {}
		}
        if(this.browserType == this.Type.Toolbar || this.browserType == this.Type.Navigation || this.browserType == this.Type.Full) {
            this.updateArrows();
            this.loadingIndicator.setVisible(false);
        }
	},

	onError: function(event) {
		$mc.log("WebView webgame Error: ", JSON.stringify(event));
        if(this.browserType == this.Type.Toolbar || this.browserType == this.Type.Navigation || this.browserType == this.Type.Full) {
            this.updateArrows();
            this.loadingIndicator.setVisible(false);
        }
	},
    
	destroy: function($super) {
		if(this.bottomBar) {
			this.prevArrow.removeFromParent();
			this.nextArrow.removeFromParent();
			this.doneButton.removeFromParent();
			this.loadingIndicator.removeFromParent();
			this.bottomBorders[0].removeFromParent();
			this.bottomBorders[1].removeFromParent();
			
			try { this.prevArrow.destroy(); } catch (e) { }
			try { this.nextArrow.destroy(); } catch (e) { }
			try { this.doneButton.destroy(); } catch (e) { }
			try { this.loadingIndicator.destroy(); } catch (e) { }
			try { this.bottomBorders[0].destroy(); } catch (e) { }
			try { this.bottomBorders[1].destroy(); } catch (e) { }

			this.removeChild(this.bottomBar);
			this.bottomBar.release();
			this.bottomBar = null;
		}
		
		this.removeChild(this.webView);
		this.webView.release();
        try {
            Device.NetworkEmitter.removeListener(this.proxyListener);
        } catch (e) {}
        try {
            Device.KeyEmitter.removeListener(this.keyListener);
        } catch (e) {}

		$super();
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Creative'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative'] = exports; //
//  Mobclix.Creative.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

exports.Creative =
/** @lends Mobclix.Creative.prototype */
{
	Types: require('NGCore/Client/Mobclix/Creative/Base').Types,
	Web: require('NGCore/Client/Mobclix/Creative/Web').Web,

	/**
	 * Create an Creative model from a JSON objects
	 * @param {object}	JSON creative object
	 * @private
	 */
	Create: function(obj) {
		var creativeType = null;
		try {
			creativeType = obj.creative.type || "web";
		} catch(e) {
			creativeType = "web";
		}

		switch(creativeType) {
			case 'html':
			case 'web':
			default:
				$mc.log("HTML or Unknown ad type detected: ", creativeType);
				return new this.Web(obj);
		}
	}
};; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/CreativeView/Web'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/Web'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/Web'] = exports; //
//  Mobclix.CreativeView.Web.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Controller = require('NGCore/Client/Mobclix/Core/Controller').Controller;
var UI = require('NGCore/Client/UI').UI;
var Device = require('NGCore/Client/Device').Device;
var Storage = require('NGCore/Client/Storage').Storage;
var Base = require('NGCore/Client/Mobclix/CreativeView/Base').Base;
var MMWebView = require('NGCore/Client/Mobclix/Core/MMWebView').MMWebView;
var RMWebView = require('NGCore/Client/Mobclix/CreativeView/WebView').WebView;
var Browser = require('NGCore/Client/Mobclix/Browser').Browser;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var ProxyListener = Core.MessageListener.subclass({
	onUpdate: function() {}
});

exports.Web = Base.subclass(
/** @lends Mobclix.CreativeView.Web.prototype */
{
	__className: "Mobclix.CreativeView.Web",
	webView: null,
	cacheLocation: null,
	loaded: false,
    touched: false,
	fs: null,
	useRichMedia: false,
	
	/**
	 * @class Web CreativeView class for display {@link Mobclix.Creative.Web} creatives
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @extends Mobclix.Creative.Base
	 * @private
	 */
	initialize: function($super) {
		$super();

		if(this.useRichMedia) {
			this.webView = new RMWebView();
			this.webView.parentCreative = this;
		} else {
			this.webView = new MMWebView();
		}
		
		this.addChild(this.webView);
		this.fs = Storage.FileSystem;
		
		var self = this;
		
        this.webView.setScrollable(false);
        
		if(this.useRichMedia) {
			this.webView.setOnPageevent(this.webView.onPageEvent);
		} else {
            this.webView.setOnPageevent(function(event) {
                self.onPageEvent(event);
            });
        }
		
		this.webView.setOnStartload(function(event) {
			self.onStartLoad(event);
		});

		this.webView.setOnShouldload(function(event) {
			return self.onShouldLoad(event);
		});

		this.webView.setOnPageload(function(event) {
			self.onPageLoad(event);
		});
		
		this.webView.setOnError(function(event) {
			self.onError(event);
		});
		
		this.proxyListener = new ProxyListener();
		$mc.log("Adding life cycle listener");
		Device.LifecycleEmitter.addListener(this.proxyListener, function(event) {
			$mc.log("life cycle changed!");
			if(event == Device.LifecycleEmitter.Event.Terminate) {
				self.fs.deleteFile(this.cacheLocation);
				self.fs = null;
				self.cacheLocation = null;
			}
		});
		$mc.log("Added life cycle listener");
	},
	
	getParameterByName: function(url, name, d) {
		name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
		var regexS = "[\\?&]"+name+"=([^&#]*)";
		var regex = new RegExp( regexS );
		var results = regex.exec( url );
		if( results == null )
			return d;
		else
			return decodeURIComponent(results[1].replace(/\+/g, " "));
	},
	
	/**
	 * Resize the internal webview if our bounds change
	 * 
	 * NOTE: Couldn't find any "autoresizing" options like iOS
	 * has, this should be replaced with that if found.
	 */
	setFrame: function() {
		UI.View.prototype.setFrame.apply(this, arguments);
		var frame = this.getFrame();
		this.webView.setFrame(0, 0, frame[2], frame[3]);
	},

	/**
	 * Tells AdView what kind of view this is
	 * and when to reuse it
	 */
	reuseIdentifier: function() {
		return "web";
	},
	
	/**
	 * Should prepare the current creative view to be reused
	 * Only called if canBeReused returns true
	 */
	prepareForReuse: function() {
		this.webView.loadUrl("about:blank");
		this.fs.deleteFile(this.cacheLocation);
		this.cacheLocation = null;
        this.loaded = false;
        this.touched = false;
	},
	
	/**
	 * Whether or not the current creative view can be reused
	 * Reuseable creative views are encouraged to lower memory and cpu usage
	 */
	canBeReused: function() {
		return true;
	},
	
	/**
	 * Load the current creative
	 */
	loadWithCreative: function($super, creative) {
		$super(creative);
		
		var ts = parseInt((new Date()).getTime(), 10);
		this.cacheLocation = "MobclixTempCreative-"+ts+".html";
		
		$mc.log("Loading HTML: ", this.currentCreative.html);
		
		this.fs.writeFile(this.cacheLocation, this.currentCreative.html);
		this.webView.loadDocument(this.cacheLocation);
	},
	
	onShouldLoad: function(event) {
        if(this.loaded && !this.touched) {
            try {
                this.adView.currentCreative.getEvents().triggerEvent("touch");
            } catch(e) { }
        }
        this.touched = true;
		if(!this.useRichMedia) {
			this.adView.openActionURL(this.currentCreative, event.url);
			return false;
		}
		
		var shouldOpenInNewWindow = this.getParameterByName(event.url, "shouldOpenInNewWindow", null);
		
		if ((this.webView.expanded || this.webView.fullscreen) &&
				shouldOpenInNewWindow != "yes") {
			return true;
		} else if (shouldOpenInNewWindow == "no") {
			return true;
		}
		
		// If not an expanded or fullscreen ad, check if another modal is open
		if (!this.webView.expanded && !this.webView.fullscreen) {
			if(!this.adView.shouldTouchThrough()) {
				$mc.log("Already in modal, can't open:", url);
				return false;
			}
			this.adView.willTouchThrough();
		}
		
		var browser = new Browser();
		
		var self = this;
		browser.onDidFinish = function() {
			// If not an expanded or fullscreen ad, reset touchThrough status
			if (!self.webView.expanded && !self.webView.fullscreen)
				self.adView.didTouchThrough(self);
			self.webView.adDidReturnFromHidden();
			self.webView.resumeListeners();
		};
		this.webView.adWillBecomeHidden();
		this.webView.pauseListeners();
	
		browser.loadUrl(event.url);
		browser.presentViewController(true);
		browser.release();
		browser = null;

		return false;
	},
	
	onPageEvent: function(event) {
		$mc.log("WebView webgame Page Event: ", JSON.stringify(event));
        var method = event.eventStream.split("?")[0];
        if (method == "setUserAgent") {
            var userAgent = this.getParameterByName(event.eventStream, "ua") || null;
            Controller.setUserAgent(userAgent);
        }
	},

	onStartLoad: function(event) {
		$mc.log("WebView webgame Page Start Load: ", JSON.stringify(event));
	},

	onPageLoad: function(event) {
		$mc.log("WebView webgame Page Load: ", JSON.stringify(event));
		if (!this.loaded) {
			this.adView.creativeViewFinishedLoading(this, this.currentCreative);
			this.loaded = true;
            try {
                this.webView.invoke("var uaUrl = \"ngcore://setUserAgent?ua=\" + escape(navigator.userAgent); window.location=uaUrl;");
            } catch (err) {}
		}
	},

	onError: function(event) {
		$mc.log("WebView webgame Error: ", JSON.stringify(event));
	},
	
	/**
	 * Stop all loading of the creative
	 */
	stopLoading: function() {
		this.webView.stopLoading();
	},
	
	/**
	 * Called after a creative has been displayed, any post-display 
	 * events or actions that need to be triggered, should be triggered here
	 */
	creativeHasBeenDisplayed: function() {
		
	},
	
	/**
	 * Clean up
	 */
	destroy: function($super) {
		$mc.log('Web - destroy - adView_frame: ');
		this.webView.removeFromParent();
		
		try {
			this.webView.release();
			this.webView = null;
		} catch (e) {
			$mc.log("Exception while destroying WebView: ", e);
		}
			
		try {
			this.fs.deleteFile(this.cacheLocation);
			this.fs = null;
			this.cacheLocation = null;
		} catch (e) {
			$mc.log("Exception while destroying CreativeView.Web: ", e);
		}
		
		this.proxyListener = null;
		
		$super();
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/CreativeView/FullScreen'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/FullScreen'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/FullScreen'] = exports; //
//  Mobclix.CreativeView.FullScreen.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Controller = require('NGCore/Client/Mobclix/Core/Controller').Controller;
var UI = require('NGCore/Client/UI').UI;
var Device = require('NGCore/Client/Device').Device;
var Storage = require('NGCore/Client/Storage').Storage;
var Base = require('NGCore/Client/Mobclix/CreativeView/Base').Base;
var MMWebView = require('NGCore/Client/Mobclix/Core/MMWebView').MMWebView;
var RMWebView = require('NGCore/Client/Mobclix/CreativeView/WebView').WebView;
var Browser = require('NGCore/Client/Mobclix/Browser').Browser;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var ProxyListener = Core.MessageListener.subclass({
	onUpdate: function() {}
});

exports.FullScreen = Base.subclass(
/** @lends Mobclix.CreativeView.FullScreen.prototype */
{
	__className: "Mobclix.CreativeView.FullScreen",
	browser: null,
	cacheLocation: null,
	fs: null,
	useRichMedia: false,
	loaded: false,
    touched: false,
    
	/**
	 * @class Web CreativeView class for display {@link Mobclix.Creative.Web} creatives
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @extends Mobclix.Creative.Base
	 * @private
	 */
	initialize: function($super) {
		$super();

        $mc.log("Initializing the FullScreen CreativeView");
        
		var self = this;
        
        
		
        
        $mc.log("Initializing the FileSystem");
		this.fs = Storage.FileSystem;
		
        $mc.log("Setting up poxylistener");
		this.proxyListener = new ProxyListener();
		$mc.log("Adding life cycle listener");
		Device.LifecycleEmitter.addListener(this.proxyListener, function(event) {
			$mc.log("life cycle changed!");
			if(event == Device.LifecycleEmitter.Event.Terminate) {
				self.fs.deleteFile(this.cacheLocation);
				self.fs = null;
				self.cacheLocation = null;
			}
		});
		$mc.log("Added life cycle listener");
	},
	
	/**
	 * Resize the internal webview if our bounds change
	 * 
	 * NOTE: Couldn't find any "autoresizing" options like iOS
	 * has, this should be replaced with that if found.
	 *
	setFrame: function() {
		UI.View.prototype.setFrame.apply(this, arguments);
		var frame = this.getFrame();
		this.webView.setFrame(0, 0, frame[2], frame[3]);
	},*/

	/**
	 * Tells AdView what kind of view this is
	 * and when to reuse it
	 */
	reuseIdentifier: function() {
		return "fullscreen";
	},
	
	/**
	 * Should prepare the current creative view to be reused
	 * Only called if canBeReused returns true
	 */
	prepareForReuse: function() {
		//this.webView.loadUrl("about:blank");
		this.fs.deleteFile(this.cacheLocation);
		this.cacheLocation = null;
        this.loaded = false;
        this.touched = false;
	},
	
	/**
	 * Whether or not the current creative view can be reused
	 * Reuseable creative views are encouraged to lower memory and cpu usage
	 */
	canBeReused: function() {
		return true;
	},
	
	/**
	 * Load the current creative
	 */
	loadWithCreative: function($super, creative) {
		$super(creative);
		
		var ts = parseInt((new Date()).getTime(), 10);
		this.cacheLocation = "MobclixTempCreative-"+ts+".html";
		
		$mc.log("Loading HTML: ", this.currentCreative.html);
		
        var browserType = Browser.Type.Toolbar;
        if (this.currentCreative.html.search(/<meta[^>]*MobclixUseWidgetStyle/i) != -1)
            browserType = Browser.Type.Minimal;
        if (this.currentCreative.html.search(/<meta[^>]*MobileAdsUseWidgetStyle/i) != -1)
            browserType = Browser.Type.Minimal;
        
        var self = this;
        
        $mc.log("Creating browser");
		this.browser = new Browser(browserType, this);
        
        // Set the frame here to prevent iOS scaling issues.
        var screenSize = {width: NGWindow.getWidth(), height: NGWindow.getHeight()};
		var startFullScreenFrame = [0, screenSize.height, screenSize.width, screenSize.height];
        this.browser.setFrame(startFullScreenFrame);
        
        this.browser.onDidFinish = function() {
            try {
                if(typeof self.adView.onDismissAd == 'function') {
                    self.adView.onDismissAd(self.adView);
                }
            } catch (err) {}
            try {
                self.adView._canRequestNextAd = true;
            } catch (err) {}
        };
        
		this.fs.writeFile(this.cacheLocation, this.currentCreative.html);
		this.browser.loadWithCreative(this.cacheLocation);
	},
	
	/**
	 * Stop all loading of the creative
	 */
	stopLoading: function() {
		//this.webView.stopLoading();
	},
	
    display: function() {
        this.browser.presentViewController(true);
		this.browser.release();
		this.browser = null;
    },
    
	/**
	 * Called after a creative has been displayed, any post-display 
	 * events or actions that need to be triggered, should be triggered here
	 */
	creativeHasBeenDisplayed: function() {
		
	},
	
	/**
	 * Clean up
	 */
	destroy: function($super) {
		$mc.log('Web - destroy - fullscreen creativeview: ');
		
		try {
			this.browser.release();
            this.browser = null;
		} catch (e) {
			$mc.log("Exception while destroying Browser: ", e);
		}
			
		try {
			this.fs.deleteFile(this.cacheLocation);
			this.fs = null;
			this.cacheLocation = null;
		} catch (e) {
			$mc.log("Exception while destroying CreativeView.Web: ", e);
		}
		
		this.proxyListener = null;
		
		$super();
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/MMClass'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMClass'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMClass'] = exports; //
//  Mobclix.Core.MMClass.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;
var __internalMMClassCounter = 0;

exports.Memory =
/** @lends Mobclix.Core.MMClass.prototype */
{
	__className: "MMClass",
	retainCount: 0,
	__instanceId: 0,

	/**
	 * @class MMClass provides a base foundation for memory managed objects
	 * @description Any objects that subclass MMClass will have their memory managed for them
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @private
	 */
	initialize: function($super) {
		if($super) $super();
		this.__instanceId = ++__internalMMClassCounter;
		// $mc.log("--- initialized: "+this.__description()+" ---");
		this.retain();
	},
	
	/**
	 * Redirects all calls to $addProperty
	 * @private
	 * @see Mobclix.Utils#$addProperty
	 * @function
	 * @static
	 */
	$addProperty: function(propName, shouldRetain, defaultValue) {
		$mc.addProperty(this, propName, shouldRetain, defaultValue);
	},
	
	/**
	 * Gets the description of the current object
	 *  @private
	 */
	__description: function() {
		var hash = this.__instanceId.toString();
		while(hash.length < 5) 	hash = "0" + hash;

		return "[" + this.__className + " 0x" + hash + "]";
	},
	
	/**
	 * Increase the instances retain count by one
	 * @return	current instance
	 * @private
	 */
	retain: function() {
		this.retainCount++;
		// $mc.log("--- retained: "+this.__description()+", new count: "  + this.retainCount + " ---");
		return this;
	},
	
	/**
	 * Schedules {@link #release} to be called at the start of the next run loop
	 * @see Mobclix.Core.MMClass.release
	 * @return	current instance
	 * @private
	 */
	autorelease: function() {
		var self = this;
		setTimeout(function() {
			self.release();
		}, 1);
		return this;
	},
	
	/**
	 * Decreases the instances retain count by one
	 * If the retainCount hits 0, the object will call {@link #destroy}.
	 * @see Mobclix.Core.MMClass.destroy
	 * @private
	 */
	release: function() {
		this.retainCount--;

		// $mc.log("--- released: "+this.__description()+", new count: "  + this.retainCount + " ---");
		
		if(this.retainCount <= 0) {
			this.destroy();
		}
	},
	
	/**
	 * Convers the object to a useable string format
	 * @private
	 */
	toString: function() {
		return "[" + this.__className + " object]";
	},
	
	/**
	 * @private
	 */
	destroy: function($super) {
		// $mc.log("--- destroy: "+this.__description()+" ---");
		if($super) $super();
	}
	
};

exports.MMClass = Core.Class.subclass(exports.Memory);
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/Session'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Session'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/Session'] = exports; //
//  Mobclix.Core.Session.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

exports.Session = Core.Class.singleton({
	identifier: null,
	connectionType: null,

	initialize: function() {

	},
	
	renewIdentifier: function() {
		this.identifier = $mc.sha1(Core.Capabilities.getUniqueId() + Core.Time.getRealTime());
		$mc.log("Generated session identifier: " + this.identifier);
	},
	
	update: function() {
		
	},
	
	destroy: function() {
		this.identifier = null;
		this.connectionType = null;
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/SessionTracking'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/SessionTracking'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/SessionTracking'] = exports; //
//  Mobclix.Core.SessionTracking.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Storage = require('NGCore/Client/Storage').Storage;
var Config = require('NGCore/Client/Mobclix/Core/Config').Config;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;
var Session = require('NGCore/Client/Mobclix/Core/Session').Session;

exports.SessionTracking = Core.Class.subclass({
	offlineSessionCount: 0,
	sessionStartDate: null,
	sessionWentIdleDate: null,
	sessionEndDate: null,
	idleSessionTime: 0.0,
	lastSessionLength: 0.0,
	dataFile: null,
	firstRun: false,
	
	initialize: function($super, controller) {
		if($super) $super();

		this.dataFile = "MobclixSessionTracking-" + controller.getApplicationId() + ".json";
		
		this.offlineSessionCount = 0;
		this.lastSessionLength = 0.0;
		this.idleSessionTime = 0.0;
		this.firstRun = true;
		
		var self = this;

		this.loadSessionTrackingData(function() {
			if(self.lastSessionLength == 0 && self.sessionWentIdleDate) {
				self.sessionEndDate = self.sessionWentIdleDate;
				self.lastSessionLength = (self.sessionEndDate.getTime() - self.sessionStartDate.getTime()) / 1000;
			}

			self.startNewSession();
		});
	},
	
	startNewSession: function() {
		this.sessionStartDate = new Date();
		this.sessionWentIdleDate = null;
		this.sessionEndDate = null;
	},

	// Application State Tracking

	didBecomeActive: function() {
		if(!this.sessionWentIdleDate) return; // First launch.

		var now = new Date();
		var idleInterval = (now.getTime() - this.sessionWentIdleDate.getTime()) / 1000;
		$mc.log("idleInterval: ", idleInterval);

		if(idleInterval >= Config.getIdleTimeoutInterval()) {
			$mc.log("Starting new session!");
			this.lastSessionLength = (this.sessionWentIdleDate.getTime() - this.sessionStartDate.getTime()) / 1000;
			Session.renewIdentifier();
			Config.updateConfiguration(require('NGCore/Client/Mobclix/Core/Controller').Controller);
			this.startNewSession();
		} else if(Config.hasConfigFailed()) {
			this.offlineSessionCount--; // Config will auto-increase this if it fails again.
			Config.updateConfiguration(require('NGCore/Client/Mobclix/Core/Controller').Controller);
		} else {
			this.idleSessionTime += idleInterval;
			$mc.log("Within idle timeout range: ", Config.getIdleTimeoutInterval());
		}

		this.saveSessionTrackingData();
	},
	
	willGoInactive: function() {
		this.sessionWentIdleDate = new Date();
		this.saveSessionTrackingData();
	},

	willTerminate: function() {
		this.sessionEndDate = new Date();
		this.lastSessionLength = (this.sessionEndDate.getTime() - this.sessionStartDate.getTime()) / 1000;
		this.saveSessionTrackingData();
	},
	
	// Session Tracking Data Management
	
	loadSessionTrackingData: function(callback) {
		Storage.FileSystem.readFile(this.dataFile, false, function(error, value) {
			try {
				value = eval("("+value+")");
			} catch(e) { }
			
			if(value && typeof value == 'object' && value.length > 0) {
				this.offlineSessionCount = $mc.parseDouble(value.offlineSessionCount) || 0.0;
				
				this.idleSessionTime = $mc.parseDouble(value.idleSessionTime) || 0.0;
				
				if(value.sessionStartDate) {
					try { this.sessionStartDate = new Date(value.sessionStartDate); } catch (e) { }
				}
				
				if(value.sessionWentIdleDate) {
					try { this.sessionWentIdleDate = new Date(value.sessionWentIdleDate); } catch (e) { }
				}
				
				if(value.sessionEndDate) {
					try { this.sessionEndDate = new Date(value.sessionEndDate); } catch (e) { }
				}
				
				this.lastSessionLength = $mc.parseDouble(value.lastSessionLength) || 0.0;

				if(value.firstRun) {
					this.firstRun = $mc.parseBool(value.firstRun);
				}
			}
			
			callback();
		});
	},
	
	saveSessionTrackingData: function() {
		var data = {};
		data.offlineSessionCount = this.offlineSessionCount;
		data.idleSessionTime = this.idleSessionTime;
		data.lastSessionLength = this.lastSessionLength;
		data.firstRun = this.firstRun ? "true" : "false";

		if(this.sessionStartDate) {
			data.sessionStartDate = this.sessionStartDate.toString();
		}

		if(this.sessionWentIdleDate) {
			data.sessionWentIdleDate = this.sessionWentIdleDate.toString();
		}

		if(this.sessionEndDate) {
			data.sessionEndDate = this.sessionEndDate.toString();
		}

		try {
			Storage.FileSystem.writeFile(this.dataFile, JSON.stringify(data));
		} catch(e) { }
	},
	
	
	// Clean up
	
	destroy: function($super) {
		this.sessionEndDate = null;
		this.sessionStartDate = null;
		this.sessionWentIdleDate = null;
		this.originalUDID = null;

		dataFile.release();
		_environment.release();
		
		if($super) $super();
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/ViewController'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/ViewController'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/ViewController'] = exports; //
//  Mobclix.ViewController.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var UI = require('NGCore/Client/UI').UI;
var MMView = require('NGCore/Client/Mobclix/Core/MMView').MMView;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var ViewController = exports.ViewController = MMView.subclass(
/** @lends Mobclix.ViewController.prototype */
{
	__className: "Mobclix.ViewController",
	_isPresented: false,
	initialize: function($super) {
		$super();
		
		this.setBackgroundColor("00");
	},
	
	presentViewController: function(animated) {
		animated = animated || false;

		var screenSize = {width: NGWindow.getWidth(), height: NGWindow.getHeight()};
		
		var startFullScreenFrame = [0, screenSize.height, screenSize.width, screenSize.height];
		var finalFullScreenFrame = [0, 0, screenSize.width, screenSize.height];
		this.setFrame(startFullScreenFrame);
		
		this.viewWillAppear(animated);
		NGWindow.document.addChild(this);
		var self = this;
		
		if(animated) {
			UI.animate(function() {
				self.setFrame(finalFullScreenFrame);
			}, 300, function() {
				self.viewDidAppear(true);
			});
		} else {
			this.setFrame(finalFullScreenFrame);
			this.viewDidAppear(false);
		}
	},
	
	dismissViewController: function(animated) {
		$mc.log("animated: ", animated);
		animated = animated || false;
		this.viewWillDisappear(animated);
		var self = this;
		
		if(animated) {
			UI.animate(function() {
				self.setFrame([0, NGWindow.getHeight(), NGWindow.getWidth(), NGWindow.getHeight()]);
			}, 300, function() {
				self.removeFromParent();
				self.viewDidDisappear(true);
			});
		} else {
			this.removeFromParent();
			this.viewDidDisappear(false);
		}
	},
	
	isPresented: function() {
		return this._isPresented;
	},

	viewWillAppear: function(animated) {
		this.retain();
		this._isPresented = true;
	},
	
	viewDidAppear: function(animated) {
	},
	
	viewWillDisappear: function(animated) {
		this._isPresented = false;
	},
	
	viewDidDisappear: function(animated) {
		this.release();
	},
	
	destroy: function($super) {
		$super();
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Core/MMWebView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMWebView'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Core/MMWebView'] = exports; //
//  Mobclix.Core.MMWebView.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var UI = require('NGCore/Client/UI').UI;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var MMWebView = exports.MMWebView = UI.WebView.subclass($mc.extend(require('NGCore/Client/Mobclix/Core/MMView').MMViewMethods, {
	__className: "MMWebView"
}));; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Creative/Base'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Base'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Base'] = exports; //
//  Mobclix.Creative.Base.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var MMClass = require('NGCore/Client/Mobclix/Core/MMClass').MMClass;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var Action = require('NGCore/Client/Mobclix/Creative/Action').Action;
var Events = require('NGCore/Client/Mobclix/Creative/Events').Events;

// Creative Types
exports.Types = {
	Web: 1,
	Text: 2,
	Banner: 3
};

exports.Base = MMClass.subclass(
/** @lends Mobclix.Creative.Base.prototype */
{
	__className: "Mobclix.Creative.Base",

	// @public properties
	identifier: "",
	type: null,
	events: null,
	properties: {},
	action: null,
	requestParameters: {},

	/**
	 * @class Base class for different creative types.
	 * @constructs The default constructor. 
	 * @param	$super This parameter is stripped out during execution. Do not supply it.
	 * @param	{object} obj	JSON creative used to create this model
	 * @private
	 */
	initialize: function($super, obj) {
		$super();
		var x = 0;

		try {
			this.identifier = obj.creative.id || "";
		} catch(e) {
			this.identifier = "";
		}

		var creativeType = null;
		try {
			creativeType = obj.creative.type || "web";
		} catch(e) {
			creativeType = "web";
		}

		switch(creativeType) {
			case 'html':
			case 'web':
			default:
				this.type = exports.Types.Web;
		}
		
		try {
			this.properties = obj.creative.props || {};
		} catch(e) {
			this.properties = {};
		}

		try {
			if(obj.creative.action) {
				this.action = new Action(obj.creative.action);
			}
		} catch (e) { }

		try {
			var eventUrls = null;
			try {
				eventUrls = obj.creative.eventUrls || {};
			} catch(e) {
				eventUrls = null;
			}

			this.events = new Events(eventUrls);
		} catch(e) {
			$mc.log("Exception creating events.. ", e);
		}
		
		try {
			this.requestParameters = this.properties.params || {};
		} catch(e) {
			this.requestParameters = {};
		}
	},
	
	getAction: function() {
		return this.action;
	},
	
	getEvents: function() {
		return this.events;
	},
	
	// Destructor
	destroy: function($super) {
		$mc.log("Destroying creative");
		this.identifier = null;
		this.type = null;
		this.events = null;
		this.properties = null;
		if(this.action) this.action.release();
		this.requestParameters = null;
		$super();
	}
	
});

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Creative/Web'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Web'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Web'] = exports; //
//  Mobclix.Creative.Web.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var Base = require('NGCore/Client/Mobclix/Creative/Base').Base;

exports.Web = Base.subclass(
/** @lends Mobclix.Creative.Web.prototype */
{
	__className: "Mobclix.Creative.Web",

	html: "",
	
	/**
	 * @class Web class for the web creative.
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @param	{object} obj	JSON creative used to create this model
	 * @augments Mobclix.Creative.Base
	 * @private
	 */
	initialize: function($super, obj) {
		$super(obj);
		
		try {
			this.html = this.properties.html || "";
		} catch(e) {
			this.html = "";
		}
	},
	
	/**
	 * Destroys the current object
	 * @private
	 */
	destroy: function($super) {
		this.html = "";
		$super();
	}
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Creative/Action'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Action'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Action'] = exports; //
//  Mobclix.Creative.Action.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var MMClass = require('NGCore/Client/Mobclix/Core/MMClass').MMClass;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;
var Browser = require('NGCore/Client/Mobclix/Browser').Browser;

exports.Action = MMClass.subclass({
	
	__className: "Mobclix.Creative.Action",
	action: null,
	events: null,
	
	initialize: function($super, obj) {
		$super();
		
		this.action = obj;
		
		var eventUrls = null;
		try {
			eventUrls = obj.creative.eventUrls || {};
		} catch(e) {
			eventUrls = null;
		}
		
		this.events = new Events(eventUrls);
	},
	
	shouldAutoplay: function() {
		return $mc.parseBool(this.action.autoplay) || false;
	},
	
	getEvents: function() {
		return this.events;
	},
	
	getUrl: function() {
		return this.action.url || null;
	},
	
	getBrowserType: function() {
		try {
			var browserType = this.action.browserType.toLowerCase();
			
			if(browserType == "minimal") {
				return Browser.Type.Minimal;
			} else if(browserType == "full") {
				return Browser.Type.Full;
			} else if(browserType == "navigation") {
				return Browser.Type.Navigation;
			} else {
				return Browser.Type.Toolbar;
			}
		} catch(e) {
			$mc.log("Exception getting browser type: ", e);
			return Browser.Type.Toolbar;
		}
	},
	
	destroy: function($super) {
		this.events.release();
		$super();
	}
	
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/Creative/Events'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Events'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/Creative/Events'] = exports; //
//  Mobclix.Creative.Events.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var MMClass = require('NGCore/Client/Mobclix/Core/MMClass').MMClass;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;
var HTTPRequest = require('NGCore/Client/Mobclix/Core/HTTPRequest').HTTPRequest;
var Controller = require('NGCore/Client/Mobclix/Core/Controller').Controller;

exports.Events = MMClass.subclass({
	__className: "Mobclix.Creative.Events",
	events: null,
	
	initialize: function($super, obj) {
		$super();
		
		var self = this;
		this.events = {};
		$mc.each(obj, function(urls, key) {
			var normalizedUrls = [];
			$mc.each(urls, function(url) {
				if(url.toString().indexOf("://") != -1) {
					normalizedUrls.push(url);
				}
				
				if(normalizedUrls.length > 0) {
					key = self._normalizeKey(key);
					self.events[key] = normalizedUrls;
				}
			});
		});
	},
	
	triggerEvent: function(name) {
		name = this._normalizeKey(name);
		if(!this.events[name] || this.events[name].length == 0) return;
		
		$mc.each(this.events[name], function(url) {
			var request = new HTTPRequest;
			request.start({
				url: url,
				type: "get",
                userAgent: Controller.getUserAgent()
			});
			request.release();
		});
	},
	
	_normalizeKey: function(key) {
		return key.toString().replace(/^on/i, "").toLowerCase();
	},

	destroy: function($super) {
		this.events.release();
		$super();
	}
	
});
; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/CreativeView/Base'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/Base'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/Base'] = exports; //
//  Mobclix.CreativeView.Base.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var Core = require('NGCore/Client/Core').Core;
var MMView = require('NGCore/Client/Mobclix/Core/MMView').MMView;

var Base = exports.Base = MMView.subclass(
/** @lends Mobclix.CreativeView.Base.prototype */
{
	__className: "Mobclix.CreativeView.Base",
	adView: null,
	
	/**
	 * @class Base CreativeView class.
	 * @constructs The default constructor. 
	 * @param $super This parameter is stripped out during execution. Do not supply it.
	 * @private
	 */
	initialize: function($super) { $super(); },
	
	/**
	 * Tells AdView what kind of view this is
	 * and when to reuse it
	 */
	reuseIdentifier: function() {
		return null;
	},
	
	/**
	 * Should prepare the current creative view to be reused
	 * Only called if canBeReused returns true
	 */
	prepareForReuse: function() {
		
	},
	
	/**
	 * Whether or not the current creative view can be reused
	 * Reuseable creative views are encouraged to lower memory and cpu usage
	 */
	canBeReused: function() {
		return false;
	},
	
	/**
	 * Load the current creative
	 */
	loadWithCreative: function(creative) {
		this.currentCreative = creative;
	},
	
	/**
	 * Stop all loading of the creative
	 */
	stopLoading: function() {
		
	},
	
	/**
	 * Called after a creative has been displayed, any post-display 
	 * events or actions that need to be triggered, should be triggered here
	 */
	creativeHasBeenDisplayed: function() {
		
	},
	
	/**
	 * Clean up!
	 */
	destroy: function($super) {
		this.currentCreative = null;
		$super();
	}
});

(function() {
	Base.addProperty('currentCreative', true);
})();

; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/CreativeView/WebView'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/WebView'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/WebView'] = exports; //
//  Mobclix.CreativeView.WebView.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var UI = require('NGCore/Client/UI').UI;
var Core = require('NGCore/Client/Core').Core;
var Device = require('NGCore/Client/Device').Device;
var Controller = require('NGCore/Client/Mobclix/Core/Controller').Controller;
var WebViewMessageListener = require('NGCore/Client/Mobclix/CreativeView/WebViewMessageListener').WebViewMessageListener;
var MMWebView = require('NGCore/Client/Mobclix/Core/MMWebView').MMWebView;
var Browser = require('NGCore/Client/Mobclix/Browser').Browser;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var WebView = exports.WebView = MMWebView.subclass({
	__className: "Mobclix.CreativeView.WebView",

    parentCreative: null,
    
    // Permissions
    uniqueKey: "",
    autoplay: true,
    requireUserInteraction: false,
    hasUserInteracted: false,
    
    // State tracking
    screenCover: null,
    backButton: null,
    adView_frame: [0,0,0,0],
    expanded: false,
    fullscreen: false,
    detaching: false,
    dont_destroy_me: false,
    
    // GPS
    gpsDistanceFilter: 0.0,
    gpsDataCallbackFunctionName: null,
    gpsListenerAdded: false,
    gpsEnabled: false,
    networkEnabled: false,
    
    messageListener: null,
    
    // Display Callbacks
    adDidDisplayCallbackFunctionName: null,
    adFinishedResizingCallbackFunctionName: null,
    adWillContractCallbackFunctionName: null,
    adWillTerminateCallbackFunctionName: null,
    adWillBecomeHiddenCallbackFunctionName: null,
    adDidReturnFromHiddenCallbackFunctionName: null,
    
    initialize: function($super, obj) {
		$super(obj);
		
        this.createBackButton();
        
        this.messageListener = new WebViewMessageListener(this);
        
        Device.KeyEmitter.addListener(this.messageListener, this.messageListener.onKeyEvent, 10000);
        Device.LifecycleEmitter.addListener(this.messageListener, this.messageListener.onLifecycleEvent, 10000);
	},
    
    createBackButton: function()
    {
    	// Add a back button.
        this.backButton = new UI.Button();
        this.backButton.setNormalText('x');
        this.backButton.setTextSize(32);
        this.backButton.setTextGravity(UI.ViewGeometry.Gravity.Center);
        this.backButton.setFrame([10, 10, 32, 32]);
        this.backButton.setNormalGradient({
            corners: '12 12 12 12',
            outerLine: "00 3",
            //gradient: [ "FF9bd6f4 0.0", "FF0077BC 1.0" ]
            gradient: [ "FFFF0000 0.0", "FFFF0000 1.0" ]
        });
        this.backButton.setHighlightedGradient({
            corners: '12 12 12 12',
            outerLine: "00 3",
            //gradient: [ "FF0077BC 0.0", "FF9bd6f4 1.0" ]
            gradient: [ "FF990000 0.0", "FF990000 1.0" ]
        });
        var self = this;
        this.backButton.onclick = function() {
            self.close(300);
        };
    
    },
    
    pauseListeners: function()
    {
        this.messageListener.pauseListeners();
    },
    
    resumeListeners: function()
    {
        this.messageListener.resumeListeners();
    },
    
    getParameterByName: function(url, name, d)
    {
        name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
        var regexS = "[\\?&]"+name+"=([^&#]*)";
        var regex = new RegExp( regexS );
        var results = regex.exec( url );
        if( results == null )
            return d;
        else
            return decodeURIComponent(results[1].replace(/\+/g, " "));
    },
    
    onPageEvent: function(event)
    {
        if (event == null) {
            NGWindow.log("WebView webgame Page Event: null");
        }
		NGWindow.log(["WebView webgame Page Event: ", event.eventStream]);
        var method = event.eventStream.split("?")[0];
        
        if (method == "domReady") {
            this.domReady();
        } else if (method == "checkPermissionsForUserInteractionResponse") {
            this.checkPermissionsForUserInteractionResponse(event.eventStream);
        } else if (method == "accelerometerStart") {
            this.accelerometerStart(event.eventStream);
        } else if (method == "accelerometerStop") {
            this.accelerometerStop(event.eventStream);
        } else if (method == "gyroscopeStart") {
            this.gyroscopeStart(event.eventStream);
        } else if (method == "gyroscopeStop") {
            this.gyroscopeStop(event.eventStream);
        } else if (method == "magnetometerStart") {
            this.magnetometerStart(event.eventStream);
        } else if (method == "magnetometerStop") {
            this.magnetometerStop(event.eventStream);
        } else if (method == "deviceMotionStart") {
            this.deviceMotionStart(event.eventStream);
        } else if (method == "deviceMotionStop") {
            this.deviceMotionStop(event.eventStream);
        } else if (method == "gpsStart") {
            this.gpsStart(event.eventStream);
        } else if (method == "gpsStop") {
            this.gpsStop(event.eventStream);
        } else if (method == "deviceAccelerometerAvailable") {
            this.deviceAccelerometerAvailable(event.eventStream);
        } else if (method == "deviceGyroscopeAvailable") {
            this.deviceGyroscopeAvailable(event.eventStream);
        } else if (method == "deviceDeviceMotionAvailable") {
            this.deviceDeviceMotionAvailable(event.eventStream);
        } else if (method == "deviceGPSAvailable") {
            this.deviceGPSAvailable(event.eventStream);
        } else if (method == "deviceMagnetometerAvailable") {
            this.deviceMagnetometerAvailable(event.eventStream);
        } else if (method == "deviceVibrateAvailable") {
            this.deviceVibrateAvailable(event.eventStream);
        } else if (method == "deviceEmailAvailable") {
            this.deviceEmailAvailable(event.eventStream);
        } else if (method == "deviceSMSAvailable") {
            this.deviceSMSAvailable(event.eventStream);
        } else if (method == "deviceShakeListeningAvailable") {
            this.deviceShakeListeningAvailable(event.eventStream);
        } else if (method == "deviceVibrate") {
            this.deviceVibrate(event.eventStream);
        } else if (method == "deviceStartShakeListening") {
            this.deviceStartShakeListening(event.eventStream);
        } else if (method == "deviceStopShakeListening") {
            this.deviceStopShakeListening(event.eventStream);
        } else if (method == "deviceAlert") {
            this.deviceAlert(event.eventStream);
        } else if (method == "deviceBatteryState") {
            this.deviceBatteryState(event.eventStream);
        } else if (method == "deviceUniqueId") {
            this.deviceUniqueId(event.eventStream);
        } else if (method == "deviceModel") {
            this.deviceModel(event.eventStream);
        } else if (method == "deviceSystemVersion") {
            this.deviceSystemVersion(event.eventStream);
        } else if (method == "deviceHardwareModel") {
            this.deviceHardwareModel(event.eventStream);
        } else if (method == "deviceConnectionType") {
            this.deviceConnectionType(event.eventStream);
        } else if (method == "deviceLanguage") {
            this.deviceLanguage(event.eventStream);
        } else if (method == "deviceLocale") {
            this.deviceLocale(event.eventStream);
        } else if (method == "deviceScalingFactor") {
            this.deviceScalingFactor(event.eventStream);
        } else if (method == "devicePlatform") {
            this.devicePlatform(event.eventStream);
        } else if (method == "deviceScreenSize") {
            this.deviceScreenSize(event.eventStream);
        } else if (method == "deviceScreenDensity") {
            this.deviceScreenDensity(event.eventStream);
        } else if (method == "deviceInterfaceOrientation") {
            this.deviceInterfaceOrientation(event.eventStream);
        } else if (method == "deviceCurrentOrientation") {
            this.deviceCurrentOrientation(event.eventStream);
        } else if (method == "displayExpandToFullScreen") {
            this.displayExpandToFullScreen(event.eventStream);
        } else if (method == "displayResizeTo") {
            this.displayResizeTo(event.eventStream);
        } else if (method == "displayContractAd") {
            this.displayContractAd(event.eventStream);
        } else if (method == "displayOpenInBrowser") {
            this.displayOpenInBrowser(event.eventStream);
        } else if (method == "displaySetAdDidDisplayCallback") {
            this.setAdDidDisplayCallback(event.eventStream);
        } else if (method == "displaySetAdFinishedResizingCallback") {
            this.setAdFinishedResizingCallback(event.eventStream);
        } else if (method == "displaySetAdWillContractCallback") {
            this.setAdWillContractCallback(event.eventStream);
        } else if (method == "displaySetAdWillTerminateCallback") {
            this.setAdWillTerminateCallback(event.eventStream);
        } else if (method == "displaySetAdWillBecomeHiddenCallback") {
            this.setAdWillBecomeHiddenCallback(event.eventStream);
        } else if (method == "displaySetAdDidReturnFromHiddenCallback") {
            this.setAdDidReturnFromHiddenCallback(event.eventStream);
        } else if (method == "displaySetAllDisplayCallbacks") {
            this.setAllDisplayCallbacks(event.eventStream);
        } else
            this.loadUrl("http://www.yahoo.com");
	},
    
    guidGenerator: function()
    {
        var S4 = function() {
           return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
        };
        return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
    },
    
    callback: function(callbackFunctionName, value, addQuotes)
    {
        var js = callbackFunctionName;
        if (addQuotes)
            js += "(\"";
        else
            js += "(";
        
        if (value != null)
            js += value;
        
        if (addQuotes)
            js += "\")";
        else
            js += ")";
            
        NGWindow.log(["WebView - callback: ", js]);
        return js;
    },
    
    domReady: function()
    {
        this.uniqueKey = this.guidGenerator();
        this.invoke("window.addEventListener('click', function(){mAdViewPermissionsKey=" + this.uniqueKey + ";}, true);");
    },
    
    checkPermissionsForUserInteraction: function(callback, errorCallbackFunctionName)
    {
        var js = "try { window.location=\"ngcore://checkPermissionsForUserInteractionResponse?uniquekey=mAdViewPermissionsKey";
        if (callback != null && callback != "") {
            js += "&callback=" + escape(callback)
        }
        js += "; } catch (e) { + " + errorCallbackFunctionName + "('User has not interacted with ad yet.');}";
        this.invoke(js);
    },
    
    checkPermissionsForUserInteractionResponse: function(uri)
    {
        var uniqueKey = this.getParameterByName(uri, "uniqueKey") || null;
        var callback = this.getParameterByName(uri, "callback") || null;
        if (this.uniqueKey == uniqueKey) {
            this.hasUserInteracted = true;
            
            if (callback != null && callback != "null") {
                this.invoke(unescape(callback));
            }
        }
    },
    
    
    // ****** SENSORS *********
    
    accelerometerStart: function(uri)
    {
        NGWindow.log(['WebView - accelerometerStart: ', uri]);
        var interval = this.getParameterByName(uri, "interval") || null;
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (Core.Capabilities.getHasAccel()) {
                this.messageListener.accelerometerListenerCallbackFunctionName = callbackFunctionName;
                this.messageListener.accelerometerListenerInterval = interval * 1000;
                Device.MotionEmitter.addListener(this.messageListener, this.messageListener.onMotionEvent, 10000);
                
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                        this.invoke(this.callback(errorCallbackFunctionName, "Device does not support an accelerometer.", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    accelerometerStop: function(uri)
    {
        NGWindow.log(['WebView - accelerometerStop: ', uri]);
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            this.messageListener.accelerometerListenerCallbackFunctionName = null;
            this.messageListener.checkRemoveMotionListener();
            
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    gyroscopeStart: function(uri)
    {
        NGWindow.log(['WebView - gyroscopeStart: ', uri]);
        var interval = this.getParameterByName(uri, "interval") || null;
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (Core.Capabilities.getHasGyro()) {
                this.messageListener.gyroscopeListenerCallbackFunctionName = callbackFunctionName;
                this.messageListener.gyroscopeListenerInterval = interval * 1000;
                Device.MotionEmitter.addListener(this.messageListener, this.messageListener.onMotionEvent, 10000);
                
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                        this.invoke(this.callback(errorCallbackFunctionName, "Device does not support a gyroscope.", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    gyroscopeStop: function(uri)
    {
        NGWindow.log(['WebView - gyroscopeStop: ', uri]);
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            this.messageListener.gyroscopeListenerCallbackFunctionName = null;
            this.messageListener.checkRemoveMotionListener();
            
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    magnetometerStart: function(uri)
    {
        NGWindow.log(['WebView - magnetometerStart: ', uri]);
        var interval = this.getParameterByName(uri, "interval") || null;
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (Core.Capabilities.getHasCompass()) {
                this.messageListener.compassListenerCallbackFunctionName = callbackFunctionName;
                this.messageListener.compassListenerInterval = interval * 1000;
                Device.MotionEmitter.addListener(this.messageListener, this.messageListener.onMotionEvent, 10000);
                
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                        this.invoke(this.callback(errorCallbackFunctionName, "Device does not support the magnetometer.", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    magnetometerStop: function(uri)
    {
        NGWindow.log(['WebView - magnetometerStop: ', uri]);
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            this.messageListener.magnetometerListenerCallbackFunctionName = null;
            
            this.messageListener.checkRemoveMotionListener();
            
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    deviceMotionStart: function(uri)
    {
        NGWindow.log(['WebView - deviceMotionStart: ', uri]);
        var interval = this.getParameterByName(uri, "interval") || null;
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        if (errorCallbackFunctionName != null)
            this.invoke(this.callback(errorCallbackFunctionName, "Device does not support device motion.", false));
    },
    
    deviceMotionStop: function(uri)
    {
        NGWindow.log(['WebView - deviceMotionStop: ', uri]);
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        if (errorCallbackFunctionName != null)
            this.invoke(this.callback(errorCallbackFunctionName, "Device does not support device motion.", false));
    },
    
    gpsStart: function(uri)
    {
        NGWindow.log(['WebView - gpsStart: ', uri]);
        var distanceFilter = this.getParameterByName(uri, "distanceFilter") || null;
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (Core.Capabilities.getHasGps()) {
                this.messageListener.gpsListenerCallbackFunctionName = callbackFunctionName;
                this.messageListener.gpsListenerDistanceFilter = distanceFilter;
                Device.LocationEmitter.addListener(this.messageListener, this.messageListener.onLocationEvent, 10000);
                
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                        this.invoke(this.callback(errorCallbackFunctionName, "Device does not support GPS location.", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    gpsStop: function(uri)
    {
        NGWindow.log(['WebView - gpsStop: ', uri]);
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            this.messageListener.gpsListenerCallbackFunctionName = null;
            this.messageListener.gpsListenerDistanceFilter = 0;
            this.messageListener.gpsListenerLastReportedLongitude = 0;
            this.messageListener.gpsListenerLastReportedLatitude = 0;
            
            Device.LocationEmitter.removeListener(this.messageListener);
            
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    
    
    
    
    // ******* DEVICE *********
    
    deviceAccelerometerAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceAccelerometerAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var b = "false";
        if (Core.Capabilities.getHasAccel())
            b = "true";
        else
            b= "false";
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, b, false));
    },
    
    deviceGyroscopeAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceGyroscopeAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var b = "false";
        if (Core.Capabilities.getHasGyro())
            b = "true";
        else
            b= "false";
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, b, false));
    },
    
    deviceDeviceMotionAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceDeviceMotionAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var b = "false";
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, b, false));
    },
    
    deviceGPSAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceGPSAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var b = "false";
        if (Core.Capabilities.getHasGps())
            b = "true";
        else
            b= "false";
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, b, false));
    },

    deviceMagnetometerAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceMagnetometerAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var b = "false";
        if (Core.Capabilities.getHasCompass())
            b = "true";
        else
            b= "false";
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, b, false));
    },
    
    deviceVibrateAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceVibrateAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;

        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, "false", false));
    },
    
    deviceEmailAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceEmailAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, "true", false));
    },
    
    deviceSMSAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceSMSAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, "true", false));
    },
    
    deviceShakeListeningAvailable: function(uri)
    {
        NGWindow.log(['WebView - deviceShakeListeningAvailable: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var b = "false";
        if (Core.Capabilities.getHasAccel())
            b = "true";
        else
            b= "false";
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, b, false));
    },
    
    deviceVibrate: function(uri)
    {
        NGWindow.log(['WebView - deviceVibrate: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;

        if (errorCallbackFunctionName != null)
            this.invoke(this.callback(errorCallbackFunctionName, "Device does not support vibrate.", false));
    },
    
    deviceStartShakeListening: function(uri)
    {
        NGWindow.log(['WebView - deviceStartShakeListening: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (Core.Capabilities.getHasAccel()) {               
                this.messageListener.shakeListenerCallbackFunctionName = callbackFunctionName;
                
                Device.ShakeEmitter.addListener(this.messageListener, this.messageListener.onShakeEvent, 10000);
                
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                        this.invoke(this.callback(errorCallbackFunctionName, "Device does not support shaking.", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    deviceStopShakeListening: function(uri)
    {
        NGWindow.log(['WebView - deviceStopShakeListening: ', uri]);
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            Device.ShakeEmitter.removeListener(this.messageListener);
            
            this.messageListener.shakeListenerCallbackFunctionName = null;
            
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), false));
        }
    },
    
    deviceAlert: function(uri)
    {
        NGWindow.log(['WebView - deviceAlert: ', uri]);
        var title = this.getParameterByName(uri, "title") || null;
        var message = this.getParameterByName(uri, "message") || null;
        var buttonTitles = this.getParameterByName(uri, "buttonTitles") || null;
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
        
        try {
            var dialog = new UI.AlertDialog();
            dialog.setTitle(title);
            dialog.setText(message);
            var buttonArray = buttonTitles.split("|");
            dialog.setChoices(buttonArray);
            var self = this;
            dialog.setOnChoice( function(event) {
                NGWindow.log(['WebView - deviceAlert - choice: ', event, callbackFunctionName]);
                self.invoke(self.callback(callbackFunctionName, event.choice + ", '" + buttonArray[event.choice] + "'", false));
                dialog.hide();
            });
            dialog.show();
        } catch (error) { }
    },
    
    deviceBatteryState: function(uri)
    {
        NGWindow.log(['WebView - deviceBatteryState: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, "unavailable", true));
    },
    
    deviceUniqueId: function(uri)
    {
        NGWindow.log(['WebView - deviceUniqueId: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getUniqueId(), true));
    },

    deviceModel: function(uri)
    {
        NGWindow.log(['WebView - deviceModel: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getDeviceName(), true));
    },
    
    deviceSystemVersion: function(uri)
    {
        NGWindow.log(['WebView - deviceSystemVersion: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getPlatformOSVersion(), true));
    },
    
    deviceHardwareModel: function(uri)
    {
        NGWindow.log(['WebView - deviceHardwareModel: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getPlatformHW(), true));
    },
    
    deviceConnectionType: function(uri)
    {
        NGWindow.log(['WebView - deviceConnectionType: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Controller.getNetworkState(), true));
    },
    
    deviceLanguage: function(uri)
    {
        NGWindow.log(['WebView - deviceLanguage: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getLanguage(), true));
    },
    
    deviceLocale: function(uri)
    {
        NGWindow.log(['WebView - deviceLocale: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getLocale(), true));
    },
    
    deviceScalingFactor: function(uri)
    {
        NGWindow.log(['WebView - deviceScalingFactor: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getScreenUnits(), true));
    },
    
    devicePlatform: function(uri)
    {
        NGWindow.log(['WebView - devicePlatform: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getPlatformOS(), true));
    },
    
    deviceScreenSize: function(uri)
    {
        NGWindow.log(['WebView - deviceScreenSize: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getScreenWidth() + ", " +
                              Core.Capabilities.getScreenHeight(), false));
    },
    
    deviceScreenDensity: function(uri)
    {
        NGWindow.log(['WebView - deviceScreenDensity: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, Core.Capabilities.getScreenPixelUnits(), false));
    },
    
    deviceCurrentOrientation: function(uri)
    {
        NGWindow.log(['WebView - deviceScreenDensity: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        var r = "landscape";
    
        var o = Device.OrientationEmitter.getDeviceOrientation();
        if (o == Device.OrientationEmitter.Orientation.Portrait ||
                o == Device.OrientationEmitter.Orientation.PortraitUpsideDown) 
            r = "portrait";
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, r, true));
    },
    
    deviceInterfaceOrientation: function(uri)
    {
        NGWindow.log(['WebView - deviceScreenDensity: ', uri]);
        var callbackFunctionName = this.getParameterByName(uri, "callbackFunctionName") || null;
    
        var r = "landscape";
    
        var o = Device.OrientationEmitter.getInterfaceOrientation();
        if (o == Device.OrientationEmitter.Orientation.Portrait ||
                o == Device.OrientationEmitter.Orientation.PortraitUpsideDown) 
            r = "portrait";
    
        if (callbackFunctionName != null)
            this.invoke(this.callback(callbackFunctionName, r, true));
    },
    
    

    
    
    
    
    
    // *********** DISPLAY ************
    
    displayExpandToFullScreen: function(uri)
    {
        NGWindow.log('ngcore: displayExpandToFullScreen');
            
        var animationDuration = this.getParameterByName(uri, "animationDuration") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (this.fullscreen) {
                if (errorCallbackFunctionName != null)
                    this.invoke(this.callback(errorCallbackFunctionName, "Cannot expand a fullscreen ad", false));
                return;
            }
        
            if (!this.autoplay && !this.userHasInteracted) {
                var js = "window.location=" + uri;
                this.checkPermissionsForUserInteraction(js);
                return;
            }
            
            if (this.expandTo(animationDuration,0,0,
                              Core.Capabilities.getScreenWidth(),
                              Core.Capabilities.getScreenHeight())) {                          
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                    this.invoke(this.callback(errorCallbackFunctionName, "Failed to expand", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error, false));
        }
    },
    
    displayResizeTo: function(uri)
    {
        NGWindow.log('ngcore: displayResizeTo');
        
        var x = this.getParameterByName(uri, "x", 0);
        var y = this.getParameterByName(uri, "y", 0);
        var w = this.getParameterByName(uri, "width", 0);
        var h = this.getParameterByName(uri, "height", 0);
        var animationDuration = this.getParameterByName(uri, "animationDuration") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (this.fullscreen) {
                if (errorCallbackFunctionName != null)
                    this.invoke(this.callback(errorCallbackFunctionName, "Cannot resize a fullscreen ad", false));
                return;
            }
        
            if (!this.autoplay && !this.userHasInteracted) {
                var js = "window.location=" + uri;
                this.checkPermissionsForUserInteraction(js);
                return;
            }
            
            if (this.expandTo(animationDuration,x,y,w,h)) {
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                    this.invoke(this.callback(errorCallbackFunctionName, "Failed to expand", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error, false));
        }
    },
    
    displayContractAd: function(uri)
    {
        NGWindow.log('ngcore: displayContractAd');
        var animationDuration = this.getParameterByName(uri, "animationDuration") || null;
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (this.fullscreen) {
                if (errorCallbackFunctionName != null)
                    this.invoke(this.callback(errorCallbackFunctionName, "Cannot contract a fullscreen ad", false));
                return;
            }
        
            if (this.close(animationDuration)) {
                if (successCallbackFunctionName != null)
                    this.invoke(this.callback(successCallbackFunctionName, null, false));
            } else {
                if (errorCallbackFunctionName != null)
                    this.invoke(this.callback(errorCallbackFunctionName, "Failed to contract ad", false));
            }
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error, false));
        }
    },

    exitCallback: function(event)
    {
        NGWindow.log(['WebView - exitCallback: ', event]);
        
        this.close(300);
    },
    
    close: function(duration)
    {
        if (this.expanded == false)
            return false;
        
        if (this.detaching)
            return false;
        this.detaching = true;
        
        if (duration <= 0) duration = 1;
        if (duration > 3000) duration = 3000;
        
        
        var self = this;
        var parentAdViewFrame;
        parentAdViewFrame = this.parentCreative.adView.getFrame();
        this.adWillContract();
        
        this.backButton.removeFromParent();
        
        UI.animate( function() {
                self.setFrame(parentAdViewFrame);
            }, duration, function() {
                self.adFinishedResizing();
            
                self.dont_destroy_me = true;
                self.removeFromParent();
                self.parentCreative.addChild(self);
                self.dont_destroy_me = false;
                
                self.setFrame(self.adView_frame);
                
                self.screenCover.removeFromParent();
                self.expanded = false;
                self.detaching = false;
                
                self.parentCreative.adView.didTouchThrough(this.parentCreative);
            });
        return true;
    },


    expandTo: function(duration, x, y, width, height)
    {
        NGWindow.log('WebView - expandTo');
        
        if (duration <= 0) duration = 1;
        if (duration > 3000) duration = 3000;
        
        var self = this;
        if (this.expanded == false) {
            if (!this.parentCreative.adView.shouldTouchThrough())
                return false;

            this.parentCreative.adView.willTouchThrough(this.parentCreative);
        
            if (this.detaching)
                return false;
            this.detaching = true;
        
            NGWindow.log('WebView - expandTo - expanding');
            this.adView_frame = this.getFrame(this.adView_frame);
            NGWindow.log(['WebView - expandTo - adView_frame: ', this.adView_frame]);
            
            this.screenCover = new UI.View();
            this.screenCover.setFrame([0,0,
                                       Core.Capabilities.getScreenWidth(),
                                       Core.Capabilities.getScreenHeight()]);
            
            /*var backgroundView = new UI.Button();
            backgroundView.setFrame([0,0,320,800]);
            backgroundView.setBackgroundColor("000000");
            backgroundView.setAlpha(0.3);
            this.screenCover.addChild(backgroundView);*/
            
            var closeCover = new UI.Button();
            closeCover.setFrame([0,0,
                                 Core.Capabilities.getScreenWidth(),
                                 Core.Capabilities.getScreenHeight()]);
            closeCover.setBackgroundColor("000000");
            closeCover.setAlpha(0.3);
            this.screenCover.addChild(closeCover);
            
            
            closeCover.setOnClick(function(event) {
                self.exitCallback(event);
            });
            
            NGWindow.document.addChild(this.screenCover);
            
            this.dont_destroy_me = true;
            this.parentCreative.removeChild(this);
            this.screenCover.addChild(this);
            this.dont_destroy_me = false;
            
            var parentAdViewFrame;
            parentAdViewFrame = this.parentCreative.adView.getFrame();
            this.setFrame(parentAdViewFrame);
            
            this.detaching = false;
            this.expanded = true;

        }
        
        try {
            this.backButton.removeFromParent();
        } catch (error) {}
        if (width >= Core.Capabilities.getScreenWidth() * .8 ||
                height >= Core.Capabilities.getScreenHeight() * .8) {
            this.screenCover.addChild(this.backButton);
        }
        
        UI.animate( function() {
                self.setFrame([x,y,width,height]);
            }, 500, function() {
                self.adFinishedResizing();
            });
        
        return true;
    },
    
    displayOpenInBrowser: function(uri)
    {
        NGWindow.log('ngcore: displayOpenInBrowser');
        var url = this.getParameterByName(uri, "url");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName") || null;
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName") || null;
        
        try {
            if (!this.autoplay && !this.userHasInteracted) {
                var js = "window.location=" + uri;
                this.checkPermissionsForUserInteraction(js);
                return;
            }
        
            var browser = new Browser();
            browser.onDidFinish = function() {
                // Whatever you need to do
            };
            
            browser.loadUrl(url);
            browser.presentViewController(true);
            browser.release();
            browser = null;
            
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, error.toString(), true));
        }
    },
    
    
    
    // ************** DISPLAY LISTENERS *****************
    
    setAdDidDisplayCallback: function(uri)
    {
        var adDidDisplayCallback = this.getParameterByName(uri, "adDidDisplayCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adDidDisplayCallback = adDidDisplayCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    adDidDisplay: function()
    {
        if (this.adDidDisplayCallback != null)
            this.invoke(this.callback(this.adDidDisplayCallback, null, false));
    },
    
    setAdFinishedResizingCallback: function(uri)
    {
        var adFinishedResizingCallback = this.getParameterByName(uri, "adFinishedResizingCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adFinishedResizingCallback = adFinishedResizingCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    adFinishedResizing: function()
    {
        if (this.adFinishedResizingCallback != null)
            this.invoke(this.callback(this.adFinishedResizingCallback, null, false));
    },
    
    setAdWillContractCallback: function(uri)
    {
        var adWillContractCallback = this.getParameterByName(uri, "adWillContractCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adWillContractCallback = adWillContractCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    adWillContract: function()
    {
        if (this.adWillContractCallback != null)
            this.invoke(this.callback(this.adWillContractCallback, null, false));
    },
    
    setAdWillTerminateCallback: function(uri)
    {
        var adWillTerminateCallback = this.getParameterByName(uri, "adWillTerminateCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adWillTerminateCallback = adWillTerminateCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    adWillTerminate: function()
    {
        if (this.adWillTerminateCallback != null)
            this.invoke(this.callback(this.adWillTerminateCallback, null, false));
    },
    
    setAdWillBecomeHiddenCallback: function(uri)
    {
        var adWillBecomeHiddenCallback = this.getParameterByName(uri, "adWillBecomeHiddenCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adWillBecomeHiddenCallback = adWillBecomeHiddenCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    adWillBecomeHidden: function()
    {
        if (this.adWillBecomeHiddenCallback != null)
            this.invoke(this.callback(this.adWillBecomeHiddenCallback, null, false));
    },
    
    setAdDidReturnFromHiddenCallback: function(uri)
    {
        var adDidReturnFromHiddenCallback = this.getParameterByName(uri, "adDidReturnFromHiddenCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adDidReturnFromHiddenCallback = adDidReturnFromHiddenCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    adDidReturnFromHidden: function()
    {
        if (this.adDidReturnFromHiddenCallback != null)
            this.invoke(this.callback(this.adDidReturnFromHiddenCallback, null, false));
    },
    
    setAllDisplayCallbacks: function(uri)
    {
        var adFinishedResizingCallback = this.getParameterByName(uri, "adFinishedResizingCallbackFunctionName");
        var adWillContractCallback = this.getParameterByName(uri, "adWillContractCallbackFunctionName");
        var adWillTerminateCallback = this.getParameterByName(uri, "adWillTerminateCallbackFunctionName");
        var adWillBecomeHiddenCallback = this.getParameterByName(uri, "adWillBecomeHiddenCallbackFunctionName");
        var adDidReturnFromHiddenCallback = this.getParameterByName(uri, "adDidReturnFromHiddenCallbackFunctionName");
        var successCallbackFunctionName = this.getParameterByName(uri, "successCallbackFunctionName");
        var errorCallbackFunctionName = this.getParameterByName(uri, "errorCallbackFunctionName");
        try {
            this.adFinishedResizingCallback = adFinishedResizingCallback;
            this.adWillContractCallback = adWillContractCallback;
            this.adWillTerminateCallback = adWillTerminateCallback;
            this.adWillBecomeHiddenCallback = adWillBecomeHiddenCallback;
            this.adDidReturnFromHiddenCallback = adDidReturnFromHiddenCallback;
            if (successCallbackFunctionName != null)
                this.invoke(this.callback(successCallbackFunctionName, null, false));
        } catch (error) {
            if (errorCallbackFunctionName != null)
                this.invoke(this.callback(errorCallbackFunctionName, escape(error.toString()), true));
        }
    },
    
    
    /**
	 * Destroys the current object
	 * @private
	 */
	destroy: function($super) {
        NGWindow.log('WebView - destroy');
        if (this.dont_destroy_me) {

        } else {
            if (this.screenCover != null) {
                this.screenCover.removeFromParent();
                this.screenCover.destroy();
            }
            
            messageListener.destroy();
            
            $super();
        }
	}
});; return exports;};
$MODULE_FACTORY_REGISTRY['NGCore/Client/Mobclix/CreativeView/WebViewMessageListener'] = function(){var exports = $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/WebViewMessageListener'] || {}; $MODULE_REGISTRY['NGCore/Client/Mobclix/CreativeView/WebViewMessageListener'] = exports; //
//  Mobclix.Core.MMWebViewMessageListener.js
//  Mobclix Mobage SDK
//
//  Copyright 2011 Mobclix. All rights reserved.
//

var UI = require('NGCore/Client/UI').UI;
var Core = require('NGCore/Client/Core').Core;
var Device = require('NGCore/Client/Device').Device;
var $mc = require('NGCore/Client/Mobclix/Core/Utils').Utils;

var WebViewMessageListener = exports.WebViewMessageListener = Core.MessageListener.subclass({
	__className: "WebViewMessageListener",
    
    webview: null,
    
    accelerometerListenerCallbackFunctionName: null,
    accelerometerListenerInterval: 0,
    accelerometerListenerLastTimestamp: 0,
    
    gyroscopeListenerCallbackFunctionName: null,
    gyroscopeListenerInterval: 0,
    gyroscopeListenerLastTimestamp: 0,
    
    compassListenerCallbackFunctionName: null,
    compassListenerInterval: 0,
    compassListenerLastTimestamp: 0,
    
    shakeListenerCallbackFunctionName: null,
    gpsListenerCallbackFunctionName: null,
    gpsListenerDistanceFilter: 0,
    gpsListenerLastReportedLongitude: 0,
    gpsListenerLastReportedLatitude: 0,
    
    initialize: function($super, webview) {
		$super();
		this.webview = webview;
	},
    
    pauseListeners: function()
    {
        try {
            Device.ShakeEmitter.removeListener(this);
        } catch (error) {}
        try {
            Device.MotionEmitter.removeListener(this);
        } catch (error) {}
        try {
            Device.LocationEmitter.removeListener(this);
        } catch (error) {}
    },
    
    resumeListeners: function()
    {
        try {
            if (this.shakeListenerCallbackFunctionName != null) {
                Device.ShakeEmitter.addListener(this, this.onShakeEvent, 10000);
            }
        } catch (error) {}
        try {
            Device.MotionEmitter.addListener(this, this.onMotionEvent, 10000);
            this.checkRemoveMotionListener();
        } catch (error) {}
        try {
            if (this.gpsListenerCallbackFunctionName != null) {
                Device.LocationEmitter.addListener(this, this.onLocationEvent, 10000);
            }
        } catch (error) {}
    },
    
    onKeyEvent: function(params) {
        NGWindow.log(["MMWebViewMessageListener - onKeyEvent - event: ", params]);
    },
    
    onLifecycleEvent: function(params) {
        NGWindow.log(["MMWebViewMessageListener - onLifecycleEvent - event: ", params]);
        if (params == Device.LifecycleEmitter.Event.Suspend) {
            this.webview.adWillBecomeHidden();
            this.pauseListeners();
        } else if (params == Device.LifecycleEmitter.Event.Resume) {
            this.webview.adDidReturnFromHidden();
            this.resumeListeners();
        } else if (params == Device.LifecycleEmitter.Event.Terminate) {
            this.webview.adWillTerminate();
            this.pauseListeners();
        }
    },
 
    onMotionEvent: function(params) {
        var t = (new Date()).getTime();
        if (this.accelerometerListenerCallbackFunctionName != null &&
                t > this.accelerometerListenerLastTimestamp + this.accelerometerListenerInterval) {
            this.accelerometerListenerLastTimestamp = t;
            var data = params.getAccelData();
            try {
                this.webview.invoke(this.webview.callback(this.accelerometerListenerCallbackFunctionName,
                                                          data[0] + "," + data[1] + "," + data[2],
                                                          false));
            } catch (error) {}
        }
        if (this.gyroscopeListenerCallbackFunctionName != null &&
                t > this.gyroscopeListenerLastTimestamp + this.gyroscopeListenerInterval) {
            this.gyroscopeListenerLastTimestamp = t;
            var data = params.getGyroData();
            try {
                this.webview.invoke(this.webview.callback(this.gyroscopeListenerCallbackFunctionName,
                                                          data[0] + "," + data[1] + "," + data[2],
                                                          false));
            } catch (error) {}
        }
        if (this.compassListenerCallbackFunctionName != null &&
                t > this.compassListenerLastTimestamp + this.compassListenerInterval) {
            this.compassListenerLastTimestamp = t;
            var data = params.getCompassData();
            try {
                this.webview.invoke(this.webview.callback(this.compassListenerCallbackFunctionName,
                                                          data[0],
                                                          false));
            } catch (error) {}
        }
    },
    
    checkRemoveMotionListener: function() {
        NGWindow.log(["MMWebViewMessageListener - checkRemoveMotionListener"]);
        if (this.accelerometerListenerCallbackFunctionName == null &&
                this.gyroscopeListenerCallbackFunctionName == null &&
                this.compassListenerCallbackFunctionName == null) {
            try {
                NGWindow.log(["MMWebViewMessageListener - checkRemoveMotionListener - trying to remove listener"]);
                Device.MotionEmitter.removeListener(this);
            } catch (error) {
                NGWindow.log(["MMWebViewMessageListener - checkRemoveMotionListener - error: ", error.toString()]);
            }
        }
    },
 
    onLocationEvent: function(params)
    {
        if (this.gpsListenerCallbackFunctionName != null) {
            try {
                if (distanceBetweenCoordinates(
                        params.getPosition().getX(),
                        params.getPosition().getY(),
                        this.gpsListenerLastReportedLongitude,
                        this.gpsListenerLastReportedLatitude) < this.gpsListenerDistanceFilter) {
                    return;
                }
                
                this.gpsListenerLastReportedLongitude = params.getPosition().getX();
                this.gpsListenerLastReportedLatitude = params.getPosition().getY();
            
                var locationData = { "coordinate": { "latitude": params.getPosition().getX(),
                                                     "longitude": params.getPosition().getY() },
                                     "course": params.getHeading(),
                                     "speed": 0,
                                     "timestamp": params.getTimestamp(),
                                     "horizontalAccuracy": params.getAccuracy(),
                                     "verticalAccuracy": params.getAccuracy() };
                this.webview.invoke(this.webview.callback(this.gpsListenerCallbackFunctionName,
                                                          "eval('(" + JSON.stringify(locationData) + ")')",
                                                          false));
            
            } catch (error) {}
        }
    },
    
    distanceBetweenCoordinates: function(long1, lat1, long2, lat2)
    {
        var R = 6371000; // meters
        return Math.acos(Math.sin(lat1)*Math.sin(lat2) + 
                         Math.cos(lat1)*Math.cos(lat2) *
                         Math.cos(long2-long1)) * R;
    },
 
    onShakeEvent: function(params)
    {
        NGWindow.log(['MMWebViewMessageListener - onShakeEvent: ', params]);
        if (this.shakeListenerCallbackFunctionName != null)
            webview.invoke(this.callback(this.shakeListenerCallbackFunctionName, null, false));
    },
    
    /**
	 * Destroys the current object
	 * @private
	 */
	destroy: function($super) {
        NGWindow.log('MMWebViewMessageListener - destroy');
        
        try {
            Device.KeyEmitter.removeListener(this);
        } catch (error) {}
        try {
            Device.LifecycleEmitter.removeListener(this);
        } catch (error) {}
        try {
            Device.ShakeEmitter.removeListener(this);
        } catch (error) {}
        try {
            Device.MotionEmitter.removeListener(this);
        } catch (error) {}
        try {
            Device.LocationEmitter.removeListener(this);
        } catch (error) {}
        
        $super();
	}
});; return exports;};
(function()
{
	if(!Function.prototype.hasOwnProperty('bind'))
	{
		var slice = Array.prototype.slice;
		Function.prototype.bind = function(context)
		{
			var func = this;
			if(arguments.length > 1)
			{
				var args = slice.call(arguments, 1);
				return function()
				{
					if(arguments.length)
					{
						var finalArgs = args.concat(slice.call(arguments));
						return func.apply(context, finalArgs);
					}
					else
					{
						return func.apply(context, args);
					}
				}
			}
			else
			{
				return function()
				{
					if(arguments.length)
						return func.apply(context, arguments);
					else
						return func.call(context);
				}
			}
		}
	}
})();

(function()
{
	if(!Array.prototype.hasOwnProperty('indexOf'))
	{
		Array.prototype.indexOf = function(obj)
		{
			var len = this.length;
			for(var i=0; i < this.length; ++i)
			{
				if(obj === this[i])
					return i;
			}
			return -1;
		}
	}
})();

function userGameInit()
{
	console.log("ngCore calling main()");
	main();
}
//////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-11-0?
 *  @file:      NgWebEngine.js
 *  Website:    http://www.ngmoco.com/
 *  Copyright:  2010, by ngmoco:)
 *              Unauthorized redistribution of source code is 
 *              strictly prohibited. Violators will be prosecuted.
 * 
 *  @brief:
 */
//////////////////////////////////////////////////////////////////////////////
var NGSetTimeoutRunTimers = require('NGCore/Client/UI/NGJSEnvironmentSupport').NGSetTimeoutRunTimers;
var SystemBinding = require('NGCore/Client/UI/SystemBinding').SystemBinding;
var UI = require('NGCore/Client/UI').UI;
var AlertDialog = UI.AlertDialog;
var ProgressDialog = UI.ProgressDialog;
var Downloader = require('NGCore/Client/Network/DownloadManifest').Downloader;
var LocalGameList = require('NGCore/Client/Core/LocalGameList').LocalGameList;
var Device = require('NGCore/Client/Device').Device;
var Core = require('NGCore/Client/Core').Core;
var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Localization = require('NGCore/Client/Core/Localization').Localization;

// Global until oauth does not depend on storage.
Storage = require('NGCore/Client/Storage').Storage;

//////////////////////////////////////////////////////////////////////////////////////////////////
// App switching.

var NgProcID =
{
    PersistProc: -1,
    GameProc: -2
};

//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */

var gNgShutdownPending = false;


/////////////////////////////////////////////////////////////////////////////////////////////////
// Global data.
//////////////////////////////////////////////////////////////////////////////////////////////////

var gNgEngineEntities;
var gNgAddedEngineEntities;
var gNgRemovedEngineEntities;

var gNgUpdateEngineEntities;
var gNgTouchEngineEntities;
var gNgKeyPressEngineEntities;


//////////////////////////////////////////////////////////////////////////////////////////////////
// This function is called once by the html container to initialize the game.
//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */

function NgEngineInitPrivate()
{
	NgLogInit();

	NgApplication.getInstance().restart();

	gNgEngineEntities = new Array();
	gNgAddedEngineEntities = new Array();
	gNgRemovedEngineEntities = new Array();

	gNgUpdateEngineEntities = new Array();
	gNgTouchEngineEntities = new Array();
    gNgKeyPressEngineEntities = new Array();

	Core.Analytics.instantiate();
}

//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */

function NgEngineProcessEntityAddRemove()
{
	for(var i in gNgAddedEngineEntities)
	{
		var e = gNgAddedEngineEntities[i];
		if(e.mIsTouchable) NgInsertSortedTouch(e);
		if(e.mIsKeyable)	NgInsertSortedKeyPress(e);
		if(e.mIsUpdatable) gNgUpdateEngineEntities[e.mId] = e;
	}
	gNgAddedEngineEntities = [];

	for(var i in gNgRemovedEngineEntities)
	{
		var e = gNgRemovedEngineEntities[i];

		if(e.mIsTouchable)	gNgTouchEngineEntities.splice(NgFindIndex(gNgTouchEngineEntities,e),1);
		if(e.mIsKeyable) gNgKeyPressEngineEntities.splice(NgFindIndex(gNgKeyPressEngineEntities,e),1);
		if(e.mIsUpdatable) delete gNgUpdateEngineEntities[e.mId];
	}
	gNgRemovedEngineEntities = [];
}

/**
  * @private
  */

function NgHandleException(ex)
{
	if (Core.Proc.isPrivileged()) {
		NgLogException( ex );
	}
	else {
		var exStr = JSON.stringify(ex);
		NgLogException( ex );
		Core.LocalGameList._forwardException(exStr);
	}
}

function NgEngineInit(inputs)
{
	NgLogD("NgEngineInit beg");
	try
	{
		NgEngineInitPrivate();

		time.setCtr('frame',1000,NgLogD);

		//NgLogD("Initializing Storage");
		//Storage.init();
		//NgLogD("Storage initialized");
		NgLogD("KeyValue Storage initializing...");
		Storage.KeyValueCache.init();
		NgLogD("KeyValue Storage initialized...");
	
		Core.Time.instantiate();
	
		NgLogD("Instantiate the Localization context (singleton), depends on Capabilities");
		Localization.instantiate();

	}
	catch( ex )
	{
		NgHandleException(ex);
	}
	NgLogD("NgEngineInit end");	
	
	return NgEngineUpdate(inputs);
}

function NgPreInit(inputs)
{
	NgLogD("Localization NgPreInit beg");
	return update(inputs);
}

/**
  * @private
  */

function NgGameInit(inputs)
{
	NgLogD("NgGameInit beg");
	try
	{
		NGWindow = UI.Window;

		userGameInit();
	}
	catch( ex )
	{
		NgHandleException(ex);
	}
	NgLogD("NgGameInit end");

	return update(inputs);
}

/**
  * @private
  */

// TEMPORARY: Until native code is updated to call NgEngineUpdate.
function update ( inputs )
{
	return NgEngineUpdate ( inputs );
}

//Frame loop calls this every time, get the object out of require once ahead of time.
var NGSetTimeoutRunTimers = require('NGCore/Client/UI/NGJSEnvironmentSupport').NGSetTimeoutRunTimers;

var setTimeoutOrig = setTimeout;
setTimeout  = function(fn, time)
{
	return setTimeoutOrig(function() 
	{
		try
		{
			fn();
		}
		catch( ex )
		{
			NgHandleException(ex);
		}
	}, time);
	
}


var setIntervalOrig = setInterval;
setInterval  = function(fn, time)
{
	return setIntervalOrig(function() 
	{
		try
		{
			fn();
		}
		catch( ex )
		{
			NgHandleException(ex);
		}
	}, time);
	
}



/**
  *	Main entry point for native to invoke JS.
  * @private
  */
var NgEngineUpdate = (function()
{
	var Core = require('NGCore/Client/Core').Core;
	
return function ( inputs )
{
	// time causes a racehorse-sized leak in v8. Only use this for single profiling runs. DO NOT CHECK IN.
//	time.stop('frame');
//	time.start('frame');
	
	try {
		NGSetTimeoutRunTimers();

		if(inputs.length)
		{
			NgEngineProcessEntityAddRemove();
			var commands = inputs.split(':');
			for(var i=0; i<commands.length; ++i)
			{
				command = commands[i];

				// Make sure this isn't an empty input.
				if(0 == command.length) {
					continue;
				}

				switch(parseInt(command))
				{
					case NgEntityTypes.App:
						NgApplication.getInstance().handleCommand(command);
						break;
					case NgEntityTypes.NgFileSys:
						NgApplication.getInstance().getFileSys().handleCommand(command);
                        break;
					case NgEntityTypes.Storage:
						NgLogD("Command for storage is " + command);
						Storage.getInstanceForCommand(command).handleCommand(command);
						break;
					case NgEntityTypes.NgUI:
						NGWindow.handleCommand(command);
						break;
					case NgEntityTypes.NgSystemBinding:
						SystemBinding.handleCommand(command);
						break;
					case 3117:
						console.log('got leet response');
						if(typeof(_WifiDiagCallback) != 'undefined')
							_WifiDiagCallback(command);
						break;
					default:
						Core.Proc._classRecvGen( command.split( ',' ) );
						break;
				}
			}
		}

		if( gNgShutdownPending )
		{
			gNgShutdownPending = false;
		}
		else	// Don't do updates if we're resetting.
		{
			NgEngineProcessEntityAddRemove();
			for(var i in gNgUpdateEngineEntities)
			{
				var entity = gNgUpdateEngineEntities[i];
				if(!entity.mRegistered) continue;
				entity.onUpdate();
			}
		}
	}
	catch(ex)
	{
		NgHandleException(ex);
	}
		
	var tmp = Core.Proc.getCommandString() + gNgCommandString;
	gNgCommandString = tmp;
	Core.Proc.clearCommandString();

	return NgFlushCommandsToString();
}
})();


//////////////////////////////////////////////////////////////////////////////////////////////////
////	NgApplication class
//////////////////////////////////////////////////////////////////////////////////////////////////

var Capabilities = require('NGCore/Client/Core/Capabilities').Capabilities;
var Logger = require('NGCore/Client/Core/Logger').Logger;

/** @private */

var NgApplicationCommands = {
	Caps : 0,
	Debug : 1,
	FrameTime : 2,
	FrameRate : 3,
	Start : 4,
	DeviceOrientation: 10,
	SetOrientation: 11,
	BackPress: 12,
	OnBackPressed: 13,
	LaunchExternalNativeApp: 15,
	ExitSystemProcess: 16
};

/**
  * Enumeration values for orientation change events received by
  * {@link NgApplicationObserver}.
  */

var NgApplicationOrientation = {
	Portrait : 0,
	PortraitUpsideDown : 1,
	LandscapeLeft : 2,
	LandscapeRight : 3,
	FaceUp : 4,
	FaceDown : 5
};

/**
  * The NgApplication constructor is invoked during application bootstrap and
  * should not be created by the ngGame application.  Access to the application
  * object should be through the singleton accessor {@link NgApplication#getInstance}.
  * @constructor
  *
  * @class
  * The NgApplication class represents global state and services that are available to
  * ngGame applications.  This includes file system operations,
  * download services, etc.  The application class also manages a time source
  * that is synchronized between the native engine and the ngGame application. <br>
  * The application object is a singleton and should only be accessed through the
  * {@link NgApplication#getInstance} method.
  */

function NgApplication()
{
	/** @private */
	this.mFileSys = Storage.FileSystem;
	/** @private */
	this.mFrameTime = 0.0;
	/** @private */
	this.mObservers = [];
}

// Singleton instance.
/** @private */
NgApplication.sInstance = null;

/**
  * Acquire the singleton instance of the application class.
  * @type NgApplication
  * @return The global application object.
  */

NgApplication.getInstance = function()
{
	if( NgApplication.sInstance == null )
		NgApplication.sInstance = new NgApplication();

	return NgApplication.sInstance;
};

// APITODO: Switch these methods to be defined out-of-line, not by an object literal.

NgApplication.prototype =
{
	mFileSys : null,
	mObservers : [],
	mFrameTime : 0.0,
	
	/** @private */
	restart : function()
	{
	},
	
	/** @private */
	handleCommand : function(command)
	{
		//		NgLogD( "NgApplication command = " + command );

		var commandId = NgPeekCommandId( command );

		switch( commandId )
		{
			case NgApplicationCommands.FrameTime:
				this.parseFrameTime( command );
				break;
			case NgApplicationCommands.Start:
				this.onApplicationStart();
				break;
			case NgApplicationCommands.OnBackPressed:
				this.onApplicationBackPressed();
				break;
			default:
				NgLogE( "NgApplication command unknown: " + command);
				break;
		}
	},
	
	/**
	  * Acquire the file system object.
	  * @type NgFileSys
	  * @return The file system instance.
	  */
	getFileSys : function()
	{
		return this.mFileSys;
	},

	/** @private */
	ngLog : function( level, dbgStr )
	{
		NgPushCommand4( NgEntityTypes.App, NgApplicationCommands.Debug, Core.Base64.encode( dbgStr ), level );
	},
	
	/** @private */
	parseFrameTime : function( command )
	{
		var fields = NgParseCommand2(command,parseInt,parseFloat);
		var frameTime = fields[1];

		if(this.mFrameDelta == undefined)
			this.mFrameDelta = 0;
		else
			this.mFrameDelta = frameTime - this.mFrameTime;

		this.mFrameTime = frameTime;
	},
	
	/**
	  * Get the application time for the current frame.
	  * @type number
	  * @return The time in milliseconds.
	  */
	getFrameTime : function()
	{
		return this.mFrameTime;
	},
	
	/**
	  * Get the application time delta between the current frame and the last frame.
	  * @type number
	  * @return The time delta in milliseconds.
	  */
	getFrameDelta : function()
	{
		return this.mFrameDelta;
	},

	/**
	  * Set the desired application frame rate. <br>
	  * Note: The frame rate specification is not currently fully functional on all 
	  * platforms.
	  * @param {number} frameRate The desired frame rate in hz.
	  * @type void
	  */
	setFrameRate : function(frameRate)
	{
		NgPushCommand3( NgEntityTypes.App, NgApplicationCommands.FrameRate, frameRate);
	},

	/**
	  * Set the current device orientation for the application. <br>
	  * Note: Setting the orientation is not currently fully functional on all
	  * platforms.
	  * @param {NgApplicationOrientation} orientation The desired orientation.
	  * @type void
	  */
	setOrientation : function(orientation)
	{
		NgPushCommand3( NgEntityTypes.App, NgApplicationCommands.SetOrientation, orientation);
	},

	/**
	  * Register an application observer to receive application callbacks.
	  * @param {NgApplicationObserver} obs The observer to register.
	  * @type void
	  */
	registerObserver : function(obs)
	{
		obs.index = this.mObservers.push(obs);
	},

	unregisterObserver : function(obs)
	{
		if (obs.index)
			delete this.mObservers[obs.index - 1];
	},

	/** @private */
	onApplicationStart : function()
	{
		NgUI.onLoad();
		for (i in this.mObservers)
		{
			// TODO is this even possible?
			this.mObservers[i].onApplicationStart();
		}
	},
	
	/** @private */
	onApplicationReceivedCustomMessage : function( message )
	{
		for (i in this.mObservers)
		{
			this.mObservers[i].onApplicationReceivedCustomMessage( message );
		}
	},
	
	/** @private */
	onApplicationBackPressed : function()
	{
			var observerResult = false;
			for (i in this.mObservers)
			{
				 if (this.mObservers[i].onApplicationBackPressed())
				 {
					observerResult = true;
					break;
				 }
			}
			if (!observerResult)
			{
				// back button was not fully handled. Ask the native application to handle it.
				NgPushCommand2(NgEntityTypes.App, NgApplicationCommands.BackPress);
			}
	},
	
	/** @private */
	exitSystemProcess : function ()
	{
		NgLogD ( "pushing exit command" );
		//This makes java exit the app through android lifecycle
		NgPushCommand2(NgEntityTypes.App, NgApplicationCommands.BackPress);
		NgLogD ( "pushed exit command" );
	}
};

// Observer base class for application events.

/**
  * Initialize a new application observer.
  * @constructor
  *
  * @class
  * The NgApplicationObserver class is used as the base class for any user-defined
  * class that receives application-level callbacks.  This currently includes
  * notifications on all application lifecycle events and device orientation
  * changes. <br>
  * Register the application observer by calling {@link NgApplication#registerObserver}.
  */

function NgApplicationObserver() {}

NgApplicationObserver.prototype =
{
	index: 0,
	/**
	  * Callback for application lifecycle start event.
	  * @type void
	  */
	onApplicationStart:function() {},

	/** @private */
	onApplicationReceivedCustomMessage:function( message ) {},

	/**
	  * Callback for device orientation change events.
	  * @param {NgApplicationOrientation} orientation Orientation enumeration value.
	  * @type void
	  */
	onApplicationDeviceOrientation:function( orientation ) {},

	/*
	 * Listener for when the user pushes the HW back button. Currently Android only.
	 *
	 * @return boolean true if back was handled entirely (eat the event), 
	 * false if it was not
	 *
	 */
	onApplicationBackPressed:function()
	{
		return false;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////
// class Entity
// Base class for other entity types.
//////////////////////////////////////////////////////////////////////////////////////////////////

// ObjectTypes
// Defined in
//		JS:  NgEntityTypes in NgWebEngine.js and
//		C++: EntityCommandIds in GameView.h
// 1 = App
// 2 = NgTouchEvent
// 3 = NgKeyPressEvent
// 4 = Accel
// 5 = NgTextInputBox2D
// 6 = Animation (completion events)
// 7 = Sound (completion events)
// 8 = EngineEntity
// 9 = DrawableEntity2D
// 10 = NgCanvas2D
// 11 = NgCamera2D
// 12 = NgSprite2D
// 13 = NgText2D
// 14 = NgWebView2D
// 15 = NgAudioManager
// 16 = NgGroup2D
// 100 = LoadApp

// App Commands
// in:
// capabilities = 0, command dictionary format
// frameTime = 2, double
// out:
// NgLogD = 1, string

// NgTouchEvent Commands
// non-native
//	action: 1 = add, 2 = remove, 3 = modify
//	id: touch instance ID
//	x: x position
//	y: y position
// native
//	action: 4 = add, 5 = remove, 6 = modify
//	id: touch instance ID
//	x: x pos
//	y: y pos
//  eid: entity instance ID
//	lx: local x pos
//  ly: local y pos

// NgKeyPressEvent Commands
// action: 1 = down, 2 = up
// id: instance ID
// value: key value

// InputText Box Commands

// Animation
// in:
// only one kind of event, so first value is id of sprite to callback.

// Sound
// in:
//

// Accel Commands
// out:
// SetEventRate = 0, rate (hz)
// in:
// x, y, z position (floats)

// EngineEntity commands

// DrawableEntity2D commands:
// SetNativeTouchType=1,id,value (None=1, Enable = 2, EnableBounds = 3)

// NgCanvas2D Commands
// NewNgCanvas2D=1, id
// DeleteNgCanvas2D=2, id
// Update=3, id, args... not used currently
// SetRoot=4, id, grp id
// ClearRoot=5, id
// EnableNativePicking=6, id, bool

// NgCamera2D Commands
// NewNgCamera2D=1,		id, canvasId, porperties
// DeleteNgCamera2D=2,	id
// UpdateNgCamera2D=3,	id, properties
//	Properties: vx, vy, vz, vh, vw, cx, cy, ch, cw

// NgSprite2D Commands
// NewNgSprite2D=1,		id, canvasId, texture, properties
// DeleteNgSprite2D=2,	id
// UpdateNgSprite2D=3,	id, properties
//   Properties: x, y, z, w, h, r, a

// NgText2D Operations
// NewNgText2D=1		id, canvasId, properties
// DeleteNgText2D=2	id
// UpdateNgText2D=3	id, properties
//  Properties: x, y, z, w, h, justify, text

// NgGroup2D Operations
// New = 1			id, canvasId, [properties/todo]
// Delete = 2		id
// Update = 3		id, [properties/todo]
// Child = 4		id, subcmd, [child id]
//						subcmd 0 = add, 1 = rem, 2 = remAll (no child id)
// Rot = 5			id, anglef
// Pos = 6			id, xf, yf, zf
// Alpha = 7		id, alphaf
// Scale = 8		id, xf, yf

// APITODO: Clean up these identifiers.
// APITODO: Sound is probably not used any more.
// APITODO: Animation is probably not used any more.

var NgEntityTypes = {
	App : 1,
	NgTouchEvent : 2,
	NgKeyPressEvent : 3,
	Accel : 4,
	NgTextInputBox2D : 5,
	Animation : 6,
	Sound : 7,
	NgEngineEntity : 8,
	NgDrawableEntity2D : 9,
	NgCanvas2D : 10,
	NgCamera2D : 11,
	NgSprite2D : 12,
	NgText2D : 13,
	NgWebView2D : 14,
	NgGroup2D : 16,
	NgPhysics2D: 17,
	NgPrimitive2D: 18,
	NgFileSys: 19,
	Gyro : 22,
	NgUI : 23,
	Storage: 24,
	NgSystemBinding: 25,
	NgCustomMessage : 50,
	LoadApp : 100
};

var NgEngineEntityCommandIDs = {
	SetNativeTouchType : 1
};

/**
 * Initializes instance to default values. <br>
 * mId member defaults to 0 but can be set by application before calling {@link NgEngineEntity#register}.
 * @constructor
 *
 * @class
 * NgEngineEntity is the base class for all game entities, such as NgSprite2D and NgText2D. <br>
 * This class introduces key callback functions for touch, key press and per-frame update
 * notification. <br>
 * Additionally, the class introduces a register/unregister mechanism
 * for controlling the existence of the entity in the native game engine.
 *
 */

function NgEngineEntity()
{
	/** The entity id.  Used by the native engine for identification.  @type number */
	this.mId = 0;
	/** The touch priority.  Touches are routed first to the highest priority entities.  @type number */
	this.mTouchPriority = 0;
	/** The key press priority.  Key presses are routed first to the highest priority entities.  @type number */
	this.mKeyPressPriority = 0;
	/** @private */
	this.mIsTouchable = false;
	/** @private */
	this.mIsKeyable = false;
	/** @private */
	this.mIsUpdatable = false;
	/** @private */
	this.mNativeTouchType = NgEngineEntity.NativeTouchType.Enable;
	/** @private */
	this.mRegistered = false;
}

// Static methods and data.

/**
  * NgEngineEntity touch policy enumeration. <br>
  * Used with {@link NgEngineEntity#setNativeTouchType} and {@link NgCanvas2D#enableNativePicking}. <br>
  * Values: <br>
  * None : Disables native touches for this entity (and its children). <br>
  * Enable : Enables this entity to receive touches (or visits child entities) <br>
  * EnableBounds : Enables this entity to receive touches on its axis-aligned bounding box.  If
  * a touch is received on a group, it will report the touch and _not_ visit the group's children.
  */

NgEngineEntity.NativeTouchType = {
	None : 0,
	Enable : 1,
	EnableBounds : 2
};

/**
  * @private
  */

NgEngineEntity.engineCurrentId = 1;

/**
  * Allocate a unique ID for an entity.
  * @return ID value.
  * @type number
  * @private
  */

NgEngineEntity.newEngineId = function ()
{
	return NgEngineEntity.engineCurrentId++;
}

/**
  * Reclaim an entity ID.
  * @private
  */

NgEngineEntity.deleteEngineId = function ()
{
	// Nothing.
}

// Instance methods.

// Basic entity callbacks.

/** @private */

NgEngineEntity.prototype.newEntity = function() {}

/** @private */

NgEngineEntity.prototype.deleteEntity = function() {}

/**
  *	Callback for standard touch events. <br>
  * Standard touch events correspond to all touches
  * within the game view.  For each touch on the game view, all registered touchable
  * entities will receive the event.  Application logic must perform filtering to determine
  * if a particular entity corresponds to the touch event. <br>
  * Refer to {@link NgEngineEntity#toggleTouchable} for control of an entity's touchable state.
  * @param {NgTouchEvent} touch The touch event.
  * @return The application can return true to indicate that it has consumed this event or false
  * to allow other entities to continue processing this event.
  * @type bool
  */

NgEngineEntity.prototype.onTouch = function(touch)
{
	return false;
}

/**
  * Callback for native touch events. <br>
  * Native touch events are pre-filtered by the game engine
  * to correspond to a specific touchable entity.  For each touch on the game view, the game
  * engine will determine which game entities are selected by the touch event.  Only the 
  * selected entities will receive the onNativeTouch event callback. <br>
  * Native touch capability is not affected by touchable state of the entity determined by
  * {@link NgEngineEntity#toggleTouchable}.  Refer to {@link NgEngineEntity#setNativeTouchType} 
  * for management of an entity's native touch policy.
  * @param {NgNativeTouchEvent} touch The touch event.
  * @return The application can return true to indicate that it has consumed this event or false
  * to allow other entities to continue processing this event.
  * @type bool
  */

NgEngineEntity.prototype.onNativeTouch = function(touch)
{

}

/**
  * Callback for keyboard events. <br>These events correspond to physical or software keyboard events. <br>
  * Enable/disable key press events for an entity with {@link NgEngineEntity#toggleKeyable}.
  * @param {NgKeyPressEvent} keyPress The key press event.
  * @return The application can return true to indicate that it has consumed this event or false
  * to allow other entities to continue processing this event.
  * @type bool
  */

NgEngineEntity.prototype.onKeyPress = function(keyPress)
{
	return false;
}

/**
  *	Callback for update events. <br>Per-frame entity logic should be implemented in this callback. <br>
  * Enable/disable update events for an entity with {@link NgEngineEntity#toggleUpdatable}.
  * The return value of this method is ignored.
  * @type void
  */

NgEngineEntity.prototype.onUpdate = function()
{
}

/**
  *	Register this entity instance with the native game engine. <br>
  * The initialization sequence of engine entities has specific constraints: <br>
  * After construction and before calling
  * the register method, class methods that affect the native engine state cannot be called.  
  * During this period, changes to entity state by changing instance variables will be
  * sent to the native engine on the call to register. <br>
  * After register is called, 
  * changes to instance variables will be ignored.  During this phase, the only
  * way to affect native engine state is through methods that push commands to
  * the native side.
  * @type void
  */

NgEngineEntity.prototype.register = function()
{
	this.mParents = new Array();

	if( this.mId >= 0 )
	{
		this.mId = NgEngineEntity.newEngineId();
	}

	this.mRegistered = true;
	gNgEngineEntities[this.mId] = this;
	gNgAddedEngineEntities[this.mId] = this;
	this.newEntity();
}

/**
  * Unregister this entity from the native game engine.
  * @type void
  */

NgEngineEntity.prototype.unregister = function()
{
	var parents = this.mParents.concat(new Array());

	for (var i in parents)
	{
		NgLogD ( "Removing child " + this.mId + " from parent Group " + parents[i].mId + " because the Entity was unregistered");
		parents[i].removeChild( this );
	}

	this.mRegistered = false;
	delete gNgEngineEntities[this.mId];
	// CAUTION : DO NOT SPLICE gNgEngineEntities EVER.
	//gNgEngineEntities.splice(this.mId,1);

	gNgRemovedEngineEntities[this.mId] = this;
	this.deleteEntity();

	if(this.mId >= 0)
		NgEngineEntity.deleteEngineId(this.mId);
}

/**
  * Enable/disable key press callbacks for this entity. <br>This method flips the enable state
  * for key press events. <br>
  * In order to receive key press callbacks, an entity
  * must override the onKeyPress event and enable keyable state by calling this 
  * method. <br>
  * The default state is false.
  * @type void
  */

NgEngineEntity.prototype.toggleKeyable = function()
{
	if(this.mIsKeyable)
		gNgKeyPressEngineEntities.splice(NgFindIndex(gNgKeyPressEngineEntities,this),1);
	else
		NgInsertSortedKeyPress(this);

	this.mIsKeyable = !this.mIsKeyable;
}

/**
  * Enable/disable update callbacks for this entity. <br>
  * This method flips the enable state
  * for update events. <br>
  * In order to receive update callbacks, an entity
  * must override the onUpdate event and enable updatable state by calling this 
  * method. <br>
  * The default state is false.
  * @type void
  */

NgEngineEntity.prototype.toggleUpdatable = function()
{
	if(this.mIsUpdatable)
	{
		delete gNgUpdateEngineEntities[this.mId];
	}
	else
	{
		gNgUpdateEngineEntities[this.mId] = this;
	}
	this.mIsUpdatable = !this.mIsUpdatable;
}

/**
  * Enable/disable touch callbacks for this entity. <br>
  * This method flips the enable state for touch events. <br>
  * In order to receive touch callbacks, an entity
  * must override the onTouch event and enable touchable state by calling this 
  * method. <br>
  * The default state is false.
  * @type void
  */

NgEngineEntity.prototype.toggleTouchable = function()
{
	if(this.mIsTouchable)
		gNgTouchEngineEntities.splice(NgFindIndex(gNgTouchEngineEntities,this),1);
	else
		NgInsertSortedTouch(this);

	this.mIsTouchable = !this.mIsTouchable;
}

/**
  * Set native touch traversal policy. <br>
  * This method controls how the native game engine
  * traverses the game scene graph. <br>
  * The policies are described in further detail with {@link NgEngineEntity#NativeTouchType}. <br>
  * The default state is "Enable".
  * @param {NativeTouchType} type The policy enum for native touch processing.
  * @type void
  */

NgEngineEntity.prototype.setNativeTouchType = function( type )
{
	this.mNativeTouchType = type;
	NgPushCommand4(NgEntityTypes.NgDrawableEntity2D, NgEngineEntityCommandIDs.SetNativeTouchType, this.mId, this.mNativeTouchType );
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
var Core = require('NGCore/Client/Core').Core;

// These methods handle all composition for commands being sent back to the
// native engine.

/**
  * @private
  */

var gNgCommandStrings = [];

/**
  * @private
  */

var gNgCommandString = '';

// 0 deferred string composition via user loop
// 1 deferred string composition via internal loop
// 2 on-the-fly string composition.

// TODO: Benchmark all variation on all platforms.  Choose appropriate one(s)
// and prune code for others.

// UPDATE: ALL variations on contructing a string performed IDENTICALLY in
// the iPhone's UIWebView.  Unbelievable.

/**
  * @private
  */

var gNgCommandMode = 2;

/**
  * @private
  */

function NgQueueCommandText(command)
{
	switch(gNgCommandMode)
	{
		case 0:
		case 1:
			gNgCommandStrings.push( command );
			break;
		case 2:
			gNgCommandString += command;
			break;
	}
}

/**
  * @private
  */

function NgFlushCommandsToString()
{
	var outputString = '';
	
	switch(gNgCommandMode)
	{	
		case 0:
			for( var num = 0, end = gNgCommandStrings.length; num < end; ++num )
			{
				outputString += gNgCommandStrings[ num ];
			}
			break;
			
		case 1:
			outputString = String.prototype.concat.apply(gNgCommandStrings);
			break;
	}
	
	switch(gNgCommandMode)
	{
		case 0:
		case 1:
			gNgCommandStrings = [];
			break;
		case 2:
			outputString = gNgCommandString;
			gNgCommandString = '';
			break;
	}
	
	return outputString;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

function NgParseString(txt)
{
	return txt;
}

/**
  * @private
  */

function NgParseBase64(txt)
{
	if( txt )
		return Core.Base64.decode(txt);
	else
		return "";
}

/**
  * @private
  */

function NgParseBool(txt)
{
	return parseInt(txt) ? true : false;
}

function NgParseInt(txt)
{
	return parseInt(txt, 10);
}

function NgKVArrayToCmd(kvArray)
{
	var out = "";
	var count = 0
	for (var s in kvArray)
	{
		var value = kvArray[s];
		
		out += "," + s + "," + Core.Base64.encode(value);
		++count;
	}
	return count + out;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Submit a command with 1 argument to the native engine.
 * @private
 */
function NgPushCommand1(arg1)
{
	gNgCommandString += ":" + arg1;
}

/**
 * Submit a command with 2 arguments to the native engine.
 * @private
 */
function NgPushCommand2(arg1, arg2)
{
	gNgCommandString += ":" + arg1 + "," + arg2;
}

/**
 * Submit a command with 3 arguments to the native engine.
 * @private
 */
function NgPushCommand3(arg1, arg2, arg3)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3;
}

/**
 * Submit a command with 4 arguments to the native engine.
 * @private
 */
function NgPushCommand4(arg1, arg2, arg3, arg4)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4;
}

/**
 * Submit a command with 5 arguments to the native engine.
 * @private
 */
function NgPushCommand5(arg1, arg2, arg3, arg4, arg5)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5;
}

/**
 * Submit a command with 6 arguments to the native engine.
 * @private
 */
function NgPushCommand6(arg1, arg2, arg3, arg4, arg5, arg6)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6;
}

/**
 * Submit a command with 7 arguments to the native engine.
 * @private
 */
function NgPushCommand7(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6 + "," + arg7;
}

/**
 * Submit a command with 8 arguments to the native engine.
 * @private
 */
function NgPushCommand8(arg1, arg2, arg3, arg4, arg5, arg6, arg7,arg8)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6 + "," + arg7 + "," + arg8;
}

/**
 * Submit a command with 8 arguments to the native engine.
 * @private
 */
function NgPushCommand9(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
{
	gNgCommandString += ":" + arg1 + "," + arg2 + "," + arg3 + "," + arg4 + "," + arg5 + "," + arg6 + "," + arg7 + "," + arg8 + "," + arg9;
}

/**
 * Submit a command with n arguments to the native engine.
 * @private
 */
function NgPushCommandN()
{
	var argv = arguments;
	var argc = argv.length;
	
	var tmp = ":";
	
	if( argc > 0 )
	{
		tmp += argv[ 0 ];
		
		for( var num = 1; num < argc; ++num )
		{
			tmp += "," + argv[ num ];
		}
	}
	
	gNgCommandString += tmp;
}

/**
 * Peek at the command ID in a command string.  This helps avoid 
 * splitting the string twice in a number of cases.
 * @return Command id or null if parsing failed.
 * @private
 */

function NgPeekCommandId(str)
{
	var vals = str.split ( ",", 2 );
	if( vals.length == 2 )
		return parseInt ( vals[ 1 ] );
	else
		return null;
}

/**
 * Peek at the class and command ID in a command string.  This helps avoid 
 * splitting the string twice in a number of cases.
 * @return Two-element array of ids or null if parsing failed.
 * @private
 */

function NgPeekClassAndCommandId(str)
{
	var vals = str.split ( ",", 2 );
	if( vals.length == 2 )
	{
		vals[ 0 ] = parseInt ( vals[ 0 ] );
		vals[ 1 ] = parseInt ( vals[ 1 ] );
		return vals;
	}
	else
		return null;
}


/**
 * Parse an incoming command string to individual strings.
 * @return an array of fields in serialization order.
 * @private
 */
function NgParseCommandToStrings(src)
{
	return src.split(",");
}

/**
  * @private
  */

function NgParseCommand1(src, func1)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand2(src, func1, func2)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand3(src, func1, func2, func3)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	ret[ 2 ] = func3( fields[ 3 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand4(src, func1, func2, func3, func4)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	ret[ 2 ] = func3( fields[ 3 ] );
	ret[ 3 ] = func4( fields[ 4 ] );
	
	return ret;
}

/**
  * @private
  */

function NgParseCommand5(src, func1, func2, func3, func4, func5)
{
	var ret = [];
	
	var fields = src.split(",");
	
	ret[ 0 ] = func1( fields[ 1 ] );
	ret[ 1 ] = func2( fields[ 2 ] );
	ret[ 2 ] = func3( fields[ 3 ] );
	ret[ 3 ] = func4( fields[ 4 ] );
	ret[ 4 ] = func5( fields[ 5 ] );
	
	return ret;
}


/**
 * Parse an incoming command string to typed values based on passed-in functions.
 * ex: NgParseCommandN("1:1,1.0,ACFHENA==",parseInt, parseFloat, NgParseString);
 * NOTE: The first item is assumed to be the command type, and will be
 * discarded in the output.  I.e., the output starts with the second src element.
 * @return an array of parsed fields in serialization order.
 * @private
 */

function NgParseCommandN(src)
{
	var ret = [];
	
	var argv = arguments;
	var argc = argv.length;
	
	var fields = src.split(",");
	for( var num = 1; num < argc; ++num )
	{
		ret[ num - 1 ] = argv[ num ]( fields[ num ] );
	}
	
	return ret;
}

/**
 * Parse an incoming typed dictionary.  The format of the dictionary is:
 * type,field name,value,type,field name,value[...]
 * Parsed values will be asigned to the field name in the dst array/object.
 * NOTE: Strings passed in this format must not have embedded commas (use
 * base64 encoding if arbitrary strings are being used.
 * @arg src The source command string.
 * @arg srcStart The field index to start parsing dictionary entries from.
 * @arg dst The destination object/array for parsed values.
 * @arg initialFields Optionally store the fields before srcStart in the passed-in array.
 * @return true if all fields were successfully parsed.
 * @private
 */

function NgParseCommandDictionary(src,srcStart,dst,initialFields)
{
	var ret = true;
	var fields = src.split(",");
	var end = fields.length;
	
	if(initialFields)
	{
		for( var num = 0; num < srcStart; ++num )
		{
			initialFields[ num ] = fields[ num ];
		}
	}
	
	for( var num = srcStart; num < end; )
	{
		var type = fields[ num++ ];
		var name = fields[ num++ ];
		var val = fields[ num++ ];
		var good = true;
		
		switch(type)
		{
			case 'i':	// int
				val = parseInt( val );
				break;
			case 'f':	// float
				val = parseFloat( val );
				break;
			case 's':	// string
				break;
			case 'S':	// base64 string
				val = Core.Base64.decode(val);
				break;
			case 'b':	// bool
				val = parseInt(val) ? true : false;
				break;
			default:
				//				NgLogD("NgParseCommandDictionary unknown type for " + type + " " + name + " " + val);
				ret = false;
				good = false;
				break;
		}
		
		if( good )
		{
			dst[ name ] = val;
			
			// TEMP PRW
			NgLogD( "dict: " + name + " : " + dst[ name ] );
		}
		else
		{
			NgLogD("dict: could not process " + type );
		}
	}
	
	return ret;
}
/**
  * @private
  */

var gNgTrace=null;

//////////////////////////////////////////////////////////////////////////////////////////////////
// Logging functions.
//////////////////////////////////////////////////////////////////////////////////////////////////

/**
  * @private
  */
var NgDebugModes = {
	BrowserTrace : {},
	NgCommand : {},
	NgCommandDocLoc : {}
};

/**
  * @private
  */
var NgLogLevel = {
	Verbose : 5,
	Debug : 4,
	Info : 3,
	Warning : 2,
	Error : 1
};

/**
  * @private
  */
var NgLogStr = [ '', 'e', 'w', 'i', 'd', 'v'];


/**
  * @private
  */

// TEMP... this is not how we want to do this long-term.
function NgSetDebugDefaultDestination()
{
	if (typeof navigator == 'undefined')
	{
		return NgDebugModes.NgCommand;
	}

	var agent=navigator.userAgent.toLowerCase();
	if( ! ( (agent.indexOf('iphone') >=0) || (agent.indexOf('ipad') >= 0) ) )
	{
		return NgDebugModes.BrowserTrace;
	}
	else
	{
		return NgDebugModes.NgCommand;
	}
}

/**
  * @private
  */

var gNgDebugMode = NgSetDebugDefaultDestination();

/**
  * @private
  */

function NgLogInit()
{
	if( gNgDebugMode == NgDebugModes.BrowserTrace )
	{
		gNgTrace = document.getElementById("trace");
	}

	// Other modes don't need initialization.
}

function NgLogSetLevel(level)
{
	switch( level )
	{
		case NgLogLevel.Debug:
		{
			NgLogV = NgNoLog;
			NgLogD = NgDoDebugLog;
			NgLogI = NgDoInfoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
		}
			break;

		case NgLogLevel.Info:
		{
			NgLogV = NgNoLog;
			NgLogD = NgNoLog;
			NgLogI = NgDoInfoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
		}
			break;

		case NgLogLevel.Warning:
		{
			NgLogV = NgNoLog;
			NgLogD = NgNoLog;
			NgLogI = NgNoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
		}
			break;

		case NgLogLevel.Error:
		{
			NgLogV = NgNoLog;
			NgLogD = NgNoLog;
			NgLogI = NgNoLog;
			NgLogW = NgNoLog;
			NgLogE = NgDoErrorLog;
		}
			break;

		default:
		case NgLogLevel.Verbose:
		{
			NgLogV = NgDoVerboseLog;
			NgLogD = NgDoDebugLog;
			NgLogI = NgDoInfoLog;
			NgLogW = NgDoWarningLog;
			NgLogE = NgDoErrorLog;
		}
			break;
	}
}

NgDoVerboseLog = function ( msg ) {
	NgLog(NgLogLevel.Verbose, msg);
}

NgDoDebugLog = function ( msg ) {
	NgLog(NgLogLevel.Debug, msg);
}

NgDoInfoLog = function ( msg ) {
	NgLog(NgLogLevel.Info, msg);
}

NgDoWarningLog = function ( msg ) {
	NgLog(NgLogLevel.Warning, msg);
}

NgDoErrorLog = function ( msg ) {
	NgLog(NgLogLevel.Error, msg);
}

NgNoLog = function() {};
NgLogSetLevel(NgLogLevel.Verbose);

var useConsole = ((typeof console != 'undefined') && (typeof console.log == 'function'));

function NgLog( level, msg )
{
	console.log(NgLogStr[level] + ": " + msg);
}

function NgLogException( ex )
{
    var str = "\nEXCEPTION:\n";

    for( var prop in ex )
    {
		str += "property: "+ prop+ " value: ["+ ex[prop]+ "]\n";
    }

    str += "toString(): " + " value: [" + ex.toString() + "]\n\n";

	NgLogD( str );
}
/*
 @author: Remy Sharp / http://remysharp.com
 @date: 2007-04-20
 @name: time
 @methods:
 start - start named timer
 stop - stop named timer
 event - hook predefined event
 func - hook existing function, or hook anonymous function (note refrence is passed back)
 report - output timings
 */
if ((typeof window == 'undefined') || (typeof window.time == 'undefined'))
{
	(function() {
		time = {
			// start + stop taken from firebuglite.js -
			// http://getfirebug.com/firebuglite
			start : function(name) {
				if (!name) {
					error('start: If starting a timer manually a name must be set');
				} else {
					timeMap[name] = (new Date()).getTime();
					if (name in NgRecordMap) {
					} else {
						NgRecordMap[name] = new NgRecord(name);
					}
				}
			},

			stop : function(name) {
				if (name in timeMap) {
					var stop = (new Date()).getTime();
					// var l = new Report(name, timeMap[name], stop);
					var l = NgRecordMap[name].addRecord(stop - timeMap[name]);
					log.push(l);
					if (NgRecordMap[name].records % NgRecordMap[name].ctr == 0) {
						NgRecordMap[name].lineReportMethod.call(this, l);
						NgRecordMap[name].records = 0;
						NgRecordMap[name].avg = 0;
						NgRecordMap[name].min = 55555;
						NgRecordMap[name].max = 0;
					}
					delete timeMap[name];
				} else {
					error('stop:' + name + ' not found');
				}
			},

			event : function(name, elm, type) {
				if (typeof name != 'string') {
					// name has not been passed in
					type = elm;
					elm = name;
					name = '';
				}

				if (!elm.length) {
					elm = [ elm ];
				}

				if (type.indexOf('on') == -1) {
					type = 'on' + type;
				}

				var i = elm.length;
				var timerN = null;
				var c = null;
				while (i--) {
					timerN = name;
					if (!timerN) {
						timerN = elm[i].id || elm[i].getAttribute('class')
								|| elm[i].getAttribute('className')
								|| elm[i].tagName;
					}

					mapEvent(elm[i], type, timerN);
				}
			},

			func : function(name, fn) {
				if (typeof name == 'function') {
					fn = name;
				}

				// get function name as this browser may not support fn.name (IE
				// + Safari + Opera)
				if (!fn.name && typeof fn == 'function') {
					var m = fn.toString().match(/function\s*(.*)\s*\(/);
					if (m[1]) {
						fn.name = m[1];
					}
				}

				if (typeof fn == 'function' && !fn.name) {
					// function is anonymous -
					// time function using var func = time.fn(function() { ...do
					// stuff });
					if (typeof name != 'string') {
						anonFuncId++;
						name = 'anonymous' + anonFuncId;
					}

					return function() {
						time.start(name);
						var ret = fn.apply(window, arguments);
						time.stop(name);
						return ret;
					};
				} else {
					var fnName = fn.name || fn;
					if (typeof name != 'string') {
						name = fnName;
					}

					eval('var fnCopy = ' + fnName);
					if (typeof fnCopy == 'function') {
						var wrap = function() {
							time.start(name);
							var ret = fnCopy.apply(this, arguments);
							time.stop(name);
							return ret;
						};
						wrap.hooked = true;
						eval(fnName + ' = wrap;');
						return eval(fnName);
					} else {
						// error hooking
						error('func: Could not hook function (name: ' + name + ')');
					}
				}
			},

			report : function(name) {
				if (typeof name == 'undefined') {
					reportMethod.call(this, log);
				} else {
					var i = log.length;
					var l = [];
					while (i--) {
						if (name == log[i].name) {
							l.push(log[i]);
						}
					}
					reportMethod.call(this, l);
				}
			},

			setReportMethod : function(fn) {
				if (fn.hooked) {
					error('setReportMethod: Cannot use hooked method ' + fn.name);
				} else {
					reportMethod = fn;
				}
			},

			setCtr : function(name, ctr, fn) {
				if (name in NgRecordMap) {
				} else
					NgRecordMap[name] = new NgRecord(name, ctr, fn);
			},

			setLineReportMethod : function(fn) {
				if (fn.hooked) {
					error('setLineReportMethod: Cannot use hooked method ' + fn.name);
				} else {
					lineReportMethod = fn;
					lineReport = true;
				}
			},

			errors : false
		};

		var timeMap = {};
		var NgRecordMap = {};
		var log = [];
		var reportMethod = defaultReport;
		var lineReport = false;
		var lineReportMethod = defaultLineReport;
		var anonFuncId = 0;

		var Report = function(n, s, e) {
			this.name = n;
			this.start = s;
			this.stop = e;
			this.delta = e - s;
			// useful if I could grab the call - but can't see how due to anon
			// functions (though I can see them in the start method)
		};

		Report.prototype.toString = function() {
			return this.name + ": " + this.delta + "ms";
		};

		function defaultReport(l) {
			alert(l.join("\n"));
		}

		function defaultLineReport(l) {
			alert(l);
		}

		function error(e) {
			if (time.errors)
				alert(e);
		}

		var NgRecord = function(name, ctr, fn) {
			this.name = name;
			this.records = 0;
			this.avg = 0;
			this.min = 555555;
			this.max = 0;
			this.ctr = ctr;
			if (fn.hooked) {
				error('setLineReportMethod: Cannot use hooked method. Will use default method' + fn.name);
				this.lineReportMethod = defaultLineReport;
			} else {
				this.lineReportMethod = fn;
			}

		}

		NgRecord.prototype.addRecord = function(delta) {
			this.avg = (this.avg * this.records + delta) / (this.records + 1);
			if (this.min > delta)
				this.min = delta;
			if (this.max < delta)
				this.max = delta;
			this.records++;
			frq = 1000 / this.avg;
			return this.name + '->  max:' + this.max + '  min:' + this.min
					+ '  avg:' + this.avg.toFixed(2) + '  freq:'
					+ frq.toFixed(2) + '\n';
		}

		// required to create a brand new instance of our copied function
		function mapEvent(e, t, n) {
			var c = e[t];
			if (typeof c == 'function') {
				e[t] = function() {
					time.start(n + ':' + t);
					var ret = c.apply(this, arguments);
					time.stop(n + ':' + t);
					return ret;
				};
			} else {
				error('event: Function must be set on element.' + t
						+ ' before hooking (name: ' + n + ')');
			}
		}
	})();
}

/// @file:      RuleGlobals.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     To be honest I am not very thrilled that we need this file.
///             This is a bit of a hold over from the orginal demo and I would
///             like to phase these out over time.  The problem with globals
///             is it make the concept of ingame script reloading difficult
///             
///             This file is also being used to setup up "global" const and
///             enum values.
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var gShowBackgroundDownloadPopup = false;
var gBackgroundContentDownload = false;
var gMaxLevel = 70;
var gDebugMissingAssets = false;

var gUsePlusStaging = true;//false;

var GameInfo = 
{
	appVersion: "1.70",//"1.22",
	appName: "WeRule"
};

var Globals = 
{
	BuildingTapTime : 300,
	BuildingTapDistance : 10
};

var gProductKeyStaging = "Kingdoms-Android";
var gPlatformKeyStaging = "0fRy4JnCweSENFzqwj0og";
var gPlatformSecretStaging = "DTLEyQmXYg7yvUI3qp6z9hEQNfKLwE1Ld1ZaInuVM0";

var gProductKeyProduction = "Kingdoms-Android";
var gPlatformKeyProduction = "0fRy4JnCweSENFzqwj0og";
var gPlatformSecretProduction = "DTLEyQmXYg7yvUI3qp6z9hEQNfKLwE1Ld1ZaInuVM0";


var gProductKeyStagingIOS = "Kingdoms-ios";
var gPlatformKeyStagingIOS = "zgJ5yc9tLGG3aJ5jd3iwg";
var gPlatformSecretStagingIOS = "cYcwHZKAlL4Ul0aaLQjp7aKHPg21JRQYmLtf1NYgA";

var gProductKeyProductionIOS = "Kingdoms-ios";
var gPlatformKeyProductionIOS = "zgJ5yc9tLGG3aJ5jd3iwg";
var gPlatformSecretProductionIOS = "cYcwHZKAlL4Ul0aaLQjp7aKHPg21JRQYmLtf1NYgA";



var gServerConsumerKey = "Fh5YZar8StzbBxH45BtNKw";
var gServerConsumerKeyIOS = "xcKeeT6wbT6blgl6h1ETqg";

var gMobclixApplicationId = "DE5EC02F-DD1A-4715-B3D9-7A8076F447CF"

//{@"Kingdoms",			@"uowOuWfm1SARXCcVOHlBiQ",	@"L2ycz0gds1nnI7fAOm5flisk0W4J6hzPyxMW0miTY"},
//{@"KingdomsQuests",			@"GUkJpy9U2QF9ggP1oO606g",	@"PVRHdlc6wHFHp7QhmhWe7MFDolbD0vmQ1xeU7i4Mg"}
var gHarvestAllActive = false;
var gAudioUseEffect = true;
var gAndroidAudioExt = ".ogg";
var gEnableAndroidDualMana  = true;
var gClientVersion = 1.50;//1.22;
var gServerBuild = 0.4;
var gSDKBuild = 1;
var gOAuthEnabled = true;
var gSkipLogin = false;
var gGameServer = "http://kingdoms-webgame.ngmoco.com";
var gLocalGameServer = "http://localhost:3000";

var gStatusMessage = "Loading";
var gKingdomName = "";
var gRawWidth = 0;
var gRawHeight = 0;
var gRawScale = 0;
var gCameraFriction = 0.875;
var gCameraSnapDecay = 0.6;
var gCameraStretchyBorder = 0.1;
var gSceneExtraTileBounds = 4;
var gCameraMaxVelocity = 40;
var gRedesignScrollBuffer = 50;
var gRedesignScrollVelocity = 10;
var gFlyOffOffset   = 50;
var gGameIdleHideUITime = 10000;
var gJobRequestSpoilTime = 172800;
var gMaxJobsPerFriend = 1;
var gMaxJobs = 35;
var gWebViewFadeSpeed = 0.1;
var gFirstGoalID = 200;
var gTunables = 
{
	ad_loc_x : 100,
	ad_loc_y : 100,
	ad_width : 100,
	ad_height : 100,
	camera_zoom_max : 1,
	camera_zoom_min : 1.55,
	camera_snap_rate : 10,
	RelmsEnabled : true
};

gAddFriendsPromptLevels = [5,10,15];
	
var gLoadingText = 
[
   [25, "Welcome to the world of fanciful kingdoms!  What will you build?"], 
   [60, "I present to you these kingdoms of other Rulers.  What will you do?"], 
   [95, "What are you going to build today?\nYour peasants can't wait to see!"],
   [100, "Preparations are complete!\nYour Kingdom eagerly awaits you!"]
];

/* these assets can be separately overriden in screen.json. Example:

"assets" : {
	"icon_gifting" : "icon_gifting.png",
};

*/
var gAssets =
{
	icon_gifting : "icon_gifting.png",
	icon_hammer : "hammerIcon.png",
	job_scryingpool : "job_scryingpool.png",
	resIcon_spoil: "resIcon_spoil.png",
	resIcon_gold: "resIcon_gold.png",
	resIcon_crown: "resIcon_crown.png",
	resIcon_XP: "resIcon_XP.png",
	resIcon_open4biz: "resIcon_open4biz.png",
	resIcon_seedbag: "resIcon_seedbag.png",
	resIcon_happy: "resIcon_happy.png",
	BtnBlue: "BtnBlue.png",
	BtnGray: "BtnGray.png",
	crown: "crown.png",
	realm_locked: "RealmsNavigation/realm_locked.png",
	capture_rarity_star: "goals/goals_star_effect.png",
	realm_available_west: "RealmsNavigation/realm_available_west.png",
	realm_available_main: "RealmsNavigation/realm_available_main.png",
	realm_available_east: "RealmsNavigation/realm_available_east.png",
	realm_available_northwest: "RealmsNavigation/realm_available_northwest.png",
	realm_available_north: "RealmsNavigation/realm_available_north.png",
	realm_available_northeast: "RealmsNavigation/realm_available_northeast.png",
	realm_available_southwest: "RealmsNavigation/realm_available_southwest.png",
	realm_available_south: "RealmsNavigation/realm_available_south.png",
	realm_available_southeast: "RealmsNavigation/realm_available_southeast.png",
	realm_purchase_west: "RealmsNavigation/realm_purchase_west.png",
	realm_purchase_main: "RealmsNavigation/realm_purchase_main.png",
	realm_purchase_east: "RealmsNavigation/realm_purchase_east.png",
	realm_purchase_northwest: "RealmsNavigation/realm_purchase_northwest.png",
	realm_purchase_north: "RealmsNavigation/realm_purchase_north.png",
	realm_purchase_northeast: "RealmsNavigation/realm_purchase_northeast.png",
	realm_purchase_southwest: "RealmsNavigation/realm_purchase_southwest.png",
	realm_purchase_south: "RealmsNavigation/realm_purchase_south.png",
	realm_purchase_southeast: "RealmsNavigation/realm_purchase_southeast.png",
	realms_coming_soon: "RealmsNavigation/realms_coming_soon.png",
	realms_counter_flag: "RealmsNavigation/realms_counter_flag.png",
	
	spinner_generated_item_points_icon: "spinner/spinnerevent_spinner_outcome_points.png",
	spinner_generated_item_boost_icon: "spinner/spinnerevent_spin_gemtotalicon.png"		/* boost icon: test data */
};

function getAssets(asset_name)	// return with an image file name
{
	var gVarName = "gAssets." + asset_name;
	if ( Exists(eval(gVarName)) )
	{
		return eval(gVarName);
	}
	else
	{
		NgLogD( gVarName + "is not defined! Please refer to the RuleGlobal.js and screen json files.");
		return "";			
	}
}

function InitDefaultTunables()
{
    gTunables.camera_zoom_max = 1;
    gTunables.camera_zoom_min = 1.55;
    gTunables.camera_snap_rate = 10;
    gTunables.RelmsEnabled = true;
}

var gErrors = {};

//////////////////////////////////////////////////////////////////////////////
// Global variables
//var gWidth = 0;
//var gHeight = 0;
var gHighFPS = 0;
var gLowFPS = 100000;
var gEffects;

var gDownloadScreenDefs = false;
//var gTimerMgr; 
var gCurKingdom = null;

//////////////////////////////////////////////////////////////////////////////
// Global constants
var gCurKingdomUser = "Bad User ????";
var gCurKingdomPass = "Bad psw ????";
var gCurKingdomId = 1;
var gProtoConfigFname = "weProtoConfig.json";
var gProtoDbFname = "weProtoDb.json";
var gUsernameSelf = "";

var gMainCameraZ = 10;
var gHudCameraZ = 20;
var gGlobalHarvestTime = 3;
var gPosTimeout = 50000;
var gScale = 1.0;
var gDoubleTapDistance = 64;
var gTapTime = 300;
var gDoubleTapTime = 400;
var gRedesignOptsTime = 350;

// Platform-dependent settings.
var compressedImgExt = ".pvr";
var compressedImgs = false;
var ContentRoot = "Content";
var skipSprites = 0;

// Never used
//var gTouches = {};
var prevLand = false;

var gLotActionMenuObject = null;

var gCurrentProducingBuilding = 4; // default is 4 (Farm)


// from Constants.h.
var gStartingMapSize = 34;
var cTileSizeWidth = 32;
var cTileSizeHeight = 16;
var cHalfMapWidth = 544; // (34 * 16) a half width actually - it represents the x width in pixels of a length of our map (NOT the hypotenuse)
var cMapHypotenuse = 608; // the length of on of the map sides (sqrt(8^2 + 16^2) * 34)
var cMapBorderLineThickness = 8;
var gInitialCameraFactor = 0.9; //this is how much of the maps width we make sure is visible when we calculate the initial camera scale
var cBoundaryBaseAlpha = 0.5;


var cMapSizeWidth = 1536;
var cMapSizeHeight = 1024;
var cRedesignModeLevelUnlock = 4;

var cMaxY = 500;
var angleRad = Math.atan ( cTileSizeHeight / cTileSizeWidth );
var angle = angleRad * ( 180.0 / Math.PI );

var kGameTouchBase = 0;
var kUITouchBase = 100;
var cCameraZoomTime = 0.3;

//////////////////////////////////////////////////////////////////////////////
// Globals
var gAnimationsCachedByProtoId = [];
var gAnimationsByNameCachedByProtoId = [];
var gAnimationsByName = {};
var gAnimationsCachedForCleanup = [];
var gLOD = 2;

var Realms = 
{
	MainRealm: { index: 0, name: "main" },
	NorthRealm: { index: 1, name: "north" },
	SouthRealm: { index: 2, name: "south" },
	EastRealm: { index: 3, name: "east" },
	WestRealm: { index: 4, name: "west" }
};

var gConfigs = null;

var gGiftingEnabled = false;
var gStashEnabled = false;
var gStashButtonEnabled = false;

var gLoadingScreenWebViewStages = [ 0, 15.0, 25.0, 40.0, 55.0, 70.0, 85.0, 100.0 ];

var gLoadingAdView = true;
var GameSpecificVariables =
{
		GameResolution : "480x320",
		SupportedResolutions :
		[
			"480x320",
			"800x480",
			"854x480",
			"960x640",
			"1024x600",
            "1024x768",
			"1280x720",
			"1280x800"
		],
		ForgotPasswordViewController :
		{
			subtitleLabelColor: "FFFFFFFF"
		},
		LoginViewController :
		{
			subtitleLabelColor: "FFFF"
		},
		RegistrationViewController :
		{
			titleLabel1RectHeight : 28,
			titleLabel1Color : "FFFF",
			passwordFieldPlaceholder : "4 to 25 characters"
		},
		RegistrationInfoViewController :
		{
			subtitleLabelColor: "FFFF"
		},
		WeEffectsMgr :
		{
			MusicInfo : 
			{
				 tracks :
                 [
                     {name : "Song1_-3dB.mp3", len : 155000},
                     {name : "Ambient_Primary.mp3", len : 121000},
                     {name : "Song2_long_-6dB.mp3", len : 224000},
                     {name : "Ambient_Primary.mp3", len : 121000}
                 ],
                 config :
                 {
                     "enabled" : true,
                     "volume" : 1.0
                 }
            }
		},
		WeSprite2D :
		{
			FallbackAnimation: "SPR_flaglargewhite_01",
			FallbackCharAnim: "SPR_farmer_idleone",
			FPSImages: "fps_images.png"
		},
		WeGameState : 
		{
			LastObjective: 19
		},
		WeLabelFactory : 
		{
			realm : "Kingdom",
			objects_to_list_max : 10,
			oneFactory : "Farm",
			moreFactories : "Farms",
            storeLockIcon : "lockedIcon.png"
		},
		Textures :
		{
			Cloud : "SPR_cloud_01",
			CloudShadow : "SPR_cloud_shadow_01",
			Signpost : "SPR_signpost_tilt_01",
			VacantLines : "vacant_lines.png",
			Mojo : "city_zap_icon.png",
			Small_Mojo : "small_mojo_icon.png",
			Small_Mojo_iOS : "small_mojo_icon@iOS.png",
			Crowns : "small_coin_icon.png",
			Crowns_iOS : "small_coin_icon@iOS.png",
			Coins : "res_coins.png",
			Coins_iOS : "res_coins@iOS.png",
			Gold : "resIcon_gold.png",
			Gold_iOS : "resIcon_gold@iOS.png",
			MojoGift: "gifting/gifting_mojo_gift.png"
		},
		Sounds:
		{
			HappyCrowd : "crowd_happy_1.ogg",
			SadCrowd : "crowd_sad_1.ogg",
			JobComplete : "jobcomplete_1.ogg",
			JobOrder : "money_cashregister.ogg",
			ObjectPlace : "tree_planting_1.ogg",
			BuildingPlace : "building_placement.ogg",
			ObjectiveComplete : "objectivecomplete_1.ogg",
			NewObjective : "Newobjective_1.ogg",
			ButtonPress : "buttonpress_4.ogg",
			Mojo : "mojo.ogg",
			MoneyCashregister : "money_cashregister.ogg",
			ConstructionShort : "construction_short.ogg",
			MoneyCoindrop : "money_coindrop.ogg",
			GoalComplete : "goals_complete.ogg",
			GoalUnlocked : "goals_unlock.ogg",
			GoalTaskComplete : "goals_task_complete.ogg",
			GoalbookOpen : "goals_book_open.ogg",
			GoalbookClose : "goals_book_close.ogg",
			GoalbookPage : "goals_book_pageTurn.ogg",
			GiftOpening : "GiftingTrumpetFanfare.ogg",
			EventSpinAnimation : "airship.ogg",
			EventRevealAward : "GiftingTrumpetFanfare.ogg"
		},
		Texts :
		{
			realm : "Kingdom",
			mojoTextU : "Mojo",
			cointTextU : "Cash",
			cointText : "crowns",
			UcointText : "Crowns",
			pointsTextU : "Points",
			Congratulations : "Congratulations!",
			YourHasBeenUpgraded : "Your kingdom has been upgraded!",
			YouDoNotHaveEnoughCashBuyThis : "You do not have enough crowns to buy this. Grow more crops at your farms to get more crowns.",
			YouDoNotHaveCashToProduce : "You don't have enough crowns to plant that crop yet.",
		    NotEnoughRoom : "Item won't fit in this space.",
		    WouldYouLikeSell : "Sorry, but this item will not fit in that space. Please try selling or storing other items, or upgrade your realm for more space."
		},
		Colors :
		{
			LoadingInfoTextColor : "FF000000",
			CopyrightTextColor : "FFFFFFFF"
		},		
		RealmSpriteOffset : [ 42, 46, 78, 120, 42 ],
		Paths :
		{
			screenDefFileStart : "WeRule_Screen_",
			screenDefFileDir : "/Configs/",
			screenDefFileDirFromServer : "/werule-game/Content/",
			globalsFile : "globals.json",
			Network_XHR_URL : "http://gamehub.mobage.com/gamehub/ngmoco/werule/ngcoreprod/android/configuration.json",
			NgGetHttpRequest_URL : "http://gamehub.mobage.com/gamehub/ngmoco/werule/ngcoreprod/configuration.json"
		}
};


//////////////////////////////////////////////////////////////////////////////
/// @file:      RuleGlobas.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     To be honest I am not very thrilled that we need this file.
///             This is a bit of a hold over from the orginal demo and I would
///             like to phase these out over time.  The problem with globals
///             is it make the concept of ingame script reloading difficult
///             
///             This file is also being used to setup up "global" const and
///             enum values.
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block

var ResponseCode =
{
	// success
	RCOK : 200,
	RCCreated : 201,
	RCAccepted : 202,
	RCNoContent : 204,
	RCResetContent : 205,
	
	// server failures
	RCBadRequest : 400,
	RCUnauthorized : 401,
	RCForbidden : 403,
	RCNotFound : 404,
	RCConflict : 409,
	RCPreconditionFailed : 412,
	RCInternalServerError : 500,
	
	//content upgdate
	RCCRequiredUpdate : 426, //content update
	RCRequiredClientUpdate : 418, //do nothing, iOS client update
	
	// client failures
	RCParseFailure : 450,
	RCInvalidServerVersion : 451
};

// Defines all the game message types for the screens
var GameMessage =
{
    KingdomLoadBegin    : 0,    // The game is "Loading" a Kingdom
    KingdomLoadComplete : 1,    // The game as finished loading the kingdom
    KingdomLoadFailed   : 2,    // The game has failed to load the kingdom

    SystemScreenChange  : 3,    // The size of the screen has changed

    ButtonPressDown     : 4,    // A button has been pressed down
    ButtonPressHeld     : 5,    // A button is begin held
    ButtonPressUp       : 6,    // A Button has been released
    
    ShowRedesignOps     : 7,    // Something has request the Redesign ops pop up to show
    HideRedesignOps     : 8     // Something has request the Redesign ops pop up to go away 
};

//////////////////////////////////////////////////////////////////////////////
/**
* BuildingState Values
* NOTE:  I am REALLY not a fan of this system.  It is kind of a modified rippoff
* of the new toy code which is overally complex in order to save something like
* 16 bits in their code.  My belief is if we run into a case where we are REALLY hurting
* what should be less then a 1 K worth of memory we can find it else where.  But for
* now I will model this off of the old iOS version until we have time to fix it
*/
var BuildingState =
{
   None :              0,
   Move :              1 << 0,
   Produce :           1 << 1,
   HelpProduce :       1 << 2,
   Build :             1 << 3,
   HelpBuild :         1 << 4,
   Create :            1 << 5,
   ServerRoundTrip :   1 << 6,

   Available :         1 << 7,
   Busy :              1 << 8,
   Ready :             1 << 9,
   Spoiled :           1 << 10,
   Constructing :      1 << 11,
   Collecting :        1 << 12,
   Shell :             1 << 13,

   Movable :           1 << 14,
   Decal :             1 << 15,
   Product :           1 << 16,
   JobProduct :        1 << 17,
   AutoProducing :     1 << 18,
   Player :            1 << 19,
   Ghost :             1 << 20
};

var JobState =
{
   None :              0,
   RequestSent :       1 << 0,
   Working :           1 << 1,
   Spoiled :    	   1 << 2
};


////////////////////////////////////////////////////////////////////////////////
// utils

var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var Vec3D = require('weEngine/WeMath').Vec3D;
var WeUiMgr = require('weEngine/WeUiMgr').WeUiMgr;

function Exists(obj)
{
    return undefined !== obj && null !== obj;
}

function SortTouchTargetsGround(touch)
{
    try
	{
	var sorted = touch.getTouchTargets();
	
    var myloc = {};
    myloc.x = touch.getPosition().getX();
    myloc.y = touch.getPosition().getY();
   // NgLogD("TOUCH " + myloc.x + " : " + myloc.y);
    sorted.sort(function (a, b) 
    {
        var pos1 = {};
        var pos2 = {};
        
        var p1 = a.mOwner;
        var p2 = b.mOwner;
        
        if (Exists(p1) && Exists(p1.mAnchor))
        {
            var screenPos = WorldToScreenPos(p1.mAnchor);
            pos1.x = screenPos.x;
            pos1.y = screenPos.y;
        }
        else
        {
         //   NgLogD("** NO OWNER1 " + a.m_Asset);
            pos1.x = 0;
            pos1.y = 0;
        }
        if (Exists(p2) && Exists(p2.mAnchor))
        {
            var screenPos = WorldToScreenPos(p2.mAnchor);
            pos2.x = screenPos.x;
            pos2.y = screenPos.y;
        }
        else
        {
        //    NgLogD("** NO OWNER2 " + b.m_Asset);
            pos2.x = 0;
            pos2.y = 0;
        }
        // pos1.x = a.localToScreen(a.getPosition()).getX();
        //         pos1.y = a.localToScreen(a.getPosition()).getY();
        //         pos2.x = b.localToScreen(a.getPosition()).getX();
        //         pos2.y = b.localToScreen(a.getPosition()).getY();
        var dist1 = WeMath.Distance2D(pos1, myloc);
        var dist2 = WeMath.Distance2D(pos2, myloc);
        // NgLogD("POS1: " + a.m_Asset + " " + pos1.x + " : " + pos1.y);
        //         NgLogD("POS2: " + b.m_Asset + " " + pos2.x + " : " + pos2.y);
        //         
        //         NgLogD("ASSET1: " + a.m_Asset + " " + dist1);
        //         NgLogD("ASSET2: " + b.m_Asset + " " + dist2);
        if (dist1 == dist2)
        return 0;
        if (dist1 > dist2)
        return 1;
        else
        return -1;
    });
	}
	catch(err)
	{
		NgLogD("stack: "+err.stack);
	}

    return sorted;
}

function SortTouchTargets(touch)
{
	if( Core.Capabilities.getPlatformOS() != "Android")
    {
        return touch.getTouchTargets();
    }

    var targets = touch.getTouchTargets();
    var sorted = [];

	for (var i=targets.length-1; i >= 0; i--)
    {
        sorted.push(targets[i]);
    }

    return sorted;
    
}

function URLQuery( url, query ) {
	query = query.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
	var expr = "[\\?&]"+query+"=([^&#]*)";
	var regex = new RegExp( expr );
	var results = regex.exec( url );
	if( results !== null ) {
		return results[1];
		return decodeURIComponent(results[1].replace(/\+/g, " "));
	} else {
		return false;
	}
}


function ParseAvatarExtension(url)
{
    var extension = ".png";
    if (url.indexOf(".jpg") >= 0)
    {
        extension = ".jpg";
    }
    
    return extension
}

function CopyProtoEntity(source, dest)
{
    dest.current_product_id = source.current_product_id;
    dest.flipped = source.flipped;
    dest.id = source.id;
    dest.location_x = source.location_x;
    dest.location_y = source.location_y;
    dest.proto_entity_id = source.proto_entity_id;
    dest.push_notify = source.push_notify;
    dest.work_started_at = source.work_started_at;
    dest.work_type = source.work_type;
    dest.num_times_touched = source.num_times_touched;
    dest.last_touch_time = source.last_touch_time;
}

function PruneDuplicateProtoNames(input_array)
{
	var output_array = [];
	
	var length = input_array.length;
	for(var i = 0; i < length; i++)
	{
		var add_element = true;
		var element = input_array[i];
		for(var j = 0; j < output_array.length; j++)
		{
			if(output_array[j].proto_name == element.proto_name)
			{
				add_element = false;
				break;
			}
		}
		if (add_element)
		{
			output_array.push(element);
		}
	}
	return output_array;
}



// Random integer between min and max (arity 2) or from 0 to min (arity 1).
Math.randint = function(min, max)
{
    if(max === undefined)
    {
        max = min;
        min = 0;
    }
    
    var range = max - min;
    return Math.floor(Math.random() * range) + min;
};

// Count number of elements in a simple associative array... do not use this
// to count the number of elements in an object with inherited members, etc.
function count( dictionary )
{
    var val = 0;
    for( var key in dictionary )
    {
        ++val;
    }
    return val;
}

/////////////////////////////////////////////////////////////////////////////
/**
 * Simple Debug function to help me figure shit out
 * @param {Object} obj the object to inspect
 * @param {Integer} maxLevel the max recursion dept (this is important due to possible circular refs
 * @param {Integer} level current recursion level
 */
function inspectRecurse(obj, maxLevel, level)
{
    var str = '';
    var type;
    var msg;


    for(var i = 0; i <= level; ++i)
    {
        str += '----';
    }
    
    for(var prop in obj)
    {
        if (obj.hasOwnProperty(prop))
        {
            type = typeof(obj[prop]);
            if(type == 'object' && (maxLevel == -1 || maxLevel >= (level+1) ))
            {
                console.log(str + prop);
                inspectRecurse(obj[prop], maxLevel, level + 1);
            }
            else if(type == 'object')
            {
                // We have gone as deep as we can go
                NgLogD(str + prop + ' == ' + obj[prop]);
            }
            else if(type != 'function')
            {
                NgLogD(str + prop + ' == ' + obj[prop] + '  == [' + type + ']');
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
/**
 * Simple Debug function to help me figure shit out
 * @param {String} name of the object to print to the tty
 * @param {Object} obj instance of the object to inspect
 * @param {maxLevel} maxLevel the max recursion dept (this is important due to possible circular refs)
 */
function inspect(name, obj, maxLevel)
{
    console.log("Inspect " + name);
    
    var level = 0;
    if(undefined === obj)
    {
        obj = null;
    }

    if(undefined === maxLevel)
    {
        maxLevel = -1;
    }

    if(obj === null)
    {
        NgLogD("---- Null Object");
        return;
    }
    
    inspectRecurse(obj, maxLevel, level);

}



function dump( dictionary, msg, sels )
{
    if( ! msg )
    {
        msg = "";
    }
    else
    {
        msg += "\n";
    }

    var ret = msg;
    
    if( sels )
    {
        for ( var key in sels )
        {
            ret += sels[ key ] + ": " + dictionary[ sels[ key ] ] + "\n";
        }
    }
    else
    {
        for( var key in dictionary )
        {
            ret += key + ": " + dictionary[ key ] + "\n";
        }
    }
    
    NgLogD(ret);
}

function fullRecurseDump(obj, tabspace, idxLast)
{
    var space = '';

    for(var spaceIdx = 0; spaceIdx < tabspace; ++spaceIdx)
    {
        space += ' ';
    }

    NgLogD(space + "**********" + idxLast);
    for(var idx in obj)
    {
        if(typeof(obj[idx]) == 'object')
        {
        	var out = space + idx + ": " + obj[idx];
        	NgLogD(out);
            fullRecurseDump(obj[idx], tabspace + 2, idx);
        }
        else
        {
            var out = space + idx + ": " + obj[idx];
            NgLogD(out);
        }
    }
}

function fullRecurseDumpNodes(obj, tabspace, tabIncrese)
{
    var space = '';
   // if( obj==null || obj.VisitedDump ) return;
    //obj.VisitedDump = true;

    for(var spaceIdx = 0; spaceIdx < tabspace; ++spaceIdx)
    {
        space += ' ';
    }
    for(var idx in obj)
    {
    	if(typeof(obj[idx]) == 'object')
        {
        	var out = space + idx + ": " + obj[idx];
        	NgLogD(out);
        	//if(idx!="superclass" && idx!="_parent" && obj[idx]!="TouchTarget" && obj[idx]!="MessageEmitter"  )
        	if(idx!="_parent" && ( idx=="_children" || obj[idx]=="_children" || obj[idx]=="Node" || obj[idx]=="Sprite" || obj[idx]=="Text") )
        	{
        		fullRecurseDumpNodes(obj[idx], tabspace + tabIncrese, tabIncrese);
        	}
        }
        else
        {
        	if(typeof(obj[idx])!= "function"  )
        	{
        		var out = space + idx + ": " + obj[idx];
        		NgLogD(out);
        	}
        }
    }
}

function printFull (text, llen)
{
	if (!Exists(text)) return;
	if (!llen) llen = 100;
	var len = text.length;
	NgLogD("@@@@@@@@ RAW TEXT DATA: @@@@@@@@@");
	for (i=0; i<len; i+=llen)
	{
		line = text.slice(i, i+llen);
		NgLogD(line);
	}
	NgLogD("@@@@@@@ END OF TEXT DATA @@@@@@@@");
}

function objDump(obj, tabspace)
{
    var out = '';
    var start = '';

    for(var space = 0; space < tabspace; ++space)
    {
    	start += ' ';
    }
    for(var idx in obj)
    {
        out += start+ idx + ": " + obj[idx] + "\n";
        
    }
    NgLogD(out);
}

function objDumpMembers(obj, tabspace)
{
    var out = '';
    var start = '';

    for(var space = 0; space < tabspace; ++space)
    {
    	start += ' ';
    }
    for(var idx in obj)
    {
    	if(  typeof(obj[idx])!= "function"  )
    	{
    		out += start+ idx + ": " + obj[idx] + "\n";
    	}
    }
    NgLogD(out);
}

function fullDump(obj)
{
    NgLogD("**********");
    for(var idx in obj)
    {
        objDump(idx, 0);
    }
}

function printStack(message)
{
	try
	{
		var a = new Object();
		a.printStack();
	}
	catch(err)
	{
		if(message)
		{
			NgLogD(message);
		}
		NgLogD("stack: "+err.stack);
	}
}

function parseColor(def)
{
	var obj = def.split(",");
	return new Core.Color(obj[0]/255, obj[1] / 255, obj[2] / 255);
}

function spliceMatching( list, which )
{
    var good = false;
    for( var index in list )
    {
        if( list[ index ] == which )
        {
            good = true;
            break;
        }
    }
    
    if( good )
    {
        list.splice( index, 1 );
    }
    
    return list;
}

// throw-away function for debugging prototype server responses.
function dumpResponse ( msg, request )
{
    NgLogD( msg + " with status = " + request.status + ".  " );
//  NgLogD( request.responseText );
    NgLogD( "    response size = " + request.responseText.length + "\n" );
}

var gDbgSprites = [];

function dbgSpritePos ( pos )
{
    if( pos[ 2 ] === undefined || pos[ 2 ] === null )
    {
        pos[ 2 ] = 1.0;
    }

    var size = 8;

    var sprite = NgSprite2D.newWithFilename ( ContentRoot + "/soc_plus.png" );
    sprite.mCanvas = WeRenderDevice.GetGameCanvas();
    sprite.mX = pos[ 0 ];
    sprite.mY = pos[ 1 ];
    sprite.mZ = pos[ 2 ];
    sprite.mWidth = size;
    sprite.mHeight = size;
    
    sprite.register ();
    
    gAttachRoot.addChild ( sprite );
    
    gDbgSprites.push ( sprite );
    
    return sprite;
}

function dbgSpriteClear ()
{
    for( var index in gDbgSprites )
    {
        var sprite = gDbgSprites[ index ];
    
        gAttachRoot.removeChild ( sprite );
        
        sprite.unregister ();
    }
    
    gDbgSprites = [];
}

function LevelSortAscending(a, b)
{
    return a.level < b.level ? -1 : 1;
}

function LevelSortDescending(a, b)
{
    return a.level < b.level ? 1 : -1;
}

//function for clampin value
function Clamp(nValue, nMin, nMax)
{
	return nValue < nMin ? nMin : nValue > nMax ? nMax : nValue ;
}

//////////////////////////////////////////////////////////////////////////////
// Class console
// Adapter object to map FireBug debugging console commands into NgGame Commands
var consoleNgLogD = 
{
    // Method: info
    // Informative Message
    info : function(output)
    {
        NgLogD(output);
    },

    // Method: debug 
    // Debug message
    debug : function(output)
    {
        NgLogD(output);
    }
};

function ConvertToDate(weTime)
{
    var dateStr =  weTime.split('T');
    var day = dateStr[0].split('-');
    var time = (dateStr[1].slice(0, dateStr[1].length-1)).split(':');
    var month = parseInt(day[1], 10) - 1;
    var date = new Date();
    date.setUTCFullYear(day[0], month, day[2]);
    date.setUTCHours(time[0]);
    date.setUTCMinutes(time[1]);
    date.setUTCSeconds(time[2]);
    
    return date;
}

function ConvertToWeDate(jsDate)
{
    return "" + jsDate.getUTCFullYear() + "-" + (jsDate.getUTCMonth() + 1) + "-" + jsDate.getUTCDate() + "T" + jsDate.getUTCHours() + ":" + jsDate.getUTCMinutes() + ":" + jsDate.getUTCSeconds() + "Z";
}



function ConvertStringToMultipleLines(string, line_length)
{
	// valid string? If not just return the number or w/e it is
	if (typeof string != 'string')
	{
		return string;
	}
	
	// split the string into an array of words
	var wordlist = string.split(' ');
	var templine = '';
	var newlines = [];
	var line_index = 0;

	// now start building our new string one word at a time
	for (var i = 0; i < wordlist.length; i++)
	{
		if (wordlist[i] == '')
		{
			continue;
		}
		
		templine += ' ' + wordlist[i];
		
		// look for our new line case...
		if (templine.length >= line_length)
		{
			line_index++;
			templine = wordlist[i];
			
			// This is going to be the last line - append it to the list...
			if (i + 1 >= wordlist.length)
			{
				newlines[line_index] = templine;
			}
			
			continue;
		}
		// update the valid templine into the line list
		newlines[line_index] = templine;
	}

	// join the lines and return our newly formatted string...
	return newlines.join("\n");
}

function IsPointInCircle( pointX, pointY, circX, circY, radius)
{
	var magX = pointX - circX;
	var magY = pointY - circY;
	var mag = (magX * magX) + (magY * magY);
	var radmag = radius * radius;
	return (mag < radmag);
}

function IsPointInRect(point, topleft, bottomright)
{
	return point && topleft && bottomright &&
		   point[0] >= topleft[0] && point[0] <= bottomright[0] &&
		   point[1] >= topleft[1] && point[1] <= bottomright[1];
}

function printf ( ) {
    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuidfegEG])/g;
    var a = arguments, i = 0, format = a[i++];

    // pad()
    var pad = function (str, len, chr, leftJustify)
    {
        if (!chr) {chr = ' ';}
        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
    };

    // justify()
    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar)
    {
        var diff = minWidth - value.length;
        if (diff > 0)
        {
            if (leftJustify || !zeroPad)
            {
                value = pad(value, minWidth, customPadChar, leftJustify);
            }
            else
            {
                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };

    // formatBaseX()
    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        // Note: casts negative numbers to positive ones
        var number = value >>> 0;
        prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] || '';
        value = prefix + pad(number.toString(base), precision || 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };

    // formatString()
    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
        if (precision !== null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
    };

    // doFormat()
    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
        var number;
        var prefix;
        var method;
        var textTransform;
        var value;

        if (substring == '%%') {return '%';}

        // parse flags
        var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false, customPadChar = ' ';
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) {
            switch (flags.charAt(j)) {
                case ' ': positivePrefix = ' '; break;
                case '+': positivePrefix = '+'; break;
                case '-': leftJustify = true; break;
                case "'": customPadChar = flags.charAt(j+1); break;
                case '0': zeroPad = true; break;
                case '#': prefixBaseX = true; break;
            }
        }

        // parameters may be null, undefined, empty-string or real valued
        // we want to ignore null, undefined and empty-string values
        if (!minWidth) {
            minWidth = 0;
        } else if (minWidth == '*') {
            minWidth = +a[i++];
        } else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        } else {
            minWidth = +minWidth;
        }

        // Note: undocumented perl feature:
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }

        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }

        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
        } else if (precision == '*') {
            precision = +a[i++];
        } else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        } else {
            precision = +precision;
        }

        // grab value using valueIndex if required?
        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

        switch (type) {
            case 's': return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'i':
            case 'd':
                number = parseInt(+value, 10);
                prefix = number < 0 ? '-' : positivePrefix;
                value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                return justify(value, prefix, leftJustify, minWidth, zeroPad);
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                number = +value;
                prefix = number < 0 ? '-' : positivePrefix;
                method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                value = prefix + Math.abs(number)[method](precision);
                return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
            default: return substring;
        }
    };
    
    NgLogD(format.replace(regex, doFormat));
}

function IsVecZero(vec)
{
    return vec[0] === 0 && vec[1] === 0 && vec[2] === 0;
}

//////////////////////////////////////////////////////////////////////////////
// Function ObjectHandler
var ObjectUtils =
{
    //public method
    GetCloneOfObject: function(oldObject)
    {
        var tempClone = {};
        if(typeof(oldObject) == "object")
        {
            for(var prop in oldObject)
            {
                // for array use private method getCloneOfArray
                if((typeof(oldObject[prop]) == "object") && (oldObject[prop] instanceof Array))
                {
                    tempClone[prop] = this.GetCloneOfArray(oldObject[prop]);
                }
                // for object make recursive call to getCloneOfObject
                else if(typeof(oldObject[prop]) == "object")
                {
                    tempClone[prop] = this.GetCloneOfObject(oldObject[prop]);
                }
                // normal (non-object type) members
                else
                {
                    tempClone[prop] = oldObject[prop];
                }
            }
        }
        return tempClone;
    },

    //private method (to copy array of objects) - getCloneOfObject will use this internally
    GetCloneOfArray: function(oldArray)
    {
        var tempClone = [];

        for (var arrIndex = 0; arrIndex <= oldArray.length; arrIndex++)
        {
            if(typeof(oldArray[arrIndex]) == "object")
            {
                tempClone.push(this.GetCloneOfObject(oldArray[arrIndex]));
            }    
            else
            {
                tempClone.push(oldArray[arrIndex]);
            }
        }
        return tempClone;
    }
};

////////////////////////////////////////////////////////////////////////////////
// Function: weGamePosToScreenPos
// modifies position in-place to match we-rule layout rules.
function weGamePosToScreenPos( pos, zOffset )
{
  var tmp = [];

  tmp[ 0 ] = cTileSizeWidth * 0.5 * ( pos[ 0 ] - pos[ 1 ] );
  tmp[ 1 ] = ( pos[ 0 ] + pos[ 1 ] ) * cTileSizeHeight * 0.5; 
  
  pos[ 0 ] = tmp[ 0 ] + gRawWidth * 0.5;
  pos[ 1 ] = -tmp[ 1 ]+ gRawHeight * 0.5;
  // flip sign because screen is inverted for webgame (?).
  
  // re-interpret zOffset which is really a y position in tile space
  // as a z value in a narrow chunk of GL z-space.
  //var zRange = 0.1;   // Magic number!!!
  //pos[ 2 ] = ( pos[ 2 ] ) - zRange + ( ( ( pos[ 1 ] + zOffset ) / ( cMaxY * 2.0 ) ) * zRange );
}

////////////////////////////////////////////////////////////////////////////////
// Function: GetGamePosToScreenLoc
// Converts a "game" position to a screen location.  The differnce between this
// and the "weGAmePosToScreenPos" function is that the camera location has
// been accounted for
function GetGamePosToScreenLoc(gamePosition)
{
	var screenLoc = [];
	var p = [];

// JMG *********
// Couldn't get this working - so I reverted to the old code from
// the original kingdoms_android_1_0
//	  var bx = new Vec2D(cTileSizeWidth, -cTileSizeHeight);
//	  var by = new Vec2D(-cTileSizeWidth, -cTileSizeHeight);
//	  var p = WeMath.AddVec2D(bx.scale(gamePosition[0]*0.5),by.scale(gamePosition[1]*0.5));
// -- also removed this from the bottom:
//    screenLoc[0]=(p[0] + WeRenderDevice.GetScreenInfo().mWidth * 0.5);
//    screenLoc[1]=(p[1] + WeRenderDevice.GetScreenInfo().mHeight * 0.5);
//    return screenLoc;	
// *************

	p[0] = cTileSizeWidth * 0.5  * (gamePosition[0] - gamePosition[1]);
	p[1] = (gamePosition[0] + gamePosition[1]) * cTileSizeHeight * 0.5;
    p[1] = -p[1];	

    // shift by screen
	var scale = WeRenderDevice.GetScaleRoot().GetScale().getX();
    p[0] += WeCamera.getX() + gRawWidth * 0.5;
    p[1] += WeCamera.getY()+ gRawHeight * 0.5;
    p[0] *= scale;
    p[1] *= scale;
	return p;
}

////////////////////////////////////////////////////////////////////////////////
// Function: weGamePosToScreenPos
// modifies position in-place to match we-rule layout rules.
function weScreenPosToGameWorld( pos )
{
    var scale = WeRenderDevice.GetScaleRoot().GetScale().getX();
    var sceenCenterX = ((pos[0] - gRawWidth*0.5)) * (1/scale) - 
                        WeCamera.transRoot.getPosition().getX() ;
    var sceenCenterY = ((pos[1] - gRawHeight*0.5)) * (1/scale)- 
                        WeCamera.transRoot.getPosition().getY();
    sceenCenterY = -sceenCenterY;
    var gamePos = [];
    gamePos[0] = sceenCenterX / cTileSizeWidth + sceenCenterY / cTileSizeHeight;
	gamePos[1] = sceenCenterY / cTileSizeHeight - sceenCenterX / cTileSizeWidth;
    gamePos[2] = 0.1;
    
	return gamePos;	
}

function ScreenToWorldPos(pos)
{
    var scale = WeRenderDevice.GetScaleRoot().GetScale().getX();
    
    var sceenCenterX = pos[0]/scale;
    var sceenCenterY = pos[1]/scale;
    
    sceenCenterX = ((sceenCenterX - gRawWidth*0.5)) - 
                        WeCamera.getX() ;
    sceenCenterY = ((sceenCenterY - gRawHeight*0.5))- 
                        WeCamera.getY();
    sceenCenterY = -sceenCenterY;
    
	return new Vec3D(   sceenCenterX / cTileSizeWidth + sceenCenterY / cTileSizeHeight,
                        sceenCenterY / cTileSizeHeight - sceenCenterX / cTileSizeWidth,
                        0.1);
}


function WorldToScreenPos(pos)
{
	var screenLoc = new Vec2D();
    var tmp = [];
	
	// do the iso math to convert to screen space
	tmp[0] = cTileSizeWidth * 0.5  * (pos.x - pos.y);
	tmp[1] = (pos.x + pos.y) * cTileSizeHeight * 0.5;
    tmp[1] = -tmp[1];
   
    // shift by screen
    var scale = WeRenderDevice.GetScaleRoot().GetScale().getX();
    tmp[0] += WeCamera.getX() + gRawWidth * 0.5;
    tmp[1] += WeCamera.getY() + gRawHeight * 0.5;
    tmp[0] *= scale;
    tmp[1] *= scale;
    
    screenLoc.x = tmp[0];
    screenLoc.y = tmp[1];
    return screenLoc;	
}

////////////////////////////////////////////////////////////////////////////////
// Function: PrintChildrenInfo
// recursively prints out info regarding each child in this object
function PrintChildrenInfo(obj)
{
	if (obj == undefined || obj == null)
	{
		return;
	}
	
	NgLogD("id:" + obj.mId);// + " name:" + obj.xName + " Z:" + obj.mZ);
	if ( obj.mChildren != undefined && obj.mChildren != null )
	{
		if ( obj.mChildren.length > 0 )
		{
			NgLogD("------------ " + obj.mChildren.length + " -------------");
			for (var i = 0; i < obj.mChildren.length; ++i)
			{			
				PrintChildrenInfo(obj.mChildren[i]);
			}
			NgLogD("-------------------------------");
		}
	}
}

function DebugPrintCallstack()
{
	try {
		// force an exception
		nonexistantfunc();
	}
	catch(e)
	{
		// now print out the relevant exception
		NgLogD("OOOOOOOooooooo........ strt DebugPrintCallstack ........oooooooOOOOOOO");
		for (var item in e)
		{
			NgLogD("$$$     " + item + ": " + e[item]);
		}
		NgLogD("OOOOOOOooooooo........ end DebugPrintCallstack ........oooooooOOOOOOO");
	}
}


////////////////////////////////////////////////////////////////////////////////
// Function: IterateChildrenAndCallFunc
// recursively runs the given function on each of this objects children.
function IterateChildrenAndCallFunc(obj, func, param)
{
	func(obj, param);
	if ( obj.mChildren != undefined && obj.mChildren != null )
	{
		if ( obj.mChildren.length > 0 )
		{
			for (var i = 0; i < obj.mChildren.length; ++i)
			{			
				IterateChildrenAndCallFunc(obj.mChildren[i], func, param);
			}
		}
	}
}

function ReOrderZHeirarchy(obj, newZ)
{
	obj.setPosition(obj.mX, obj.mY, newZ);
	// now push all this objects childrens Z slightly higher than this objects Z
	if ( obj.mChildren != undefined && obj.mChildren != null )
	{
		if ( obj.mChildren.length > 0 )
		{
			for (var i = 0; i < obj.mChildren.length; ++i)
			{			
				ReOrderZHeirarchy(obj.mChildren[i], newZ + 0.01);
			}
		}
	}
}

function FixTouchPositionForOrientation(pos)
{
    return pos;
    /*
     * $TODO This code was removed for MWC DEMO.  Put back after demo is branched
     */

    /*
    var touchPosition = new Core.Vector( pos.getX(), pos.getY() );
    
	if(Device.OrientationEmitter.getDeviceOrientation()===Device.OrientationEmitter.Orientation.LandscapeRight)
	{
		var screen = WeRenderDevice.GetScreenInfo();
		
		touchPosition.setX( screen.mWidth - touchPosition.getX() );
		touchPosition.setY( screen.mHeight - touchPosition.getY() );
	}	
	return touchPosition;
    */
}

function IsTimerFinished(cStartTime, nMiliesTillEnd)
{
	var nEndTime = WeTime.GetGameDate();
	nEndTime.setTime( nMiliesTillEnd + cStartTime.getTime());
	var currentDate = WeTime.GetGameDate();	
	return nEndTime < currentDate;
}

function dummyGift ()
{
	var item =  {
					'can_gift_back'	: false,
					'image'			: 'alpha2',
					'date_sent'		: null,
					'boost_cost'	: -1,
					'proto_gift_id'	: -1,
					'sender'		: '',
					'recipient'		: '',
					'id'			: -1,
					'campaign'		: '',
					'gift_description': '',
					'date_opened'	: null,
					'free_open'		: true,
					'gift_tier'		: 0,
					'proto_gift'	: null
				};
	return item;
}

var AlphaAnimation = Core.MessageListener.subclass(
{
    initialize : function(fAnimationTime, fFrom , fTo, object )
    {
    	this.m_fFrom=fFrom;
    	this.m_fTo=fTo;
    	this.m_fAnimationTime=fAnimationTime;
    	this.m_fAllAnimationTime=fAnimationTime;
    	this.m_object=object;
    	
    	Core.UpdateEmitter.addListener(this, this.onUpdate);
    	this.m_stoped=false;
    	
    },

    classname: 'AlphaAnimation',
    
    onUpdate: function()
    {	
    	var fDelta=  Core.Time.getFrameDelta();
    	fDelta*=0.001;
    	this.m_fAnimationTime-=fDelta;
    	var alpha= (this.m_fTo-this.m_fFrom) * ( 1- ( this.m_fAnimationTime / this.m_fAllAnimationTime));
    	if(this.m_fAnimationTime<=0)
		{
    		alpha=this.m_fTo;
    		this.Stop();
		}
		try {
			this.m_object.setAlpha(alpha);
		}
		catch(err) {
			// NgLogD("No setAlpha!");
			// NgLogD(err.stack);
		}
    		
    },
    
    Stop: function()
    {
    	if(!this.m_stoped)
    	{
	    	Core.UpdateEmitter.removeListener(this);
	    	this.m_stoped=true;
    	}
    }
});

var SinAnimation = Core.MessageListener.subclass(
{
    initialize : function(start)
    {
    	this.m_fAnimationTime=start;
    	
    	this.OnStop=null;
    	this.SetNumber=null;
    	
    	Core.UpdateEmitter.addListener(this, this.onUpdate);
    	this.m_stoped=false;
    },

    classname: 'SinAnimation',
    
    onUpdate: function()
    {	
    	
    	var fDelta=  Core.Time.getFrameDelta();
    	fDelta*=0.001;
    	this.m_fAnimationTime+=fDelta*Math.PI;
    
    	var alpha=(Math.sin(this.m_fAnimationTime)+1)*0.5;
    	if(this.SetNumber)
    	{
    		this.SetNumber(alpha);
    	}
    },
    
    Stop: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);
    		if(this.OnStop)
    		{
    			this.OnStop();
    		}	
    	}
    }
});


var NumberAnimation = Core.MessageListener.subclass(
{
    initialize : function(fAnimationTime, fFrom , fTo )
    {
    	this.m_fFrom=fFrom;
    	this.m_fTo=fTo;
		this.m_fAnimationStart = Core.Time.getFrameTime() / 1000;
    	this.m_fAllAnimationTime=fAnimationTime;
    	
    	this.OnStop=null;
    	this.SetNumber=null;
    	this.m_bLoop=false;
    	
    	Core.UpdateEmitter.addListener(this, this.onUpdate);
    	this.m_stoped=false;
    },

    classname: 'NumberAnimation',
    
    setLoop: function(loop)
    {
    	this.m_bLoop=loop;
    },
    
    onUpdate: function()
    {	
		var t = Core.Time.getFrameTime();
		t = ((t / 1000) - this.m_fAnimationStart) / this.m_fAllAnimationTime;
		var alpha = this.m_fFrom + (this.m_fTo-this.m_fFrom) * t;
    	if(t > 1)
		{
    		alpha=this.m_fTo;
    		if(this.m_bLoop)
    		{
				this.m_fAnimationStart = Core.Time.getFrameTime() / 1000;
    		}
    		else
    		{
		    	if(this.SetNumber)
		    	{
		    		this.SetNumber(alpha);
		    	}
				this.Stop();
				return;
    		}
		}
    	if(this.SetNumber)
    	{
    		this.SetNumber(alpha);
    	}
    },
    
    Stop: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);
    		if(this.OnStop)
    		{
    			this.OnStop();
    		}	
    	}
    },
    
    StopNoCallBack: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);	
    	}
    }
    
});

var MoveAnimation = Core.MessageListener.subclass(
{
    initialize : function(fAnimationTime, fFromX , fToX, fFromY, fToY )
    {
    	this.m_fFromX=fFromX;
    	this.m_fToX=fToX;
    	this.m_fFromY=fFromY;
    	this.m_fToY=fToY;
		this.m_fAnimationStart = Core.Time.getFrameTime() / 1000;
    	this.m_fAllAnimationTime=fAnimationTime;
    	
    	this.OnStop=null;
    	this.SetNumber=null;
    	this.m_bLoop=false;
    	
    	Core.UpdateEmitter.addListener(this, this.onUpdate);
    	this.m_stoped=false;
    },

    classname: 'MoveAnimation',
    
    setLoop: function(loop)
    {
    	this.m_bLoop=loop;
    },
    
    onUpdate: function()
    {	
		var t = Core.Time.getFrameTime();
		t = ((t / 1000) - this.m_fAnimationStart) / this.m_fAllAnimationTime;
		var alpha = this.m_fFromX + (this.m_fToX-this.m_fFromX) * t;
		var alpha2 = this.m_fFromY + (this.m_fToY-this.m_fFromY) * t;
    	if(t > 1)
		{
    		alpha=this.m_fToX;
    		alpha2=this.m_fToY;
    		if(this.m_bLoop)
    		{
				this.m_fAnimationStart = Core.Time.getFrameTime() / 1000;
    		}
    		else
    		{
		    	if(this.SetNumber)
		    	{
		    		this.SetNumber(alpha, alpha2);
		    	}
				this.Stop();
				return;
    		}
		}
    	if(this.SetNumber)
    	{
    		this.SetNumber(alpha, alpha2);
    	}
    },
    
    Stop: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);
    		if(this.OnStop)
    		{
    			this.OnStop();
    		}	
    	}
    },
    
    StopNoCallBack: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);	
    	}
    }
    
});


var Timer = Core.MessageListener.subclass(
{
    initialize : function(fAnimationTime, OnStop )
    {
    	if(OnStop== undefined || OnStop==null)
    	{
    		NgLogD("Bad parameter Timer");
    	}
    	this.m_fAnimationTime=fAnimationTime;
    	this.OnStop=OnStop;
    	this.m_stoped=false;
    	Core.UpdateEmitter.addListener(this, this.onUpdate);
    },

    classname: 'EmptyAnimation',
    
    onUpdate: function()
    {	
    	var fDelta=  Core.Time.getFrameDelta();
    	fDelta*=0.001;
    	this.m_fAnimationTime-=fDelta;
    	if(this.m_fAnimationTime<=0)
		{
    		this.Stop();
    		return;
		}
    },
    
    StopNoCallBack: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);
    		this.OnStop=null;
    	}    	
    },
    
    Stop: function()
    {
    	if(!this.m_stoped)
    	{
    		this.m_stoped=true;
    		Core.UpdateEmitter.removeListener(this);
    		if(this.OnStop)	
    		{
	    		this.OnStop();
	    		this.OnStop=null;
    		}
    	}
    }
});

var SimpleTimer = Core.Class.subclass(
{
    initialize : function(nWorkTime)
    {
    	this.Reset(nWorkTime);
    },
    
    classname: 'SimpleTimer',
    
    Reset: function(nWorkTime)
    {
    	this.mWorkTimer=nWorkTime;
    	this.mStartTime= WeTime.GetGameDate();
    	this.mEndTime = WeTime.GetGameDate();
    	this.mEndTime.setTime( this.mWorkTimer + this.mEndTime.getTime());
    	this.mProgress=0;
    },
    
    Update: function()
    {	
        var curDelta = WeTime.GetGameDate().getTime() - this.mStartTime.getTime();
        var endDelta = this.mEndTime.getTime() - this.mStartTime.getTime();
        this.mProgress = curDelta/endDelta;
        if(this.mProgress >= 1)
        {
        	this.mProgress=1;
        }
        
        if(this.mProgress < 0)
    	{
        	this.mProgress=0;
        	NgLogD("Bad data in timer");
    	}
    },
    
    GetPercents: function()
    {
    	return Clamp( Math.floor(this.mProgress*100), 0, 100 );
    },
    
    GetProgress: function()
    {
    	return this.mProgress;
    }    
    
});

function PrintMemStats()
{
	var allocs = [];
	for(var key in gMemStats) 
	{
		allocs.push([key, gMemStats[key]]);
	}

	var predicate = function(a, b) 
	{
		if(a[1] == b[1])
			return 0;
		return a[1] < b[1] ? 1 : -1;
	};

	allocs.sort(predicate);

	NgLogD('=== Memory allocation stats:');
	for(var i in allocs)
		NgLogD('' + allocs[i][0] + ' = ' + allocs[i][1]);
}


function getSmallFontSize()
{
	if ( Core.Capabilities.getDeviceName() === "Galaxy Nexus")
	{   // hack 
	    return 10;
	}
	
	if (gRawWidth < 1000)
	{
		return 10;
	}
	else
	{
		return 12;
	}
}


function getLargeFontSize()
{
	if ( Core.Capabilities.getDeviceName() === "Galaxy Nexus")
	{   // hack 
	    return 15;
	}
	
	if (gRawWidth < 1000)
	{
		return 15;
	}
	else if (gRawWidth < 1100)
	{
		return 18;
	}
	else
	{
		return 22;
	}
}

function DebugTouch(touch, message)
{
	var globals = WeUiMgr.GetJSONGlobals();
	if (Exists(globals) && Exists(globals["debug-touch"]) && globals["debug-touch"] && touch.getAction() != touch.Action.Move)
	{
		NgLogD(" Touch " + message + " onTouch() ID: " + touch.getId() + ", action: " + touch.getAction() + " at (" + touch.getPosition().getX() + ", " + touch.getPosition().getY() + ")" );
	}
}

function basename(path) 
{
    return path.replace(/\\/g,'/').replace( /.*\//, '' );
}

function dirname(path) 
{
    return path.replace(/\\/g,'/').replace(/\/[^\/]*$/, '');
}

function endsWith(str, suffix)
{
	return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

//////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-20
 *  @file:      Main.js
 *  @author:    Chris Jimison
 *  @copyright: 2010 NGMOCO:) All rights reserved
 * 
 *  @brief: Main file to launch the game.  Was the former webgame
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var Storage = require('NGCore/Client/Storage').Storage;
var Network = require('NGCore/Client/Network').Network;
var Bank = require('NGCore/Client/Bank').Bank;
var WeTime = require('weEngine/WeTime').WeTime;
var WeContentDownloader = require('weEngine/WeContentDownloader').WeContentDownloader;
var WeUiMgr = require('weEngine/WeUiMgr').WeUiMgr;

// Upgrade purchase states
var UpgradeStatus =
{
    kCanPurchase        :0,
    kCannotPurchase     :1,
    kAlreadyPurchased   :2,
    kCannotAfford       :3
};


function weReadProtoConfigs ( serverTxt )
{
	weProtoConfigs.getInstance().initWithJson(serverTxt);
	//REMOVE
	//fullRecurseDump(weProtoConfigs.getInstance().map, 4, 0);
	
    gConfigs = weProtoConfigs.getInstance().map;
	NgLogD("gConfigs:");
	for(var i in gConfigs) {
		NgLogD("" + i + " -> " + gConfigs[i]); 
	}
        
	Storage.KeyValueCache.local.getItem("protoDbVersion",function ( err, data )
    {
		var updateProtoDb = true;
		
		
		
		var dbVersion = gConfigs.ProtoDataVersion;
		
            if (!err)    // present, do comparison with downloaded proto config version.
            {
            	
            	NgLogD("stored db version: " + data + " server version: " + dbVersion);
            	updateProtoDb = (dbVersion != data);
            }
            
            if (updateProtoDb)
            {
            	weDownloadProtoDb();
            	Storage.KeyValueCache.local.setItem('protoDbVersion', dbVersion);		
            }
            else
            {
            	weReadProtoDb();
            }
        });
}

/////
// Proto db
         
function weReadTableFiles(tables)
{
    var mytables = tables;
    if (tables.length > 0)
    {
        var table = tables[0];
        var fs = Storage.FileSystem;
        NgLogD("READ FILE0 " + table);
        ReadFile(fs, "table_"+table, {'blocking': false}, function(err, data)
        {
            NgLogD("READ FILE " + table + " : "+ err);
            if (!err )    // present, do comparison with downloaded proto config version.
            {
                NgLogD("READ FILE2 " + table + " more: " + mytables.length);
                weFinishProtoDbTable(data);
            
                mytables.shift();
                weReadTableFiles(mytables);
            }
            else
            {   // error reading file, try to download everything again instead
                weDownloadProtoDb();
            }
        });
    }
    else
    {
        NgLogD("READED ALL MY TABLES");
       
        weProtoDb.getInstance().initIndices();
        weGetBankProducts();
    }
}         
         
function weDownloadFiles(tables)
{
    var mytables = tables;
    
    if (tables.length > 0)
    {
        var table = tables[0];
        NgLogD ( "GET TABLE " + table);
        var url = WeProtocol.makeAppUrl( this.kVerbGet, "/proto_database?user_name=" + "awmob2" + "&table=" + table );
                    new Network.DownloadFile().start("table_"+table, 'GET', url, [],
                     (function(status, md5)
                     {
                         NgLogD('Downloaded data ' + status + " : " + table); 
                        // weFinishProtoDbTable(data);

                         mytables.shift();
                         weDownloadFiles(mytables);
                     }).bind(this)
                 );
    }
    else
    {
        NgLogD("DOWNLOADED ALL MY TABLES");
        weReadTableFiles(this.mFilesToRead);
    }
}


function weDownloadProtoDb ()
{
    if (!DeviceIsLowMemory())
    {
        NgLogD ( "Downloading proto db" );
        WeProtocol.getProtoDb(function(request){
    	
        	 if(request && request.responseText && request.readyState == 4 )
        	 {
        		 NgLogD("received proto db response ");
    		 
        		 weFinishProtoDb(request.responseText);
        	     Storage.KeyValueCache.local.setItem('protoDb', request.responseText);	
        	 }
        	 else
        	 {
        		 NgLogD("no proto db in response");
        	 }
    	
        });
    }
    else
    {
        NgLogD ( "Downloading proto db list" );
         WeProtocol.getProtoDbList(function(request){

             if(request && request.responseText && request.readyState == 4 )
             {
                 NgLogD("received proto db list response: " + request.responseText);
                 Storage.KeyValueCache.local.setItem('protoDb_list', request.responseText); 
                 var json = JSON.parse(request.responseText);
                 this.mTablesInProgress = [];
                 this.mFilesToRead = [];
                 if (json && json.tables)
                 {
                     json.tables.forEach(function(table)
                     {
                         NgLogD ( "TABLE " + table);
                         this.mTablesInProgress.push(table);
                         this.mFilesToRead.push(table);
                     });
                     
                     weDownloadFiles(this.mTablesInProgress);
                 }
                 
             }
         });
    
    }
}

function weReadProtoDb ()
{
    if(Core.Capabilities.getPlatformOS() == "flash")
    {
        weDownloadProtoDb ();
    }
    else
    {
        NgLogD("** READ PROTODB FILE START");
        if (!DeviceIsLowMemory())
        {
            var startTime= new Date().getTime();
            Storage.KeyValueCache.local.getItem("protoDb", function ( err, data )
            	{
    	        	NgLogD("** READ PROTODB FILE FINISHED token: "+ (new Date().getTime() - startTime  ) );
    	            if ( ! err )
    	            {
    	                weFinishProtoDb ( data, false );
    	            }
    	            else
    	            {   
    	                // Try to salvage things by downloading proto db.
    	                weDownloadProtoDb ();
    	            } 
            	}
            );
        }
        else
        {
            var startTime= new Date().getTime();
            Storage.KeyValueCache.local.getItem("protoDb_list", function ( err, data )
            	{
    	            if ( !err && data)
    	            {

    	                var json = JSON.parse(data);
                         this.mTablesInProgress = [];
                         this.mFilesToRead = [];
                         if (json && json.tables)
                         {
                             json.tables.forEach(function(table)
                             {
                                 NgLogD ( "TABLE " + table);
                                 this.mTablesInProgress.push(table);
                                 this.mFilesToRead.push(table);
                             });

                             weReadTableFiles(this.mFilesToRead);
                         }
                         
                     }   
            	});
        }
    }
}

function weGetBankProducts()
{
    NgLogD("### WeLoadNamedLot user:"+gCurKingdomUser);

       getMtxProducts();



   	if (gFirstBoot)
   	{
   		//
   		//	report  analytics	
   		//
   		Core.Analytics.reportFunnelStage('NEWUSER', 1, 'KINGDOMLOAD', {});
   	}
}

function weFinishProtoDb ( txt, doCache )
{
    weProtoDb.getInstance ().initWithJson ( txt );
    
	weGetBankProducts();

    
}

function weFinishProtoDbTable ( txt, doCache )
{
    weProtoDb.getInstance().initWithJsonTable ( txt );    
}

function getMtxProducts()
{
    //
	// get mtx products	
	//
	WeProtocol.getMtxProducts(BankResponseCallback);
}

var timePingSent = 0;
function weGetServerPing()
{
	NgLogD("### weGetServerPing");
    var date = new Date();
    timePingSent = date.getTime();
    WeProtocol.getPing(function(request)
    {
    	NgLogD("### Ping response");
        if(request.readyState == 4)
        {
            if(request.responseText)
            {
            
                if (0 !== request.responseText.length )
                {
                    try
                    {     
                        var json = JSON.parse(request.responseText);
                        
                        //
                        //	set time to server time
                        //
                        WeTime.SetServerTime(new Date(json.time*1000).getTime());

                        NgLogD("starting session");
                        weStartSession();
                    }
                    catch(ex)
                    {
                        //ExitOnError(gErrors.SERVER_MESSAGE_REJECTED_CRITICAL);
                        WeUiMgr.ShowNetworkErrorPopUp();
                    }
                    
                }
                else
                {
                    NgLogD("Hmmm....:" + request.responseText);
                    //ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
                    WeUiMgr.ShowNetworkErrorPopUp();
                }
            }
            else
            {
                NgLogD("No response text " + request.responseText);
                //ExitOnError(gErrors.SERVER_MESSAGE_REJECTED_CRITICAL);
                WeUiMgr.ShowNetworkErrorPopUp();
            }
        }
        else if(request.readyState === 0)
        {
            //ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
    });
}

/////
// Session


function BankResponseCallback(request)
{
	
	WeLoadNamedLot(gCurKingdomUser);
	
    if(request && request.responseText && request.readyState == 4 )
     {
		    try
         {
             
             var data = JSON.parse(request.responseText);
             
            // var temp = {};
            //  temp.product_identifier = "WR_ITEM_01";
            //  temp.entity = 350;
            //  temp.mana = 0;
            //  temp.store_image_url = "bld_mysticmeadow01.png";
              
            //  var test = {};
            //  test.mtx_product = temp;
            //  data.push(test);
             
             var size = data.length;
             WeUiMgr.mIAPData = [];
             for(var index = 0; index < size; ++index)
             {
                 NgLogD("*** GET BANK ITEM:" + data[index].mtx_product.product_identifier + "?");

                 data[index].mtx_product.product_identifier = data[index].mtx_product.product_identifier.replace(/\s+/g, '');
                 Bank.Inventory.getItem(data[index].mtx_product.product_identifier, function(error, item)
                 {
                     if(error)
                     {
                         NgLogD("*** BANK ERROR " + error.description);
                         // WeUiMgr.ShowNetworkErrorPopUp();
                     }
                     else
                     {
                         var mojo = item.id.match(/([0-9]+)$/g);

                         var iap = {};
                         iap.name = item.name;

                         //NgLogD("########  BankResponseCallback ######");
                         //fullRecurseDump(item);
                         if (!Exists(item.description))
                         item.description = "";
                         //NgLogD("########  BankResponseCallback END ######");
                         iap.description = item.description.replace("\\n", "\n");

                         iap.cost = item.price;

                         var index = 0;
                         for(; index < size; ++index)
                         if(data[index].mtx_product.product_identifier == item.id)
                         break;

                         iap.entity = data[index].mtx_product.entity;
                         iap.asset = data[index].mtx_product.store_image_url;
                         iap.mojo = data[index].mtx_product.mana;
                         iap.product_identifier = item.id;
                         NgLogD("*** GET BANK PUSH: " + iap.product_identifier);
                         WeUiMgr.mIAPData.push(iap) ;
                     }
                 });
             }

          
         }
         catch(ex) 
         {
			   WeUiMgr.ShowNetworkErrorPopUp();
         }
     }
    
    

}

function weStartSession()
{
	
    WeProtocol.postSessions( function ( request )
    {
        if ( request.responseText && request.responseText.length )
        {
            try
            {
                 dumpResponse ( "Session started", request );
                 var configJson = JSON.parse(request.responseText);

                // weDownloadProtoConfigs(configJson.proto_configs);
                 
                 NgLogD("#### weStartSession Response from ");
                 
                 // if (Exists(configJson.interstitial_params) && Exists(configJson.interstitial_params.command))
                 //                  {
                 //                     var command = configJson.interstitial_params.command;
                 //                     NgLogD("### INTERSTITIAL COMMAND " + command);
                 //                     WeGameStateMgr.mInterstitialCommand = command;
                 //                  }
          		
                //
          		//	Update content
          		//
          		
          		if( Core.Capabilities.getPlatformOS() == "Android")
                {
          		    WeContentDownloader.UpdateContent(configJson["user_level"], function() 
                   		 {
                        	gStatusMessage = "Fetching your kingdom...";
                    	
                        	//
                        	//	download proto db
                        	//
                        	weReadProtoConfigs(configJson.proto_configs);
                    	}
                    );
                }
                else
                {
                    var level = configJson["user_level"];
                    if (DeviceIsLowMemory())
            		{
            		    level = 100;
        		    }
            		    
                    WeContentDownloader.UpdateContent(level, function() 
                   		 {
                        	gStatusMessage = "Fetching your kingdom...";
                    	
                        	//
                        	//	download proto db
                        	//
                        	weReadProtoConfigs(configJson.proto_configs);
                    	}
                    );
                }
         		
            }
            catch(ex)
            {
                NgLogException ( ex );
                WeUiMgr.ShowNetworkErrorPopUp();
            }
         }
         else
         {
             NgLogD ( "Session start failed with code " + request.status );
             WeUiMgr.ShowNetworkErrorPopUp();
         }
    });
}

////////////////////////////////////////////////////////////////////////////////

function weBase()
{
    
}

// helper method that makes it easy to create an index for a particular 
// object attribute.
weBase.prototype.makeIndex = function ( dstName, src, dstItemFunc, srcValueFunc, dbg )
{
    this[ dstName ] = {};
    var dst = this[ dstName ];
    
    for ( var item in src )
    {
        var obj = src[ item ];
        var key = dstItemFunc ( obj );
        dst[ key ] = srcValueFunc ( obj );
    }
};

////////////////////////////////////////////////////////////////////////////////

function weProtoConfigs ()
{
    
}

weProtoConfigs.prototype = new weBase();

weProtoConfigs.sInstance = null;

weProtoConfigs.getInstance = function ()
{
    if ( ! weProtoConfigs.sInstance )
    {
        weProtoConfigs.sInstance = new weProtoConfigs();
    }
    
    return weProtoConfigs.sInstance;
};

// We throw away the outer wrapper for each config that says it's a proto_config.
// They all have it, so, today it's redundant.
// Ultimately, we use the key as a key for member variables set in the config object.
// We also set up an array to do lookups by config id.
weProtoConfigs.prototype.initWithJson = function ( jsonText )
{
    this.idMap = {};
    var json = null;
    try
    {
        json = JSON.parse ( jsonText );
    }
    catch(error)
    {
        NgLogD("****************** jason parse error");
        NgLogD("Error = " + error.description);
        NgLogD("****************** jason parse error End");
        WeUiMgr.ShowNetworkErrorPopUp();
    }
    
	// Convert configs to a more sane format
	this.map = {};
    for (var i in json)
    {
        var key = json[i].proto_config.key;
		var value = json[i].proto_config.value;
		if (!isNaN(Number(value)))
		{
        	this.map[key] = parseFloat(value);
		}
		else
		{
			this.map[key] = value;
		}
			
		if(!isFinite(this.map[key]) || key == 'ProtoDataVersion') 
		{
			this.map[key] = value;
		}
    }
    
    //fullRecurseDump(this.map, 4);
	//NgLogD("@@@@@ CONFIG MAP: @@@@@");
	//printFull(JSON.stringify(this.map), 120);

    this.makeIndex ( "configs", json,
                    function ( obj ) { return obj.proto_config.key; },
                    function ( obj ) { return obj.proto_config; } );
    
    this.makeIndex ( "mapIdToConfig", json,
                    function ( obj ) { return obj.proto_config.id; },
                    function ( obj ) { return obj.proto_config; } );
    
};



////////////////////////////////////////////////////////////////////////////////

function weProtoDb ()
{
    
}

weProtoDb.prototype = new weBase();

weProtoDb.sInstance = null;

weProtoDb.getInstance = function ()
{
    if( ! weProtoDb.sInstance )
    {
        weProtoDb.sInstance = new weProtoDb();
    }
    
    return weProtoDb.sInstance;
};

// example elements of the top-level json lists
//js:   
//first element = {
//    "proto_objective":{
//        "stone_reward":0,
//        "requires_stone":0,
//        "requires_quest_id":0,
//        "requires_archers":0,
//        "previous_objective_id":0,
//        "requires_building_count":1,
//        "xp_reward":25,
//        "building_reward_id":0,
//        "requires_building_id":4,
//        "infantry_reward":0,
//        "requires_harvest":false,
//        "requires_food":0,
//        "requires_decoration_unlock":false,
//        "proto_name":"Build a Farm",
//        "wood_reward":0,
//        "requires_cavalry":0,
//        "id":2,
//        "completed_icon_png":"tut_plantCrops.png",
//        "requires_upgrade_id":0,
//        "cavalry_reward":0,
//        "requires_show_social_map":false,
//        "requires_hire":false,
//        "icon_png":"tut_buildFarm.png",
//        "gold_reward":0,
//        "requires_population":0,
//        "requires_level":0,
//        "requires_infantry":0,
//        "requires_gold":0,
//        "display_name":"Build a Farm",
//        "description":"Build a farm, so that we can start harvesting crops for our Kingdom.",
//        "requires_collected_taxes":false,
//        "requires_boost":false,
//        "mana_reward":0,
//        "food_reward":0,
//        "upgrade_reward_id":0,
//        "requires_wood":0,
//        "requires_trade":false,
//        "completed_description":"Good job. At the farm you can plant and grow different crops which you can then harvest for gold.","archers_reward":0
//        }
//    }
//    
//js:
//first element = {
//    "proto_visual":{
//        "proto_entity_id":2,
//        "diamond_selection":false,
//        "proto_name":"Villager",
//        "offset_x":0,
//        "id":2,
//        "offset_y":14,
//        "z_order_vertical_offset":null,
//        "header_tag":"SPR_villagermale_idleone"
//        }
//    }
//js:
//first element = {
//    "proto_level":{
//        "required_xp":0,
//        "level":1,
//        "id":12,
//        "max_population":3,
//        "mana_reward":0
//        }
//    }
//js:
//first element = {
//    "proto_animation":{
//        "flip_horizontal":false,
//        "proto_name":"MoveNorth",
//        "proto_visual_id":2,
//        "id":2,
//        "frames_per_second":12,
//        "header_tag":"SPR_villagermale_waway"
//        }
//    }
//js:
//first element = {
//    "proto_event":{
//        "name":"Royal Feast",
//        "reward_xp":50,
//        "created_at":"2010-07-22T00:48:02Z",
//        "button_success_text":"Serve the Food",
//        "updated_at":"2010-07-22T00:48:02Z",
//        "sort_order":null,
//        "reward_mana":0,
//        "prerequisite_entity_id":null,
//        "prerequisite_amount":null,
//        "id":1,
//        "button_fail_text":"Clean the Mess",
//        "required_level":4,
//        "reward_gold":150,
//        "completion_text":"Delicious! Your guests left full and happy.",
//        "description":"Host a great feast with your friends and family in the castle.",
//        "active":true
//        }
//    }
//js:
//first element = {
//    "proto_upgrade":{
//        "gold_cost":750,
//        "xp_reward":200,
//        "wood_cost":0,
//        "from_proto_entity_id":162,
//        "kingdom_type":"main",
//        "store_image_url":"store/bld_Castle1_full.png",
//        "proto_name":"Keep",
//        "id":1,
//        "friends_requirement":1,
//        "food_cost":0,
//        "to_proto_entity_id":24,
//        "prerequisite_id":null,
//        "stone_cost":0,
//        "mojo_cost":null,
//        "active_trade_routes_reward":2,
//        "requires_level":4,
//        "map_expand_reward":0.3,
//        "description":"Improves your Castle and increases your Kingdom's lands."
//        }
//    }
//js:
//first element = {
//    "proto_product":{
//        "producing_proto_entity_id":4,
//        "produce_duration":21600,
//        "produce_cap":250,
//        "gold_cost":50,
//        "xp_reward":80,
//        "spoilage_duration":36000,
//        "boost_cost":2,
//        "proto_name":"Potatoes",
//        "proto_animation_id":364,
//        "level":10,
//        "proto_event_id":null,
//        "produce_type":"Gold",
//        "id":1,
//        "icon_png":"resBtn_potatoes.png",
//        "producing_text":"Growing Potatoes...",
//        "event_order":null,
//        "harvesting_text":"Harvesting..."
//        }
//    }
//js:
//first element = {
//    "proto_entity":{
//        "population_cost":0,
//        "mana_cost":0,
//        "produce_cap":null,
//        "prerequisite_objective_id":null,
//        "movement_speed":1.2,
//        "gold_cost":0,
//        "decal_z_order":3,
//        "coupon_message":null,
//        "xp_reward":0,
//        "sound_gather":null,
//        "parent_proto_entity_id":5,
//        "entity_type":"Villager",
//        "coupon_url":null,
//        "build_description":null,
//        "boost_cost":0,
//        "has_web_view":false,
//        "gold_sell_value":0,
//        "giftable":false,
//        "store_image_url":null,
//        "sound_placed":null,
//        "sound_build_complete":null,
//        "proto_product_2_id":null,
//        "proto_name":"Villager",
//        "level":1,
//        "iron_cost":0,
//        "decal_proto_visual_manid":140,
//        "sound_select":"Villager_2_Sanu.mp3",
//        "proto_product_3_id":null,
//        "produce_type":null,
//        "prerequisite_amount":null,
//        "obstruction_size_x":null,
//        "id":2,
//        "store_priority":null,
//        "required_level":50,
//        "primary_proto_visual_id":2,
//        "prerequisite_id":null,
//        "prerequisite_coupon":null,
//        "obstruction_size_y":null,
//        "list_icon_png":null,
//        "sound_select_while_growing":null,
//        "icon_png":null,
//        "gift_tier":null,
//        "can_flip":true,
//        "proto_product_1_id":null,
//        "store_category":null,
//        "build_time":0
//        }
//    }
//
// TODO: We strip off one level of object-ness for the proto configs and we
// also have a separate id index... but we don't do that here yet.  Maybe
// we should, maybe we shouldn't.

weProtoDb.prototype.initWithJson = function ( jsonText )
{
/* **** 
    var fs = Storage.FileSystem; 
    fs.writeFile ( "ProtoDatabaseFromServer.txt", jsonText, function ( err )
    {
        if ( ! err )
        {
            NgLogD ( "Wrote proto database to local file successfully" );
        } 
        else
        {
            NgLogE ( "Could not write local proto database file: " + err );
        }
    });
/* **** */
    var json = null;
    try
    {
        json = JSON.parse ( jsonText );
    }
    catch(err)
    {
        NgLogD("****************** jason parse error " + jsonText.length);
        WeUiMgr.ShowNetworkErrorPopUp();
    }
    
    var first = true;
    
    for ( var item in json )
    {
        //      NgLogD ( " proto db item = " + item );
        //      NgLogD ( "  first element = " + JSON.stringify ( json[ item ][ 0 ] ) );
        
        this[ item ] = json[ item ];
    }
    
    this.initIndices();
};

weProtoDb.prototype.initWithJsonTable = function ( jsonText )
{

    var json = null;
    try
    {
        json = JSON.parse ( jsonText );
    }
    catch(err)
    {
        NgLogD("****************** jason parse error " + jsonText.length);
        WeUiMgr.ShowNetworkErrorPopUp();
    }
    
    var first = true;
    
    for ( var item in json )
    {
        this[ item ] = json[ item ];
    }
    
  //  this.initIndices();
};

// helper method that makes it easy to create an index for a particular 
// object attribute.
weBase.prototype.makeIndex = function ( dstName, src, dstItemFunc, srcValueFunc, dbg )
{
    this[ dstName ] = {};
    var dst = this[ dstName ];
    
    for ( var item in src )
    {
        var obj = src[ item ];
        var key = dstItemFunc ( obj );
        dst[ key ] = srcValueFunc ( obj );
    }
};

// NOTE: when we do initWithJson, we keep the object wrapper around each
// item, e.g., we don't remove the "proto_visual" or "proto_entity" 
// layer from the items in the list.  BUT, when we build the lookup maps
// below, we do strip this off for performance and simplicity.

weProtoDb.prototype.initIndices = function ()
{
    this.proto_entities.sort(function(a, b)
    {
        return a.proto_entity.store_priority - b.proto_entity.store_priority;
    });
/*    
    NgLogD("@@@@  PROTODB LEVEL 1:   @@@@");
    for (var i in this)
    	NgLogD(i+" ");
    NgLogD("@@@@ PROTO GOAL SECTION: @@@@");
    if (Exists(this.proto_goals))
    {
    	printFull(JSON.stringify(this.proto_goals), 110);
    	NgLogD("@@@@    @@@@    @@@@    @@@@");
    	printFull(JSON.stringify(this.proto_goal_tasks), 110);
    }
    NgLogD("@@@@         END         @@@@");
*/    
    // proto id to proto object lookup maps.
    this.makeIndex ( "mapIdToEntity", this.proto_entities,
                    function ( obj ) { return obj.proto_entity.id; },
                    function ( obj ) { return obj.proto_entity; } );
    
    this.makeIndex ( "mapIdToVisual", this.proto_visuals,
                    function ( obj ) { return obj.proto_visual.id; },
                    function ( obj ) { return obj.proto_visual; } );

    this.makeIndex ( "mapIdToBuildLimit", this.proto_entity_build_limits,
                    function ( obj ) { return obj.proto_entity_build_limit.id; },
                    function ( obj ) { return obj.proto_entity_build_limit; } );
                    
    this.makeIndex ( "mapIdToAnimation", this.proto_animations,
                    function ( obj ) { return obj.proto_animation.id; },
                    function ( obj ) { return obj.proto_animation; } );

    this.makeIndex ( "mapIdToLevel", this.proto_levels,
                    function ( obj ) { return obj.proto_level.id; },
                    function ( obj ) { return obj.proto_level; } );
    
    this.makeIndex ( "mapIdToProduce", this.proto_products,
                    function ( obj ) { return obj.proto_product.id; },
                    function ( obj ) { return obj.proto_product; } );
    
    this.makeIndex ( "mapIdToEvent", this.proto_events,
                    function ( obj ) { return obj.proto_event.id; },
                    function ( obj ) { return obj.proto_event; } );

    this.makeIndex ( "mapIdToFeaturedItem", this.proto_featured_items,
                    function ( obj ) { return obj.proto_featured_item.proto_entity_id; },
                    function ( obj ) { return obj.proto_featured_item; } );
    
    this.makeIndex ( "mapIdToPrizewinners", this.proto_prizewinners,
            		function ( obj ) { return obj.proto_prizewinner.id; },
            		function ( obj ) { return obj.proto_prizewinner; } );
    
    this.makeIndex( "mapIdToGoal", this.proto_goals,
            		function ( obj ) { return obj.proto_goal.proto_id; },
            		function ( obj ) { return obj.proto_goal; } );
    
    this.makeIndex( "mapIdToGoalTask", this.proto_goal_tasks,
            		function ( obj ) { return obj.proto_goal_task.proto_id; },
            		function ( obj ) { return obj.proto_goal_task; } );    

	this.makeIndex( "mapIdToPest", this.proto_pests,
					function ( obj ) { return obj.proto_pest.proto_id; },
					function ( obj ) { return obj.proto_pest; } );
            
	for(var prizeIndex in this.proto_prizewinners)
	{
		var starting_buildingId = this.proto_prizewinners[prizeIndex].proto_prizewinner.starting_building_id;
		var entity = this.getProtoEntityById(starting_buildingId);
		if (entity)
		{
		    entity.hasPrizewinnerPotential = true;
		}
	}
                    
    // Build lookup table that maps proto_visual.id to array of proto_animations
    var table = [];
    for(var animationIndex in this.proto_animations)
    {
        var animation = this.proto_animations[animationIndex].proto_animation;
        var visualId = animation.proto_visual_id;
        if(!table[visualId])
        {
            table[visualId] = [];
        }
        table[visualId].push(animation);
    }
    this.proto_animations_for_proto_visual_id = table;

    //NgLogD( " weProtoDb finished making indices" );
};

// TODO: Error/range checking.

weProtoDb.prototype.getProtoEntityById = function ( id )
{
    return this.mapIdToEntity[ id ];
};

weProtoDb.prototype.getProtoEntityChildren = function ( entity )
{
    var childIdx = 0;
    var children = [];
    var len = this.proto_entities.length; 
    for(var idx = 0; idx < len; ++idx)
    {
        if(this.proto_entities[idx].proto_entity.parent_proto_entity_id == entity.id)
        {
            children[childIdx] = this.proto_entities[idx];
            childIdx++;
        }
    }

    return children;
};

weProtoDb.prototype.getProtoLevelLength = function ()
{
    return this.proto_levels.length;
};

weProtoDb.prototype.getProtoLevelByIdx = function ( idx )
{
    return this.proto_levels[idx].proto_level;
};

weProtoDb.prototype.getLevelByXp = function ( xp )
{
    var num_levels = this.proto_levels.length;
    for (var i = num_levels - 1; i >= 0; i--)
    {
        if (xp >= this.proto_levels[i].proto_level.required_xp)
        {
            return this.proto_levels[i].proto_level.level;
        }
    }
    return 1;
};

weProtoDb.prototype.getProtoLevelById = function ( id )
{
    return this.mapIdToLevel[ id ];
};

weProtoDb.prototype.getProtoEntityLength = function ()
{
    return this.proto_entities.length;
};

weProtoDb.prototype.getProtoVisualById = function ( id )
{
    return this.mapIdToVisual[ id ];
};

weProtoDb.prototype.getProtoProduceId = function ( id )
{
    return this.mapIdToProduce[ id ];
};

weProtoDb.prototype.getProtoEventId = function ( id )
{
    return this.mapIdToEvent[ id ];
};

weProtoDb.prototype.getFeaturedItemById = function ( id )
{
	return this.mapIdToFeaturedItem[ id ];
};

weProtoDb.prototype.getProtoPrizewinnerId= function ( id )
{
    return this.mapIdToPrizeWinner[ id ];
};

weProtoDb.prototype.getProtoGoalById = function ( id )
{
	return this.mapIdToGoal[ id ];
};

weProtoDb.prototype.getProtoGoalTaskById = function ( id )
{
	return this.mapIdToGoalTask[ id ];
};

weProtoDb.prototype.getProtoGoalTasksByProtoGoalId = function ( id )
{
	var tasks = [];
	for (var i in this.mapIdToGoalTask)
	{
		if (this.mapIdToGoalTask[i].proto_goal_id == id)
			tasks.push(this.mapIdToGoalTask[i]);
	}
	return tasks;
};

weProtoDb.prototype.getProtoProducesForEntity = function ( id )
{
    var products = [];
    var productsLen = this.proto_products.length;
    for(var idx = 0; idx < productsLen; ++idx)
    {
        if(this.proto_products[idx].proto_product.producing_proto_entity_id == id)
        {
            products.push(this.proto_products[idx].proto_product);
        }
    }
    return products;
};

weProtoDb.prototype.getProtoEntityBuildLimitsById = function ( id )
{
    return this.mapIdToBuildLimit[ id ];
};

weProtoDb.prototype.getProtoEntityAnimationById = function ( id )
{
    return this.mapIdToAnimation[ id ];
};

weProtoDb.prototype.getProtoAnimationsForProtoVisualId = function ( id )
{
    return this.proto_animations_for_proto_visual_id[ id ];
};

weProtoDb.prototype.getProtoAnimationsForProtoVisualIdState = function ( id, state )
{
	var returnProto = null;
	var protos = this.proto_animations_for_proto_visual_id[ id ];
	
	if (Exists(protos))
	{
		var protosLen = protos.length;
		returnProto = protos[0]; // Set base proto if not found
		
		// Go to all proto types
		for(var idx = 0; idx < protosLen; ++idx)
		{
			if (protos[idx].proto_name == state)
			{
				// State found, return this animation
				returnProto = protos[idx];
				break;
			}
		}
	}
    return returnProto;
};

weProtoDb.prototype.hasCompletedObjective = function( current_id, target_id )
{
	if (current_id == -1)
	{
		return true;
	}
	
	// otherwise we're going to traverse the objective list backwards and see if this one is in their list
	var obj = this.getCurrentObjective(current_id);
	if (obj)
	{
		if(obj.previous_objective_id == target_id)
		{
			return true;
		}
		else if (obj.previous_objective_id === 0) // we're done going down the objective list - they haven't completed the objective
		{
			return false;
		}
		else
		{
			// recursively check the next previous obj
			return this.hasCompletedObjective(obj.previous_objective_id, target_id);
		}
	}
	return false;
};

weProtoDb.prototype.getCurrentObjective = function( id )
{	
    // hunt down the objective we're looking for - they're in no particular order
    for (var i = 0; i < this.proto_objectives.length; i++)
    {
        if( this.proto_objectives[i].proto_objective.id == id )
        {
            return this.proto_objectives[i].proto_objective;
        }
    }
    // failsafe condition, should never be called if game logic is right
    return this.proto_objectives[0].proto_objective;
};

weProtoDb.prototype.getNextObjective = function( id )
{
    // hunt down the objective we're looking for - they're in no particular order
    for (var i = 0; i < this.proto_objectives.length; i++)
    {
        if( this.proto_objectives[i].proto_objective.previous_objective_id == id )
        {
            return this.proto_objectives[i].proto_objective;
        }
    }
    // failsafe condition...
    return undefined;
};


////////////////////////////////////////////////////////////////////////////////
// Returns all the products in an array for the given level
weProtoDb.prototype.getProductsForLevel = function( level )
{
    var productlist = [];
    for(var i = 0; i < this.proto_products.length; i++ )
    {
        if( this.proto_products[i].proto_product.level == level )
        {
            productlist.push( this.proto_products[i].proto_product );
        }
    }
    return productlist;
};

////////////////////////////////////////////////////////////////////////////////
// Returns all the upgradeds in an array for the given level
weProtoDb.prototype.getUpgradesForLevel = function( level )
{
    var upgradelist = [];
    for(var i = 0; i < this.proto_upgrades.length; i++ )
    {
        if( this.proto_upgrades[i].proto_upgrade.requires_level == level )
        {
            upgradelist.push( this.proto_upgrades[i].proto_upgrade );
        }
    }
    return upgradelist;
};

////////////////////////////////////////////////////////////////////////////////
// Returns the level for the given XP
weProtoDb.prototype.getProtoLevelForLevel = function( level )
{
    for(var i = 0; i < this.proto_levels.length; i++ )
    {
        if( this.proto_levels[i].proto_level.level == level )
        {
            return this.proto_levels[i].proto_level;
        }
    }
    return null;
};

////////////////////////////////////////////////////////////////////////////////
// Returns all the upgradeds in an array for the given level
weProtoDb.prototype.getObjectsForLevel = function( level )
{
    var objectlist = [];
    for(var i = 0; i < this.proto_entities.length; i++ )
    {
		var ent = this.proto_entities[i].proto_entity;
        if( ent.required_level === level )
        {
			if( ent.store_category == 'Building' || ent.store_category == 'Decoration' || ent.store_category == 'Tree') 
			{
				if( ent.gold_cost !== 0 || ent.mana_cost !== 0 || WeGameStateMgr.IsEventParticipationID(ent.id))
				{
            		objectlist.push( ent );
				}		
        	}
		}
    }
    return objectlist;
};

////////////////////////////////////////////////////////////////////////////////
// Returns the number of unlocked farms for this level
weProtoDb.prototype.getNewFarmsForLevel = function( level )
{
    if (level == 1)
    {
        return 0;
    }
    
    return this.proto_levels[level - 1].proto_level.max_population - this.proto_levels[level - 2].proto_level.max_population;
};

////////////////////////////////////////////////////////////////////////////////
// Returns the mojo rewarded for this level
weProtoDb.prototype.getMojoRewardForLevel = function( level )
{
    return this.proto_levels[level - 1].proto_level.mana_reward;
};

////////////////////////////////////////////////////////////////////////////////
// Returns upgrade for the given upgrade_id
weProtoDb.prototype.getUpgrade = function( upgrade_id )
{
    if (Exists(this.proto_upgrades))
    {
        for(var i = 0; i < this.proto_upgrades.length; i++ )
        {
            if( this.proto_upgrades[i].proto_upgrade.id == upgrade_id )
            {
                return this.proto_upgrades[i].proto_upgrade;
            }
        }
    }
    return null;
};

////////////////////////////////////////////////////////////////////////////////
// Checks to see if a user CAN purchase a specific upgrade
weProtoDb.prototype.canPurchaseUpgrade = function( upgrade )
{

//  var upgrade = this.proto_upgrades[0].proto_upgrade;
    var current_upgrades = [];
    var info = WeGameStateMgr.GetGameLotInfo();
    // bail if we're missing info...
    if ( upgrade === undefined || info === undefined )
    {
        return UpgradeStatus.kCannotPurchase;
    }
    // build a list of upgrades they already have
    for(var i = 0; i < info.upgrades.length; i++ )
    {
        current_upgrades.push(info.upgrades[i].proto_upgrade_id);
    }

    // They already have it - we're done...
    if ( current_upgrades.indexOf(upgrade.id) != -1 )
    {
        return UpgradeStatus.kAlreadyPurchased;
    }

    // Do they have the pre-req?
    if ( upgrade.prerequisite_id !== null )
    {
        if ( current_upgrades.indexOf(upgrade.prerequisite_id) == -1 )
        {
            return UpgradeStatus.kCannotPurchase;
        }
    }

    // Do they have all the gold/mana/level requirements met
    if ( info.mLevel < upgrade.requires_level )
    {
        return UpgradeStatus.kCannotPurchase;
    }
    
    // Can they afford it?
    if ( info.gold < upgrade.gold_cost )
    {
        return UpgradeStatus.kCannotAfford;
    }
    
    return UpgradeStatus.kCanPurchase; 
};

weProtoDb.prototype.getProtoUpgradeById = function( id )
{
    var upgrades = this.proto_upgrades;
    if (upgrades.length > 0)
    {
        for(var idx = 0; idx < upgrades.length; ++idx)
        {
            if (upgrades[idx].id == id)
                return upgrades[idx].proto_upgrade;
        }
        
    }
    
    return null;
};

weProtoDb.prototype.debugPrintUpgrades = function()
{
    var upgrades = WeGameStateMgr.GetGameLotInfo().upgrades; 
    if (upgrades.length > 0)
    {
        for(var idx = 0; idx < upgrades.length; ++idx)
        {
            NgLogD("/////////////////////////////////////////////");
            for (var item in upgrades[idx])
            {
                NgLogD("item:" + item + " value:" + upgrades[idx][item]);
            }
            NgLogD("/////////////////////////////////////////////");
        }   
    }
};

weProtoDb.prototype.hasUpgrade = function( protoUpgrade )
{
    var upgrades = WeGameStateMgr.GetGameLotInfo().upgrades; 
    if (upgrades.length > 0)
    {
        for(var idx = 0; idx < upgrades.length; ++idx)
        {
            if (upgrades[idx].proto_upgrade_id == protoUpgrade.id)
            {
                return true;
            }
        }   
    }
    
    return false;
};

weProtoDb.prototype.calculateMaxLotMultiplier = function()
{
	var kingdom_type = "main";
	var info = WeGameStateMgr.GetGameLotInfo();
	if (info !== null && info !== undefined)
	{
		kingdom_type = info.kingdom_type;
	}
	
    var multiplier = 1.0;
    var upgrades = this.proto_upgrades;
    if (Exists(upgrades))
    {
        for(var idx = 0; idx < upgrades.length; ++idx)
        {
            var upgrade = upgrades[idx].proto_upgrade;
            if (upgrade.kingdom_type == kingdom_type && upgrade.map_expand_reward !== null)
            {
                multiplier += upgrade.map_expand_reward;
            }
        }      
    } 
    return multiplier;
};

weProtoDb.prototype.isStoreItemUnlockedNoBuildLimits = function(item)
{
	//TODO change to isStoreItemUnlockedFarm in farm
	
	var exception = WeGameStateMgr.lockAllItemsExcept();
	if (exception && item.id != exception)
		return false;
	
	var has_objective = true;
	if (!gConfigs.DisableTutorial)
	{
		var curr_obj_id = WeGameStateMgr.GetCurrentObjectiveId();
		if (item.prerequisite_objective_id !== null)
		{
		    has_objective = weProtoDb.getInstance().hasCompletedObjective(curr_obj_id, item.prerequisite_objective_id);
		}
	}
	// do they meet level and pop needs
	var has_level = item.required_level <= WeGameStateMgr.GetGameLotInfo().mLevel;
	var has_population = (WeGameStateMgr.GetGameLotInfo().getAvailablePopulation() > 0 || item.population_cost === 0);
	
	return has_objective && has_level && has_population;
};

weProtoDb.prototype.isStoreItemUnlocked/*WithBuildLimits*/ = function(item)
{
	var exception = WeGameStateMgr.lockAllItemsExcept();
	if (exception && item.id != exception)
		return false;
	
	var has_objective = true;
	if (!gConfigs.DisableTutorial)
	{
		var curr_obj_id = WeGameStateMgr.GetCurrentObjectiveId();
		if (item.prerequisite_objective_id !== null)
		{
		    has_objective = weProtoDb.getInstance().hasCompletedObjective(curr_obj_id, item.prerequisite_objective_id);
		}
	}
	
	var player_level = WeGameStateMgr.GetGameLotInfo().mLevel;
	
	// do they meet level and pop needs
	var has_level = item.required_level <= player_level;
	var has_population = (WeGameStateMgr.GetGameLotInfo().getAvailablePopulation() > 0 || item.population_cost === 0);
	
    var reached_build_limit = this.isBuildLimitReached(item);

    var violated_kingdom_restriction = this.hasViolatedKingdomRestriction(item);
    var stashcount = this.getStoreItemStashCount(item);
    
	return has_objective && (has_level || stashcount > 0) && has_population && !reached_build_limit && !violated_kingdom_restriction;
};

weProtoDb.prototype.hasViolatedKingdomRestriction = function(item)
{
	if (item && item.kingdom_restriction && item.kingdom_restriction.length > 0 && item.kingdom_restriction != WeGameStateMgr.GetGameLotInfo().kingdom_type)
    {
		return true;
	}
	return false;
};

weProtoDb.prototype.isBuildLimitReached = function(item)
{
	var entityCount = 0;
	var db = weProtoDb.getInstance();

	// count the entities with this proto-entity id already in the Lot
	if(Exists(WeGameStateMgr.mLotInfo.entities))
	{
		var entListLen = WeGameStateMgr.mLotInfo.entities.length;

		for (var i = 0; i < entListLen; i++) {
			if (WeGameStateMgr.mLotInfo.entities[i].proto_entity_id == item.id) {
				entityCount += 1;
			}
		}
	}

	var player_level = WeGameStateMgr.GetGameLotInfo().mLevel;
	var entityBuildLimit = -1;
	if (Exists(db.proto_entity_build_limits)) {
		 var protoLen = db.proto_entity_build_limits.length;
  		 
  		 for (var n = 0; n < protoLen; n++) {
  			 
  			 var protoEntityBuildLimit = db.proto_entity_build_limits[n].proto_entity_build_limit;

			 var id = protoEntityBuildLimit.proto_entity_id;
			 var limit = protoEntityBuildLimit.limit;
			 var level = protoEntityBuildLimit.level;
  			 
        	 if(id == item.id && player_level >= level) {
				entityBuildLimit = Math.max(entityBuildLimit, limit);
           	 }
  		 }
	}

    return (entityBuildLimit >= 0 && entityCount >= entityBuildLimit);
};

weProtoDb.prototype.getStoreItemStashCount = function(item)
{
	if( item != null && item != undefined )
	{
		var stash = WeGameStateMgr.GetStash();
		for(var i in stash)
		{
			if(stash[i].type_id == item.id)
				return stash[i].count;
		}
	}
	return 0;
};

/* so far we do only have 1 enabled ProtoGameEvent at the same time, so only returns that */
weProtoDb.prototype.getProtoGameEvent = function()
{
	return this.proto_game_events;
};
//////////////////////////////////////////////////////////////////////////////
/// @file:      WeCamera.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
/// @brief:     This is the conceptual camera, not to be confused with the
///             NgCamera that is used be moved about the Game world
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;

// //////////////////////////////////////////////////////////////////////////////
// Class WeCamera
function WeCamera()
{
}

// //////////////////////////////////////////////////////////////////////////////
// Statics
WeCamera.scaleRoot = undefined;
WeCamera.transRoot = undefined;

WeCamera.observers = {};
WeCamera.isChanged = false;

// SingleTouch dragging
WeCamera.deltaX = 0;
WeCamera.deltaY = 0;

// Momentum
WeCamera.velocity = new Vec2D(0, 0);

// DoubleTap Zooming
WeCamera.desiredZoom = gTunables.camera_zoom_min;
WeCamera.desiredZoomAnchor = undefined;
WeCamera.desiredZoomPosition = undefined;
WeCamera.startingZoom = 0;
WeCamera.startingZoomTime = 0;

WeCamera.moveToLocation = 0;
WeCamera.startingMoveTime = -1;
WeCamera.moveEndCallBack = undefined;

WeCamera.zoomToLocation = 0;
WeCamera.startingMoveTime = -1;
WeCamera.moveEndCallBack = undefined;

// MultiTouch Zooming
WeCamera.multiTouchCenter = undefined;
WeCamera.multiTouchRadius = 0;

WeCamera.mTouches = [];
WeCamera.mLastTouchTime = 0;
WeCamera.mLastTouchLocation = new Vec2D(-10000, -10000);

WeCamera.prototype.Name = function()
{
    return "WeCamera";
};

WeCamera.setScale = function(x, y)
{
	y = Clamp(y, gTunables.camera_zoom_min, gTunables.camera_zoom_max);
	x = Clamp(x, gTunables.camera_zoom_min, gTunables.camera_zoom_max);
	
	var nScaleX = WeCamera.scaleRoot.GetScale().getX();
	var nScaleY = WeCamera.scaleRoot.GetScale().getY();
	if(nScaleX!=x || nScaleY!=y)
	{
		WeCamera.isChanged=true;
		//WeCamera.notifyObservers();
	}
	WeCamera.scaleRoot.SetScale(x, y);
};

WeCamera.setPosition = function(posX, posY)
{
	if(WeCamera.getX()!=posX || WeCamera.getY()!=posY)
	{
		WeCamera.isChanged=true;
		//WeCamera.notifyObservers();
	}
	
	WeCamera.transRoot.setPosition(posX, posY);
};

WeCamera.getTouchCount = function()
{
    var count = 0;
    for ( var key in WeCamera.mTouches)
    {
        if (WeCamera.mTouches[key])
        {
            ++count;
        }
    }
    return count;
};

WeCamera.clearTouches = function()
{
	for ( var key in WeCamera.mTouches)
	{
		delete WeCamera.mTouches[key];
	}
	WeCamera.multiTouchRadius = 0;
};

WeCamera.onTouch = function(touch)
{
	DebugTouch(touch, "WeCamera onTouch()");
	
	var touchAction = touch.getAction();
	if( Core.Capabilities.getPlatformOS() === "Android")
	{
	    //var touchPosition = touch.getPosition() ;
    	//Super Hack for camera 2 point touch
    	if(touch.getId()===1)
    	{
    		if (WeGameStateMgr.GetActiveObject() !== null )
    		{
    			WeCamera.mTouchCache=ObjectUtils.GetCloneOfObject(touch);
    		}
    	}
    	else
    	{
    		WeGameStateMgr.SetActiveObject(null);
    		if (WeCamera.mTouchCache )
    		{
    			WeCamera.onTouch(WeCamera.mTouchCache); 
    			WeCamera.mTouchCache=null;
    		}
    	}
	}
	
	var touchPosition = FixTouchPositionForOrientation( touch.getPosition() );
	
	if (WeGameStateMgr.GetActiveObject() !== null && WeGameStateMgr.GetActiveObject().LockCamera())
	{ 
		// we are holding something. We want to scroll map if touch is near the edge
		if (touchAction != touch.Action.End)
		{
			var screen = WeRenderDevice.GetScreenInfo();

			if (touchPosition.getX() < gRedesignScrollBuffer)
			{
				WeCamera.deltaX += gRedesignScrollVelocity;
			}
			else if (touchPosition.getX() > screen.mWidth - gRedesignScrollBuffer)
			{
				WeCamera.deltaX -= gRedesignScrollVelocity;
			}
			else if (touchPosition.getY() < gRedesignScrollBuffer)
			{
				WeCamera.deltaY += gRedesignScrollVelocity;
			}
			else if (touchPosition.getY() > screen.mHeight - gRedesignScrollBuffer)
			{
				WeCamera.deltaY -= gRedesignScrollVelocity;
			}
		}
		return true;
	}

	var here = new Vec2D(touchPosition.getX(), touchPosition.getY());
	var now = Core.Time.getFrameTime();
	var count = WeCamera.getTouchCount();
	if( count > 2)
	{
		WeCamera.clearTouches();
	}
	var touchAction = touch.getAction();
	switch (touchAction)
	{
	case touch.Action.Start:
		WeCamera.mTouches["k" + touch.getId()] = {
			startLocation : here,
			updateLocation : here,
			startTime : now,
			lastLocation : here,
			lastTime : now
		};

        if (WeGameStateMgr.GetGlobalGameWidget() !== null 
        	&& !WeGameStateMgr.IsLotObjectsMovable()
            && WeGameStateMgr.GetActiveObject() === null)
        {
            WeGameStateMgr.SetGlobalGameWidget(null);   
        }
		// Start tracking a pinch zoom
		if (count >= 1)
		{
			WeCamera.InitMultiTouchRadius(here);
        }
        break;

    case touch.Action.Move:
        var last = WeCamera.mTouches["k" + touch.getId()];
        if (last)
        {
            var deltaLocation = WeMath.SubVec2D(here, last.lastLocation);
            var deltaTime = now - last.lastTime;
            
            if(Exists(gTunables.optimizations) && gTunables.optimizations.touch_filter && deltaTime >= Globals.BuildingTapTime)
            {
                var kingdom = WeGameStateMgr.GetGameLotInfo();
                if(kingdom && kingdom.IsTouchEnabled())
                {
                    kingdom.DisableTouch();
                    if(gTunables.optimizations.hide_ui_on_camera)
                    {
                        WeGameStateMgr.ShowGameUI(false);
                    }
                }
            }

            // ignore zero moves
            if (deltaLocation.lengthSqr() == 0)
            	break;

            // Accumulate moved touch
            if (count == 1)
            {
                WeCamera.deltaX += deltaLocation.x;
                WeCamera.deltaY += deltaLocation.y;
            }

            last.lastLocation = here;
            last.lastTime = now;
		}
		else
		{
			WeCamera.mTouches["k" + touch.getId()] = {
					startLocation : here,
					startTime : now,
					updateLocation : here,
					lastLocation : here,
					lastTime : now
				};		
		}
		if (WeCamera.getTouchCount()>1 && WeCamera.multiTouchRadius<=0)
		{
			WeCamera.InitMultiTouchRadius(here);
        }
        break;

    case touch.Action.End:
        var start = WeCamera.mTouches["k" + touch.getId()];
        delete WeCamera.mTouches["k" + touch.getId()];
        var lastTouchUp = WeCamera.mLastTouchTime;
        WeCamera.mLastTouchTime = 0;

        if(Exists(gTunables.optimizations) && gTunables.optimizations.touch_filter)
        {
            var kingdom2 = WeGameStateMgr.GetGameLotInfo();
            if(kingdom2 && !kingdom2.IsTouchEnabled())
            {
                kingdom2.EnableTouch();
                if(!WeGameStateMgr.IsLotObjectsMovable() && gTunables.optimizations.hide_ui_on_camera)
                {
                    WeGameStateMgr.ShowGameUI(true);
                }
            }
        }
        // If we're coming down off of a 2-touch, stop tracking pinchzoom.
        if (count == 2)
        {
            WeCamera.multiTouchRadius = 0;
        }

		// If not a solo touch, kill the tap and break;
		if (count > 1)
			break;

		// Single touch events
		if (start)
		{
			var deltaTime = now - start.startTime;
			var deltaLocation = WeMath.DistanceSqr2D(here, start.startLocation);

			// Taps
			if (deltaTime < gTapTime
					&& deltaLocation < gDoubleTapDistance * gDoubleTapDistance)
			{
				if (now - lastTouchUp < gDoubleTapTime
						&& WeMath.DistanceSqr2D(here, WeCamera.mLastTouchLocation) < gDoubleTapDistance
								* gDoubleTapDistance)
				{
					// double tap
					var currentZoomProgress = (WeCamera.desiredZoom - gTunables.camera_zoom_min)
							/ (gTunables.camera_zoom_max - gTunables.camera_zoom_min);
					var newZoom = gTunables.camera_zoom_max;
					if (currentZoomProgress > 0.5)
					{
						newZoom = gTunables.camera_zoom_min;
						WeCamera.ZoomCamera(newZoom);
					}
					else
					{
						WeCamera.ZoomCamera(newZoom, here);
					}

					WeCamera.mLastTouchTime = 0;
				} else
				{
					// tap
					WeCamera.mLastTouchTime = now;
					WeCamera.mLastTouchLocation = here;
				}
			}
		}
		break;
	}
	return true;
}; // WeCamera.onTouch

WeCamera.InitMultiTouchRadius = function(here)
{
	var count = 0;
	var t0 = new Vec2D(0, 0);
	for ( var key in WeCamera.mTouches)
	{
		var t = WeCamera.mTouches[key].lastLocation;
		t0.x += t.x;
		t0.y += t.y;
		++count;
		if (count == 2)
			break;
	}
	t0.x *= 0.5;
	t0.y *= 0.5;
	
	var scaleX=WeRenderDevice.GetScaleRoot().GetScale().getX();
	var scaleY=WeRenderDevice.GetScaleRoot().GetScale().getY();
	t0.x = (t0.x)/ scaleX- WeCamera.getX();
	t0.y = (t0.y)/ scaleY- WeCamera.getY();
	var t1 = new Vec2D( (here.x) / scaleX - WeCamera.getX(), 
	        (here.y)/ scaleY - WeCamera.getY());
	WeCamera.multiTouchCenter = t0;
	WeCamera.multiTouchRadius = WeMath.Distance2D(t0, t1);
}

WeCamera.TilePositionToWorld = function(pos)
{
	var screenLoc = new Vec2D();
	screenLoc.x = cTileSizeWidth * 0.5 * (pos.x - pos.y);
	screenLoc.y = (pos.x + pos.y) * cTileSizeHeight * 0.5;
	screenLoc.x = -screenLoc.x;
	return screenLoc;
};

WeCamera.IsTileInScreen = function(location)
{
	var vTemp = WorldToScreenPos(location);
	if (vTemp.x < 0 || vTemp.y < 0 || vTemp.x > gRawWidth
			|| vTemp.y > gRawHeight)
	{
		return false;
	}
	return true;
};

WeCamera.Reset = function()
{
	//HACK mega
	WeCamera.setScale(0.8823, 0.8823);

	WeCamera.setPosition(32.1472, 27.3159);	

	WeCamera.startingMoveTime = -1;
	WeCamera.startingZoomTime = -1;
	WeCamera.multiTouchRadius= 0;
	
	// SingleTouch dragging
	WeCamera.deltaX = 0;
	WeCamera.deltaY = 0;

	// Momentum
	WeCamera.velocity.x=0;
	WeCamera.velocity.y=0;
	
	WeCamera.clearTouches();
};

WeCamera.MoveToPosition = function(location, cCallBack)
{
	WeCamera.moveEndCallBack = cCallBack;
	WeCamera.moveToLocation = location;
	WeCamera.startingMoveTime = Core.Time.getFrameTime();
};

WeCamera.ZoomCamera = function(scale, location, anchor)
{
	if (!location)
	{
		location = new Vec2D(gRawWidth * 0.5, gRawHeight * 0.5);
	}
	WeCamera.desiredZoomPosition = location;

	var nCurrentSclale = WeCamera.getScale();

	if (!anchor)
	{
		anchor = new Vec2D((location.x) / nCurrentSclale - WeCamera.getX(),
				(location.y) / nCurrentSclale - WeCamera.getY());
	}
	WeCamera.desiredZoomAnchor = anchor;
	WeCamera.desiredZoom = Clamp(scale, gTunables.camera_zoom_min,
			gTunables.camera_zoom_max);
	WeCamera.startingZoom = nCurrentSclale;
	WeCamera.startingZoomTime = Core.Time.getFrameTime();
	WeCamera.notifyObservers();
};

WeCamera.OnUpdate = function()
{
	if (WeCamera.startingMoveTime > 0)
	{
		var moveElapsed = (Core.Time.getFrameTime() - WeCamera.startingMoveTime)
				/ (cCameraZoomTime * 1000);
		if (moveElapsed > 1.0)
		{
			moveElapsed = 1.0;
			WeCamera.startingMoveTime = -1;
		}

		var posX = WeCamera.getX();
		var posY = WeCamera.getY();

		posX += (WeCamera.moveToLocation.x - posX) * moveElapsed;
		posY += (WeCamera.moveToLocation.y - posY) * moveElapsed;
		
		WeCamera.setPosition(posX, posY);

		if (WeCamera.startingMoveTime === -1)
		{
			if(WeCamera.moveEndCallBack)
			{
				WeCamera.moveEndCallBack.Event();
				delete WeCamera.moveEndCallBack;
				WeCamera.moveEndCallBack = undefined;
			}
		}
		

		WeCamera.notifyObservers();
		return;
	}
	
	// Handle pinch zoom
	if (WeCamera.multiTouchRadius > 0)
	{
		var t0 = new Vec2D(0, 0);
		var t1 = t0;
		var count = 0;
		var dist=[];
		for ( var key in WeCamera.mTouches)
		{
			t1 = WeCamera.mTouches[key].lastLocation;
			dist[count]=WeMath.SubVec2D(WeCamera.mTouches[key].lastLocation, WeCamera.mTouches[key].updateLocation);
			WeCamera.mTouches[key].updateLocation=WeCamera.mTouches[key].lastLocation;
			t0.x += t1.x;
			t0.y += t1.y;
			++count;
			if (count == 2)
			{
				break;
			}
		}
		if (count != 2)
		{
			return;
		}
		
		var sameDir= dist[0].x* dist[1].x+dist[0].y* dist[1].y;
		
		if (WeGameStateMgr.GetGameLot().touchedObject !== null)
	    {
	        WeGameStateMgr.GetGameLot().Unhighlight(WeGameStateMgr.GetGameLot().touchedObject);
	    }
	    
    	if(WeGameStateMgr.GetActiveObject() !==null)
    	{
			WeGameStateMgr.SetActiveObject(null);
    	}
		
		t0.x *= 0.5;
		t0.y *= 0.5;

		var radius = WeMath.Distance2D(t0, t1);
		var currentZoom = radius / WeCamera.multiTouchRadius;
		if(sameDir<=0)
		{
			var x = 0;
			// Sigmoid function to bound zooming to a reasonable range
	
			if (currentZoom < gTunables.camera_zoom_min)
			{
				x = (currentZoom - gTunables.camera_zoom_min) * 4
						/ gTunables.camera_zoom_min;
				currentZoom = x * gTunables.camera_zoom_min * 0.25
						/ Math.sqrt(1 + x * x) + gTunables.camera_zoom_min;
			} else if (currentZoom > gTunables.camera_zoom_max)
			{
				x = (currentZoom - gTunables.camera_zoom_max);
				currentZoom = x / Math.sqrt(1 + x * x) + gTunables.camera_zoom_max;
			}
	
			currentZoom = Clamp(currentZoom, gTunables.camera_zoom_min,
					gTunables.camera_zoom_max);
			
			WeCamera.setScale(currentZoom, currentZoom);
		}
		else
		{
			currentZoom=WeCamera.getScale();
		}
		
		var scale = currentZoom;

		var anchor = WeCamera.multiTouchCenter;
		var screenAnchor = new Vec2D((anchor.x + WeCamera.getX()) * scale,
				(anchor.y + WeCamera.getY()) * scale);

		WeCamera.deltaX += (t0.x - screenAnchor.x);
		WeCamera.deltaY += (t0.y - screenAnchor.y);

		// Force our zoom back into range.
		WeCamera.desiredZoomAnchor = WeCamera.multiTouchCenter;
		WeCamera.desiredZoomPosition = t0;
		WeCamera.startingZoom = currentZoom;
		WeCamera.startingZoomTime = Core.Time.getFrameTime();
		if (currentZoom < gTunables.camera_zoom_min)
		{
			WeCamera.desiredZoom = gTunables.camera_zoom_min;
		} else if (currentZoom > gTunables.camera_zoom_max)
		{
			WeCamera.desiredZoom = gTunables.camera_zoom_max;
		} else
		{
			WeCamera.startingZoomTime = 0;
		}
	}

	// Handle doubletap and over-pinch zooming
	else if (WeCamera.startingZoomTime > 0)
	{
		var zoomElapsed = (Core.Time.getFrameTime() - WeCamera.startingZoomTime)
				/ (cCameraZoomTime * 1000);
		if (zoomElapsed > 1.0)
		{
			zoomElapsed = 1.0;
			WeCamera.startingZoomTime = -1;
		}
		// cubic ease out
		//zoomElapsed = 1 - zoomElapsed;
		//zoomElapsed = 1 - zoomElapsed * zoomElapsed * zoomElapsed;

		var currentZoom = (WeCamera.desiredZoom - WeCamera.startingZoom)
				* zoomElapsed + WeCamera.startingZoom;
		
		if (currentZoom < gTunables.camera_zoom_min
				|| currentZoom > gTunables.camera_zoom_max)
		{
			WeCamera.startingZoomTime = -1;

		}
		currentZoom = Clamp(currentZoom, gTunables.camera_zoom_min,gTunables.camera_zoom_max);

		WeCamera.setScale(currentZoom, currentZoom);

		// Anchor the zoom point to the screen where the user touched.
		WeCamera.desiredZoomAnchor.x -= WeCamera.deltaX / currentZoom;
		WeCamera.desiredZoomAnchor.y -= WeCamera.deltaY / currentZoom;

		var anchor = WeCamera.desiredZoomAnchor;
		var screenAnchor = new Vec2D(
				(anchor.x + WeCamera.getX()) * currentZoom,
				(anchor.y + WeCamera.getY()) * currentZoom);

		WeCamera.deltaX += (WeCamera.desiredZoomPosition.x - screenAnchor.x);
		WeCamera.deltaY += (WeCamera.desiredZoomPosition.y - screenAnchor.y);
		
		WeCamera.velocity.x=0;
		WeCamera.velocity.y=0;
	}
    
    var nVelocityFriction=0.85;
    WeCamera.velocity.x *= nVelocityFriction;
    WeCamera.velocity.y *= nVelocityFriction;
    var nDeltaFriction=0.2;
    WeCamera.velocity.x += WeCamera.deltaX * nDeltaFriction;
    WeCamera.velocity.y += WeCamera.deltaY * nDeltaFriction;
  
    var screen = WeRenderDevice.GetScreenInfo();
    
    var bounds = (64 + gSceneExtraTileBounds);
    if(WeGameStateMgr.mLot && WeGameStateMgr.GetGameLotGrid())
    {    
        bounds = WeGameStateMgr.GetGameLotGrid().mTileIndexExtent
            + gSceneExtraTileBounds;
    }
    var left = GetGamePosToScreenLoc([ -bounds, bounds ]);
    var top = GetGamePosToScreenLoc([ bounds, bounds ]);
    var right = GetGamePosToScreenLoc([ bounds, -bounds ]);
    var bottom = GetGamePosToScreenLoc([ -bounds, -bounds ]);
    var tl = new Vec2D(left[0], top[1]);
    var br = new Vec2D(right[0] - screen.mWidth, bottom[1] - screen.mHeight);

    // Handle single-touch dragging and zoom adjustment

	if (WeCamera.deltaX !== 0 || WeCamera.deltaY !== 0)
	{
		var tle = WeMath.AddVec2D(tl,
				new Vec2D(-screen.mWidth * gCameraStretchyBorder,
						-screen.mHeight * gCameraStretchyBorder));
		var bre = WeMath.AddVec2D(br, new Vec2D(screen.mWidth * gCameraStretchyBorder,
						screen.mHeight * gCameraStretchyBorder));

		var scale = Clamp(WeCamera.getScale(), gTunables.camera_zoom_min,
				gTunables.camera_zoom_max);

		var posX = WeCamera.getX();
		var posY = WeCamera.getY();

		var deltax = WeCamera.deltaX / scale;
		var deltay = WeCamera.deltaY / scale;

		if (deltax < 0 && bre.x + deltax <= 0)
		{
			deltax = -bre.x / scale;
		} else if (deltax > 0 && tle.x + deltax >= 0)
		{
			deltax = -tle.x / scale;
		}

		if (deltay < 0 && bre.y + deltay <= 0)
		{
			deltay = -bre.y / scale;
		} else if (deltay > 0 && tle.y + deltay >= 0)
		{
			deltay = -tle.y / scale;
		}

		posX += deltax;
		posY += deltay;
		WeCamera.setPosition(posX, posY);

		WeCamera.deltaX = 0;
		WeCamera.deltaY = 0;
	}
	// impart momentum
	
	else if (WeCamera.getTouchCount() == 0)
	{
		// Accumulate some momentum

		
		var vsq = WeCamera.velocity.lengthSqr();
		if (vsq > gCameraMaxVelocity * gCameraMaxVelocity)
		{
			// WTF woodoo gCameraMaxVelocity * 1.41421 moved to gCameraMaxVelocity
			// var mag = gCameraMaxVelocity
			// / (WeCamera.velocity.length() * 1.41421);
			var mag = gCameraMaxVelocity / WeCamera.velocity.length();
			WeCamera.velocity.x *= mag;
			WeCamera.velocity.y *= mag;
		} else if (vsq < 1)
		{
			WeCamera.velocity.initialize(0, 0);
			vsq = 0;
		}

		var posX = WeCamera.getX();
		var posY = WeCamera.getY();

		var deltax = 0;
		var deltay = 0;

		var nScaleX = WeCamera.scaleRoot.GetScale().getX();
		var nScaleY = WeCamera.scaleRoot.GetScale().getY();

		if (vsq > 0)
		{
			deltax += WeCamera.velocity.x / nScaleX;
			deltay += WeCamera.velocity.y / nScaleY;

			WeCamera.velocity.x *= gCameraFriction;
			WeCamera.velocity.y *= gCameraFriction;
		}

		if (br.x + deltax < 0)
		{
			posX -= br.x / nScaleX;
			deltax += br.x / nScaleX;
			deltax *= gCameraSnapDecay;
		} else if (tl.x + deltax > 0)
		{
			
			posX -= tl.x / nScaleX;
			deltax += tl.x / nScaleX;
			deltax *= gCameraSnapDecay;

		}

		if (br.y + deltay < 0)
		{
			
			posY -= br.y / nScaleY;
			deltay += br.y / nScaleY;
			deltay *= gCameraSnapDecay;

		} else if (tl.y + deltay > 0)
		{
			posY -= tl.y / nScaleY;
			deltay += tl.y / nScaleY;
			deltay *= gCameraSnapDecay;

		}

		var nDeltaFriction2=1.0;
		posX += deltax*nDeltaFriction2;
		posY += deltay*nDeltaFriction2;

		//HACK of camera
		//var vSpeed=0.05;
		//WeCamera.transRoot.setPosition(WeCamera.getX()+(posX - WeCamera.getX())*vSpeed , WeCamera.getY()+(posY - WeCamera.getY())*vSpeed);
		
		
		WeCamera.setPosition(posX, posY);
		
		WeCamera.notifyObservers();
		
	}
};

WeCamera.pointInRealm = function (pos, left, top)
{
	NgLogD("@@ "+pos+" "+left+" "+top);
	var boundsY;
	var point = [pos[0], pos[1]];
	var k = (top[1] - left[1])/(top[0] - left[0]);
	if (pos[0] < left[0])
	{
		point[0] = left[0];
		point[1] = left[1];
		return point; 
	}
	else if (pos[0] >= left[0] && pos[0] < top[0])
		boundsY = k * (pos[0] - left[0]);
	else if (pos[0] >= top[0] && pos[0] <= 2*top[0]-left[0])
		boundsY = -k * (pos[0] - (2*top[0]-left[0]));
	else
	{
		point[0] = 2*top[0]-left[0];
		point[1] = left[1];
		return point; 		
	}
	
	if (pos[1] - left[1] > boundsY) point[1] = boundsY + left[1];
	else if (pos[1] - left[1] < -boundsY) point[1] = -boundsY + left[1];
	NgLogD("## "+point+" "+k+" "+boundsY);
	return point;
},

WeCamera.getScale = function()
{
	return WeRenderDevice.GetScaleRoot().GetScale().getX();
};

WeCamera.getX = function()
{
	return WeCamera.transRoot.getPosition().getX();
};

WeCamera.getY = function()
{
	return WeCamera.transRoot.getPosition().getY();
};

WeCamera.addObserver = function(observer)
{
	WeCamera.observers[observer.mId] = observer;
};

WeCamera.removeObserver = function(observer)
{
	delete WeCamera.observers[observer.mId];
};

WeCamera.notifyObservers = function()
{
	if(WeCamera.isChanged === true )
	{
		var observers = WeCamera.observers;
		for ( var i in observers)
		{
			var observer = observers[i];
			observer.onCameraUpdated();
		}
		WeCamera.isChanged=false;
	}
	
	
};

//////////////////////////////////////////////////////////////////////////////
/// @file:      WeLotCollection.js
/// @author:    cjimison@gmail.com
/// @copyright: 2010 NGMOCO:) All rights reserved
/// 
	/// @brief:     The lot collection is everything that hangs out on the lot.
///             Buildings, people, etc, etc
//////////////////////////////////////////////////////////////////////////////
var WeBuilding = require('Code/WeBuilding').WeBuilding;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
var WeEffectsMgr = require('weEngine/WeEffects').WeEffectsMgr;
var WeMath = require('weEngine/WeMath');
var Vec2D = require('weEngine/WeMath').Vec2D;
var WeCloudManager = require('weEngine/WeCloudMgr').WeCloudManager;
var WeCharacter = require('weEngine/WeCharacter').WeCharacter;
var WeContentDownloader = require('weEngine/WeContentDownloader').WeContentDownloader;
var Core = require('NGCore/Client/Core').Core;
var WeSocialMapMgr = require('weEngine/WeSocialMapMgr').WeSocialMapMgr;

////////////////////////////////////////////////////////////////////////////////

function weKingdom ()
{
    this.mUniqueChildCount = 0;
    this.mChildMaxCount = 0;
    this.mChildCount = 0;
    this.mUniqueCharacterMap= [];
    
    this.mKingdomObjects = [];
    this.mDisplayInit = false;
    this.mLevel = 1;
    
    this.mIsBubblesShowing=true;
    this.mLastRatingTimestamp = 0;
    this.mLastRatingTimestampKey = 'lastRatingTimestamp';
}

weKingdom.prototype = new weBase ();

// active_jobs []
//  entity_id
// all_jobs
// all_kingdoms
// archers
// cavalry
// created_at
// current_proto_objective_id
// entities []
// food
// gold
// has_available_jobs
// has_collected_taxes
// has_harvested
// has_hired
// has_traded
// has_used_mana
// id
// infantry
// kingdom_type
// last_gifting_at
// mana
// max_active_trade_routes
// name
// neighbors_count
// population_in_use
// show_current_objective_for_completion
// show_interstitial_ad_after_delay
// show_interstitial_ad_after_inactivity
// stone
// upgrades []
// user_id
// wood
// xp

weKingdom.prototype.Name = function()
{
    return "weKingdom";
};

////////////////////////////////////////////////////////////////////////////////
// Method: initWithJson
weKingdom.prototype.initWithJson = function ( jsonTxt )
{
    try
    {
        NgLogD("jsonTxt == " + jsonTxt); 
        //printFull(jsonTxt, 120);
        var json = JSON.parse( jsonTxt );
        for ( var item in json.kingdom )
        {
            //if(json.kingdom.hasOwnProperity(item))
            //{
                this[ item ] = json.kingdom[ item ];
            //}
        }
        this.initIndices ();
    }
    catch(ex)
    {
        NgLogD("Error: weKingdom.prototype.initWithJson");
        WeUiMgr.ShowNetworkErrorPopUp();
    }
};

////////////////////////////////////////////////////////////////////////////////
// Method: initIndices
weKingdom.prototype.initIndices = function ()
{
    // Get entity instance by id.
    this.makeIndex ( "mapIdToEntity", this.entities,
        function ( obj ) { return obj.id; },
        function ( obj ) { return obj; } );
};

////////////////////////////////////////////////////////////////////////////////
// Method: getEntityById
weKingdom.prototype.getEntityById = function ( id )
{
    return this.mapIdToEntity[ id ];
};

////////////////////////////////////////////////////////////////////////////////
// Method: Update the current kingdoms info struct
weKingdom.prototype.UpdateInfo = function (newInfo)
{
//    NgLogD("************* UpdateInfo ****************");
//    for (var item in newInfo)
//    {
//        NgLogD(item + ":" + newInfo[item]);
//    }
//    NgLogD("*****************************************");
	
	if (newInfo.id != this.id)
	{
		// different kingdom id - so pretty much ignore it, like the iphone client does.
		return;
	}
	/* werule
	var all_kingdoms = this.all_kingdoms;
	var len = all_kingdoms.length;
	var bMyRealm=false;
	for(var idx = 0; idx < len; ++idx)
	{
	    if( all_kingdoms[idx].kingdom_id == newInfo.id)
	    {
	    	//NgLogD("Not my realm: "+newInfo.id);
	    	bMyRealm=true;
	    	break;
	    }
	}		
	if(!bMyRealm)
	{
		return;
	}
	*/
	
    // Capture any new values in the fresh dataset
    for(var arg in this)
    {
        if(undefined !== newInfo[arg])
        {
            this[arg] = newInfo[arg];
        }
    }
    
    var nextProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(this.mLevel+1);    
    var required_xp = 0;
    if (nextProtoLevel !== null)
    {
        required_xp = nextProtoLevel.required_xp;
    }
    // Managed completed objective flag - whats odd is that it seems like the server should update these stats,
    // but that doesn't appear to be the case, we need to manually tack on the rewards for objective completion
    if (!gConfigs.DisableTutorial && this.show_current_objective_for_completion === true)
    {
        var objId = WeGameStateMgr.GetCurrentObjectiveId();
        var obj = weProtoDb.getInstance().getCurrentObjective(objId);
        this.gold += obj.gold_reward;
        this.mana += obj.mana_reward;
        this.xp += obj.xp_reward;
            
        // check for level up - the levelupscreen will retro-actively head to the objective complete screen if necessary
        if (this.xp >= required_xp && required_xp !== 0)
        {
            this.handleLevelUp();
        }
        else {
            WeUiMgr.TransitionScreenTo("ObjectiveScreen");
        }
    }
    // has the player leveled up?
    else if (this.xp >= required_xp && required_xp !== 0)
    {
        this.handleLevelUp();
    }
};

weKingdom.prototype.getPlayerState = function()
{
	var state = {'level': this.mLevel, 'xp': this.xp, 'gold': this.gold, 'mana': this.mana}; 
	return state;
},

// checks xp and calls handleLevelUp right number of times
weKingdom.prototype.checkLevelUp = function()
{
	//
	//	Show only one popup if leveled up multiple levels
	//

	
	var level  = weProtoDb.getInstance().getLevelByXp(this.xp);
	
	NgLogD("check level up: current level : " + this.mLevel + " to level " + level );
	
	if (this.mLevel == level)
	{
		return;
	}
	var nextProtoLevel = weProtoDb.getInstance().getProtoLevelForLevel(level); 
	
	var required_xp = 0;
	if (nextProtoLevel !== null)
		required_xp = nextProtoLevel.required_xp;

	if (this.xp >= required_xp && required_xp !== 0)
	{
		this.handleLevelUp();
	}
};

weKingdom.prototype.handleLevelUp = function()
{
	// Removed the mana addition because this should REALLY come from the server -
	// and in some cases it does.
	var level  = weProtoDb.getInstance().getLevelByXp(this.xp);
	
	NgLogD("handle level up: new xp  " + this.xp + "level: " + level);
	
    this.mLevel = level;
    
    if(WeGameStateMgr.IsCurrentUser())
    {
        gCurGameLotInfo.mLevel = this.mLevel;
    }
    
    //WeEffectsMgr.PlaySoundEffect("levelup_1.wav");
    /*
    Tadas Razmislavicius:
    WeEffectsMgr.PlaySoundEffect cancels sound if other sound is played after...
    So i'm using audio effects :)
    */

    var sound = "Content/levelup_1";
	var os = Core.Capabilities.getPlatformOS();
    
    if( os == "flash" )
    {
        sound = null;
        //sound += '.mp3';
    }
    else if( os == "iPhone OS" )
    {
        sound = null;
        //sound += '.caf';
    }
    else if( os == "Android" )
    {
        sound +=  '.ogg';
    }
/*    
    if (sound !== null){
        var ae  = new Audio.Effect('Content/levelup_1.wav');
        var aee = new Audio.ActiveEffect(ae);
        aee.play();
    }
*/    
     var obj = {};
         obj.handle = function ()
         { 
          var args = {};
          var itemDef = WeUiMgr.GetItemDef("LevelUp");
          gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);
          gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);      
          
          return gameWidget;
         };
         obj.args = null;
	if(WeUiMgr.mActiveScreen == "CaptureScreen")
	{
		// ### do not transit. fix of WERULEMOBAGE-828
	}
	else
	{
		WeSocialMapMgr.transitionScreenToKingdom();
	}
  
	WeGameStateMgr.SetPopupWidget(obj);
    //WeUiMgr.TransitionScreenTo("LevelUpScreen");
    // Check WeGameStateMgr.mHighestLevelContentDownloaded. if not yet reached. show waiting.
    if (!WeContentDownloader.HaveContent(this.mLevel) && WeContentDownloader.IsDownloading())
    {   
    	WeUiMgr.ShowLoading(true);
    	WeContentDownloader.SetWaitLevelDownloadCallback(function()
        {
    		WeUiMgr.ShowLoading(false);
        },  this.mLevel);
        
    }

};


weKingdom.prototype.showRatingDialog = function()
{
	var rateDialog = new UI.AlertDialog();

	rateDialog.setTitle("Rate us!");
	rateDialog.setText("Please give us 5 Stars and tell us what you think.");
	rateDialog.setChoices(["Sounds great", "No thanks"]);
	rateDialog.setOnChoice(function(event)
	{
		switch(event.choice)
		{
		case 0:
			var marketUrl = "market://details?id=" + Core.Capabilities.getBundleIdentifier();
			Device.IPCEmitter.launch(marketUrl, function(error){
					NgLogD("rateGamePrompt: Error launching URL: " + marketUrl);
				});
			break;
	default:
				}
			});
	rateDialog.show();
},

weKingdom.prototype.showAddFriendsPrompt = function()
{
	NgLogD("showing add friends prompt");

	var newArgs = {};
    
    
    
	newArgs.OnYes = function(theNewArgs)
	{
		
		WeGameStateMgr.SetGlobalGameWidget(null);
	};

	newArgs.OnNo = function(theNewArgs)
	{
	    Storage.KeyValueCache.local.setItem('addFriendsPrompt', 1);
		
		WeSocialMapMgr.launchSocialMap(1, true);
	};
	
	newArgs.popup_label = "Make new friends!";
	newArgs.popup_text = "The community map is the place to find new We Rule friends.";
	newArgs.OnYesText = "Pass";
	newArgs.OnNoText = "Let's Go";
	
	var itemDef = WeUiMgr.GetItemDef("popup_box");
	var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
	newArgs.xGameWidget = newGameWidget;
	newGameWidget.setPosition(gRawWidth * 0.5, gRawHeight * 0.5);
},

weKingdom.prototype.checkAddFriendsPrompt = function()
{	
	if (gAddFriendsPromptLevels.indexOf(this.mLevel) != -1)
	{
		Storage.KeyValueCache.local.getItem('addFriendsPrompt', function(err, data)
		{
			if (err)
			{
				this.showAddFriendsPrompt();
			}
		}.bind(this)
		);
	}
},

weKingdom.prototype.checkRatingDialog = function()
{
	NgLogD("checking ratingpopup");
	
	//
	//	see if we need to show rating dialog
	//
	var configs = weProtoConfigs.getInstance().map;
	
	var lastRatingTimestamp  = this.mLastRatingTimestamp;
	
	if (Exists(configs.RatingLevel) && Exists(configs.RatingExpire))
	{
				
		var expire = configs.RatingExpire;
		expire = configs.RatingExpire;
		
		if (this.mLevel < configs.RatingLevel)
		{
			return;
		}
		
		var self = this;
		
		Storage.KeyValueCache.local.getItem('lastRatingTimestamp', function(err, data)
		{
			if (!err)
			{
				lastRatingTimestamp = data;
			}
			
			if (lastRatingTimestamp == 0)
			{
				Storage.KeyValueCache.local.setItem('lastRatingTimestamp', Date.now());
				
				//
				//	show rating popup
				//
				
				self.showRatingDialog();
			}
			
		});
	}
	else
	{
		return;
	}
	
	
},

weKingdom.prototype.getAvailablePopulation = function()
{
    var level = weProtoDb.getInstance().getProtoLevelForLevel(this.mLevel);
    var avail_pop = level.max_population - this.population_in_use;
    return avail_pop;
};

weKingdom.prototype.UpdateLot = function(info)
{

};

weKingdom.prototype.ConstructShellObject = function(protoEntity, eventFlag)
{

    var db = weProtoDb.getInstance();
	var isInStash = db.getStoreItemStashCount(protoEntity) > 0;
	var isBuildLimitReached = db.isBuildLimitReached(protoEntity);
	var hasViolatedKingdomRestriction = db.hasViolatedKingdomRestriction(protoEntity);

    var havePoints = protoEntity.points_cost <= WeEventGame.getEventPoints();
	var haveGold = protoEntity.gold_cost <= this.gold;
	var haveMana = protoEntity.mana_cost <= this.mana;
	var havePop = protoEntity.population_cost <= this.getAvailablePopulation();
	
	NgLogD("*** EVENT FLAG " + eventFlag );
	
	// WERULEMOBAGE-771
	if(hasViolatedKingdomRestriction)
	{
        NgLogD("Has violated kingdom restriction!");
        return false;
	}

	if((!isInStash && (!haveGold || !haveMana || !havePop || isBuildLimitReached || (eventFlag && !havePoints))) || (isInStash && !havePop && isBuildLimitReached))
    {
        NgLogD("Failing additional shell object - not enough mana/gold/pop");
        return false;
    }
    
    var db = weProtoDb.getInstance();
    var entity = {};

    entity.flipped = false;
    entity.proto_entity_id = protoEntity.id;
    
    var protoVisual = db.getProtoVisualById ( protoEntity.primary_proto_visual_id );
    var protoVisualDecal = db.getProtoVisualById ( protoEntity.decal_proto_visual_id );
    var building = new WeBuilding(entity, protoEntity, protoVisual, protoVisualDecal, false, true);
    building.eventFlag = eventFlag;
    var pos;
    if(this.mShellObject) 
    {
        pos = this.mShellObject.mAnchor;
    }
    else
    {
        pos = ScreenToWorldPos([gRawWidth * 0.5, gRawHeight * 0.5]);
        pos.x = Math.floor(pos.x); 
        pos.y = Math.floor(pos.y); 
    }      
    
    entity.location_x = pos.x;
    entity.location_y = pos.y;

	//NgLogD("Is this giftcart? - "+building.IsGiftCart());
    //building.mAnchor = pos;
    var added = false;
    // Now set this object to the "active" object
    //if(WeGameStateMgr.GetGameLotGrid().AddObstructionClosest(building, pos))
    if(building.AddToGridClosestFirst(WeGameStateMgr.GetGameLotGrid(), pos))
    {
        // the object was able to be added at the location!!!
        this.ReleaseShellObject();
        this.mShellObject = building;
        this.mShellObject.mDisableRemoveObstruction = false;
        // Focus camera on the new object
       
        //NgLogD("*************** Shell added to the game!!!");
        //NgLogD("At Anchor " + this.mShellObject.mAnchor);
     	//NgLogD("pos was " + building.mAnchor);
    	//NgLogD(this.mShellObject.mSprite);
    	//NgLogD(this.mShellObject.mDecal);
        //NgLogD("*************** END!!!");
        
        // $TODO: Add camera movementgTunables.camera_zoom_min to added object
        
        var CameraEvent = function(mShellObject)
        {
            this.mShellObject=mShellObject;
            
             this.Event = function()
             {
                 this.mShellObject.OpenLotActionMenu();
             };
        };
       

        if (WeCamera.IsTileInScreen(pos))
        {
            this.mShellObject.OpenLotActionMenu();
        } else
        {
            var vTemp = WeCamera.TilePositionToWorld(this.mShellObject.mAnchor);
            WeCamera.MoveToPosition(vTemp, new CameraEvent(this.mShellObject));         
        }
        added = true;
    }
    else
    {
        // you have no place to place this guy... sorry
        building.destroy();
        // We need to bring up a popup

        var newArgs = {};
        newArgs.OnOk = function(theNewArgs)
        {
        };
        newArgs.popup_label = GameSpecificVariables.Texts.NotEnoughRoom;
        newArgs.popup_text = GameSpecificVariables.Texts.WouldYouLikeSell;

        var itemDef = WeUiMgr.GetItemDef("popup_box");
        var newGameWidget = WeUiMgr.CreateGameWidget(itemDef, newArgs);
        newArgs.xGameWidget = newGameWidget;
        newGameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
        WeGameStateMgr.SetGlobalGameWidget(null); 
    }

    // JMARR hack to fix bubble placement for new buildings.
    WeCamera.notifyObservers();
    
    return added;
};

weKingdom.prototype.ReleaseShellObject = function()
{
    if(this.mShellObject)
    {
        this.mShellObject.destroy();
        delete this.mShellObject;
    }
    this.mShellObject=null;
};

////////////////////////////////////////////////////////////////////////////////
// Method: ConstructObjectFromShell
weKingdom.prototype.ConstructObjectFromShell = function(bubble, building, eventFlag)
{
    var self = this;
    var db = weProtoDb.getInstance();
    var entity = {};
    var data = {};
    var lotChildren = [];
    var childMaxCount = 1000;
    var uniqueChildCount = 1000;
    entity.location_x = this.mShellObject.mAnchor.x;
    entity.location_y = this.mShellObject.mAnchor.y;
    

    entity.flipped = true;
    entity.proto_entity_id = this.mShellObject.mProtoEntity.id;

	var stashCount = db.getStoreItemStashCount(this.mShellObject.mProtoEntity); 
	var isInStash = stashCount > 0;
    
    //HACK move to better place
    if( building )
    {
        entity.flipped=building.IsFlipped();
    }    

    //NgLogD("*************** id = " + this.mShellObject.mProtoEntity.id);

    data.entity = entity;
    
	WeGameStateMgr.SetIsPlacingOrder(true);
	NgLogD("*** CONSTRUCT " + eventFlag);
	
	var myeventFlag = eventFlag;
    // When the bubble closes set us back to available
    bubble.On('close', function()
    {
        var request = bubble.xRequest;
        // lets do the actual sell
        if(request.readyState == 4)
        {
            self.mConstructing = false;
			WeGameStateMgr.SetIsPlacingOrder(false);
            if (request.responseText && 0 !== request.responseText.length )
            {
                var jsonRep;
                try
                {
                    //NgLogD("" + request.responseText);
                    jsonRep = JSON.parse(request.responseText);
                    NgLogD("<<<<<!! Adding new store item " + JSON.stringify(request.responseText));

                    if(jsonRep.entity)
                    {
                        //NgLogD("ConstructObjectFromShell");
                        var protoEntity = db.getProtoEntityById ( jsonRep.entity.proto_entity_id );
                        var protoVisual = db.getProtoVisualById ( protoEntity.primary_proto_visual_id );
                        var protoVisualDecal = db.getProtoVisualById ( protoEntity.decal_proto_visual_id );
                        //var protoAnimation = db.getProtoVisualById ( protoEntity.decal_proto_visual_id );
                        
                        // Fist, lets remove the shell object from the Grid
                        if (Exists(self.mShellObject))
                        {
                            self.mShellObject.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());
                        }
                                                
                        var building = new WeBuilding(  jsonRep.entity,
                                                        protoEntity,
                                                        protoVisual,
                                                        protoVisualDecal,
                                                        true);

                        var children = db.getProtoEntityChildren(protoEntity);
                        var wasAdded = true;  
                        if(children.length > 0 && childMaxCount > 0)
                        {
                            var childLength = children.length;
                            childMaxCount -= childLength;
                            for(idx = 0; idx < childLength; idx++)
                            {
                                id = children[idx].proto_entity.id;
                                var type = children[idx].proto_entity.type;
                                
                                var childProtoEntity=db.getProtoEntityById(id);
                                var childProtoVisual=db.getProtoVisualById(childProtoEntity.primary_proto_visual_id);
                            
                                if(childProtoEntity.entity_type == "Villager")
                                {
                                	
                                	
                                    //if (true || building.IsConstructionDone() && wasAdded)
                                	if(wasAdded)
                                    {
                                    	if(childProtoVisual)
                                    	{
	                                        var agentDef = {};
	                                        agentDef.xChildProtoEntity = childProtoEntity;
	                                        agentDef.xBuilding = building;
	                                        lotChildren.push(agentDef);
                                    	}
                                    	else
                                    	{
                                    		NgLogD("ERROR no ProtoVisual for "+childProtoEntity.proto_name+ " protovisual id "+ childProtoEntity.primary_proto_visual_id);
                                    	}
                                    }
                                    
                                }
                                else
                                {
                                    NgLogD("Unsupported child type = " + childProtoEntity.entity_type);
                                }
                            }
                        }

                        if (!isInStash && protoEntity.xp_reward > 0)
                        {
                            building.CreateResourceFlyOff(protoEntity.xp_reward, "xp", 0);
                        }

                        // Broke! Bug: WeRuleMobage-587
                        // for(var idx = 0; idx < db.proto_entities.length; ++idx)
                        //                         {
                        //                             var ent = db.proto_entities[idx].proto_entity;
                        //                             if(ent.id == entity.proto_entity_id)
                        //                             {
                        //                                 var in_stash = db.getStoreItemStashCount(ent);
                        //                                 if(!in_stash)
                        //                                 {
                        //                                     NgLogD("*** IN STASH");
                        //                                     db.proto_entities.splice(idx, 1);
                        //                                 }
                        //                                 break;
                        //                             }
                        //                         }
                        
                        self.entities.push(jsonRep.entity);
                        self.initIndices();


                        self.population_in_use += protoEntity.population_cost;  
						if(!isInStash)
						{
                        	self.gold -= protoEntity.gold_cost;
                        	self.mana -= protoEntity.mana_cost;
						}
                        
                        self.mKingdomObjects.push(building);

                        if(self.mShellObject) 
                        {
                            self.mShellObject.mDisableRemoveObstruction = true;
                        }
                        
                        // this creates a new shell object - that'll allow the player to build multiple objects of the same
                        // kind. If this fails - (they don't have gold/pop room or perhaps physical room, don't drop the shell)

                        
						// If this was last stash item - don't create new shell,
						// allow player to reconsider his intentions - using
						// gold and mojo is serious business!
						 /* only try to create another shell if not locked */
                        if (stashCount === 1 || !WeGameStateMgr.PlacePendingObjects(myeventFlag) || !weProtoDb.getInstance().isStoreItemUnlocked(protoEntity))
                        {
                      	  WeGameStateMgr.SetActiveObject(null);
                          WeGameStateMgr.SetPendingObject(null);
                        }
                        
                        
                        NgLogD("***** TEST " + building.mEntity.proto_entity_id);
                        if (WeEventGame.isEventProducingID(building.mEntity.proto_entity_id))
                		{   // we only create the set of items when none on screen
                		    // this prevents the same active items from appearing after another harvest.
                		    var cSprite = building.GetMainSprite();
                		    WeEventGame.createDropsFromActiveItems(cSprite.GetX(), cSprite.GetY());
                		}

                        if (Exists(self.mShellObject))
                        {
                            self.mShellObject.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());
                    
                            //I think it is bad
                            if(self.mShellObject.AddToGridClosestFirst(WeGameStateMgr.GetGameLotGrid(), building.mAnchor))
                            //if(WeGameStateMgr.GetGameLotGrid().AddObstructionClosest(  self.mShellObject,
                            //                                                            building.mAnchor))
                             {
                                //WeCamera.transRoot.setPosition( pos.x, pos.y, WeCamera.transRoot.mZ);
                                self.mShellObject.OpenLotActionMenu();
                                WeGameStateMgr.SetActiveObject(self.mShellObject); 
                                self.mShellObject.mTouchId = -888;
                                gLotActionMenuObject = self.mShellObject;
                                // does it need to differentiate between buildings and trees?
                                if (building.CountDecalState())
        						{
        							WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.ObjectPlace);
        						}
        						else
        						{
        							WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.BuildingPlace );
        						}
                             }
                             else
                             {   // new shell needs to have lotaction menu open. Also set it as activeobject   
                                 //NgLogD("Object added in shit ");
                                 self.mShellObject.OpenLotActionMenu();
                                 WeGameStateMgr.SetActiveObject(self.mShellObject); 
                             }
						}

                        var numChildren = lotChildren.length;
                        //NgLogD("*********** Processing Lot children: " + lotChildren.length);
                        for(idx = 0; idx < numChildren; ++idx)
                        {
                            //NgLogD("*********** Load Child: " + idx);
                            var lotAgentDef = lotChildren[idx];
                            self.CreateCharacter(lotAgentDef.xBuilding, lotAgentDef.xChildProtoEntity);
                        }
                        WeGameStateMgr.SendAllRelocatedBuildingToServer();
                        
                        // update our local data
                        WeGameStateMgr.GetGameLotInfo().UpdateInfo(jsonRep.entity.kingdom.kingdom);
                    }
                    else
                    {
                        //NgLogD("Over the build limit for that item: ");
                        // Over the build limit for that item
                        WeGameStateMgr.SetGlobalGameWidget(null);
                        WeGameStateMgr.SetActiveObject(null);
                        WeGameStateMgr.SetPendingObject(null);
                    }
                }
                catch(ex)
                {
                    NgLogD("Server rejected out build request ");
                    // Server rejected out build request
                    WeGameStateMgr.SetGlobalGameWidget(null);
              	  	WeGameStateMgr.SetActiveObject(null);
              	  	WeGameStateMgr.SetPendingObject(null);
                    
                    WeUiMgr.ShowNetworkErrorPopUp();
                    NgLogException( ex );
                }
                
                
                // JMARR hack to fix bubble placement for new buildings.
                WeCamera.notifyObservers();
            }
            else
            {
                NgLogD("trying to get building info, but it feels confusing...");
                WeGameStateMgr.SetGlobalGameWidget(null);
          	  	WeGameStateMgr.SetActiveObject(null);
          	  	WeGameStateMgr.SetPendingObject(null);
            }
        }
        else if(request.readyState === 0)
        {
            ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
        }
    });
        
    this.mConstructing = true;
    // Lets send the request off
    
    // if (building.eventFlag)
    //     {
    //         NgLogD("<<<<<<!!!! BUILD EVENT BUILDING " + building.mProtoEntity.id);
    //         var items = WeEventGame.getPointsStore();
    //         var triggered = false;
    //         for (var key in items)
    //      {
    //          var protoID = parseInt(key);
    //          var entityID = parseInt(items[key].entity_id);
    //          NgLogD("ITEM IDS E " + entityID);
    //          NgLogD("ITEM IDS P " + protoID);
    //          if (entityID == building.mProtoEntity.id)  
    //          {
    //              triggered = true;
    //                 WeProtocol.purchaseItem(protoID, function(request)
    //                 {
    //                     bubble.xRequest = request;
    //                     bubble.Trigger('done');
    //                 });
    //                 
    //                 break;
    //          } 
    //      }
    //      
    //      if (!triggered)
    //      {
    //          bubble.Trigger('done');
    //          NgLogD("<<<<<<!!!! ERROR: EVENT BUILDING NOT FOUND");
    //         }
    //     }
    //     else
    {
        WeProtocol.buildBuilding(WeGameStateMgr.GetCurrentKingdomId(), data, isInStash, function(request)
        {
            bubble.xRequest = request;
            bubble.Trigger('done');
        });
    }
};

weKingdom.prototype.DisableTouch = function ()
{
	NgLogD(">>> Touch <<< WeKingdom DisableTouch()");
	
    this.mTouchTargetEnabled = false;
    var objs = this.mKingdomObjects;
    var len = objs.length;
    for(var buildIdx = 0; buildIdx < len; ++buildIdx)
    {
        objs[buildIdx].DisableTouch();
    }
};

weKingdom.prototype.EnableTouch = function ()
{
	NgLogD(">>> Touch <<< WeKingdom EnableTouch()");

    this.mTouchTargetEnabled = true;
    var objs = this.mKingdomObjects;
    var len = objs.length;
    for(var buildIdx = 0; buildIdx < len; ++buildIdx)
    {
        objs[buildIdx].EnableTouch();
    }
};

weKingdom.prototype.IsTouchEnabled = function ()
{
    return this.mTouchTargetEnabled;
};

weKingdom.prototype.CreateBuilding = function (list, cb)
{
    if (WeUiMgr.GetActiveScreen() == "SocialMapScreen")
    {
        cb();
        WeGameStateMgr.SetCurrentKingdomId(-1);
        this.numChildren = 0;
        return;
    }
    
    var childMaxCount = 1000;
    var db = weProtoDb.getInstance();
    if(list.length > 0)
    {
        var index = 0;  
        if(list.hasOwnProperty(index))
        {
            if (WeUiMgr.GetActiveScreen() == "InGameScreen")
            {
                WeUiMgr.ShowLoading(true);
            }
            var loaded = this.entities.length - list.length;
            var percent = (loaded/this.entities.length * 80).toFixed(1);
            if (list.length <= 1)
            {
                percent = 80;
            }
            WeUiMgr.mLoadingProgress =   percent + "%";

            var entity = list[ index ];
            var protoEntity = db.getProtoEntityById ( entity.proto_entity_id );
            
            // HACK to remove gift cart
			//if (protoEntity.id == gConfigs['GiftingCartEntityId']) continue;
			
            if ( protoEntity )
            {
		        WeUiMgr.ShowLoading(true);	// always check the loading progress screen...
                var protoVisual = db.getProtoVisualById ( protoEntity.primary_proto_visual_id );
                var protoVisualDecal = db.getProtoVisualById ( protoEntity.decal_proto_visual_id );
                var protoAnimation = db.getProtoVisualById ( protoEntity.decal_proto_visual_id );
				              
                var building = new WeBuilding(  entity,
                                                protoEntity,
                                                protoVisual,
                                                protoVisualDecal,
                                                true);
                
                var children = db.getProtoEntityChildren(protoEntity);
                var wasAdded = true;  
                if(children.length > 0 && childMaxCount > 0)
                {
                    var childLength = children.length;
                    childMaxCount -= childLength;
                    for(idx = 0; idx < childLength; idx++)
                    {
                        id = children[idx].proto_entity.id;
                        var type = children[idx].proto_entity.type;
                        
                        var childProtoEntity=db.getProtoEntityById(id);
                        var childProtoVisual=db.getProtoVisualById(childProtoEntity.primary_proto_visual_id);
                    
                        if(childProtoEntity.entity_type == "Villager")
                        {
                        	
                        	
                            //if (true || building.IsConstructionDone() && wasAdded)
                        	if(wasAdded)
                            {
                            	if(childProtoVisual)
                            	{ 
	                                var agentDef = {};
	                                agentDef.xChildProtoEntity = childProtoEntity;
	                                agentDef.xBuilding = building;
	                                this.lotChildren.push(agentDef);
                            	}
                            	else
                            	{
                            		NgLogD("ERROR no ProtoVisual for "+childProtoEntity.proto_name+ " protovisual id "+ childProtoEntity.primary_proto_visual_id);
                            	}
                            }
                            
                        }
                        else
                        {
                            NgLogD("Unsupported child type = " + childProtoEntity.entity_type);
                        }
                    }
                }
                
                if(wasAdded)
                {
                    this.mKingdomObjects.push(building);
                }
                else
                {
                    printf("*** Error: building not added to map{ %s %s }",
                    protoEntity.proto_name, protoEntity.entity_type);
                }
            }
        }
        list.shift();
        var self = this;
        new Timer(0, function()
        {
            self.CreateBuilding(list,cb);
        });
    }
    else
    {   // now create villagers
        
    //    cb();
        this.numChildren = 0;
        this.CreateCharacterFromList(cb);
    }
};

weKingdom.prototype.CreateCharacterFromList = function (cb)
{
    if (WeUiMgr.GetActiveScreen() == "SocialMapScreen")
    {
        NgLogD("**** Interrupt Villager loading.");
        WeGameStateMgr.SetCurrentKingdomId(-1);
        WeGameStateMgr.SetLoadingKingdom(false);
        return;
    }
    
    if(this.numChildren < this.lotChildren.length)
    {
        if (WeUiMgr.GetActiveScreen() == "InGameScreen")
        {
            WeUiMgr.ShowLoading(true);
        }
        var idx = this.numChildren;  
        var lotAgentDef = this.lotChildren[idx];
        this.CreateCharacter(lotAgentDef.xBuilding, lotAgentDef.xChildProtoEntity);
        this.numChildren = this.numChildren + 1;
        
        var loaded = this.numChildren;
        var percent = (80 + (loaded/this.lotChildren.length * 20)).toFixed(1);
        if (this.numChildren >= this.lotChildren.length-1)
        {
            percent = 100;
        }
        WeUiMgr.mLoadingProgress =   percent + "%";
        
        
        var self = this;
        new Timer(0, function()
        {
            self.CreateCharacterFromList(cb);
        });
    }
    else
    {
        WeGameStateMgr.SendAllRelocatedBuildingToServer();
        this.lotChildren = [];
        cb();
    }
};

weKingdom.prototype.CalculateLevelAndExp = function ()
{
    var db = weProtoDb.getInstance();
    var levelLength = db.getProtoLevelLength(); 
    if(this.xp == -1)
    {
        this.xp = 1;
    }
    this.mLevel = db.getLevelByXp(this.xp);
};
////////////////////////////////////////////////////////////////////////////////
// Method: initDisplay
// This couples weKingdom to the games globals... not the prettiest, just a demo.
weKingdom.prototype.InitDisplay = function (cb)
{
    if(this.mDisplayInit)
    {
        return;
    }
    this.mDisplayInit = true;
    
    NgLogD("#### clearDisplay");
    
    this.clearDisplay();    
    WeUiMgr.ShowLoading(true);
    
    if (!DeviceIsLowMemory())
    {
        NgLogD("#### WeCloudManager.LoadRealm");
        WeCloudManager.LoadRealm(this.kingdom_type,GameSpecificVariables.Textures.Cloud , GameSpecificVariables.Textures.CloudShadow);
        NgLogD("#### WeCloudManager.LoadRealm End");
    }
    var configs = weProtoConfigs.getInstance().configs;
    var db = weProtoDb.getInstance();
    
    //NgLogD("######## protoconfigs: #########");
    //for (var key in configs)
    //	NgLogD(configs[key].key + ": "+configs[key].value);    	
    //NgLogD("############# end  #############");
    
    
    NgLogD("#### geting config keys.LoadRealm");
    
    //stash and gifting
    for (var key in configs)
    {
    	if (configs[key].key == "GiftingEnabled")
    	{
    		gGiftingEnabled = (configs[key].value == "TRUE");
    	}
    	if (configs[key].key == "StashEnabled")
    	{
    		gStashEnabled = (configs[key].value == "TRUE");
    	}
    	if (configs[key].key == "StashButtonEnabled")
    	{
    		gStashButtonEnabled = (configs[key].value == "TRUE");
    	}
    }
    
// We really should convert config data to global configs structure and use it in the client...
    
/*	OTHER GIFT-RELATED CONFIGS:
D/.3fs)   ( 1840): (53)js: RequiredTimeForGifting: 24
D/.3fs)   ( 1840): (53)js: GiftBoostCostForTier_0: 2
D/.3fs)   ( 1840): (53)js: GiftTableForTier_0: 1
D/.3fs)   ( 1840): (53)js: GiftTableForTier_1: 2
D/.3fs)   ( 1840): (53)js: GiftingEnabled: TRUE
D/.3fs)   ( 1840): (53)js: GiftingCartEntityId: 663
D/.3fs)   ( 1840): (53)js: FreeGiftOpens: 5
D/.3fs)   ( 1840): (53)js: LimitFreeOpens: FALSE
D/.3fs)   ( 1840): (53)js: GiftingWizardEnabled: TRUE
D/.3fs)   ( 1840): (53)js: GiftCartPosX : -11
D/.3fs)   ( 1840): (53)js: GiftCartPosY: -5
D/.3fs)   ( 1840): (53)js: GiftingPushesEnabled: TRUE
D/.3fs)   ( 1840): (53)js: GiftDisplaySize: 25
D/.3fs)   ( 1840): (53)js: FreeGiftOpenTimeframe: 12
*/    
    
    var tileSize = 16.0; // configs.configs.BlackMapTileSize.value;
   // WeGameStateMgr.GetGameLotGrid().Flush();

    var idx = 0;
    var id;
    this.mTouchTargetEnabled = true;
    // find the Player Level for this lot
    
    this.lotChildren = [];
    var childMaxCount = 1000;
    var uniqueChildCount = 1000;
    if(Exists(gTunables.optimizations))
    {
        childMaxCount = gTunables.optimizations.character_max;
        this.mUniqueChildCount = gTunables.optimizations.unique_character_count;
        this.mChildMaxCount = childMaxCount;
    }
    this.entitiesToCreate = this.entities.slice();
    
    this.CreateBuilding(this.entitiesToCreate, cb);

};

weKingdom.prototype.CreateCharacter = function (building, childProtoEntity )
{		
    if(this.mChildMaxCount<=this.mChildCount)
    {
    	return;
    }
	
	var bAdd=false;
    if(this.mUniqueCharacterMap[childProtoEntity.id])
    {
        if(this.mUniqueCharacterMap[childProtoEntity.id] < this.mUniqueChildCount)
        {
            ++this.mUniqueCharacterMap[childProtoEntity.id];
            bAdd=true;
        }
    }
    else
    {
    	this.mUniqueCharacterMap[childProtoEntity.id] = 1;
    	bAdd=true;
    }
    if(bAdd)
    {
    	var db = weProtoDb.getInstance();
		var childProtoVisual=db.getProtoVisualById(childProtoEntity.primary_proto_visual_id);
		if(Exists( childProtoVisual) )
		{
			var childProtoVisualDecal=db.getProtoVisualById(childProtoEntity.decal_proto_visual_id);
			var cWeCharacter = new WeCharacter(false, false, childProtoEntity);
			cWeCharacter.Setup(childProtoEntity, childProtoVisual, childProtoVisualDecal);
			building.AddVillager(cWeCharacter);
			
			this.mChildCount++;
		}
	}
};

////////////////////////////////////////////////////////////////////////////////
// Method: updateJobInfo
weKingdom.prototype.UpdateJobInfo = function (job)
{
    var updated = false;
    var active_jobs = this.active_jobs;
    var len = active_jobs.length;
    for(var idx = 0; idx < len; ++idx)
    {
        if( active_jobs[idx].id == job.id )
        {
        	var jobidx=active_jobs[idx];
        	jobidx.entity_id  = job.entity_id;
        	jobidx.friend_kingdom_id = job.friend_kingdom_id;
        	jobidx.friend_name = job.friend_name;
        	jobidx.id = job.id;
        	jobidx.is_active = job.is_active;
        	jobidx.is_blocking = job.is_blocking;
        	jobidx.product_id = job.product_id;
        	jobidx.request_kingdom_id = job.request_kingdom_id;
        	jobidx.request_name = job.request_name;
        	jobidx.state = job.state;
        	jobidx.work_started_at = job.work_started_at;
            updated = true;
        }
    }
    
    if (updated === false)
    {   // add it
        //NgLogD("ADD NEW ACTIVE JOB");
        var element = {};
        element.entity_id   = job.entity_id;
        element.friend_kingdom_id = job.friend_kingdom_id;
        element.friend_name = job.friend_name;
        element.id = job.id;
        element.is_active = job.is_active;
        element.is_blocking = job.is_blocking;
        element.product_id = job.product_id;
        element.request_kingdom_id = job.request_kingdom_id;
        element.request_name = job.request_name;
        element.state = job.state;
        element.work_started_at = job.work_started_at;
        
        active_jobs.push(element);
    }
};

////////////////////////////////////////////////////////////////////////////////
// Method: clearDisplay
weKingdom.prototype.clearDisplay = function ()
{
    for ( var cur = 0; cur < this.mKingdomObjects.length; ++cur )
    {
        var obj = this.mKingdomObjects[ cur ];
        obj.destroy();
    }
    this.mKingdomObjects = null;
    this.mKingdomObjects = [];
    
    this.mUniqueChildCount = 0;
    this.mChildMaxCount = 0;
    this.mChildCount = 0;
    this.mUniqueCharacterMap= [];
};
/*
weKingdom.prototype.DisableDecalTouchTargets = function()
{
    var len =  this.mKingdomObjects.length;
    for ( var cur = 0; cur < this.mKingdomObjects.length; ++cur )
    {
        var obj = this.mKingdomObjects[ cur ];
        if(obj.IsDecal())
        {
            obj.Disable(); 
        }
    }
};

weKingdom.prototype.DisableTouchTargets = function()
{
    
};
*/
weKingdom.prototype.ShowDelivered = function(job)
{
    var protoProd = weProtoDb.getInstance().getProtoProduceId(job.product_id);      
    var protoEvent = weProtoDb.getInstance().getProtoEventId(protoProd.proto_event_id);
    var itemDef = WeUiMgr.GetItemDef("job_delivered");
    var args = {};
    
    args.job = job;
    args.game_label_1 = protoEvent.completion_text;
    args.game_label_2 = protoEvent.reward_gold;
    args.game_label_3 = protoEvent.reward_xp;
    args.game_asset_1 = protoProd.icon_png;
    
    args.OnYes = function(args)
    {
        var cb = function(request)
        {
            if(request.readyState == 4)
            {
                if ( request.responseText && request.responseText.length )
                {
                    try
                    {
                        obj = JSON.parse(request.responseText);
                        var job = obj.job;
                        WeGameStateMgr.GetGameLotInfo().UpdateJobInfo(job);

                        // I need to update all affected entities
                        WeGameStateMgr.GetGameLotInfo().UpdateEntities(job.affected_entities);

                        if (job.request_kingdom && job.request_kingdom.kingdom && job.request_kingdom.kingdom.id === WeGameStateMgr.GetCurrentKingdomId())
                        {
                           WeGameStateMgr.GetGameLotInfo().UpdateInfo(job.request_kingdom.kingdom);
                        }

                        if (job.friend_kingdom && job.friend_kingdom.kingdom && job.friend_kingdom.kingdom.id === WeGameStateMgr.GetCurrentKingdomId())
                        {
                           WeGameStateMgr.GetGameLotInfo().UpdateInfo(job.friend_kingdom.kingdom);
                        }
                    }
                    catch(ex)
                    {
                        NgLogD("*********** Could not request COMPLETE JOB.  Response = " + ex);
                        WeUiMgr.ShowNetworkErrorPopUp();
                    }
                }
                else
                {
                    NgLogD ( "Could not COMPLETE JOB response from server" );
                    WeUiMgr.ShowNetworkErrorPopUp();
                    // For now lets just pretent is all went thought ok
                }
            }
            else if(request.readyState === 0)
            {
                ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
            }
        };
    
        WeProtocol.pickupCompletedJob ( args.job, cb );
        WeGameStateMgr.SetGlobalGameWidget(null);

		args.job.sender.DisplayJobsReadyForPickup();
    };
    
    var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);

    gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
    WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.HappyCrowd );
    WeGameStateMgr.SetGlobalGameWidget(gameWidget);
};

weKingdom.prototype.ShowFailedDelivery = function(job)
{
    var protoProd = weProtoDb.getInstance().getProtoProduceId(job.product_id);      
    var protoEvent = weProtoDb.getInstance().getProtoEventId(protoProd.proto_event_id);
    var itemDef = WeUiMgr.GetItemDef("job_failed");
    var args = {};
    args.job = job;
    if (protoEvent.failure_text && protoEvent.failure_text.length > 0)
    {
        args.game_label_1 = protoEvent.failure_text;
    }
    else
    {
        args.game_label_1 = "You couldn't have a " + protoEvent.name + "...";
    }
        
	args.job = job;
    args.game_label_2 = protoEvent.reward_gold;
    args.game_label_3 = protoEvent.reward_xp;
    args.game_asset_1 = protoProd.icon_png;
    
    args.OnYes = function(args)
    {
        var cb = function(request)
        {
            if(request.readyState == 4)
            {
                if ( request.responseText.length )
                {
                    try
                    {
                        obj = JSON.parse(request.responseText);
                        var job = obj.job;
                        WeGameStateMgr.GetGameLotInfo().UpdateJobInfo(job);

                        // I need to update all affected entities
                        WeGameStateMgr.GetGameLotInfo().UpdateEntities(job.affected_entities);

                        if (job.request_kingdom && job.request_kingdom.kingdom && job.request_kingdom.kingdom.id === WeGameStateMgr.GetCurrentKingdomId())
                        {
                           WeGameStateMgr.GetGameLotInfo().UpdateInfo(job.request_kingdom.kingdom);
                        }

                        if (job.friend_kingdom && job.friend_kingdom.kingdom && job.friend_kingdom.kingdom.id === WeGameStateMgr.GetCurrentKingdomId())
                        {
                           WeGameStateMgr.GetGameLotInfo().UpdateInfo(job.friend_kingdom.kingdom);
                        }
                    }
                    catch(ex)
                    {
                        NgLogD("*********** Could not request COMPLETE JOB.  Response = " + ex);
                        WeUiMgr.ShowNetworkErrorPopUp();
                    }
                }
                else
                {
                    NgLogD ( "Could not COMPLETE JOB response from server" );
                    WeUiMgr.ShowNetworkErrorPopUp();
                }
            }
            else if(request.readyState === 0)
            {
                ExitOnError(gErrors.NETWORK_FAILURE_CRITICAL);
            }
        };
        
        WeProtocol.cancelJob ( args.job, cb );
        WeGameStateMgr.SetGlobalGameWidget(null);

		args.job.sender.DisplayJobsReadyForPickup();
    };
    
    var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);

    gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
    WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.SadCrowd );
    WeGameStateMgr.SetGlobalGameWidget(gameWidget);
};
////////////////////////////////////////////////////////////////////////////////
// Method: DisplayJobsReadyForPickup
weKingdom.prototype.DisplayJobsReadyForPickup = function ()
{
    var self = this;
    var active_jobs = this.active_jobs;
    if(!active_jobs)
    {
    	return;
    }
    var len = active_jobs.length;
    for(var idx = 0; idx < len; ++idx)
    {
        // get building
        if (active_jobs[idx].request_kingdom_id == WeGameStateMgr.GetCurrentKingdomId()
			&& this.IsJobSpoiled(active_jobs[idx])
			&& active_jobs[idx].shown == undefined)
		
        {   // need to cancel the job
            
            NgLogD("****** JOB SPOILED FOR PICKUP");
            var args = {};
            args.OnYes = function(args)
            {
                WeGameStateMgr.SetGlobalGameWidget(null);    
                // show fail delivered screen
                self.ShowFailedDelivery(args.job);
            };
    
            var job = active_jobs[idx];
			job.shown = true;
            var protoProd = weProtoDb.getInstance().getProtoProduceId(job.product_id);      
            if (Exists(protoProd))
            {
                var protoEvent = weProtoDb.getInstance().getProtoEventId(protoProd.proto_event_id);
            
                args.job = job;
				args.job.sender = this;
                args.game_label_2 = protoProd.proto_name;
                args.game_label_3 = job.friend_name + "'s "+GameSpecificVariables.Texts.realm;
                args.game_label_1 = protoEvent.button_fail_text;
                args.game_asset_1 = protoProd.icon_png;
                var itemDef = WeUiMgr.GetItemDef("job_delivery_spoil");
            
                var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);

                gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
                WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.JobComplete );
                WeGameStateMgr.SetGlobalGameWidget(gameWidget);
            }
            break;
        }
        else if( active_jobs[idx].request_kingdom_id == WeGameStateMgr.GetCurrentKingdomId() 
			&& active_jobs[idx].state == "ReadyForPickup"
			&& active_jobs[idx].shown == undefined)
        {   // show delivered view
            
            NgLogD("****** JOB READY FOR PICKUP");
            
            var args = {};
            args.OnYes = function(args)
            {
                WeGameStateMgr.SetGlobalGameWidget(null);
                // show  delivered screen
                self.ShowDelivered(args.job);
            };
    
            var job = active_jobs[idx];
			job.shown = true;
            var protoProd = weProtoDb.getInstance().getProtoProduceId(job.product_id);   
            if (Exists(protoProd))
            {   
                var protoEvent = weProtoDb.getInstance().getProtoEventId(protoProd.proto_event_id);
            
                args.job = job;
				args.job.sender = this;
                args.game_label_2 = protoProd.proto_name;
                args.game_label_3 = job.friend_name + "'s "+GameSpecificVariables.Texts.realm;
                args.game_label_1 = protoEvent.button_success_text;
                args.game_asset_1 = protoProd.icon_png;
                // protoEvent.completion_text and failure_text
                var itemDef = WeUiMgr.GetItemDef("job_completed");
            
                var gameWidget = WeUiMgr.CreateGameWidget(itemDef, args);

                gameWidget.setPosition(gRawWidth*0.5, gRawHeight*0.5);
                WeEffectsMgr.PlaySoundEffect(GameSpecificVariables.Sounds.JobComplete);
                WeGameStateMgr.SetGlobalGameWidget(gameWidget);
            }
            break;
        }
    }
    
};

weKingdom.prototype.IsBubblesShowing = function()
{
	return this.mIsBubblesShowing;
}

weKingdom.prototype.HideBubbles = function(flag)
{
	
    var alpha = 1;
    if (flag)
    {   // hide bubbles
        alpha = 0;
    }
    this.mIsBubblesShowing=!flag;
    for (var i = 0; i < this.mKingdomObjects.length; i++ )
    {
        var obj = this.mKingdomObjects[ i ];
        if (obj.mBubble)
        {
            obj.mBubble.Trigger('setAlpha', alpha);
        }
    }
};

weKingdom.prototype.UpdateEntities = function(affected)
{
    var affected_entities = affected;
    if (affected_entities === undefined)
    {
        return;
    }
    NgLogD("CHECKING UPDATE ENTITIES " + affected_entities);
    var len = affected_entities.length;
    
    for(var idx = 0; idx < len; ++idx)
    {
        var affectedEnt = affected_entities[idx].entity;
        var count = this.mKingdomObjects.length;
        for (var n=0; n < count; n++)
        {
            var obj = this.mKingdomObjects[ n ];
            if(affectedEnt.id == obj.mEntity.id)
            {
                obj.UpdateEntity(affectedEnt);
            }
        }
    }
};

////////////////////////////////////////////////////////////////////////////////
weKingdom.prototype.UpgradeEntity = function(fromId, toId)
{
    var db = weProtoDb.getInstance();

    // hunt through the entities and find our target
    var entity = null;
    var i = 0;
    for ( i = 0; i < this.entities.length; i++ )
    {
        if ( this.entities[i].proto_entity_id == fromId )
        {
            entity = this.entities[i];
            entity.proto_entity_id = toId;
            break;
        }
    }
    
    if ( entity === null )
    {
        return;
    }

    for ( i = 0; i < this.mKingdomObjects.length; i++ )
    {
        var obj = this.mKingdomObjects[ i ];
        if ( obj.mProtoEntity.id == fromId )
        {
            // remove the obstruction
            obj.RemoveFromGrid(WeGameStateMgr.GetGameLotGrid());
            obj.destroy();

            var protoEntity = db.getProtoEntityById ( toId );
            var protoVisual = db.getProtoVisualById ( protoEntity.primary_proto_visual_id );
            var protoVisualDecal = db.getProtoVisualById ( protoEntity.decal_proto_visual_id );
            var building = new WeBuilding(entity, protoEntity, protoVisual, protoVisualDecal, true);
            // REMOVING - init used to return this value...
            // successful building? If so - replace it in the object list.
//            if ( wasAdded )
//            {
                this.mKingdomObjects[i] = building;
//            }
//            else // failed somehow, backout the fromId change and bail out...
//            {
//                WeGameStateMgr.GetGameLotGrid().AddObstruction(obj);
//                entity.proto_entity_id = fromId;
//            }
        }
    }
};

weKingdom.prototype.IsJobSpoiled = function(job)
{
	if (!Exists(job))
	{
		return false;
	}
	
	// TODO
    if (job.state === 'Spoiled')
    {
        return true;
    }
    
    entity = this.getEntityById(job.entity_id);
    
    if (!Exists(entity))
    {
    	return false;
    }
        
    var timeSinceWorkStarted = WeTime.GetGameTime() - ConvertToDate(entity.work_started_at).getTime();

  //  var prod = this.GetJobProductByProducingProtoEntityId(this.mProtoEntity.id);
    var prod = weProtoDb.getInstance().getProtoProduceId(job.product_id);
    if(prod)
    {
	    if (job.state === 'Working' && timeSinceWorkStarted > (prod.produce_duration + prod.spoilage_duration)*1000)
	    {
	        return true;   
	    }
    }
    else
    {
    	NgLogD("weKingdom.prototype.IsJobSpoiled Bad state no ProducingProtoEntity fot id: "+job.product_id);
    }
    
    return false;
};

weKingdom.prototype.UpdateJobBubbles = function()
{
    var i=0;
    for ( i = 0; i < this.mKingdomObjects.length; i++ )
    {
        var obj = this.mKingdomObjects[ i ];
        
        if (obj.IsStateSet(BuildingState.AutoProducing))
        {   // only go through auto produce buildings since they can have jobs
            if(WeGameStateMgr.IsCurrentUser())
            {
                if (obj.ShouldHaveOwnerJobBubble())
                {
                    obj.OpenJobBubble();
                }
                else
                {
                    obj.CloseJobBubble();
                }
            }
            else
            {
                if (obj.ShouldHaveFriendJobBubble())
                {
                    obj.OpenJobBubble();
                }
                else
                {
                    obj.CloseJobBubble();
                }
            }
        }
    }
};

weKingdom.prototype.CancelAvailableJobs = function()
{
	this.mHasAvailableJobs = false;
}

weKingdom.prototype.HasAvailableJobs = function()
{
	NgLogD("kingdom has_available_jobs:" + this.mHasAvailableJobs);
	
	if (Exists(this.mHasAvailableJobs))
	{
		return this.mHasAvailableJobs;
	}
	
	this.mHasAvailableJobs = WeGameStateMgr.HasOpenJobsIn(this.kingdom_type);

	return this.mHasAvailableJobs;
};

//////////////////////////////////////////////////////////////////////////////
/** 
 *  @date:      2010-12-20
 *  @file:      Main.js
 *  @author:    Chris Jimison
 *  @copyright: 2010 NGMOCO:) All rights reserved
 * 
 *  @brief: Main file to launch the game.  Was the former webgame TEST
 */
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Require Block
//PlusImageBase = "/PlusContent/";
var Core = require('NGCore/Client/Core').Core;
var Device = require('NGCore/Client/Device').Device;
var GL2 = require('NGCore/Client/GL2').GL2;
var WeScreen = require('weEngine/WeScreen2D').WeScreen;
var WeUiMgr = require('weEngine/WeUiMgr').WeUiMgr;
var WeEffectsMgr = require('weEngine/WeEffects').WeEffectsMgr;
var WeRenderDevice = require('weEngine/WeRenderDevice').WeRenderDevice;
//var SpriteData = require('../Code/Rule_sprite_data');
var SpriteTable = require('weEngine/WeSpriteParser').SpriteTable;
var SpriteTableHeader = require('weEngine/WeSpriteParser').SpriteTableHeader;
var WeSimulator = require('weEngine/WeSimulator').WeSimulator;
var WeProtocol = require('weEngine/WeProtocol').WeProtocol;
var Audio = require('NGCore/Client/Audio').Audio;
var NGUI = require('NGCore/Client/UI').UI;
var Network = require('NGCore/Client/Network').Network;
var WeSplashManager = require('weEngine/WeSplashManager').WeSplashManager;
var WeGoals = require('weEngine/WeGoals').WeGoals;
var WePests = require('weEngine/WePests').WePests;
var WeRealms = require('weEngine/WeRealms').WeRealms;
var Social = require('NGCore/Client/Social').Social;
var Mobclix = require('NGCore/Client/Mobclix').Mobclix;
var WeTransaction = require('weEngine/WeTransaction').WeTransaction;
var WeGameStateMgr = require('weEngine/WeGameStateMgr').WeGameStateMgr;
var WeConfiguration = require('weEngine/WeConfiguration').WeConfiguration;
var WeContentDownloader = require('weEngine/WeContentDownloader').WeContentDownloader;
var WeContent = require('weEngine/WeContent').Content;
var WeEventGame = require('weEngine/WeEventGame').WeEventGame;
var WeEventSpinner = require('weEngine/WeEventSpinner').WeEventSpinner;
////////////////////////////////////////////////////////////////////////////////

// default to fulfill orphaned orders unless told by server otherwise
var gAsyncFulfillEnabled = true;

var gFirstBoot = false;

var gFixedWidth = 0;
var gFixedHeight = 0;

function asyncFulfill() {
    PurchaseControllersReq.asyncFulfill(function(sku, orderid, receipt, cb){
        //NgLogD("Async Fulfill order for " + sku + ": " + orderid);
        fulfillOrder(sku, orderid, receipt, cb);
    },
    function(){
        //NgLogD("Done with async order check.");
    });
}

function getResolutionString()
{
	return gFixedWidth + "x" + gFixedHeight;
}

function fulfillOrder(sku, orderid, receipt, cb) {
    var transaction = {};
    transaction.product_identifier = sku;
    transaction.quantity = 1;
    transaction.identifier = orderid;
    transaction.receipt = receipt;
    transaction.date = new Date();
    transaction.procver = "v2.0";
    WeProtocol.createMtxTransaction(WeGameStateMgr.GetCurrentKingdomId(), transaction,
    function(request)
    {
        try
        {
	    	var mojoText = GameSpecificVariables.Texts.mojoTextU;
            var obj = JSON.parse(request.responseText);
            if (obj && obj.mtx_transaction && obj.mtx_transaction.kingdom)
            {
                //NgLogD("MTX WORKED (fulfillOrder)!! " + obj.mtx_transaction.kingdom);
                WeGameStateMgr.GetGameLotInfo().UpdateInfo(obj.mtx_transaction.kingdom);

                var alertDialog = new NGUI.AlertDialog();
                alertDialog.setTitle("Previous "+mojoText+" Order");
                alertDialog.setText("You got more "+mojoText+" from a previous order.");
                alertDialog.setChoices(["OK"]);
                alertDialog.onchoice = function(event) {
                    cb();
                };
                alertDialog.show();
            }
            else
            {
                NgLogD("MTX ERROR (fulfillOrder) " + JSON.stringify(request));
                // silently ignore error, there is no need to inform user
                cb();
            }
        }
        catch(ex)
        {
            NgLogD("MTX ERROR");
            NgLogD("MTX ERROR status:" + request.statusText);
            NgLogD("MTX ERROR response:" + request.responseText);
            WeUiMgr.ShowNetworkErrorPopUp();
        }
    });
}

function RestartGame()
{
	Core.LocalGameList.restartGame();
}

function ExitGame()
{
    if(Core.Capabilities.getBootGame() === Core.Capabilities.getGame())
    {
        NgLogD("Called from Gamehubmobage ... Exiting ");
        NgPushCommand2(NgEntityTypes.App, NgApplicationCommands.BackPress); 
    }
    else
    {
        NgLogD("NOTE ::: Launcher URL is: " + gLauncherUrl);
        gLauncherUrl = Core.Capabilities.getStartingServer() + "/" + Core.Capabilities.getBootGame();
        Core.LocalGameList.runUpdatedGame(gLauncherUrl);
    }
}

function ExitOnError(errorObj)
{
    NgLogD("Lets throw the error!!");
    var itemDef = WeUiMgr.GetItemDef("ErrorUI");
    var widget = WeUiMgr.CreateGameWidget(itemDef, errorObj);
    widget.setPosition(gRawWidth*0.5, gRawHeight*0.5, 10000000);
    
    // Setup a timer
    WeSimulator.OnTimer(itemDef.args.time * 1000, function()
    {
        ExitGame();
    });
}

function GetArgumentValue( response, argument )
{
	var nIndex= response.indexOf(argument+"=");
	if(nIndex!=-1)
	{
		nIndex+=  (argument+"=").length;
		
		var nEndIndex= response.indexOf("&", nIndex);
		if(nEndIndex==-1)
		{
			nEndIndex= response.length;
		}
		return response.substr(nIndex, nEndIndex-nIndex );
	}
	return null;
}

function LoginInit()
{
	//gCurKingdomUser = Social.US.Session.getCurrentSession().user().gamertag;
	NgLogD( "##### LoginInit");
    var mobageSession = Social.US.Session.getCurrentSession();
    if (!Exists(mobageSession))
    {
        var alertDialog = new NGUI.AlertDialog();
		alertDialog.setTitle("Error!");
		alertDialog.setText("Please restart!");
		alertDialog.setChoices(["OK"]);
		alertDialog.onchoice = function(event)
		{
				Device.LifecycleEmitter.exitProcess();
		};
		alertDialog.show();
		
		return;
    }
    
	mobageSession.getSessionTokensForConsumerKey(gServerConsumerKey,
	function(error, data) {
		if(error) {
			// There was an error. Most likely this is a network connectivity problem.
			// You should try this function again later.
			NgLogD('Authorization failed:'+error);
				return;
		}
		
		
		
		// These credentials can now be sent to the We Rule server.
		NgLogD('Authorized and credentials are:'+data.oauth_token+" "+ data.oauth_secret);
		WeProtocol.Setup(gGameServer, data.oauth_token, data.oauth_secret, gProductKeyStaging, gClientVersion);
		
		NgLogD('## Authorization send to server:');
		
		{
                var user = mobageSession.user();
				NgLogD("## got user");
				
				WeGameStateMgr.mCurrentPhotoId = user.photoId;

				objDumpMembers(user, 4);
				
				
				// Remove dublication
				WeGameStateMgr.SetCurrentKingdomUser(user.gamertag);
			    gCurKingdomUser = user.gamertag;
			    WeProtocol.userName = gCurKingdomUser;
			    gUsernameSelf = gCurKingdomUser; 
			
			    weGetServerPing();

		}

	});
}

////////////////////////////////////////////////////////////////////////////////
// Function: performOauth
//  Connects to the WeRule Servers using Oauth.  The other option is to use the
//  back door access via the "skipOAuth" method
function performOauth()
{
	NgLogD("##### performOauth ");
    var appName;
    var pKey;
    var pSecret;
    if (gUsePlusStaging)
    {
        //ThePlusRequest.setServerMode(ThePlusRequest.serverModes.staging);
        appName = gProductKeyStaging;
        pKey = gPlatformKeyStaging;
        pSecret = gPlatformSecretStaging;
    }
    else
    {
        //ThePlusRequest.setServerMode(ThePlusRequest.serverModes.production);
        appName = gProductKeyProduction;
        pKey = gPlatformKeyProduction;
        pSecret = gPlatformSecretProduction;
    }

    //var listener = new MessageListenerReq.MessageListener();
    //UserReq.User.addCurrentUserListener(listener, function(){
        //NgLogD("Current user changed!");
    //});
    
    // app naming convention hack
    if (gUsePlusStaging)
    {
      //appName = appName + "-Dev";
    }
    
    var gameData = {
        consumerKey: pKey,
        consumerSecret: pSecret,
        appName: appName,
        appVersion: GameInfo.appVersion
    };
    
    LoginInit();

}

////////////////////////////////////////////////////////////////////////////////
// Function: SkipOAuth
// Uses the backdoor access to the werule servers.  $TODO.  This MUST be removed
// before shiping of this game!!!!
function SkipOAuth()
{
    WeGameStateMgr.SetCurrentKingdomUser(gCurKingdomUser);
    WeGameStateMgr.SetCurrentKingdomId(gCurKingdomId);

    WeProtocol.Setup(gGameServer, "LETME", "THROUGH", gProductKeyStaging, gClientVersion );
    
    weGetServerPing();
}

function WeGameInit()
{
	NgLogD("### WeGameInit opa");
    if(gOAuthEnabled && Core.Capabilities.getPlatformOS() != "flash")
    {
    	NgLogD("#### performOauth opa");
        performOauth();
    }
    else
    {
        SkipOAuth();
    }
}

var gLauncherUrl = "";
var gCanBack = false;
var gShouldBack = false;
var gShowingBackUI = false;

var UserListener = Core.MessageListener.singleton (
{
    
    startListening: function(user)
    {
        var theuser = user;
        user.addListener(this, function(event)
           {
               if (WeGameStateMgr.mCurrentPhotoId != theuser.photoId)
               {
                   WeGameStateMgr.mCurrentPhotoId = theuser.photoId;
                   
                   if(theuser.photoId==undefined || theuser.photoId==null )
                   {
	                   	NgLogD("OnHandleTag_social_avatar no image for user");
	                   	objDumpMembers(theuser);
                   }
                   else
                   {
                   
	                   var url = "./Content/.User_" + theuser.gamertag + ".png";
	                   (new Network.DownloadFile()).start(url, "GET", theuser.photoId, [], 
	                   function(statusCode,fileSignature){
	                	   NgLogD("DownloadFile "+url+" status code "+statusCode);
	                   });
                   }
               }
           });
    }
});

var KeyListener = Core.MessageListener.singleton (
{
    initialize: function()
    {
        Device.KeyEmitter.addListener(this, this.onUpdate, 500);
    },

    onUpdate : function(keyEvent)
    {
        if (keyEvent.code === Device.KeyEmitter.Keycode.back)
        {
            if(gCanBack)
            {
				if(WeUiMgr.mActiveScreen == "InGameScreen")
				{
				    if (NGWindow.document.m_news_tab_webview_full)
				    {
				        NGWindow.document.removeChild(NGWindow.document.m_news_tab_webview_full);
        				NGWindow.document.m_news_tab_webview_full.destroy();
        				NGWindow.document.m_news_tab_webview_full = null;
        				return true;
				    }
					else if(WeGameStateMgr.GetRealmName() == 'main')
					{
						// In main kingdom realm - go back to mobage
						return false;
					}	
					else
					{
						// In some other realm - go back to main realm
						if (WeLoadNamedLot(gCurKingdomUser))
						{
							WeGameStateMgr.SetCurrentKingdomUser(gCurKingdomUser);
						}
						return true;
					}
				}
				if(WeUiMgr.mActiveScreen == "InGameScreen_Friend")
				{
					// In friend kingdom, go to social map	
                    WeSocialMapMgr.launchSocialMap(1);
                    return true;
				}
				if(WeUiMgr.mActiveScreen == "SocialMapScreen")
                {
                    WeSocialMapMgr.gotoKingdomFromMap(0);
                    return true;
                }
                else if(WeUiMgr.mActiveScreen == "BuildBuyScreen") 
				{
					// Go to game from social or build buy screen
					WeGameStateMgr.SetGlobalGameWidget(null);
					WeRenderDevice.EnableGame(true);
					if (WeUiMgr.mActiveScreen == "SocialMapScreen" && WeSocialMapMgr.isLoadingMap == true)	/* the social map is loading something */
					{
					    WeSocialMapMgr.isLoadingMap = false;	/* cancel loading */						
					}
					if ( WeLoadNamedLot(gCurKingdomUser) )
					{
						WeGameStateMgr.SetCurrentKingdomUser(gCurKingdomUser);
					}
					WeSocialMapMgr.transitionScreenToKingdom();
					return true;
				}
				
				if (Exists(gSplashManager))
				{
					return false;
				}
				
				if (WeUiMgr.mActiveScreen == "IntroScreen")
				{
				    return false;
				}
				
				if(WeGameStateMgr.GetCurrentKingdomUser() == null)
                {
                    NgLogD("boot: back button pressed");
                    Core.LocalGameList.runUpdatedGame(gLauncherUrl);
                }
                else
                {
					return false;	
                }
            }
            else
            {
            	NgLogD("@@@ Delaying Back action!");
                gShouldBack = true;
            }
            return true;
        }
        return false;
    }
});

var NetworkListener = Core.MessageListener.singleton (
{
    initialize: function()
    {
		Device.NetworkEmitter.addListener(this, this.onUpdate, 500);
    },

    onUpdate : function(status)
    {

		if (status == Device.NetworkEmitter.Status.None)
		{
            NgLogD("Error: onUpdate status == none");
			WeUiMgr.ShowNetworkErrorPopUp();
		}
    }
});

var LifeCycleListener = Core.MessageListener.singleton ({
	initialize: function ()
	{
		NgLogD("LifeCycleEmitter ready!");
		Device.LifecycleEmitter.addListener(this, this.onUpdate, 400);
	},
	
	onUpdate: function (lifeCycleEvent)
	{
		
		NgLogD("LifeCycleEmitter updating! " + lifeCycleEvent);
		if (lifeCycleEvent === Device.LifecycleEmitter.Event.Terminate)
		{
			NgLogD("LifeCycleEmitter - terminating!");
			Audio.Music.pause();
			WeEffectsMgr.mMusicEnabled = false;
			if(Exists(WeEffectsMgr.mActiveEffect))
				WeEffectsMgr.mActiveEffect.stop();
		} 
		else
		if (lifeCycleEvent === Device.LifecycleEmitter.Event.Suspend)
		{
			NgLogD("LifeCycleEmitter - pausing!");
			Audio.Music.pause();
			WeGameStateMgr.mSuspended = true;
			WeEffectsMgr.mMusicEnabled = false;
			if(Exists(WeEffectsMgr.mActiveEffect))
				WeEffectsMgr.mActiveEffect.stop();
			if (WeUiMgr.mActiveScreen !== "IntroScreen")
    		{
			    WeUiMgr.ShowLoading(true);
		    }
		} else
		if (lifeCycleEvent === Device.LifecycleEmitter.Event.Resume)
		{
			NgLogD("LifeCycleEmitter - resuming!");
			WeEffectsMgr.mMusicEnabled = true;
			Audio.Music.play();
			WeGameStateMgr.mSuspended = false;
			if (WeUiMgr.mActiveScreen !== "IntroScreen")
			{   
			    WeUiMgr.ShowLoading(false);
		        if(WeUiMgr.mActiveScreen == "SocialMapScreen") 
				{
					WeRenderDevice.EnableGame(true);
				}
				else
				{
				    WeGameStateMgr.SetActiveObject(null);
    				WeGameStateMgr.SetPendingObject(null);
				}	
				
                WeProtocol.postWakeUp( function ( request )
                {   // don't need to do anything. WeProtocol should handle the messages

                    if ( request.responseText && request.responseText.length )
                    {
                        NgLogD("FAST APP SWITCH: " + request.responseText);
                        new Timer(1, function()
                        {
                            if(Exists(WeGameStateMgr.mInterstitialCommand))
                			{
                				HandleURLRequest(WeGameStateMgr.mInterstitialCommand);
                				WeGameStateMgr.mInterstitialCommand = null;
                            }
                        });
                    }
                });
            }
		    
		} 
	}
});

function GetStatusMessage()
{
    return gStatusMessage;
}


function InitConfiguration()
{
	NgLogD("### InitConfiguration");
	
    WeEffectsMgr.ShowSpinner();
    
    // Set start that spinner up
    SpriteTable.setCallback(function()
    {
    	WeConfiguration.Load(function(configuration)
    		{
    			//
    			//	setup server info
    			//
    			gGameServer = configuration.server; 
    			gUsePlusStaging = configuration.socialServer.indexOf("sandbox") > 0;
    			
    			NgLogD("using server" + gGameServer + "use staging" + gUsePlusStaging);
    			
    			//
    			// read mobclix id
    			//
    			if( Core.Capabilities.getPlatformOS() == "Android")
			    {
    			    mobclixID = configuration.AD_ID;
    			}
    			else
    			{
    			    mobclixID = configuration.AD_ID_IOS;
			    }
			    
    			NgLogD("mobclix ID" + mobclixID);
    			
    			Mobclix.startWithApplicationId(mobclixID);
    			
    			WeGameInit();
    		}
    	);
    });
    
    var fs = Storage.FileSystem;
    ReadFile(fs, GameSpecificVariables.Paths.screenDefFileDir + "sprite_table.json", {'blocking': false}, function(err, data)
    {
        if (!err )    
        {   
            var theJSON = JSON.parse(data);
            if (theJSON.sprite_headers && theJSON.sprite_table)
            {
                SpriteTableHeader.download(theJSON.sprite_headers, theJSON.sprite_table);
            }
        }

    });

}


function IsTexture(path)
{
	return path.indexOf('sprite_sheet') > 0 && (endsWith(path, '.png') || endsWith(path, '.pvr') || endsWith(path, '.atc'));
}

function IsImage(path)
{
	return path.indexOf('sprite_sheet') == -1 && endsWith(path, '.png');
}

function IsAudio(path)
{
	return endsWith(path, '.ogg') || endsWith(path, '.mp3');
}

function ReadImagesManifest(manifest, level)
{
	var fs = Storage.FileSystem;
    ReadFile(fs, manifest, {'blocking': false}, function(err, data)

	{
		if(!err)
		{
			try
			{
				content = JSON.parse(data);
				
				for(var i in content)
				{
					// Strip path
					var s = i.lastIndexOf('/');
					var name = i.substring(s+1);
					
					if(IsTexture(name))
					{
						if (!SpriteTable.imgExists(name))
						{
						    SpriteTable.addImg(name);
					    }
						
						WeContent.AddTextureFile(name, level);
					}
					else if (IsImage(name))
					{
					
						var fullName = name;
						
						//
						//	we support up to one level deep filenames (goals/goals.png)
						//
						parts = i.split('/');
						parent = parts[parts.length - 2];
						
						
						if (isNaN(Number(parent)))
						{
							fullName = i.split('/').slice(-2).join('/');
							WeContent.AddImageFile(fullName, level);
						}
						else
						{
							WeContent.AddImageFile(name, level);
						}
						
					}
					else if (IsAudio(name))
					{
						WeContent.AddAudioFile(name, level);
					}
				}
			}
			catch (e)
			{
				
			}
		
		}
		else 
		{
			NgLogD("could not read manifest file: " + err);
		}
		
		WeContentDownloader.OnManifestRead();
	});
}


function CheckBlacklist(cb)
{
	function DisplayAlert()
	{
		var alertDialog = new NGUI.AlertDialog();
        alertDialog.setTitle("Sorry!");
        alertDialog.setText("We Rule is currently not available on your device. We're working hard to make the game accessible to everyone. Please check back soon, and try other Mobage games in the meantime.");
        alertDialog.setChoices(["OK"]);
        alertDialog.onchoice = function(event)
		{
			Device.LifecycleEmitter.exitProcess();
        };
        alertDialog.show();
	};

	function DisplayWarning()
	{
		var alertDialog = new NGUI.AlertDialog();
        alertDialog.setTitle("Thanks for downloading We Rule!");
        alertDialog.setText("We are working on expanding our device support, but things may be bumpy on your phone for now.");
        alertDialog.setChoices(["OK"]);
        alertDialog.show();
	};

	var deviceName = Core.Capabilities.getDeviceName();
	var fs = Storage.FileSystem;
	ReadFile(fs, "./Configs/blacklist.json", {'blocking': false}, function(err, data)
	{
		if(!err)
		{
			try
			{
				var blacklist = JSON.parse(data);

				// Iterate over forbidden devices
				for(var i in blacklist.devices)
				{
					if(blacklist.devices[i] === deviceName)
						return DisplayAlert();
				}

				// Iterate over forbidden resolutions
				var deviceResolution = gRawWidth + 'x' + gRawHeight;
				for(var i in blacklist.resolutions)
				{
					if(blacklist.resolutions[i] === deviceResolution)
						return DisplayAlert();
				}
			}
			catch(ex)
			{
				NgLogD("Unable to parse blacklist");
			}
		}

		/*
		if(gFirstBoot)
		{
			// We passed first test, now check the whitelist
			ReadFile(fs, "./Configs/whitelist.json", {'blocking': false}, function(err, data)
			{
				if(!err)
				{
					var whitelist = JSON.parse(data);
					var found = false;	
					for(var i in whitelist.devices)
					{
						if(whitelist.devices[i] === deviceName)
						{
							found = true;
							break;
						}
					}

					if(!found)
						DisplayWarning();
				}
			
				if(Exists(cb))
					cb();

			});
		}
		else
		{
		}*/
		
		if(Exists(cb))
			cb();

	});
}

function GetLOD(cb) 
{
	var deviceName = Core.Capabilities.getDeviceName();
	var fs = Storage.FileSystem;
	ReadFile(fs, "./Configs/lod.json", {'blocking': false}, function(err, data)
	{
		if(!err)
		{
			lods = JSON.parse(data);
			lod = lods[deviceName];
			if(Exists(lod) && parseInt(lod) === lod)
			{
				cb(lod);
			}
			else
			{
				lod = lods["{default}"];
				if(Exists(lod) && parseInt(lod) === lod)
					cb(lod)
				else
					cb(2);
			}
		}
		else
		{
			NgLogD("Unable to read LODs from ./Configs/lod.json");
			cb(2);
		}
	});
}

function WeStartSplashSequence()
{
	NgLogD("=== WeStartSplashSequence");
	gCanBack = true;
    
    
    // begin the splash sequence - upon finishing it'll start the engine init
    gSplashManager = new WeSplashManager();
    gSplashManager.startSequence(WeEngineInit);
}

function ShowBackUI()
{
	NgLogD("Would you like to see some BackUI?");
}

function WeEngineInit()
{ 
	NgLogD("=== WeEngineInit");



    // clean up the splash manager - its useless to us now.
    gSplashManager.destroy();
    gSplashManager = null;
    
	WeUiMgr.RequestScreenInfo(function()
	{
		WeCamera.scaleRoot = WeRenderDevice.GetScaleRoot();
		WeCamera.transRoot = WeRenderDevice.GetTranslationRoot();

		WeSimulator.Setup();
		WeUiMgr.GetScreen().Setup(WeRenderDevice.GetUiRoot());

		WeGameStateMgr.Setup();
		WeUiMgr.TransitionScreenTo("IntroScreen"); 
		gCanBack = true;
		if(gShouldBack)
		{
			ShowBackUI();
			gShouldBack = false;
		}
		else
		{
			//
			//	Init game configuration
			//
			InitConfiguration();
		}
		
		Social.Common.Service.showCommunityButton([1.0,0.0], "dark", function(error)
		{
			NgLogD("ERROR showCommunityButton: "+error);
		}		
		);
	});
}

function ReadFile(fs, file, values, cb)
{
    if( Core.Capabilities.getPlatformOS() == "Android")
    {
        fs.readFile ( file, values, cb);
    }
    else
    {
        
        fs.readFile ( file, cb);
    }
}

function LoadErrors(cb)
{
    var fs = Storage.FileSystem;
    
    ReadFile(fs, "/Configs/errors.json", {'blocking': false}, function(err, data)
        {
            if (!err )
            {
                try
                {
                    gErrors = JSON.parse(data);
                    cb();
                }
                catch(ex)
                {
                    NgLogD("Error = " + ex);
                    NgLogD("Data = " + data);
                    NgLogD("************ Error parsing the JSON data");
                    ExitGame();
                }
            }
            else
            {
                NgLogD("*********** Error loading the Errors Text - head exploded");
                ExitGame();
            }
        });   
}

function CreateGLView()
{
    var glView = new NGUI.GLView();

    glView.onload = function()
    {
        if( Core.Capabilities.getPlatformOS() == "Android")
        {
            glView.setFrame(0, 0, gRawWidth, gRawHeight);
        }
        else
        {
            gRawWidth = Core.Capabilities.getScreenWidth();
            gRawHeight = Core.Capabilities.getScreenHeight();

            if (gRawWidth < gRawHeight)
            {
                gRawWidth = Core.Capabilities.getScreenHeight();
                gRawHeight = Core.Capabilities.getScreenWidth();
            }
    	}

    	gFixedWidth = gRawWidth;
		gFixedHeight = gRawHeight;
    	
    	SetDimensions();
    	
    	NgLogD("loaded GLView");
		var eScreen = require('weEngine/RulePlusHome').RuleHome;
		eScreen.initialize();
       // Device.LifecycleEmitter.requestEngineKeepAlive(glView);
       if( Core.Capabilities.getPlatformOS() == "Android")
       {
		   KeyListener.instantiate();
	   }
		NetworkListener.instantiate();
        LifeCycleListener.instantiate();

        gLauncherUrl = Core.Capabilities.getStartingServer() + "/" + Core.Capabilities.getBootGame();
        

        //
        //	setup content downloader
        //
        WeContentDownloader.Setup(function()
        {
        	gFirstBoot = WeContentDownloader.GetContentLevel() < 0; 
		        	
		        	if (gFirstBoot)
		        	{
		        		//
		        		//	report  analytics	
		        		//
		        		Core.Analytics.reportFunnelStage('NEWUSER', 0, 'INITIALLOAD', {});
		        	}
        });
				
        
        LoadErrors(function()
		{
		    if( Core.Capabilities.getPlatformOS() == "Android")
		    {
			    CheckBlacklist(function()
    			{
				
    				WeRenderDevice.Setup(gRawWidth, gRawHeight);
        			WeEffectsMgr.Setup(GameSpecificVariables.WeEffectsMgr.MusicInfo);
        		
    				WeStartSplashSequence();
    			});
			}
			else
			{
			    WeRenderDevice.Setup(gRawWidth, gRawHeight);
    			//WeEffectsMgr.Setup(GameSpecificVariables.WeEffectsMgr.MusicInfo);
    		//	WeEffectsMgr.mMusicEnabled = false;
				WeStartSplashSequence();
			}

			GetLOD(function(lod)
			{
				gLOD = lod;
			});
        });

        var deviceName = Core.Capabilities.getDeviceName();
        NgLogD("**** DEVICE NAME " + deviceName)
		// Determine which texture format to use
		var glExtensions = glView.getOGLExtensions();
		if( Core.Capabilities.getPlatformOS() == "Android")
        {
    		for(var i in glExtensions)
    		{
    			if(glExtensions[i] == 'GL_AMD_compressed_ATC_texture') {
    				gTextureCompression = 'atc';
    				break;
    			}

    			if(glExtensions[i] == 'GL_IMG_texture_compression_pvrtc') {
    				gTextureCompression = 'pvr';
    				break;
    			}
    		}
		}
		else
		{
		    if (DeviceIsLowMemory())
    		{
    		    gTextureCompression = 'pvr';
    	    }
	    }
    };
    
    NgLogD("*** SCREEN PIXELS UNITS: " + Core.Capabilities.getScreenPixelUnits());
   
    if( Core.Capabilities.getPlatformOS() == "Android")
    {
        glView.setAttribute('frame', [0, 0, NGWindow.outerHeight, NGWindow.outerWidth]);
    }
    else
    {
        glView.setAttribute('frame', [0, 0, NGWindow.outerWidth, NGWindow.outerHeight]);
    }
        
    glView.setAttribute('active', true);
}

function DeviceIsLowMemory()
{
    var deviceName = Core.Capabilities.getDeviceName();
    if (deviceName === "iPad1,1" || deviceName === "iPhone2,1")
    {
        return true;
    }
    
    return false;
    
}
////////////////////////////////////////////////////////////////////////////////
function main()
{
    NgLogD("****************** "+GameInfo.appName+" Started");
    gCanBack = false;
    gShouldBack = false;
	gHarvestAll = null;
	gTextureCompression = 'png';

    if( Core.Capabilities.getPlatformOS() == "Android")
    {
        var LayoutListener = Core.MessageListener.subclass(
            {
                initialize: function()
                {
                    Device.OrientationEmitter.setInterfaceOrientation(Device.OrientationEmitter.Orientation.LandscapeLeft);
                    Device.LayoutEmitter.addListener(this, this.onLayout);
                },

                onLayout: function(layout)
                {
                    NgLogD("onLayout: " + JSON.stringify(layout));

                    gRawHeight = layout['height'];
                    gRawWidth = layout['width'];

					if (gRawHeight > gRawWidth)
					{
						gRawHeight = layout['width'];
						gRawWidth = layout['height'];
					}

                    CreateGLView();
                }

            });

            var layout = new LayoutListener();
    }
    else
    {
	    Device.OrientationEmitter.setInterfaceOrientation(Device.OrientationEmitter.Orientation.LandscapeLeft);
    	CreateGLView();
    }
    
}

var gCurGameLotInfo = null;

function SetDimensions()
{
	if (gFixedWidth == 1232 || gFixedWidth == 1184 || gFixedWidth == 1196)
	{
		gFixedWidth = 1280;
	}
	
	if (gFixedHeight == 752)
	{
		gFixedHeight = 800;
	}
}

//
// fix non standard resolutions
//
function FixDimensions()
{
	
	gRawWidth = ProperScreenWidth(gRawWidth);
	
	if (gRawHeight === 752)
	{
		gRawHeight = 800;
	}
}

function ProperScreenWidth(width)
{
    var w = width;
    
    if (w == 1232 || w == 1184 || w == 1196)
	{
		w = 1280;
	}

	return w;
}


////////////////////////////////////////////////////////////////////////////////
// Function: WeLotLoaded
// Called when the "lot" has finished loaded and is ready to play?
// @param request is an XmlHttpRequest results which should have the kingdom
//        protoconfig info in it
var gHasShowPromo = false;
function WeLotLoaded ( request )
{
	NgLogD("##### WeLotLoaded ");
	//handle server erroe
    if(request.responseText===null)
    {   	
        WeUiMgr.ShowLoading(false);  
        NgLogD("WeLostLoaded no response text");
    	WeUiMgr.ShowNetworkErrorPopUp();
    	WeGameStateMgr.SetLoadingKingdom(false);  
    	return;
    }
    WeEventGame.setup();
    
    //Removing old kingdom if have new one
    var lotInfo = WeGameStateMgr.GetGameLotInfo();
    if(Exists(lotInfo))
    {
        lotInfo.clearDisplay();
    }
    WeGameStateMgr.SetGameLotInfo(null); 
    WeClearSpriteCache();	
	
    NgLogD("##### new weKingdom ");
    
    var kingdom = new weKingdom();
    
    NgLogD("#####  kingdom.initWithJson ");
    
    kingdom.initWithJson( request.responseText );
    
    NgLogD("##### finished  kingdom.initWithJson ");
    
    WeGameStateMgr.SetGameLotInfo(kingdom); 
/// Initialize it only once.
    if (gCurGameLotInfo === null)
    {
        gCurGameLotInfo = WeGameStateMgr.GetGameLotInfo();
    }
    
    NgLogD("#####   WeGameStateMgr.mLot  ");
	if (!Exists(WeGameStateMgr.mLot))
	{
		WeGameStateMgr.Setup();
	}
    WeGameStateMgr.mLot.Init();
    
    
    NgLogD("#####   kingdom.InitDisplay  ");
    WeProtocol.getPests(WeGameStateMgr.GetCurrentKingdomId());
    
    kingdom.CalculateLevelAndExp();
    WeGameStateMgr.SetIsSocialJobPlaced(false);
    var cbAfterDownload = function()
    {
                
        var cb = function()
    	{
    	    NgLogD("##### finish  kingdom.InitDisplay  ");

            //WeUiMgr.GetScreen().HideSplash();
            NgLogD("#####   HideSpinner  ");
            WeEffectsMgr.HideSpinner();

            WeGameStateMgr.SetLoadingKingdom(false);
            gKingdomName = WeGameStateMgr.GetCurrentKingdomUser();

            
            WeGameStateMgr.mLot.LoadMapTile();
        
            WeGameStateMgr.SetIsFirstLoad(false);
            WeUiMgr.ShowLoading(false);

            NgLogD("##### finished  WeLotLoaded ");

    		WeProtocol.getPests(WeGameStateMgr.GetCurrentKingdomId());
    		WeRealms.CreateRealmsData();
    		
    		if (WeGameStateMgr.IsCurrentUser())
    		{
    			if (!WeContentDownloader.GetDownloadedAll())
    			{
    				NgLogD("Updating all content");
    			
    				WeContentDownloader.UpdateAllContent(function()
    					{
    						NgLogD("Updated all content");
    					});
    				
    				if (gShowBackgroundDownloadPopup)
    				{
	    				WeContentDownloader.SetWaitLevelDownloadCallback(function()
	    				{
	    					var alertDialog = new NGUI.AlertDialog();
	    					alertDialog.setTitle("Background download");
	    					alertDialog.setText("all content has been downloaded");
	    					alertDialog.setChoices(["OK"]);
	    					alertDialog.onchoice = function(event) {};
	    					alertDialog.show();
	    					
	    				}, gMaxLevel);
    				}
    			}
    			
    			// ACQUIRE DANGLING EVENT ITEMS
    			if (WeEventGame.eventItems && WeEventGame.eventItems.active)
    			{
    				for (var proto_event_item_id in WeEventGame.eventItems.active)
    				{
    				    var count = WeEventGame.eventItems.active[proto_event_item_id];
    				    for (var i=0; i < count; i++)
    				    {
    					    WeProtocol.acquireItem(proto_event_item_id, function(request)
                    		{
                                var obj = WeProtocol.getRequestResponse(request);
                                NgLogD("*** ACQUIRING DANGLING active EVENT ITEMS: " + request.responseText);
                            });
                        }
                        
    				}
    			}
    			
        		var playerState = kingdom.getPlayerState();
                Core.Analytics.reportGameEvent('KINGDOMLOAD', {}, playerState);

    		}
        };

        
        // if (WeGameStateMgr.GetIsFirstLoad() === false)
        //      {
        //          WeGameStateMgr.mLot.LoadMapTile();
        //      }
        if (WeGameStateMgr.IsCurrentUser() && !gHasShowPromo && gTunables.promo_enabled)
        {
            gHasShowPromo = true;
            WeUiMgr.TransitionScreenTo("PromotionalScreen");
        }
        else if(WeGameStateMgr.IsCurrentUser() && (gHasShowPromo || !gTunables.promo_enabled))
        {
            WeUiMgr.TransitionScreenTo("InGameScreen");
        }
        else
        {
            WeUiMgr.TransitionScreenTo("InGameScreen_Friend");
        }
        //if there is an objective available - show the current objective
        if (!gConfigs.DisableTutorial && WeGameStateMgr.HasRemainingObjectives() && WeGameStateMgr.IsCurrentUser() && WeGameStateMgr.GetIsFirstLoad())
        {
              WeGameStateMgr.SetGlobalGameWidget(null);
              WeUiMgr.TransitionScreenTo("ObjectiveScreen");
        }

        WeUiMgr.ShowLoading(true);
        kingdom.InitDisplay(cb);
    };
    
     cbAfterDownload();

    
}

function WeClearSpriteCache()
{
    // for(var i in gAnimationsCachedByProtoId)
    //     {
    //         var animation = gAnimationsCachedByProtoId[i];
    //         for(var j in animation)
    //         {
    //             NgLogD("*** DESTROY ANIM");
    //             animation[j].destroy();
    //         }      
    //     }
    
    // for(var i in gAnimationsByName)
    //     {
    //         var animation = gAnimationsByName[i];
    //         for(var j in animation)
    //         {
    //             NgLogD("*** DESTROY ANIM2");
    //             animation[j].destroy();
    //         }      
    //     }
    
    for(var i in gAnimationsCachedForCleanup)
    {
        if (gAnimationsCachedForCleanup[i])
            gAnimationsCachedForCleanup[i].destroy();
    }
    
    gAnimationsCachedForCleanup = [];
    gAnimationsCachedByProtoId = [];
    gAnimationsByNameCachedByProtoId = [];
    gAnimationsByName = {};
}

////////////////////////////////////////////////////////////////////////////////
// Function: WeLotLoad
// Called when the Session has started but we don't yet have a Lot.  We need tod download it
// @param lotId, number id for the lot to load up
function WeLoadNamedLot(lotName)
{
	NgLogD("### WeLoadNamedLot name "+lotName);
    if (WeGameStateMgr.IsLoadingKingdom())
    {
        return false;
    }	
    WePests.killAllPests();
	gHarvestAll = null;
	gHarvestAllActive = false;
    WeUiMgr.ShowLoading(true);
    WeGameStateMgr.SetLoadingKingdom(true);      
    
    WeProtocol.getKingdomByName ( lotName, WeLotLoaded );

	WeTransaction.resumeTransactions();
	
	return true;
}

function WeLotLoad(lotId)
{
    if (WeGameStateMgr.IsLoadingKingdom())
    {
        return false;
    }
    WePests.killAllPests();
	gHarvestAll = null;
	gHarvestAllActive = false;
    WeUiMgr.ShowLoading(true);    
    WeUiMgr.mLoadingProgress = "0%";
    WeGameStateMgr.SetLoadingKingdom(true);
    
    WeProtocol.getKingdom ( lotId, WeLotLoaded );
    return true;
}

function HandleURLRequest(url)
{
    NgLogD("URL is " + url);

    var ids = gConfigs.EventParticipationEntityIds;
    var participate_ids = null;
	if (gConfigs.EventParticipationEntityIds)
	{
		if(ids == parseInt(ids))
			participate_ids = [ids];
		else
			participate_ids = gConfigs.EventParticipationEntityIds.split('|');
	}

    var nId = WeEventGame.getFirstEventProducingEntityProtoId();	// can get the proto entity id for the event from the new event logic
	if (!nId)	//if no new event proto entity id, use the old event logic
		nId = (participate_ids && participate_ids.length >=1)? new Number(participate_ids[0]) : null;
    if (url.indexOf("app://show_event_participation_entity_in_featured_store_tab") >= 0)
    {
		if (nId)
		{
			// report clicked event start
			WeProtocol.reportClickedEventStart();
	    	NgLogD("Startas ShowItemToBuild " + nId);
			WeUiMgr.ShowItemToBuildNoMoneyManaTest(nId);
		}
	    return false;
    }
    else if (url.indexOf("app://show_event_status_view") >= 0)
    {
        // show_url
        // show_progress = false
        // days_left
        var paramURL = URLQuery(url, "show_url");
        var showProgress = URLQuery(url, "show_progress");
        var daysLeft = URLQuery(url, "days_left");
        var showGoalBook = URLQuery(url, "show_goal_book");
        NgLogD("### show url " + paramURL);
        NgLogD("### show_progress " + showProgress);
        NgLogD("### days_left " + daysLeft);
        NgLogD("### show_goal_book " + showGoalBook);
        
        WeGameStateMgr.mEventDaysLeft = daysLeft;
        if (Exists(paramURL) && paramURL)
        {
            url = paramURL;
            WeGameStateMgr.mInterstitialURL = url;
            WeUiMgr.TransitionScreenTo("EventStatus");
        }
        else if (Exists(showGoalBook) && showGoalBook)
        {
            WeGoals.showEventGoal = true;
            WeUiMgr.TransitionScreenTo("GoalsScreen");
        }
        
	    return false;
    }
	else if (url.indexOf("app://close_web_view") >= 0)
	{
    	WeGameStateMgr.SetPopupWidget(null);
        WeGameStateMgr.SetGlobalGameWidget(null);
	    return false;		
	}
    else if (url.indexOf("app://close_event_status_view") >= 0)
    {
		WeSocialMapMgr.transitionScreenToKingdom();
	    return false;
    }
    else if (url.indexOf("app://show_event_status_goal_book") >= 0)
    {
        WeGoals.showEventGoal = true;
        WeUiMgr.TransitionScreenTo("GoalsScreen");
	    return false;
    }
	else if (url.indexOf("app://show_event_screen") >= 0)
	{	// go to the new event screen
        WeUiMgr.TransitionScreenTo("SpecialEventScreen");
		return false;
	}
	else if (url.indexOf("app://show_social_map") >= 0)
	{	// go to the social map screen
        WeUiMgr.TransitionScreenTo("SocialMapScreen");
	    WeRenderDevice.EnableGame(false);
		WeSocialMapMgr.isLoadingMap = false;
		return false;
	}
    else if (url.indexOf("app://show_event_participation_entity_in_store") >= 0)
    {
        WeUiMgr.ShowItemToBuildNoMoneyManaTest(nId);
	    return false;
    }
    else if (url.indexOf("app://show_event_participation_entity_in_building_store_tab") >= 0)
    {
        WeUiMgr.ShowItemToBuildNoMoneyManaTest(nId);
	    return false;
    }
    else if (url.indexOf("app://show_event_participation_entity_in_iap_store_tab") >= 0)
    {
        WeUiMgr.ShowItemToBuildNoMoneyManaTest(nId);
	    return false;
    }
    else if (url.indexOf("app://reload_current_kingdom") >= 0)
    {
             WeLotLoad(WeGameStateMgr.GetCurrentKingdomId());
                return false;
     }

    return true;
}

function WebViewCommands(event) 
{
    NgLogD("URL is " + event.url);
    NgLogD("Nav Type is " + event.navigation);

    return HandleURLRequest(event.url);
} 

